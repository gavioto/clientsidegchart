<HTML>
<BODY BGCOLOR="white">
<PRE>
<FONT color="green">001</FONT>    /* <a name="line.1"></a>
<FONT color="green">002</FONT>     * Copyright 2007-2010 John C. Gunther<a name="line.2"></a>
<FONT color="green">003</FONT>     * <a name="line.3"></a>
<FONT color="green">004</FONT>     * Licensed under the Apache License, Version 2.0 (the<a name="line.4"></a>
<FONT color="green">005</FONT>     * "License"); you may not use this file except in compliance<a name="line.5"></a>
<FONT color="green">006</FONT>     * with the License. You may obtain a copy of the License at:<a name="line.6"></a>
<FONT color="green">007</FONT>     *  <a name="line.7"></a>
<FONT color="green">008</FONT>     *  http://www.apache.org/licenses/LICENSE-2.0<a name="line.8"></a>
<FONT color="green">009</FONT>     *<a name="line.9"></a>
<FONT color="green">010</FONT>     * Unless required by applicable law or agreed to in writing,<a name="line.10"></a>
<FONT color="green">011</FONT>     * software distributed under the License is distributed on an<a name="line.11"></a>
<FONT color="green">012</FONT>     * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,<a name="line.12"></a>
<FONT color="green">013</FONT>     * either express or implied. See the License for the specific<a name="line.13"></a>
<FONT color="green">014</FONT>     * language governing permissions and limitations under the<a name="line.14"></a>
<FONT color="green">015</FONT>     * License.<a name="line.15"></a>
<FONT color="green">016</FONT>     * <a name="line.16"></a>
<FONT color="green">017</FONT>     */<a name="line.17"></a>
<FONT color="green">018</FONT>    package com.googlecode.gchart.client;<a name="line.18"></a>
<FONT color="green">019</FONT>    <a name="line.19"></a>
<FONT color="green">020</FONT>    import com.google.gwt.i18n.client.DateTimeFormat;<a name="line.20"></a>
<FONT color="green">021</FONT>    import com.google.gwt.i18n.client.NumberFormat;<a name="line.21"></a>
<FONT color="green">022</FONT>    import com.google.gwt.user.client.DOM;<a name="line.22"></a>
<FONT color="green">023</FONT>    import com.google.gwt.user.client.Window;<a name="line.23"></a>
<FONT color="green">024</FONT>    import com.google.gwt.dom.client.Element;<a name="line.24"></a>
<FONT color="green">025</FONT>    import com.google.gwt.dom.client.EventTarget;<a name="line.25"></a>
<FONT color="green">026</FONT>    import com.google.gwt.event.dom.client.ClickEvent;<a name="line.26"></a>
<FONT color="green">027</FONT>    import com.google.gwt.event.dom.client.ClickHandler;<a name="line.27"></a>
<FONT color="green">028</FONT>    import com.google.gwt.event.dom.client.DoubleClickEvent;<a name="line.28"></a>
<FONT color="green">029</FONT>    import com.google.gwt.event.dom.client.DoubleClickHandler;<a name="line.29"></a>
<FONT color="green">030</FONT>    import com.google.gwt.event.dom.client.HasClickHandlers;<a name="line.30"></a>
<FONT color="green">031</FONT>    import com.google.gwt.event.dom.client.HasDoubleClickHandlers;<a name="line.31"></a>
<FONT color="green">032</FONT>    import com.google.gwt.event.dom.client.HasMouseDownHandlers;<a name="line.32"></a>
<FONT color="green">033</FONT>    import com.google.gwt.event.dom.client.HasMouseMoveHandlers;<a name="line.33"></a>
<FONT color="green">034</FONT>    import com.google.gwt.event.dom.client.HasMouseOutHandlers;<a name="line.34"></a>
<FONT color="green">035</FONT>    import com.google.gwt.event.dom.client.HasMouseOverHandlers;<a name="line.35"></a>
<FONT color="green">036</FONT>    import com.google.gwt.event.dom.client.HasMouseUpHandlers;<a name="line.36"></a>
<FONT color="green">037</FONT>    import com.google.gwt.event.dom.client.HasMouseWheelHandlers;<a name="line.37"></a>
<FONT color="green">038</FONT>    import com.google.gwt.event.dom.client.MouseDownEvent;<a name="line.38"></a>
<FONT color="green">039</FONT>    import com.google.gwt.event.dom.client.MouseDownHandler;<a name="line.39"></a>
<FONT color="green">040</FONT>    import com.google.gwt.event.dom.client.MouseMoveEvent;<a name="line.40"></a>
<FONT color="green">041</FONT>    import com.google.gwt.event.dom.client.MouseMoveHandler;<a name="line.41"></a>
<FONT color="green">042</FONT>    import com.google.gwt.event.dom.client.MouseOutEvent;<a name="line.42"></a>
<FONT color="green">043</FONT>    import com.google.gwt.event.dom.client.MouseOutHandler;<a name="line.43"></a>
<FONT color="green">044</FONT>    import com.google.gwt.event.dom.client.MouseOverEvent;<a name="line.44"></a>
<FONT color="green">045</FONT>    import com.google.gwt.event.dom.client.MouseOverHandler;<a name="line.45"></a>
<FONT color="green">046</FONT>    import com.google.gwt.event.dom.client.MouseUpEvent;<a name="line.46"></a>
<FONT color="green">047</FONT>    import com.google.gwt.event.dom.client.MouseUpHandler;<a name="line.47"></a>
<FONT color="green">048</FONT>    import com.google.gwt.event.dom.client.MouseWheelEvent;<a name="line.48"></a>
<FONT color="green">049</FONT>    import com.google.gwt.event.dom.client.MouseWheelHandler;<a name="line.49"></a>
<FONT color="green">050</FONT>    import com.google.gwt.event.shared.HandlerRegistration;<a name="line.50"></a>
<FONT color="green">051</FONT>    import com.google.gwt.user.client.Event;<a name="line.51"></a>
<FONT color="green">052</FONT>    import com.google.gwt.user.client.ui.AbsolutePanel;<a name="line.52"></a>
<FONT color="green">053</FONT>    import com.google.gwt.user.client.ui.Composite;<a name="line.53"></a>
<FONT color="green">054</FONT>    import com.google.gwt.user.client.ui.Grid;<a name="line.54"></a>
<FONT color="green">055</FONT>    import com.google.gwt.user.client.ui.HasHTML;<a name="line.55"></a>
<FONT color="green">056</FONT>    import com.google.gwt.user.client.ui.HasHorizontalAlignment;<a name="line.56"></a>
<FONT color="green">057</FONT>    import com.google.gwt.user.client.ui.HasText;<a name="line.57"></a>
<FONT color="green">058</FONT>    import com.google.gwt.user.client.ui.HasVerticalAlignment;<a name="line.58"></a>
<FONT color="green">059</FONT>    import com.google.gwt.user.client.ui.HTML;<a name="line.59"></a>
<FONT color="green">060</FONT>    import com.google.gwt.user.client.ui.Image;<a name="line.60"></a>
<FONT color="green">061</FONT>    import com.google.gwt.user.client.ui.SimplePanel;<a name="line.61"></a>
<FONT color="green">062</FONT>    import com.google.gwt.user.client.ui.UIObject;<a name="line.62"></a>
<FONT color="green">063</FONT>    import com.google.gwt.user.client.ui.Widget;<a name="line.63"></a>
<FONT color="green">064</FONT>    import java.util.ArrayList;<a name="line.64"></a>
<FONT color="green">065</FONT>    import java.util.Date;<a name="line.65"></a>
<FONT color="green">066</FONT>    import com.google.gwt.core.client.GWT;<a name="line.66"></a>
<FONT color="green">067</FONT>    <a name="line.67"></a>
<FONT color="green">068</FONT>    /**<a name="line.68"></a>
<FONT color="green">069</FONT>     * A GChart can represent and display a line chart, a bar chart, a pie chart, an<a name="line.69"></a>
<FONT color="green">070</FONT>     * area chart, or a chart that contains arbitrary combinations of line, bar,<a name="line.70"></a>
<FONT color="green">071</FONT>     * pie, and/or area based curves.<a name="line.71"></a>
<FONT color="green">072</FONT>     * <a name="line.72"></a>
<FONT color="green">073</FONT>     * &lt;p&gt;<a name="line.73"></a>
<FONT color="green">074</FONT>     * For detailed examples, with screen shots, visit the &lt;a<a name="line.74"></a>
<FONT color="green">075</FONT>     * href="package-summary.html#ChartGallery"&gt;Chart Gallery&lt;/a&gt;.<a name="line.75"></a>
<FONT color="green">076</FONT>     * <a name="line.76"></a>
<FONT color="green">077</FONT>     * &lt;p&gt;<a name="line.77"></a>
<FONT color="green">078</FONT>     * For detailed instructions on how to integrate Client-side GChart into your<a name="line.78"></a>
<FONT color="green">079</FONT>     * GWT application, see &lt;a href="package-summary.html#InstallingGChart"&gt;<a name="line.79"></a>
<FONT color="green">080</FONT>     * Installing Client-side GChart&lt;/a&gt;.<a name="line.80"></a>
<FONT color="green">081</FONT>     * <a name="line.81"></a>
<FONT color="green">082</FONT>     * &lt;p&gt;<a name="line.82"></a>
<FONT color="green">083</FONT>     * &lt;b&gt;CSS Style Rule&lt;/b&gt;<a name="line.83"></a>
<FONT color="green">084</FONT>     * &lt;ul&gt;<a name="line.84"></a>
<FONT color="green">085</FONT>     * .gchart-GChart { the GChart's primary top-level styles }<a name="line.85"></a>
<FONT color="green">086</FONT>     * &lt;/ul&gt;<a name="line.86"></a>
<FONT color="green">087</FONT>     * <a name="line.87"></a>
<FONT color="green">088</FONT>     * It is sometimes more natural to consider certain CSS attributes as properties<a name="line.88"></a>
<FONT color="green">089</FONT>     * of a GChart Java object. So, GChart supports "CSS convenience methods" that<a name="line.89"></a>
<FONT color="green">090</FONT>     * let you (optionally) use Java to specify GChart CSS attributes such as<a name="line.90"></a>
<FONT color="green">091</FONT>     * &lt;tt&gt;border-color&lt;/tt&gt; and &lt;tt&gt;background-color&lt;/tt&gt;. See {@link #USE_CSS<a name="line.91"></a>
<FONT color="green">092</FONT>     * USE_CSS} for a detailed description of these CSS convenience methods--which<a name="line.92"></a>
<FONT color="green">093</FONT>     * won't interfere with standard CSS-based specifications if you never invoke<a name="line.93"></a>
<FONT color="green">094</FONT>     * them.<a name="line.94"></a>
<FONT color="green">095</FONT>     * <a name="line.95"></a>
<FONT color="green">096</FONT>     */<a name="line.96"></a>
<FONT color="green">097</FONT>    <a name="line.97"></a>
<FONT color="green">098</FONT>    public class GChart extends Composite implements HasClickHandlers,<a name="line.98"></a>
<FONT color="green">099</FONT>        HasDoubleClickHandlers, HasMouseDownHandlers, HasMouseMoveHandlers,<a name="line.99"></a>
<FONT color="green">100</FONT>        HasMouseOutHandlers, HasMouseOverHandlers, HasMouseUpHandlers,<a name="line.100"></a>
<FONT color="green">101</FONT>        HasMouseWheelHandlers {<a name="line.101"></a>
<FONT color="green">102</FONT>    <a name="line.102"></a>
<FONT color="green">103</FONT>      /**<a name="line.103"></a>
<FONT color="green">104</FONT>       * Defines the location of a data point's annotation or hover annotation<a name="line.104"></a>
<FONT color="green">105</FONT>       * (which can be defined by either plain text, HTML, or a widget) relative to<a name="line.105"></a>
<FONT color="green">106</FONT>       * the location of that point's symbol. The "Field Summary" section below<a name="line.106"></a>
<FONT color="green">107</FONT>       * lists all available annotation locations.<a name="line.107"></a>
<FONT color="green">108</FONT>       * &lt;p&gt;<a name="line.108"></a>
<FONT color="green">109</FONT>       * <a name="line.109"></a>
<FONT color="green">110</FONT>       * The default annotation location is {@link AnnotationLocation#SOUTH SOUTH}<a name="line.110"></a>
<FONT color="green">111</FONT>       * for annotations and is symbol-type-dependent for hover annotations. See the<a name="line.111"></a>
<FONT color="green">112</FONT>       * &lt;tt&gt;setHoverLocation&lt;/tt&gt; method for list of these defaults.<a name="line.112"></a>
<FONT color="green">113</FONT>       * <a name="line.113"></a>
<FONT color="green">114</FONT>       * &lt;p&gt;<a name="line.114"></a>
<FONT color="green">115</FONT>       * <a name="line.115"></a>
<FONT color="green">116</FONT>       * You can further adjust the position of a point's annotation (or hover<a name="line.116"></a>
<FONT color="green">117</FONT>       * annotation) by specifying non-zero positional shifts via the<a name="line.117"></a>
<FONT color="green">118</FONT>       * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; and &lt;tt&gt;setAnnotationYShift&lt;/tt&gt; (or via the<a name="line.118"></a>
<FONT color="green">119</FONT>       * &lt;tt&gt;setHoverXShift&lt;/tt&gt;, &lt;tt&gt;setHoverYShift&lt;/tt&gt;), and<a name="line.119"></a>
<FONT color="green">120</FONT>       * &lt;tt&gt;setHoverAnnotationSymbolType&lt;/tt&gt; methods for hover annotations).<a name="line.120"></a>
<FONT color="green">121</FONT>       * &lt;p&gt;<a name="line.121"></a>
<FONT color="green">122</FONT>       * <a name="line.122"></a>
<FONT color="green">123</FONT>       * @see Curve.Point#setAnnotationLocation Point.setAnnotationLocation<a name="line.123"></a>
<FONT color="green">124</FONT>       * @see Curve.Point#setAnnotationXShift Point.setAnnotationXShift<a name="line.124"></a>
<FONT color="green">125</FONT>       * @see Curve.Point#setAnnotationYShift Point.setAnnotationYShift<a name="line.125"></a>
<FONT color="green">126</FONT>       * @see Symbol#setHoverLocation Symbol.setHoverLocation<a name="line.126"></a>
<FONT color="green">127</FONT>       * @see Symbol#setHoverAnnotationSymbolType<a name="line.127"></a>
<FONT color="green">128</FONT>       *      Symbol.setHoverAnnotationSymbolType<a name="line.128"></a>
<FONT color="green">129</FONT>       * @see Symbol#setHoverXShift Symbol.setHoverXShift<a name="line.129"></a>
<FONT color="green">130</FONT>       * @see Symbol#setHoverYShift Symbol.setHoverYShift<a name="line.130"></a>
<FONT color="green">131</FONT>       * @see #DEFAULT_HOVER_LOCATION DEFAULT_HOVER_LOCATION<a name="line.131"></a>
<FONT color="green">132</FONT>       * <a name="line.132"></a>
<FONT color="green">133</FONT>       */<a name="line.133"></a>
<FONT color="green">134</FONT>      public static final class AnnotationLocation {<a name="line.134"></a>
<FONT color="green">135</FONT>        // non-public tagging-only locations used by ANCHOR_MOUSE_* symbol types<a name="line.135"></a>
<FONT color="green">136</FONT>        static final AnnotationLocation AT_THE_MOUSE =<a name="line.136"></a>
<FONT color="green">137</FONT>            new AnnotationLocation(0, 0);<a name="line.137"></a>
<FONT color="green">138</FONT>        static final AnnotationLocation AT_THE_MOUSE_SNAP_TO_X =<a name="line.138"></a>
<FONT color="green">139</FONT>            new AnnotationLocation(0, 0);<a name="line.139"></a>
<FONT color="green">140</FONT>        static final AnnotationLocation AT_THE_MOUSE_SNAP_TO_Y =<a name="line.140"></a>
<FONT color="green">141</FONT>            new AnnotationLocation(0, 0);<a name="line.141"></a>
<FONT color="green">142</FONT>        /**<a name="line.142"></a>
<FONT color="green">143</FONT>         * Specifies that a point's annotation (label) should be positioned so as to<a name="line.143"></a>
<FONT color="green">144</FONT>         * be centered on the symbol used to represent the point.<a name="line.144"></a>
<FONT color="green">145</FONT>         * <a name="line.145"></a>
<FONT color="green">146</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.146"></a>
<FONT color="green">147</FONT>         */<a name="line.147"></a>
<FONT color="green">148</FONT>        public static final AnnotationLocation CENTER =<a name="line.148"></a>
<FONT color="green">149</FONT>            new AnnotationLocation(0, 0);<a name="line.149"></a>
<FONT color="green">150</FONT>        private static final AnnotationLocation north =<a name="line.150"></a>
<FONT color="green">151</FONT>            new AnnotationLocation(0, -1);<a name="line.151"></a>
<FONT color="green">152</FONT>        private static final AnnotationLocation west =<a name="line.152"></a>
<FONT color="green">153</FONT>            new AnnotationLocation(-1, 0);<a name="line.153"></a>
<FONT color="green">154</FONT>        private static final AnnotationLocation south =<a name="line.154"></a>
<FONT color="green">155</FONT>            new AnnotationLocation(0, 1);<a name="line.155"></a>
<FONT color="green">156</FONT>    <a name="line.156"></a>
<FONT color="green">157</FONT>        /**<a name="line.157"></a>
<FONT color="green">158</FONT>         * Specifies that a point's annotation (label) should be placed just above,<a name="line.158"></a>
<FONT color="green">159</FONT>         * and centered horizontally on, vertical bars that grow down from a<a name="line.159"></a>
<FONT color="green">160</FONT>         * horizontal baseline, and just below, and centered horizontally on,<a name="line.160"></a>
<FONT color="green">161</FONT>         * vertical bars that grow up from a horizontal baseline.<a name="line.161"></a>
<FONT color="green">162</FONT>         * <a name="line.162"></a>
<FONT color="green">163</FONT>         * &lt;p&gt;<a name="line.163"></a>
<FONT color="green">164</FONT>         * <a name="line.164"></a>
<FONT color="green">165</FONT>         * This another name for &lt;tt&gt;AnnotationLocation.NORTH&lt;/tt&gt;. Its sole purpose<a name="line.165"></a>
<FONT color="green">166</FONT>         * is to clarify/document the behavior of this location type when used in<a name="line.166"></a>
<FONT color="green">167</FONT>         * conjunction with curves that employ &lt;tt&gt;VBAR_BASELINE_*&lt;/tt&gt; symbol<a name="line.167"></a>
<FONT color="green">168</FONT>         * types.<a name="line.168"></a>
<FONT color="green">169</FONT>         * <a name="line.169"></a>
<FONT color="green">170</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.170"></a>
<FONT color="green">171</FONT>         * @see SymbolType#VBAR_BASELINE_CENTER SymbolType.VBAR_BASELINE_CENTER<a name="line.171"></a>
<FONT color="green">172</FONT>         * <a name="line.172"></a>
<FONT color="green">173</FONT>         */<a name="line.173"></a>
<FONT color="green">174</FONT>        public static final AnnotationLocation CLOSEST_TO_HORIZONTAL_BASELINE = north;<a name="line.174"></a>
<FONT color="green">175</FONT>    <a name="line.175"></a>
<FONT color="green">176</FONT>        /**<a name="line.176"></a>
<FONT color="green">177</FONT>         * Specifies that a point's annotation (label) should be placed just to the<a name="line.177"></a>
<FONT color="green">178</FONT>         * right of, and centered vertically on, horizontal bars that grow left from<a name="line.178"></a>
<FONT color="green">179</FONT>         * a vertical baseline, and just to the left of, and centered vertically on,<a name="line.179"></a>
<FONT color="green">180</FONT>         * horizontal bars that grow right from a vertical baseline.<a name="line.180"></a>
<FONT color="green">181</FONT>         * <a name="line.181"></a>
<FONT color="green">182</FONT>         * &lt;p&gt;<a name="line.182"></a>
<FONT color="green">183</FONT>         * <a name="line.183"></a>
<FONT color="green">184</FONT>         * This another name for &lt;tt&gt;AnnotationLocation.WEST&lt;/tt&gt;. Its sole purpose<a name="line.184"></a>
<FONT color="green">185</FONT>         * is to clarify/document the behavior of this location type when used in<a name="line.185"></a>
<FONT color="green">186</FONT>         * conjunction with curves that employ the &lt;tt&gt;HBAR_BASELINE_*&lt;/tt&gt; symbol<a name="line.186"></a>
<FONT color="green">187</FONT>         * types.<a name="line.187"></a>
<FONT color="green">188</FONT>         * <a name="line.188"></a>
<FONT color="green">189</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.189"></a>
<FONT color="green">190</FONT>         * @see SymbolType#HBAR_BASELINE_CENTER SymbolType.HBAR_BASELINE_CENTER<a name="line.190"></a>
<FONT color="green">191</FONT>         * <a name="line.191"></a>
<FONT color="green">192</FONT>         */<a name="line.192"></a>
<FONT color="green">193</FONT>    <a name="line.193"></a>
<FONT color="green">194</FONT>        public static final AnnotationLocation CLOSEST_TO_VERTICAL_BASELINE = west;<a name="line.194"></a>
<FONT color="green">195</FONT>    <a name="line.195"></a>
<FONT color="green">196</FONT>        /**<a name="line.196"></a>
<FONT color="green">197</FONT>         * Specifies that a point's annotation (label) should be positioned just to<a name="line.197"></a>
<FONT color="green">198</FONT>         * the right of, and vertically centered on, the symbol used to represent<a name="line.198"></a>
<FONT color="green">199</FONT>         * the point.<a name="line.199"></a>
<FONT color="green">200</FONT>         * <a name="line.200"></a>
<FONT color="green">201</FONT>         * @see Curve.Point#setAnnotationLocation<a name="line.201"></a>
<FONT color="green">202</FONT>         */<a name="line.202"></a>
<FONT color="green">203</FONT>        public static final AnnotationLocation EAST =<a name="line.203"></a>
<FONT color="green">204</FONT>            new AnnotationLocation(1, 0);<a name="line.204"></a>
<FONT color="green">205</FONT>    <a name="line.205"></a>
<FONT color="green">206</FONT>        /**<a name="line.206"></a>
<FONT color="green">207</FONT>         * Specifies that a point's annotation (label) should be placed just below,<a name="line.207"></a>
<FONT color="green">208</FONT>         * and centered horizontally on, vertical bars that grow down from a<a name="line.208"></a>
<FONT color="green">209</FONT>         * horizontal baseline, and just above, and centered horizontally on,<a name="line.209"></a>
<FONT color="green">210</FONT>         * vertical bars that grow up from a horizontal baseline.<a name="line.210"></a>
<FONT color="green">211</FONT>         * <a name="line.211"></a>
<FONT color="green">212</FONT>         * &lt;p&gt;<a name="line.212"></a>
<FONT color="green">213</FONT>         * <a name="line.213"></a>
<FONT color="green">214</FONT>         * This another name for &lt;tt&gt;AnnotationLocation.SOUTH&lt;/tt&gt;. Its sole purpose<a name="line.214"></a>
<FONT color="green">215</FONT>         * is to clarify/document the behavior of this location type when used in<a name="line.215"></a>
<FONT color="green">216</FONT>         * conjunction with curves that employ &lt;tt&gt;VBAR_BASELINE_*&lt;/tt&gt; symbol<a name="line.216"></a>
<FONT color="green">217</FONT>         * types.<a name="line.217"></a>
<FONT color="green">218</FONT>         * <a name="line.218"></a>
<FONT color="green">219</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.219"></a>
<FONT color="green">220</FONT>         * @see SymbolType#VBAR_BASELINE_CENTER SymbolType.VBAR_BASELINE_CENTER<a name="line.220"></a>
<FONT color="green">221</FONT>         * <a name="line.221"></a>
<FONT color="green">222</FONT>         */<a name="line.222"></a>
<FONT color="green">223</FONT>        public static final AnnotationLocation FARTHEST_FROM_HORIZONTAL_BASELINE = south;<a name="line.223"></a>
<FONT color="green">224</FONT>    <a name="line.224"></a>
<FONT color="green">225</FONT>        /**<a name="line.225"></a>
<FONT color="green">226</FONT>         * Specifies that a point's annotation (label) should be placed just to the<a name="line.226"></a>
<FONT color="green">227</FONT>         * left of, and centered vertically on, horizontal bars that grow left from<a name="line.227"></a>
<FONT color="green">228</FONT>         * a vertical baseline, and just to the right of, and centered vertically<a name="line.228"></a>
<FONT color="green">229</FONT>         * on, horizontal bars that grow right from a vertical baseline.<a name="line.229"></a>
<FONT color="green">230</FONT>         * <a name="line.230"></a>
<FONT color="green">231</FONT>         * &lt;p&gt;<a name="line.231"></a>
<FONT color="green">232</FONT>         * <a name="line.232"></a>
<FONT color="green">233</FONT>         * This another name for &lt;tt&gt;AnnotationLocation.EAST&lt;/tt&gt;. Its sole purpose<a name="line.233"></a>
<FONT color="green">234</FONT>         * is to clarify/document the behavior of this location type when used in<a name="line.234"></a>
<FONT color="green">235</FONT>         * conjunction with curves that employ the &lt;tt&gt;HBAR_BASELINE_*&lt;/tt&gt; family<a name="line.235"></a>
<FONT color="green">236</FONT>         * of symbol types.<a name="line.236"></a>
<FONT color="green">237</FONT>         * <a name="line.237"></a>
<FONT color="green">238</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.238"></a>
<FONT color="green">239</FONT>         * @see SymbolType#HBAR_BASELINE_CENTER SymbolType.HBAR_BASELINE_CENTER<a name="line.239"></a>
<FONT color="green">240</FONT>         * <a name="line.240"></a>
<FONT color="green">241</FONT>         */<a name="line.241"></a>
<FONT color="green">242</FONT>        public static final AnnotationLocation FARTHEST_FROM_VERTICAL_BASELINE = EAST;<a name="line.242"></a>
<FONT color="green">243</FONT>    <a name="line.243"></a>
<FONT color="green">244</FONT>        /**<a name="line.244"></a>
<FONT color="green">245</FONT>         * Specifies that a point's annotation (label) should be positioned just<a name="line.245"></a>
<FONT color="green">246</FONT>         * inside, and centered on, the arc side of a pie slice.<a name="line.246"></a>
<FONT color="green">247</FONT>         * &lt;p&gt;<a name="line.247"></a>
<FONT color="green">248</FONT>         * <a name="line.248"></a>
<FONT color="green">249</FONT>         * You can move a pie slice's annotation a specific number of pixels<a name="line.249"></a>
<FONT color="green">250</FONT>         * radially away from (or towards) the pie center by passing a positive (or<a name="line.250"></a>
<FONT color="green">251</FONT>         * negative) argument to the associated &lt;tt&gt;Point&lt;/tt&gt;'s<a name="line.251"></a>
<FONT color="green">252</FONT>         * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; method.<a name="line.252"></a>
<FONT color="green">253</FONT>         * <a name="line.253"></a>
<FONT color="green">254</FONT>         * &lt;p&gt;<a name="line.254"></a>
<FONT color="green">255</FONT>         * This is pie-friendly synonym for, and when used with non-pie symbol types<a name="line.255"></a>
<FONT color="green">256</FONT>         * will behave exactly the same as, &lt;tt&gt;AnnotationLocation.NORTH&lt;/tt&gt;<a name="line.256"></a>
<FONT color="green">257</FONT>         * <a name="line.257"></a>
<FONT color="green">258</FONT>         * @see #OUTSIDE_PIE_ARC OUTSIDE_PIE_ARC<a name="line.258"></a>
<FONT color="green">259</FONT>         * @see #ON_PIE_ARC ON_PIE_ARC<a name="line.259"></a>
<FONT color="green">260</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.260"></a>
<FONT color="green">261</FONT>         * @see AnnotationLocation#NORTH NORTH<a name="line.261"></a>
<FONT color="green">262</FONT>         */<a name="line.262"></a>
<FONT color="green">263</FONT>        public static final AnnotationLocation INSIDE_PIE_ARC = north;<a name="line.263"></a>
<FONT color="green">264</FONT>    <a name="line.264"></a>
<FONT color="green">265</FONT>        /**<a name="line.265"></a>
<FONT color="green">266</FONT>         * Specifies that a point's annotation (label) should be positioned just<a name="line.266"></a>
<FONT color="green">267</FONT>         * above, and horizontally centered on, the symbol used to represent the<a name="line.267"></a>
<FONT color="green">268</FONT>         * point.<a name="line.268"></a>
<FONT color="green">269</FONT>         * <a name="line.269"></a>
<FONT color="green">270</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.270"></a>
<FONT color="green">271</FONT>         */<a name="line.271"></a>
<FONT color="green">272</FONT>        public static final AnnotationLocation NORTH = north;<a name="line.272"></a>
<FONT color="green">273</FONT>    <a name="line.273"></a>
<FONT color="green">274</FONT>        /**<a name="line.274"></a>
<FONT color="green">275</FONT>         * Specifies that a point's annotation (label) should be positioned just to<a name="line.275"></a>
<FONT color="green">276</FONT>         * the right of and above, the symbol used to represent the point.<a name="line.276"></a>
<FONT color="green">277</FONT>         * <a name="line.277"></a>
<FONT color="green">278</FONT>         * @see Curve.Point#setAnnotationLocation<a name="line.278"></a>
<FONT color="green">279</FONT>         */<a name="line.279"></a>
<FONT color="green">280</FONT>        public static final AnnotationLocation NORTHEAST =<a name="line.280"></a>
<FONT color="green">281</FONT>            new AnnotationLocation(1, -1);<a name="line.281"></a>
<FONT color="green">282</FONT>    <a name="line.282"></a>
<FONT color="green">283</FONT>        /**<a name="line.283"></a>
<FONT color="green">284</FONT>         * Specifies that a point's annotation (label) should be positioned just to<a name="line.284"></a>
<FONT color="green">285</FONT>         * the left of and above, the symbol used to represent the point.<a name="line.285"></a>
<FONT color="green">286</FONT>         * <a name="line.286"></a>
<FONT color="green">287</FONT>         * @see Curve.Point#setAnnotationLocation<a name="line.287"></a>
<FONT color="green">288</FONT>         */<a name="line.288"></a>
<FONT color="green">289</FONT>        public static final AnnotationLocation NORTHWEST =<a name="line.289"></a>
<FONT color="green">290</FONT>            new AnnotationLocation(-1, -1);<a name="line.290"></a>
<FONT color="green">291</FONT>    <a name="line.291"></a>
<FONT color="green">292</FONT>        /**<a name="line.292"></a>
<FONT color="green">293</FONT>         * Specifies that a point's annotation (label) should be centered on the<a name="line.293"></a>
<FONT color="green">294</FONT>         * center-point of the arc side of a pie slice.<a name="line.294"></a>
<FONT color="green">295</FONT>         * &lt;p&gt;<a name="line.295"></a>
<FONT color="green">296</FONT>         * <a name="line.296"></a>
<FONT color="green">297</FONT>         * You can move a pie slice's annotation a specific number of pixels<a name="line.297"></a>
<FONT color="green">298</FONT>         * radially away from (or towards) the pie center by passing a positive (or<a name="line.298"></a>
<FONT color="green">299</FONT>         * negative) argument to the associated &lt;tt&gt;Point&lt;/tt&gt;'s<a name="line.299"></a>
<FONT color="green">300</FONT>         * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; method.<a name="line.300"></a>
<FONT color="green">301</FONT>         * <a name="line.301"></a>
<FONT color="green">302</FONT>         * &lt;p&gt;<a name="line.302"></a>
<FONT color="green">303</FONT>         * This is pie-friendly synonym for, and when used with non-pie symbol types<a name="line.303"></a>
<FONT color="green">304</FONT>         * will behave exactly the same as, &lt;tt&gt;AnnotationLocation.CENTER&lt;/tt&gt;<a name="line.304"></a>
<FONT color="green">305</FONT>         * <a name="line.305"></a>
<FONT color="green">306</FONT>         * @see #OUTSIDE_PIE_ARC OUTSIDE_PIE_ARC<a name="line.306"></a>
<FONT color="green">307</FONT>         * @see #INSIDE_PIE_ARC INSIDE_PIE_ARC<a name="line.307"></a>
<FONT color="green">308</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.308"></a>
<FONT color="green">309</FONT>         * @see AnnotationLocation#CENTER CENTER<a name="line.309"></a>
<FONT color="green">310</FONT>         * <a name="line.310"></a>
<FONT color="green">311</FONT>         */<a name="line.311"></a>
<FONT color="green">312</FONT>        public static final AnnotationLocation ON_PIE_ARC = CENTER;<a name="line.312"></a>
<FONT color="green">313</FONT>    <a name="line.313"></a>
<FONT color="green">314</FONT>        /**<a name="line.314"></a>
<FONT color="green">315</FONT>         * Specifies that a point's annotation (label) should be positioned just<a name="line.315"></a>
<FONT color="green">316</FONT>         * outside, and centered on, the arc side of a pie slice.<a name="line.316"></a>
<FONT color="green">317</FONT>         * &lt;p&gt;<a name="line.317"></a>
<FONT color="green">318</FONT>         * <a name="line.318"></a>
<FONT color="green">319</FONT>         * You can move a pie slice's annotation a specific number of pixels<a name="line.319"></a>
<FONT color="green">320</FONT>         * radially away from (or towards) the pie center by passing a positive (or<a name="line.320"></a>
<FONT color="green">321</FONT>         * negative) argument to the associated &lt;tt&gt;Point&lt;/tt&gt;'s<a name="line.321"></a>
<FONT color="green">322</FONT>         * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; method.<a name="line.322"></a>
<FONT color="green">323</FONT>         * <a name="line.323"></a>
<FONT color="green">324</FONT>         * &lt;p&gt;<a name="line.324"></a>
<FONT color="green">325</FONT>         * This is pie-friendly synonym for, and when used with non-pie symbol types<a name="line.325"></a>
<FONT color="green">326</FONT>         * will behave exactly the same as, &lt;tt&gt;AnnotationLocation.SOUTH&lt;/tt&gt;<a name="line.326"></a>
<FONT color="green">327</FONT>         * <a name="line.327"></a>
<FONT color="green">328</FONT>         * @see #INSIDE_PIE_ARC INSIDE_PIE_ARC<a name="line.328"></a>
<FONT color="green">329</FONT>         * @see #ON_PIE_ARC ON_PIE_ARC<a name="line.329"></a>
<FONT color="green">330</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.330"></a>
<FONT color="green">331</FONT>         * @see Curve.Point#setAnnotationXShift setAnnotationXShift<a name="line.331"></a>
<FONT color="green">332</FONT>         * @see AnnotationLocation#SOUTH SOUTH<a name="line.332"></a>
<FONT color="green">333</FONT>         */<a name="line.333"></a>
<FONT color="green">334</FONT>        public static final AnnotationLocation OUTSIDE_PIE_ARC = south;<a name="line.334"></a>
<FONT color="green">335</FONT>    <a name="line.335"></a>
<FONT color="green">336</FONT>        /**<a name="line.336"></a>
<FONT color="green">337</FONT>         * Specifies that a point's annotation (label) should be positioned just<a name="line.337"></a>
<FONT color="green">338</FONT>         * below, and horizontally centered on, the symbol used to represent the<a name="line.338"></a>
<FONT color="green">339</FONT>         * point.<a name="line.339"></a>
<FONT color="green">340</FONT>         * <a name="line.340"></a>
<FONT color="green">341</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.341"></a>
<FONT color="green">342</FONT>         */<a name="line.342"></a>
<FONT color="green">343</FONT>        public static final AnnotationLocation SOUTH = south;<a name="line.343"></a>
<FONT color="green">344</FONT>    <a name="line.344"></a>
<FONT color="green">345</FONT>        /**<a name="line.345"></a>
<FONT color="green">346</FONT>         * Specifies that a point's annotation (label) should be positioned just to<a name="line.346"></a>
<FONT color="green">347</FONT>         * the right of and below, the symbol used to represent the point.<a name="line.347"></a>
<FONT color="green">348</FONT>         * <a name="line.348"></a>
<FONT color="green">349</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.349"></a>
<FONT color="green">350</FONT>         */<a name="line.350"></a>
<FONT color="green">351</FONT>        public static final AnnotationLocation SOUTHEAST =<a name="line.351"></a>
<FONT color="green">352</FONT>            new AnnotationLocation(1, 1);<a name="line.352"></a>
<FONT color="green">353</FONT>        /**<a name="line.353"></a>
<FONT color="green">354</FONT>         * Specifies that a point's annotation (label) should be positioned just to<a name="line.354"></a>
<FONT color="green">355</FONT>         * the left of and below, the symbol used to represent the point.<a name="line.355"></a>
<FONT color="green">356</FONT>         * <a name="line.356"></a>
<FONT color="green">357</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.357"></a>
<FONT color="green">358</FONT>         */<a name="line.358"></a>
<FONT color="green">359</FONT>        public static final AnnotationLocation SOUTHWEST =<a name="line.359"></a>
<FONT color="green">360</FONT>            new AnnotationLocation(-1, 1);<a name="line.360"></a>
<FONT color="green">361</FONT>    <a name="line.361"></a>
<FONT color="green">362</FONT>        /**<a name="line.362"></a>
<FONT color="green">363</FONT>         * Specifies that a point's annotation (label) should be positioned just to<a name="line.363"></a>
<FONT color="green">364</FONT>         * the left of, and vertically centered on, the symbol used to represent the<a name="line.364"></a>
<FONT color="green">365</FONT>         * point.<a name="line.365"></a>
<FONT color="green">366</FONT>         * <a name="line.366"></a>
<FONT color="green">367</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.367"></a>
<FONT color="green">368</FONT>         */<a name="line.368"></a>
<FONT color="green">369</FONT>        public static final AnnotationLocation WEST = west;<a name="line.369"></a>
<FONT color="green">370</FONT>    <a name="line.370"></a>
<FONT color="green">371</FONT>        /*<a name="line.371"></a>
<FONT color="green">372</FONT>         * These multiply the width and height of the annotation and the<a name="line.372"></a>
<FONT color="green">373</FONT>         * symbol it is attached to in order to define the center of the<a name="line.373"></a>
<FONT color="green">374</FONT>         * annotation (c.f. &lt;tt&gt;getUpperLeftX&lt;/tt&gt; and<a name="line.374"></a>
<FONT color="green">375</FONT>         * &lt;tt&gt;getUpperLeftY&lt;/tt&gt; below), and thus the upper left corner<a name="line.375"></a>
<FONT color="green">376</FONT>         * anchoring point.<a name="line.376"></a>
<FONT color="green">377</FONT>         * <a name="line.377"></a>
<FONT color="green">378</FONT>         */ <a name="line.378"></a>
<FONT color="green">379</FONT>        private int heightMultiplier;<a name="line.379"></a>
<FONT color="green">380</FONT>        private int widthMultiplier;<a name="line.380"></a>
<FONT color="green">381</FONT>    <a name="line.381"></a>
<FONT color="green">382</FONT>        private AnnotationLocation(int widthMultiplier, int heightMultiplier) {<a name="line.382"></a>
<FONT color="green">383</FONT>          validateMultipliers(widthMultiplier, heightMultiplier);<a name="line.383"></a>
<FONT color="green">384</FONT>          this.widthMultiplier = widthMultiplier;<a name="line.384"></a>
<FONT color="green">385</FONT>          this.heightMultiplier = heightMultiplier;<a name="line.385"></a>
<FONT color="green">386</FONT>        }<a name="line.386"></a>
<FONT color="green">387</FONT>    <a name="line.387"></a>
<FONT color="green">388</FONT>        /*<a name="line.388"></a>
<FONT color="green">389</FONT>         * Retrieves a static location given its multipliers.<a name="line.389"></a>
<FONT color="green">390</FONT>         */ <a name="line.390"></a>
<FONT color="green">391</FONT>        private static AnnotationLocation getAnnotationLocation(<a name="line.391"></a>
<FONT color="green">392</FONT>            int widthMultiplier, int heightMultiplier) {<a name="line.392"></a>
<FONT color="green">393</FONT>          final AnnotationLocation[][] locationMap = {<a name="line.393"></a>
<FONT color="green">394</FONT>              { NORTHWEST, NORTH, NORTHEAST },<a name="line.394"></a>
<FONT color="green">395</FONT>              { WEST, CENTER, EAST },<a name="line.395"></a>
<FONT color="green">396</FONT>              { SOUTHWEST, SOUTH, SOUTHEAST } };<a name="line.396"></a>
<FONT color="green">397</FONT>          // assumes both multiplier are -1, 0, or 1<a name="line.397"></a>
<FONT color="green">398</FONT>          AnnotationLocation result = locationMap[heightMultiplier + 1][widthMultiplier + 1];<a name="line.398"></a>
<FONT color="green">399</FONT>          return result;<a name="line.399"></a>
<FONT color="green">400</FONT>        }<a name="line.400"></a>
<FONT color="green">401</FONT>    <a name="line.401"></a>
<FONT color="green">402</FONT>        /*<a name="line.402"></a>
<FONT color="green">403</FONT>         * Negative width or height "turn the symbol inside-out", requiring<a name="line.403"></a>
<FONT color="green">404</FONT>         * a corresponding "reflection" of annotation location (only needed<a name="line.404"></a>
<FONT color="green">405</FONT>         * for baseline-based bar symbols).<a name="line.405"></a>
<FONT color="green">406</FONT>         * <a name="line.406"></a>
<FONT color="green">407</FONT>         */ <a name="line.407"></a>
<FONT color="green">408</FONT>        static AnnotationLocation transform(AnnotationLocation a,<a name="line.408"></a>
<FONT color="green">409</FONT>            int signWidth, int signHeight) {<a name="line.409"></a>
<FONT color="green">410</FONT>          AnnotationLocation result = a;<a name="line.410"></a>
<FONT color="green">411</FONT>          if (signWidth &lt; 0 || signHeight &lt; 0)<a name="line.411"></a>
<FONT color="green">412</FONT>            result = getAnnotationLocation(<a name="line.412"></a>
<FONT color="green">413</FONT>                signWidth * a.widthMultiplier, signHeight * a.heightMultiplier);<a name="line.413"></a>
<FONT color="green">414</FONT>    <a name="line.414"></a>
<FONT color="green">415</FONT>          return result;<a name="line.415"></a>
<FONT color="green">416</FONT>        }<a name="line.416"></a>
<FONT color="green">417</FONT>    <a name="line.417"></a>
<FONT color="green">418</FONT>        /*<a name="line.418"></a>
<FONT color="green">419</FONT>         * These define the alignment of the label within it's containing 1<a name="line.419"></a>
<FONT color="green">420</FONT>         * x 1 Grid (&amp;lt;table*gt;). For example, if this containing Grid is<a name="line.420"></a>
<FONT color="green">421</FONT>         * to the left of the labeled symbol (widthMultiplier==-1) the<a name="line.421"></a>
<FONT color="green">422</FONT>         * horizontal alignment will be ALIGN_RIGHT, so as to bring the<a name="line.422"></a>
<FONT color="green">423</FONT>         * contained label flush against the left edge of the labeled<a name="line.423"></a>
<FONT color="green">424</FONT>         * symbol.<a name="line.424"></a>
<FONT color="green">425</FONT>         * <a name="line.425"></a>
<FONT color="green">426</FONT>         */ <a name="line.426"></a>
<FONT color="green">427</FONT>        HasHorizontalAlignment.HorizontalAlignmentConstant getHorizontalAlignment() {<a name="line.427"></a>
<FONT color="green">428</FONT>          HasHorizontalAlignment.HorizontalAlignmentConstant result;<a name="line.428"></a>
<FONT color="green">429</FONT>          if (widthMultiplier == -1)<a name="line.429"></a>
<FONT color="green">430</FONT>            result = HasHorizontalAlignment.ALIGN_RIGHT;<a name="line.430"></a>
<FONT color="green">431</FONT>          else if (widthMultiplier == 0)<a name="line.431"></a>
<FONT color="green">432</FONT>            result = HasHorizontalAlignment.ALIGN_CENTER;<a name="line.432"></a>
<FONT color="green">433</FONT>          else if (widthMultiplier == 1)<a name="line.433"></a>
<FONT color="green">434</FONT>            result = HasHorizontalAlignment.ALIGN_LEFT;<a name="line.434"></a>
<FONT color="green">435</FONT>          else<a name="line.435"></a>
<FONT color="green">436</FONT>            throw new IllegalStateException("Invalid widthMultiplier: "<a name="line.436"></a>
<FONT color="green">437</FONT>                + widthMultiplier + " 1, 0, or -1 were expected.");<a name="line.437"></a>
<FONT color="green">438</FONT>          return result;<a name="line.438"></a>
<FONT color="green">439</FONT>        }<a name="line.439"></a>
<FONT color="green">440</FONT>    <a name="line.440"></a>
<FONT color="green">441</FONT>        /* analogous to getHorizontalAlignment, but for vertical alignment */<a name="line.441"></a>
<FONT color="green">442</FONT>        HasVerticalAlignment.VerticalAlignmentConstant getVerticalAlignment() {<a name="line.442"></a>
<FONT color="green">443</FONT>          HasVerticalAlignment.VerticalAlignmentConstant result;<a name="line.443"></a>
<FONT color="green">444</FONT>          if (heightMultiplier == -1)<a name="line.444"></a>
<FONT color="green">445</FONT>            result = HasVerticalAlignment.ALIGN_BOTTOM;<a name="line.445"></a>
<FONT color="green">446</FONT>          else if (heightMultiplier == 0)<a name="line.446"></a>
<FONT color="green">447</FONT>            result = HasVerticalAlignment.ALIGN_MIDDLE;<a name="line.447"></a>
<FONT color="green">448</FONT>          else if (heightMultiplier == 1)<a name="line.448"></a>
<FONT color="green">449</FONT>            result = HasVerticalAlignment.ALIGN_TOP;<a name="line.449"></a>
<FONT color="green">450</FONT>          else<a name="line.450"></a>
<FONT color="green">451</FONT>            throw new IllegalStateException("Invalid heightMultiplier: "<a name="line.451"></a>
<FONT color="green">452</FONT>                                            + heightMultiplier + " -1, 0, or 1 were expected.");<a name="line.452"></a>
<FONT color="green">453</FONT>          return result;<a name="line.453"></a>
<FONT color="green">454</FONT>        }<a name="line.454"></a>
<FONT color="green">455</FONT>    <a name="line.455"></a>
<FONT color="green">456</FONT>        /*<a name="line.456"></a>
<FONT color="green">457</FONT>         * Given the x-coordinate at the center of the symbol that this<a name="line.457"></a>
<FONT color="green">458</FONT>         * annotation annotates, the annotation's width, and the symbol's<a name="line.458"></a>
<FONT color="green">459</FONT>         * width, this method returns the x-coordinate of the upper left<a name="line.459"></a>
<FONT color="green">460</FONT>         * corner (left edge) of this annotation.<a name="line.460"></a>
<FONT color="green">461</FONT>         */<a name="line.461"></a>
<FONT color="green">462</FONT>        int getUpperLeftX(double x, double w, double symbolW) {<a name="line.462"></a>
<FONT color="green">463</FONT>          int result = (int) Math.round(x<a name="line.463"></a>
<FONT color="green">464</FONT>              + (widthMultiplier * (w + symbolW) - w) / 2.);<a name="line.464"></a>
<FONT color="green">465</FONT>          return result;<a name="line.465"></a>
<FONT color="green">466</FONT>        }<a name="line.466"></a>
<FONT color="green">467</FONT>    <a name="line.467"></a>
<FONT color="green">468</FONT>        /* analogous to getUpperLeftX, but for the y-coordinate (top edge) */<a name="line.468"></a>
<FONT color="green">469</FONT>        int getUpperLeftY(double y, double h, double symbolH) {<a name="line.469"></a>
<FONT color="green">470</FONT>          int result = (int) Math.round(y<a name="line.470"></a>
<FONT color="green">471</FONT>              + (heightMultiplier * (h + symbolH) - h) / 2.);<a name="line.471"></a>
<FONT color="green">472</FONT>          return result;<a name="line.472"></a>
<FONT color="green">473</FONT>        }<a name="line.473"></a>
<FONT color="green">474</FONT>    <a name="line.474"></a>
<FONT color="green">475</FONT>        /*<a name="line.475"></a>
<FONT color="green">476</FONT>         * This method returns the annotation location whose "attachment point"<a name="line.476"></a>
<FONT color="green">477</FONT>         * keeps the annotation either completely outside, centered on, or<a name="line.477"></a>
<FONT color="green">478</FONT>         * completely inside (depending on if the heightMultiplier of this<a name="line.478"></a>
<FONT color="green">479</FONT>         * annotation is 1, 0, or -1) the point on the pie's circumference<a name="line.479"></a>
<FONT color="green">480</FONT>         * associated with the given angle. &lt;p&gt;<a name="line.480"></a>
<FONT color="green">481</FONT>         * <a name="line.481"></a>
<FONT color="green">482</FONT>         * The use of heightMultiplier rather than widthMultiplier is somewhat<a name="line.482"></a>
<FONT color="green">483</FONT>         * arbitrary, but was chosen so that the NORTH, CENTER, and SOUTH annotation<a name="line.483"></a>
<FONT color="green">484</FONT>         * locations have the same interpretation for a pie slice whose bisecting<a name="line.484"></a>
<FONT color="green">485</FONT>         * radius points due south (due south is the default initial pie slice<a name="line.485"></a>
<FONT color="green">486</FONT>         * orientation) and for a 1px x 1px BOX_CENTER type symbol positioned at the<a name="line.486"></a>
<FONT color="green">487</FONT>         * due south position on the pie's circumference. As the<a name="line.487"></a>
<FONT color="green">488</FONT>         * pie-slice-arc-bisection point moves clockwise around the pie perimeter,<a name="line.488"></a>
<FONT color="green">489</FONT>         * the attachment point (except for vertically-centered annotations, which<a name="line.489"></a>
<FONT color="green">490</FONT>         * remain centered on the pie arc) also moves clockwise, but in discrete<a name="line.490"></a>
<FONT color="green">491</FONT>         * jumps (e.g. from NORTH, to NORTHEAST, to EAST, to SOUTHEAST, to SOUTH,<a name="line.491"></a>
<FONT color="green">492</FONT>         * etc. for annotations inside the pie) so the annotation remains<a name="line.492"></a>
<FONT color="green">493</FONT>         * appropriately attached to the center of the slice's arc as the angle<a name="line.493"></a>
<FONT color="green">494</FONT>         * changes.<a name="line.494"></a>
<FONT color="green">495</FONT>         * &lt;p&gt;<a name="line.495"></a>
<FONT color="green">496</FONT>         * <a name="line.496"></a>
<FONT color="green">497</FONT>         * thetaMid is the conventional trigonometric angle measured<a name="line.497"></a>
<FONT color="green">498</FONT>         * counter-clockwise from +x.<a name="line.498"></a>
<FONT color="green">499</FONT>         * <a name="line.499"></a>
<FONT color="green">500</FONT>         */<a name="line.500"></a>
<FONT color="green">501</FONT>        AnnotationLocation decodePieLocation(double thetaMid) {<a name="line.501"></a>
<FONT color="green">502</FONT>          /*<a name="line.502"></a>
<FONT color="green">503</FONT>           * A sin or cos that is small enough so that the associated angle<a name="line.503"></a>
<FONT color="green">504</FONT>           * is horizontal (for sines) or vertical (for cosines) enough to<a name="line.504"></a>
<FONT color="green">505</FONT>           * warrant use of a "centered" annotation location.<a name="line.505"></a>
<FONT color="green">506</FONT>           * <a name="line.506"></a>
<FONT color="green">507</FONT>           */ <a name="line.507"></a>
<FONT color="green">508</FONT>          final double LOOKS_VERTICAL_OR_HORIZONTAL_DELTA = 0.1;<a name="line.508"></a>
<FONT color="green">509</FONT>          double sinTheta = Math.sin(thetaMid);<a name="line.509"></a>
<FONT color="green">510</FONT>          double cosTheta = Math.cos(thetaMid);<a name="line.510"></a>
<FONT color="green">511</FONT>          int pieTransformedWidthMultiplier = heightMultiplier<a name="line.511"></a>
<FONT color="green">512</FONT>              * ((cosTheta &lt; -LOOKS_VERTICAL_OR_HORIZONTAL_DELTA) ? -1<a name="line.512"></a>
<FONT color="green">513</FONT>              : ((cosTheta &gt; LOOKS_VERTICAL_OR_HORIZONTAL_DELTA) ? 1<a name="line.513"></a>
<FONT color="green">514</FONT>              : 0));<a name="line.514"></a>
<FONT color="green">515</FONT>          int pieTransformedHeightMultiplier = heightMultiplier<a name="line.515"></a>
<FONT color="green">516</FONT>              * ((sinTheta &lt; -LOOKS_VERTICAL_OR_HORIZONTAL_DELTA) ? 1<a name="line.516"></a>
<FONT color="green">517</FONT>              : ((sinTheta &gt; LOOKS_VERTICAL_OR_HORIZONTAL_DELTA) ? -1<a name="line.517"></a>
<FONT color="green">518</FONT>              : 0));<a name="line.518"></a>
<FONT color="green">519</FONT>    <a name="line.519"></a>
<FONT color="green">520</FONT>          return getAnnotationLocation(pieTransformedWidthMultiplier,<a name="line.520"></a>
<FONT color="green">521</FONT>              pieTransformedHeightMultiplier);<a name="line.521"></a>
<FONT color="green">522</FONT>    <a name="line.522"></a>
<FONT color="green">523</FONT>        }<a name="line.523"></a>
<FONT color="green">524</FONT>    <a name="line.524"></a>
<FONT color="green">525</FONT>      } // end of class AnnotationLocation<a name="line.525"></a>
<FONT color="green">526</FONT>    <a name="line.526"></a>
<FONT color="green">527</FONT>      /**<a name="line.527"></a>
<FONT color="green">528</FONT>       * Defines keywords that specify<a name="line.528"></a>
<FONT color="green">529</FONT>       * the location of the legend on the chart.  &lt;p&gt;<a name="line.529"></a>
<FONT color="green">530</FONT>       *<a name="line.530"></a>
<FONT color="green">531</FONT>       * &lt;i&gt;Tip:&lt;/i&gt; You can emulate the missing &lt;tt&gt;OUTSIDE_TOP&lt;/tt&gt; and<a name="line.531"></a>
<FONT color="green">532</FONT>       * &lt;tt&gt;OUTSIDE_BOTTOM&lt;/tt&gt; locations by using &lt;tt&gt;INSIDE_TOP&lt;/tt&gt; or<a name="line.532"></a>
<FONT color="green">533</FONT>       * &lt;tt&gt;INSIDE_BOTTOM&lt;/tt&gt; and shifting the y position appropriately<a name="line.533"></a>
<FONT color="green">534</FONT>       * via &lt;tt&gt;setLegendYShift&lt;/tt&gt;.<a name="line.534"></a>
<FONT color="green">535</FONT>       * &lt;p&gt;<a name="line.535"></a>
<FONT color="green">536</FONT>       *<a name="line.536"></a>
<FONT color="green">537</FONT>       * &lt;i&gt;Tip:&lt;/i&gt; If GChart's internally generated, single column<a name="line.537"></a>
<FONT color="green">538</FONT>       * formatted, legend key isn't appropriate, you can use your own<a name="line.538"></a>
<FONT color="green">539</FONT>       * legend widget via &lt;tt&gt;setLegend&lt;/tt&gt;.<a name="line.539"></a>
<FONT color="green">540</FONT>       * <a name="line.540"></a>
<FONT color="green">541</FONT>       * <a name="line.541"></a>
<FONT color="green">542</FONT>       * @see #setLegendLocation setLegendLocation<a name="line.542"></a>
<FONT color="green">543</FONT>       * @see #setLegendXShift setLegendYShift<a name="line.543"></a>
<FONT color="green">544</FONT>       * @see #setLegendYShift setLegendYShift<a name="line.544"></a>
<FONT color="green">545</FONT>       * @see #setLegend setLegend<a name="line.545"></a>
<FONT color="green">546</FONT>       * <a name="line.546"></a>
<FONT color="green">547</FONT>       */<a name="line.547"></a>
<FONT color="green">548</FONT>    <a name="line.548"></a>
<FONT color="green">549</FONT>      public static class LegendLocation {<a name="line.549"></a>
<FONT color="green">550</FONT>        /*<a name="line.550"></a>
<FONT color="green">551</FONT>         * To realize this location, the system curve representing the<a name="line.551"></a>
<FONT color="green">552</FONT>         * legend will be given this symbol type and annotation location.<a name="line.552"></a>
<FONT color="green">553</FONT>         * <a name="line.553"></a>
<FONT color="green">554</FONT>         */ <a name="line.554"></a>
<FONT color="green">555</FONT>        private SymbolType symbolType;<a name="line.555"></a>
<FONT color="green">556</FONT>        private AnnotationLocation annotationLocation;<a name="line.556"></a>
<FONT color="green">557</FONT>    <a name="line.557"></a>
<FONT color="green">558</FONT>        private LegendLocation(SymbolType symbolType,<a name="line.558"></a>
<FONT color="green">559</FONT>            AnnotationLocation annotationLocation) {<a name="line.559"></a>
<FONT color="green">560</FONT>          this.symbolType = symbolType;<a name="line.560"></a>
<FONT color="green">561</FONT>          this.annotationLocation = annotationLocation;<a name="line.561"></a>
<FONT color="green">562</FONT>        }<a name="line.562"></a>
<FONT color="green">563</FONT>    <a name="line.563"></a>
<FONT color="green">564</FONT>        SymbolType getSymbolType() {<a name="line.564"></a>
<FONT color="green">565</FONT>          return symbolType;<a name="line.565"></a>
<FONT color="green">566</FONT>        }<a name="line.566"></a>
<FONT color="green">567</FONT>    <a name="line.567"></a>
<FONT color="green">568</FONT>        AnnotationLocation getAnnotationLocation() {<a name="line.568"></a>
<FONT color="green">569</FONT>          return annotationLocation;<a name="line.569"></a>
<FONT color="green">570</FONT>        }<a name="line.570"></a>
<FONT color="green">571</FONT>    <a name="line.571"></a>
<FONT color="green">572</FONT>        /*<a name="line.572"></a>
<FONT color="green">573</FONT>         * These initial pixel shifts from the symbol/location defined<a name="line.573"></a>
<FONT color="green">574</FONT>         * initial positions are used, for example, to leave space for the<a name="line.574"></a>
<FONT color="green">575</FONT>         * x, y or y2 axis ticks, tick labels, and axis labels. Note that<a name="line.575"></a>
<FONT color="green">576</FONT>         * legend anchoring positions are always at compass point positions<a name="line.576"></a>
<FONT color="green">577</FONT>         * around the plot area (via the ANCHOR_* family of symbol types).<a name="line.577"></a>
<FONT color="green">578</FONT>         * <a name="line.578"></a>
<FONT color="green">579</FONT>         */<a name="line.579"></a>
<FONT color="green">580</FONT>        int getInitialXShift(GChart g) {<a name="line.580"></a>
<FONT color="green">581</FONT>          return 0;<a name="line.581"></a>
<FONT color="green">582</FONT>        }<a name="line.582"></a>
<FONT color="green">583</FONT>        int getInitialYShift(GChart g) {<a name="line.583"></a>
<FONT color="green">584</FONT>          return 0;<a name="line.584"></a>
<FONT color="green">585</FONT>        }<a name="line.585"></a>
<FONT color="green">586</FONT>    <a name="line.586"></a>
<FONT color="green">587</FONT>        /*<a name="line.587"></a>
<FONT color="green">588</FONT>         * Retrieves the space taken up by the legend on the left and the right<a name="line.588"></a>
<FONT color="green">589</FONT>         * sides of the chart when it is placed at this location. &lt;p&gt;<a name="line.589"></a>
<FONT color="green">590</FONT>         * <a name="line.590"></a>
<FONT color="green">591</FONT>         * The INSIDE_* family of legend locations take up no space on the left or<a name="line.591"></a>
<FONT color="green">592</FONT>         * right of the chart, so they just use the default (0). &lt;p&gt;<a name="line.592"></a>
<FONT color="green">593</FONT>         * <a name="line.593"></a>
<FONT color="green">594</FONT>         * OUTSIDE_LEFT, OUTSIDE_RIGHT methods override getLeftThickness,<a name="line.594"></a>
<FONT color="green">595</FONT>         * getRightThickness so as to account for the space the legend takes up when<a name="line.595"></a>
<FONT color="green">596</FONT>         * positioned outside the chart. &lt;p&gt;<a name="line.596"></a>
<FONT color="green">597</FONT>         * <a name="line.597"></a>
<FONT color="green">598</FONT>         * GChart uses these methods to adjust the relative positioning of various<a name="line.598"></a>
<FONT color="green">599</FONT>         * chart parts so as to leave enough room for the legend, regardless of<a name="line.599"></a>
<FONT color="green">600</FONT>         * where it is located.<a name="line.600"></a>
<FONT color="green">601</FONT>         * <a name="line.601"></a>
<FONT color="green">602</FONT>         */<a name="line.602"></a>
<FONT color="green">603</FONT>        int getLeftThickness(GChart g) {<a name="line.603"></a>
<FONT color="green">604</FONT>          return 0;<a name="line.604"></a>
<FONT color="green">605</FONT>        }<a name="line.605"></a>
<FONT color="green">606</FONT>    <a name="line.606"></a>
<FONT color="green">607</FONT>        int getRightThickness(GChart g) {<a name="line.607"></a>
<FONT color="green">608</FONT>          return 0;<a name="line.608"></a>
<FONT color="green">609</FONT>        }<a name="line.609"></a>
<FONT color="green">610</FONT>    <a name="line.610"></a>
<FONT color="green">611</FONT>        // the legend location to the right of the plot area<a name="line.611"></a>
<FONT color="green">612</FONT>        private static final class RightLegendLocation extends LegendLocation {<a name="line.612"></a>
<FONT color="green">613</FONT>          RightLegendLocation() {<a name="line.613"></a>
<FONT color="green">614</FONT>            super(SymbolType.ANCHOR_EAST, AnnotationLocation.CENTER);<a name="line.614"></a>
<FONT color="green">615</FONT>          }<a name="line.615"></a>
<FONT color="green">616</FONT>    <a name="line.616"></a>
<FONT color="green">617</FONT>          @Override<a name="line.617"></a>
<FONT color="green">618</FONT>          int getInitialXShift(GChart g) {<a name="line.618"></a>
<FONT color="green">619</FONT>            int result = g.getY2Axis().getTickLabelThickness(false)<a name="line.619"></a>
<FONT color="green">620</FONT>                + g.getY2Axis().getTickSpace()<a name="line.620"></a>
<FONT color="green">621</FONT>                + g.getY2Axis().getTickLabelPadding()<a name="line.621"></a>
<FONT color="green">622</FONT>                + g.getY2Axis().getAxisLabelThickness()<a name="line.622"></a>
<FONT color="green">623</FONT>                + g.getLegendThickness() / 2;<a name="line.623"></a>
<FONT color="green">624</FONT>            return result;<a name="line.624"></a>
<FONT color="green">625</FONT>          }<a name="line.625"></a>
<FONT color="green">626</FONT>    <a name="line.626"></a>
<FONT color="green">627</FONT>          @Override<a name="line.627"></a>
<FONT color="green">628</FONT>          int getRightThickness(GChart g) {<a name="line.628"></a>
<FONT color="green">629</FONT>            int result = g.getLegendThickness();<a name="line.629"></a>
<FONT color="green">630</FONT>            return result;<a name="line.630"></a>
<FONT color="green">631</FONT>          }<a name="line.631"></a>
<FONT color="green">632</FONT>        }<a name="line.632"></a>
<FONT color="green">633</FONT>    <a name="line.633"></a>
<FONT color="green">634</FONT>        // the legend location to the left of the plot area<a name="line.634"></a>
<FONT color="green">635</FONT>        private static final class LeftLegendLocation extends LegendLocation {<a name="line.635"></a>
<FONT color="green">636</FONT>          LeftLegendLocation() {<a name="line.636"></a>
<FONT color="green">637</FONT>            super(SymbolType.ANCHOR_WEST, AnnotationLocation.CENTER);<a name="line.637"></a>
<FONT color="green">638</FONT>          }<a name="line.638"></a>
<FONT color="green">639</FONT>    <a name="line.639"></a>
<FONT color="green">640</FONT>          @Override<a name="line.640"></a>
<FONT color="green">641</FONT>          int getInitialXShift(GChart g) {<a name="line.641"></a>
<FONT color="green">642</FONT>            int result = -g.getYAxis().getTickLabelThickness(false)<a name="line.642"></a>
<FONT color="green">643</FONT>                - g.getYAxis().getTickSpace()<a name="line.643"></a>
<FONT color="green">644</FONT>                - g.getYAxis().getTickLabelPadding()<a name="line.644"></a>
<FONT color="green">645</FONT>                - g.getYAxis().getAxisLabelThickness()<a name="line.645"></a>
<FONT color="green">646</FONT>                - g.getLegendThickness() / 2;<a name="line.646"></a>
<FONT color="green">647</FONT>            return result;<a name="line.647"></a>
<FONT color="green">648</FONT>          }<a name="line.648"></a>
<FONT color="green">649</FONT>    <a name="line.649"></a>
<FONT color="green">650</FONT>          @Override<a name="line.650"></a>
<FONT color="green">651</FONT>          int getLeftThickness(GChart g) {<a name="line.651"></a>
<FONT color="green">652</FONT>            int result = g.getLegendThickness();<a name="line.652"></a>
<FONT color="green">653</FONT>            return result;<a name="line.653"></a>
<FONT color="green">654</FONT>          }<a name="line.654"></a>
<FONT color="green">655</FONT>        }<a name="line.655"></a>
<FONT color="green">656</FONT>    <a name="line.656"></a>
<FONT color="green">657</FONT>        /**<a name="line.657"></a>
<FONT color="green">658</FONT>         * Places the legend inside the plot area, centered along the bottom<a name="line.658"></a>
<FONT color="green">659</FONT>         * edge.<a name="line.659"></a>
<FONT color="green">660</FONT>         * <a name="line.660"></a>
<FONT color="green">661</FONT>         * @see GChart#setLegendLocation setLegendLocation<a name="line.661"></a>
<FONT color="green">662</FONT>         */<a name="line.662"></a>
<FONT color="green">663</FONT>        public final static LegendLocation INSIDE_BOTTOM = new LegendLocation(<a name="line.663"></a>
<FONT color="green">664</FONT>                SymbolType.ANCHOR_SOUTH, AnnotationLocation.NORTH);<a name="line.664"></a>
<FONT color="green">665</FONT>        /**<a name="line.665"></a>
<FONT color="green">666</FONT>         * Places the legend in the lower left inside corner of the plot area.<a name="line.666"></a>
<FONT color="green">667</FONT>         * <a name="line.667"></a>
<FONT color="green">668</FONT>         * @see GChart#setLegendLocation setLegendLocation<a name="line.668"></a>
<FONT color="green">669</FONT>         */<a name="line.669"></a>
<FONT color="green">670</FONT>        public final static LegendLocation INSIDE_BOTTOMLEFT = new LegendLocation(<a name="line.670"></a>
<FONT color="green">671</FONT>                SymbolType.ANCHOR_SOUTHWEST, AnnotationLocation.NORTHEAST);<a name="line.671"></a>
<FONT color="green">672</FONT>        /**<a name="line.672"></a>
<FONT color="green">673</FONT>         * Places the legend in the lower right inside corner of the plot area.<a name="line.673"></a>
<FONT color="green">674</FONT>         * <a name="line.674"></a>
<FONT color="green">675</FONT>         * @see GChart#setLegendLocation setLegendLocation<a name="line.675"></a>
<FONT color="green">676</FONT>         */<a name="line.676"></a>
<FONT color="green">677</FONT>        public final static LegendLocation INSIDE_BOTTOMRIGHT = new LegendLocation(<a name="line.677"></a>
<FONT color="green">678</FONT>                SymbolType.ANCHOR_SOUTHEAST, AnnotationLocation.NORTHWEST);<a name="line.678"></a>
<FONT color="green">679</FONT>        /**<a name="line.679"></a>
<FONT color="green">680</FONT>         * Places the legend inside the plot area, centered along the left<a name="line.680"></a>
<FONT color="green">681</FONT>         * edge.<a name="line.681"></a>
<FONT color="green">682</FONT>         * <a name="line.682"></a>
<FONT color="green">683</FONT>         * @see GChart#setLegendLocation setLegendLocation<a name="line.683"></a>
<FONT color="green">684</FONT>         */<a name="line.684"></a>
<FONT color="green">685</FONT>        public final static LegendLocation INSIDE_LEFT = new LegendLocation(<a name="line.685"></a>
<FONT color="green">686</FONT>                SymbolType.ANCHOR_WEST, AnnotationLocation.EAST);<a name="line.686"></a>
<FONT color="green">687</FONT>        /**<a name="line.687"></a>
<FONT color="green">688</FONT>         * Places the legend inside the plot area, centered along the right<a name="line.688"></a>
<FONT color="green">689</FONT>         * edge.<a name="line.689"></a>
<FONT color="green">690</FONT>         * <a name="line.690"></a>
<FONT color="green">691</FONT>         * @see GChart#setLegendLocation setLegendLocation<a name="line.691"></a>
<FONT color="green">692</FONT>         */<a name="line.692"></a>
<FONT color="green">693</FONT>        public final static LegendLocation INSIDE_RIGHT = new LegendLocation(<a name="line.693"></a>
<FONT color="green">694</FONT>                SymbolType.ANCHOR_EAST, AnnotationLocation.WEST);<a name="line.694"></a>
<FONT color="green">695</FONT>        /**<a name="line.695"></a>
<FONT color="green">696</FONT>         * Places the legend inside the plot area, centered along the top<a name="line.696"></a>
<FONT color="green">697</FONT>         * edge.<a name="line.697"></a>
<FONT color="green">698</FONT>         * <a name="line.698"></a>
<FONT color="green">699</FONT>         * @see GChart#setLegendLocation setLegendLocation<a name="line.699"></a>
<FONT color="green">700</FONT>         */<a name="line.700"></a>
<FONT color="green">701</FONT>        public final static LegendLocation INSIDE_TOP = new LegendLocation(<a name="line.701"></a>
<FONT color="green">702</FONT>                SymbolType.ANCHOR_NORTH, AnnotationLocation.SOUTH);<a name="line.702"></a>
<FONT color="green">703</FONT>    <a name="line.703"></a>
<FONT color="green">704</FONT>        /**<a name="line.704"></a>
<FONT color="green">705</FONT>         * Places the legend in the upper left inside corner of the plot area.<a name="line.705"></a>
<FONT color="green">706</FONT>         * <a name="line.706"></a>
<FONT color="green">707</FONT>         * @see GChart#setLegendLocation setLegendLocation<a name="line.707"></a>
<FONT color="green">708</FONT>         */<a name="line.708"></a>
<FONT color="green">709</FONT>        public final static LegendLocation INSIDE_TOPLEFT = new LegendLocation(<a name="line.709"></a>
<FONT color="green">710</FONT>            SymbolType.ANCHOR_NORTHWEST, AnnotationLocation.SOUTHEAST);<a name="line.710"></a>
<FONT color="green">711</FONT>        /**<a name="line.711"></a>
<FONT color="green">712</FONT>         * Places the legend in the upper right inside corner of the plot area.<a name="line.712"></a>
<FONT color="green">713</FONT>         * <a name="line.713"></a>
<FONT color="green">714</FONT>         * @see GChart#setLegendLocation setLegendLocation<a name="line.714"></a>
<FONT color="green">715</FONT>         */<a name="line.715"></a>
<FONT color="green">716</FONT>        public final static LegendLocation INSIDE_TOPRIGHT = new LegendLocation(<a name="line.716"></a>
<FONT color="green">717</FONT>            SymbolType.ANCHOR_NORTHEAST, AnnotationLocation.SOUTHWEST);<a name="line.717"></a>
<FONT color="green">718</FONT>        /**<a name="line.718"></a>
<FONT color="green">719</FONT>         * Places the legend so that it is vertically centered on the left edge of<a name="line.719"></a>
<FONT color="green">720</FONT>         * the chart's plot area, and to the left of the y axis label.<a name="line.720"></a>
<FONT color="green">721</FONT>         * <a name="line.721"></a>
<FONT color="green">722</FONT>         */<a name="line.722"></a>
<FONT color="green">723</FONT>        public final static LegendLocation OUTSIDE_LEFT = new LeftLegendLocation();<a name="line.723"></a>
<FONT color="green">724</FONT>        /**<a name="line.724"></a>
<FONT color="green">725</FONT>         * Places the legend so that it is vertically centered on the right edge of<a name="line.725"></a>
<FONT color="green">726</FONT>         * the chart's plot area, and to the right of the y2 axis label.<a name="line.726"></a>
<FONT color="green">727</FONT>         * <a name="line.727"></a>
<FONT color="green">728</FONT>         */<a name="line.728"></a>
<FONT color="green">729</FONT>        public final static LegendLocation OUTSIDE_RIGHT = new RightLegendLocation();<a name="line.729"></a>
<FONT color="green">730</FONT>      } // class LegendLocation <a name="line.730"></a>
<FONT color="green">731</FONT>    <a name="line.731"></a>
<FONT color="green">732</FONT>      /**<a name="line.732"></a>
<FONT color="green">733</FONT>       * Represents an axis of the chart, for example, the x, y, or y2 axis. An axis<a name="line.733"></a>
<FONT color="green">734</FONT>       * consists of the axis itself, along with its tick marks, tick labels and<a name="line.734"></a>
<FONT color="green">735</FONT>       * gridlines.<a name="line.735"></a>
<FONT color="green">736</FONT>       * <a name="line.736"></a>
<FONT color="green">737</FONT>       * @see XAxis XAxis<a name="line.737"></a>
<FONT color="green">738</FONT>       * @see YAxis YAxis<a name="line.738"></a>
<FONT color="green">739</FONT>       * @see Y2Axis Y2Axis<a name="line.739"></a>
<FONT color="green">740</FONT>       * @see #getXAxis getXAxis<a name="line.740"></a>
<FONT color="green">741</FONT>       * @see #getYAxis getYAxis<a name="line.741"></a>
<FONT color="green">742</FONT>       * @see #getY2Axis getY2Axis<a name="line.742"></a>
<FONT color="green">743</FONT>       * <a name="line.743"></a>
<FONT color="green">744</FONT>       */<a name="line.744"></a>
<FONT color="green">745</FONT>      public abstract class Axis {<a name="line.745"></a>
<FONT color="green">746</FONT>        // points dropped if more than this number of axis lengths off chart<a name="line.746"></a>
<FONT color="green">747</FONT>        private double outOfBoundsMultiplier = Double.NaN;<a name="line.747"></a>
<FONT color="green">748</FONT>        // true for X, false for Y<a name="line.748"></a>
<FONT color="green">749</FONT>        protected boolean isHorizontalAxis;<a name="line.749"></a>
<FONT color="green">750</FONT>        // sys curve representing ticks<a name="line.750"></a>
<FONT color="green">751</FONT>        protected int ticksId;<a name="line.751"></a>
<FONT color="green">752</FONT>        // sys curve representing gridlines<a name="line.752"></a>
<FONT color="green">753</FONT>        protected int gridlinesId;<a name="line.753"></a>
<FONT color="green">754</FONT>        // sys curve representing axis line<a name="line.754"></a>
<FONT color="green">755</FONT>        protected int axisId;<a name="line.755"></a>
<FONT color="green">756</FONT>        // +/-1 for right/left axes<a name="line.756"></a>
<FONT color="green">757</FONT>        protected int axisPosition;<a name="line.757"></a>
<FONT color="green">758</FONT>        protected TickLocation tickLocation = DEFAULT_TICK_LOCATION;<a name="line.758"></a>
<FONT color="green">759</FONT>        // number of developer curves on axis. Count does not include<a name="line.759"></a>
<FONT color="green">760</FONT>        // system or invisible curves.<a name="line.760"></a>
<FONT color="green">761</FONT>        private int nCurvesVisibleOnAxis = 0;<a name="line.761"></a>
<FONT color="green">762</FONT>    <a name="line.762"></a>
<FONT color="green">763</FONT>        void incrementCurves() {<a name="line.763"></a>
<FONT color="green">764</FONT>          nCurvesVisibleOnAxis++;<a name="line.764"></a>
<FONT color="green">765</FONT>        }<a name="line.765"></a>
<FONT color="green">766</FONT>    <a name="line.766"></a>
<FONT color="green">767</FONT>        void decrementCurves() {<a name="line.767"></a>
<FONT color="green">768</FONT>          nCurvesVisibleOnAxis--;<a name="line.768"></a>
<FONT color="green">769</FONT>        }<a name="line.769"></a>
<FONT color="green">770</FONT>    <a name="line.770"></a>
<FONT color="green">771</FONT>        // model unit limits associated with an axis<a name="line.771"></a>
<FONT color="green">772</FONT>        protected class AxisLimits {<a name="line.772"></a>
<FONT color="green">773</FONT>          double min;<a name="line.773"></a>
<FONT color="green">774</FONT>          double max; // in user-defined model units<a name="line.774"></a>
<FONT color="green">775</FONT>    <a name="line.775"></a>
<FONT color="green">776</FONT>          AxisLimits(double min, double max) {<a name="line.776"></a>
<FONT color="green">777</FONT>            this.min = min;<a name="line.777"></a>
<FONT color="green">778</FONT>            this.max = max;<a name="line.778"></a>
<FONT color="green">779</FONT>          }<a name="line.779"></a>
<FONT color="green">780</FONT>    <a name="line.780"></a>
<FONT color="green">781</FONT>          boolean equals(AxisLimits al) {<a name="line.781"></a>
<FONT color="green">782</FONT>            boolean result = (al.min == min &amp;&amp; al.max == max);<a name="line.782"></a>
<FONT color="green">783</FONT>            return result;<a name="line.783"></a>
<FONT color="green">784</FONT>          }<a name="line.784"></a>
<FONT color="green">785</FONT>        }<a name="line.785"></a>
<FONT color="green">786</FONT>    <a name="line.786"></a>
<FONT color="green">787</FONT>        // different initial curr, prev ==&gt; "limits have changed" state<a name="line.787"></a>
<FONT color="green">788</FONT>        private AxisLimits currentLimits = new AxisLimits(Double.MAX_VALUE,<a name="line.788"></a>
<FONT color="green">789</FONT>            -Double.MAX_VALUE);<a name="line.789"></a>
<FONT color="green">790</FONT>        private AxisLimits previousLimits = new AxisLimits(-Double.MAX_VALUE,<a name="line.790"></a>
<FONT color="green">791</FONT>            Double.MAX_VALUE);<a name="line.791"></a>
<FONT color="green">792</FONT>    <a name="line.792"></a>
<FONT color="green">793</FONT>        private Widget axisLabel;<a name="line.793"></a>
<FONT color="green">794</FONT>        protected int axisLabelThickness = GChart.NAI;<a name="line.794"></a>
<FONT color="green">795</FONT>        private boolean hasGridlines = false;<a name="line.795"></a>
<FONT color="green">796</FONT>        protected int tickCount = DEFAULT_TICK_COUNT;<a name="line.796"></a>
<FONT color="green">797</FONT>        // axes auto-scale whenever min or max are NaN.<a name="line.797"></a>
<FONT color="green">798</FONT>        protected double axisMax = Double.NaN;<a name="line.798"></a>
<FONT color="green">799</FONT>        protected double axisMin = Double.NaN;<a name="line.799"></a>
<FONT color="green">800</FONT>        protected String tickLabelFontColor = DEFAULT_TICK_LABEL_FONT_COLOR;<a name="line.800"></a>
<FONT color="green">801</FONT>        protected String tickLabelFontFamily = null;<a name="line.801"></a>
<FONT color="green">802</FONT>        /*<a name="line.802"></a>
<FONT color="green">803</FONT>         * In CSS font-size pixels. These define the height of each<a name="line.803"></a>
<FONT color="green">804</FONT>         * character; our code relies on the rule of thumb that character<a name="line.804"></a>
<FONT color="green">805</FONT>         * width is approximately 3/5th this height to obtain a reasonably<a name="line.805"></a>
<FONT color="green">806</FONT>         * tight upper bound on tick label widths. So, even when Widget<a name="line.806"></a>
<FONT color="green">807</FONT>         * based tick labels override these sizes, the specified size can<a name="line.807"></a>
<FONT color="green">808</FONT>         * still impact the default amount of space reserved for the labels.<a name="line.808"></a>
<FONT color="green">809</FONT>         * <a name="line.809"></a>
<FONT color="green">810</FONT>         */ <a name="line.810"></a>
<FONT color="green">811</FONT>        protected int tickLabelFontSize = DEFAULT_TICK_LABEL_FONTSIZE;<a name="line.811"></a>
<FONT color="green">812</FONT>        protected String tickLabelFontStyle = DEFAULT_TICK_LABEL_FONT_STYLE;<a name="line.812"></a>
<FONT color="green">813</FONT>        protected String tickLabelFontWeight = DEFAULT_TICK_LABEL_FONT_WEIGHT;<a name="line.813"></a>
<FONT color="green">814</FONT>        protected String tickLabelFormat = DEFAULT_TICK_LABEL_FORMAT;<a name="line.814"></a>
<FONT color="green">815</FONT>        protected int tickLabelThickness = GChart.NAI;<a name="line.815"></a>
<FONT color="green">816</FONT>        protected int tickLabelPadding = 0;<a name="line.816"></a>
<FONT color="green">817</FONT>        protected int ticksPerLabel = 1;<a name="line.817"></a>
<FONT color="green">818</FONT>        protected int ticksPerGridline = 1;<a name="line.818"></a>
<FONT color="green">819</FONT>        protected int tickLength = DEFAULT_TICK_LENGTH;<a name="line.819"></a>
<FONT color="green">820</FONT>        protected int tickThickness = DEFAULT_TICK_THICKNESS;<a name="line.820"></a>
<FONT color="green">821</FONT>    <a name="line.821"></a>
<FONT color="green">822</FONT>        // is axis itself visible (has no impact ticks or their labels)<a name="line.822"></a>
<FONT color="green">823</FONT>        boolean axisVisible = true;<a name="line.823"></a>
<FONT color="green">824</FONT>    <a name="line.824"></a>
<FONT color="green">825</FONT>        /**<a name="line.825"></a>
<FONT color="green">826</FONT>         * Adds a tick on this axis at the specified position. Note that explicitly<a name="line.826"></a>
<FONT color="green">827</FONT>         * adding a single tick via this method will eliminate any implicitly<a name="line.827"></a>
<FONT color="green">828</FONT>         * generated ticks associated with the &lt;tt&gt;setTickCount&lt;/tt&gt; method.<a name="line.828"></a>
<FONT color="green">829</FONT>         * &lt;p&gt;<a name="line.829"></a>
<FONT color="green">830</FONT>         * <a name="line.830"></a>
<FONT color="green">831</FONT>         * The label associated with this tick will be generated by applying the<a name="line.831"></a>
<FONT color="green">832</FONT>         * format specified via &lt;tt&gt;setTickLabelFormat&lt;/tt&gt; to the specified<a name="line.832"></a>
<FONT color="green">833</FONT>         * position.<a name="line.833"></a>
<FONT color="green">834</FONT>         * &lt;p&gt;<a name="line.834"></a>
<FONT color="green">835</FONT>         * <a name="line.835"></a>
<FONT color="green">836</FONT>         * This is a convenience method equivalent to<a name="line.836"></a>
<FONT color="green">837</FONT>         * &lt;tt&gt;addTick(tickPosition, thisAxis.formatAsTickLabel(tickPosition), GChart.NAI,<a name="line.837"></a>
<FONT color="green">838</FONT>         * GChart.NAI)&lt;/tt&gt;. See {@link #addTick(double,String,int,int)<a name="line.838"></a>
<FONT color="green">839</FONT>         * addTick(tickPosition,tickLabel,widthUpperBound,heightUpperBound)} for<a name="line.839"></a>
<FONT color="green">840</FONT>         * details.<a name="line.840"></a>
<FONT color="green">841</FONT>         * <a name="line.841"></a>
<FONT color="green">842</FONT>         * @param tickPosition<a name="line.842"></a>
<FONT color="green">843</FONT>         *          the position, in model units, along this axis at which this tick<a name="line.843"></a>
<FONT color="green">844</FONT>         *          is displayed. For example, if the axis range goes from 0 to 100,<a name="line.844"></a>
<FONT color="green">845</FONT>         *          a tick at position 50 would appear in the middle of the axis.<a name="line.845"></a>
<FONT color="green">846</FONT>         * <a name="line.846"></a>
<FONT color="green">847</FONT>         * @see #clearTicks clearTicks<a name="line.847"></a>
<FONT color="green">848</FONT>         * @see #addTick(double,String) addTick(double,String)<a name="line.848"></a>
<FONT color="green">849</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.849"></a>
<FONT color="green">850</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.850"></a>
<FONT color="green">851</FONT>         * @see #formatAsTickLabel formatAsTickLabel<a name="line.851"></a>
<FONT color="green">852</FONT>         * @see #setTickCount setTickCount<a name="line.852"></a>
<FONT color="green">853</FONT>         * @see #setTickLabelFormat setTickLabelFormat<a name="line.853"></a>
<FONT color="green">854</FONT>         * @see #setTickLabelFontStyle setTickLabelFontStyle<a name="line.854"></a>
<FONT color="green">855</FONT>         * @see #setTickLabelFontColor setTickLabelFontColor<a name="line.855"></a>
<FONT color="green">856</FONT>         * @see #setTickLabelFontWeight setTickLabelFontWeight<a name="line.856"></a>
<FONT color="green">857</FONT>         * @see #setTickLabelFontSize setTickLabelFontSize<a name="line.857"></a>
<FONT color="green">858</FONT>         * <a name="line.858"></a>
<FONT color="green">859</FONT>         */<a name="line.859"></a>
<FONT color="green">860</FONT>        public void addTick(double tickPosition) {<a name="line.860"></a>
<FONT color="green">861</FONT>          addTick(tickPosition, formatAsTickLabel(tickPosition));<a name="line.861"></a>
<FONT color="green">862</FONT>        }<a name="line.862"></a>
<FONT color="green">863</FONT>    <a name="line.863"></a>
<FONT color="green">864</FONT>        // adds a labeled tick mark via this Axis' special system tick curve<a name="line.864"></a>
<FONT color="green">865</FONT>        private void addTickAsPoint(double tickPosition, String tickLabel,<a name="line.865"></a>
<FONT color="green">866</FONT>            Widget tickWidget, int widthUpperBound, int heightUpperBound) {<a name="line.866"></a>
<FONT color="green">867</FONT>    <a name="line.867"></a>
<FONT color="green">868</FONT>          Curve c = getSystemCurve(ticksId);<a name="line.868"></a>
<FONT color="green">869</FONT>          if (isHorizontalAxis)<a name="line.869"></a>
<FONT color="green">870</FONT>            c.addPoint(tickPosition, axisPosition * Double.MAX_VALUE);<a name="line.870"></a>
<FONT color="green">871</FONT>          else<a name="line.871"></a>
<FONT color="green">872</FONT>            c.addPoint(axisPosition * Double.MAX_VALUE, tickPosition);<a name="line.872"></a>
<FONT color="green">873</FONT>    <a name="line.873"></a>
<FONT color="green">874</FONT>          // unlabeled tick--we are done, so return to save time<a name="line.874"></a>
<FONT color="green">875</FONT>          if (null == tickLabel &amp;&amp; null == tickWidget)<a name="line.875"></a>
<FONT color="green">876</FONT>            return;<a name="line.876"></a>
<FONT color="green">877</FONT>    <a name="line.877"></a>
<FONT color="green">878</FONT>          // add an annotation representing the tick label<a name="line.878"></a>
<FONT color="green">879</FONT>          Curve.Point p = c.getPoint();<a name="line.879"></a>
<FONT color="green">880</FONT>          if (isHorizontalAxis) {<a name="line.880"></a>
<FONT color="green">881</FONT>            // below tick on X, above it on (the future) X2<a name="line.881"></a>
<FONT color="green">882</FONT>            p.setAnnotationLocation((axisPosition &lt; 0) ?<a name="line.882"></a>
<FONT color="green">883</FONT>                AnnotationLocation.SOUTH : AnnotationLocation.NORTH);<a name="line.883"></a>
<FONT color="green">884</FONT>            if (tickLabelPadding != 0) // padding &lt; 0 is rare but allowed<a name="line.884"></a>
<FONT color="green">885</FONT>              p.setAnnotationYShift(axisPosition * tickLabelPadding);<a name="line.885"></a>
<FONT color="green">886</FONT>            // else stick with default of 0 y-shift<a name="line.886"></a>
<FONT color="green">887</FONT>    <a name="line.887"></a>
<FONT color="green">888</FONT>          } else {<a name="line.888"></a>
<FONT color="green">889</FONT>            // to left of tick mark on Y, to right of it on Y2<a name="line.889"></a>
<FONT color="green">890</FONT>            p.setAnnotationLocation((axisPosition &lt; 0) ?<a name="line.890"></a>
<FONT color="green">891</FONT>                AnnotationLocation.WEST : AnnotationLocation.EAST);<a name="line.891"></a>
<FONT color="green">892</FONT>            if (tickLabelPadding != 0)<a name="line.892"></a>
<FONT color="green">893</FONT>              p.setAnnotationXShift(axisPosition * tickLabelPadding);<a name="line.893"></a>
<FONT color="green">894</FONT>            // else stick with default of 0 x-shift<a name="line.894"></a>
<FONT color="green">895</FONT>          }<a name="line.895"></a>
<FONT color="green">896</FONT>    <a name="line.896"></a>
<FONT color="green">897</FONT>          if (null != tickLabel)<a name="line.897"></a>
<FONT color="green">898</FONT>            p.setAnnotationText(tickLabel, widthUpperBound,<a name="line.898"></a>
<FONT color="green">899</FONT>                heightUpperBound);<a name="line.899"></a>
<FONT color="green">900</FONT>          else if (null != tickWidget)<a name="line.900"></a>
<FONT color="green">901</FONT>            p.setAnnotationWidget(tickWidget, widthUpperBound,<a name="line.901"></a>
<FONT color="green">902</FONT>                heightUpperBound);<a name="line.902"></a>
<FONT color="green">903</FONT>    <a name="line.903"></a>
<FONT color="green">904</FONT>          p.setAnnotationFontSize(getTickLabelFontSize());<a name="line.904"></a>
<FONT color="green">905</FONT>          p.setAnnotationFontFamily(getTickLabelFontFamily());<a name="line.905"></a>
<FONT color="green">906</FONT>          p.setAnnotationFontStyle(getTickLabelFontStyle());<a name="line.906"></a>
<FONT color="green">907</FONT>          p.setAnnotationFontColor(getTickLabelFontColor());<a name="line.907"></a>
<FONT color="green">908</FONT>          p.setAnnotationFontWeight(getTickLabelFontWeight());<a name="line.908"></a>
<FONT color="green">909</FONT>    <a name="line.909"></a>
<FONT color="green">910</FONT>        }<a name="line.910"></a>
<FONT color="green">911</FONT>    <a name="line.911"></a>
<FONT color="green">912</FONT>        /**<a name="line.912"></a>
<FONT color="green">913</FONT>         * Adds a tick at the specified position with the specified label on this<a name="line.913"></a>
<FONT color="green">914</FONT>         * axis, whose width and height are within the specified upper-bounds.<a name="line.914"></a>
<FONT color="green">915</FONT>         * <a name="line.915"></a>
<FONT color="green">916</FONT>         * &lt;p&gt;<a name="line.916"></a>
<FONT color="green">917</FONT>         * Note that explicitly adding a single tick via this method will eliminate<a name="line.917"></a>
<FONT color="green">918</FONT>         * any auto-generated ticks associated with the &lt;tt&gt;setTickCount&lt;/tt&gt;<a name="line.918"></a>
<FONT color="green">919</FONT>         * method.<a name="line.919"></a>
<FONT color="green">920</FONT>         * <a name="line.920"></a>
<FONT color="green">921</FONT>         * &lt;p&gt;<a name="line.921"></a>
<FONT color="green">922</FONT>         * Use this method to specify unusually spaced tick marks with labels that<a name="line.922"></a>
<FONT color="green">923</FONT>         * do not directly reflect the position (for example, for a logarithmic<a name="line.923"></a>
<FONT color="green">924</FONT>         * axis, or for a bar chart with special keyword-type labels, or a time axis<a name="line.924"></a>
<FONT color="green">925</FONT>         * that places date and time on two separate lines).<a name="line.925"></a>
<FONT color="green">926</FONT>         * <a name="line.926"></a>
<FONT color="green">927</FONT>         * @param tickPosition<a name="line.927"></a>
<FONT color="green">928</FONT>         *          the position, in model units, along this axis at which the tick<a name="line.928"></a>
<FONT color="green">929</FONT>         *          is displayed. For example, if the axis range goes from 0 to 1, a<a name="line.929"></a>
<FONT color="green">930</FONT>         *          tick at position 0.5 would appear in the middle of the axis.<a name="line.930"></a>
<FONT color="green">931</FONT>         * <a name="line.931"></a>
<FONT color="green">932</FONT>         * @param tickLabel<a name="line.932"></a>
<FONT color="green">933</FONT>         *          the label for this tick. HTML is supported in tick labels, but<a name="line.933"></a>
<FONT color="green">934</FONT>         *          it must be prefixed by &lt;tt&gt;&amp;lt;html&amp;gt&lt;/tt&gt;. See the<a name="line.934"></a>
<FONT color="green">935</FONT>         *          {@link Curve.Point#setAnnotationText(String,int,int)<a name="line.935"></a>
<FONT color="green">936</FONT>         *          setAnnotationText} method for more information.<a name="line.936"></a>
<FONT color="green">937</FONT>         * <a name="line.937"></a>
<FONT color="green">938</FONT>         * @param widthUpperBound<a name="line.938"></a>
<FONT color="green">939</FONT>         *          an upper bound on the width of the text or HTML, in pixels. Use<a name="line.939"></a>
<FONT color="green">940</FONT>         *          &lt;tt&gt;GChart.NAI&lt;/tt&gt; to get GChart to estimate this width for<a name="line.940"></a>
<FONT color="green">941</FONT>         *          you. See the &lt;tt&gt;setAnnotationText&lt;/tt&gt; method for more<a name="line.941"></a>
<FONT color="green">942</FONT>         *          information.<a name="line.942"></a>
<FONT color="green">943</FONT>         * <a name="line.943"></a>
<FONT color="green">944</FONT>         * @param heightUpperBound<a name="line.944"></a>
<FONT color="green">945</FONT>         *          an upper bound on the height of the text or HTML, in pixels. Use<a name="line.945"></a>
<FONT color="green">946</FONT>         *          &lt;tt&gt;GChart.NAI&lt;/tt&gt; to get GChart to estimate this height for<a name="line.946"></a>
<FONT color="green">947</FONT>         *          you. See the &lt;tt&gt;setAnnotationText&lt;/tt&gt; method for more<a name="line.947"></a>
<FONT color="green">948</FONT>         *          information.<a name="line.948"></a>
<FONT color="green">949</FONT>         * <a name="line.949"></a>
<FONT color="green">950</FONT>         * @see #clearTicks clearTicks<a name="line.950"></a>
<FONT color="green">951</FONT>         * @see #addTick(double) addTick(double)<a name="line.951"></a>
<FONT color="green">952</FONT>         * @see #addTick(double,String) addTick(double,String)<a name="line.952"></a>
<FONT color="green">953</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.953"></a>
<FONT color="green">954</FONT>         * @see #setTickCount setTickCount<a name="line.954"></a>
<FONT color="green">955</FONT>         * @see #setTickLabelFormat setTickLabelFormat<a name="line.955"></a>
<FONT color="green">956</FONT>         * @see #setTickLabelFontSize setTickLabelFontSize<a name="line.956"></a>
<FONT color="green">957</FONT>         * @see #setTickLabelFontStyle setTickLabelFontStyle<a name="line.957"></a>
<FONT color="green">958</FONT>         * @see #setTickLabelFontColor setTickLabelFontColor<a name="line.958"></a>
<FONT color="green">959</FONT>         * @see #setTickLabelFontWeight setTickLabelFontWeight<a name="line.959"></a>
<FONT color="green">960</FONT>         * @see Curve.Point#setAnnotationText(String,int,int) setAnnotationText<a name="line.960"></a>
<FONT color="green">961</FONT>         * @see Curve.Point#setAnnotationWidget setAnnotationWidget<a name="line.961"></a>
<FONT color="green">962</FONT>         * <a name="line.962"></a>
<FONT color="green">963</FONT>         */<a name="line.963"></a>
<FONT color="green">964</FONT>        public void addTick(double tickPosition, String tickLabel,<a name="line.964"></a>
<FONT color="green">965</FONT>            int widthUpperBound, int heightUpperBound) {<a name="line.965"></a>
<FONT color="green">966</FONT>          chartDecorationsChanged = true;<a name="line.966"></a>
<FONT color="green">967</FONT>          if (GChart.NAI != tickCount) { // clear out any auto-generated ticks<a name="line.967"></a>
<FONT color="green">968</FONT>            Curve cTicks = getSystemCurve(ticksId);<a name="line.968"></a>
<FONT color="green">969</FONT>            cTicks.clearPoints();<a name="line.969"></a>
<FONT color="green">970</FONT>            tickCount = GChart.NAI;<a name="line.970"></a>
<FONT color="green">971</FONT>          }<a name="line.971"></a>
<FONT color="green">972</FONT>          addTickAsPoint(tickPosition, tickLabel, null, widthUpperBound,<a name="line.972"></a>
<FONT color="green">973</FONT>              heightUpperBound);<a name="line.973"></a>
<FONT color="green">974</FONT>        }<a name="line.974"></a>
<FONT color="green">975</FONT>    <a name="line.975"></a>
<FONT color="green">976</FONT>        /**<a name="line.976"></a>
<FONT color="green">977</FONT>         * Adds a tick at the specified position with the specified label on this<a name="line.977"></a>
<FONT color="green">978</FONT>         * axis.<a name="line.978"></a>
<FONT color="green">979</FONT>         * &lt;p&gt;<a name="line.979"></a>
<FONT color="green">980</FONT>         * <a name="line.980"></a>
<FONT color="green">981</FONT>         * This is a convenience method equivalent to<a name="line.981"></a>
<FONT color="green">982</FONT>         * &lt;tt&gt;addTick(tickPosition, tickLabel, GChart.NAI,<a name="line.982"></a>
<FONT color="green">983</FONT>         * GChart.NAI)&lt;/tt&gt;. Most applications can usually just use this convenience<a name="line.983"></a>
<FONT color="green">984</FONT>         * method. See {@link #addTick(double,String,int,int)<a name="line.984"></a>
<FONT color="green">985</FONT>         * addTick(tickPosition,tickLabel, widthUpperBound,heightUpperBound)} for<a name="line.985"></a>
<FONT color="green">986</FONT>         * the fine print.<a name="line.986"></a>
<FONT color="green">987</FONT>         * <a name="line.987"></a>
<FONT color="green">988</FONT>         * @param tickPosition<a name="line.988"></a>
<FONT color="green">989</FONT>         *          the position, in model units, along this axis at which the tick<a name="line.989"></a>
<FONT color="green">990</FONT>         *          is displayed.<a name="line.990"></a>
<FONT color="green">991</FONT>         * <a name="line.991"></a>
<FONT color="green">992</FONT>         * @param tickLabel<a name="line.992"></a>
<FONT color="green">993</FONT>         *          the plain text or (&lt;tt&gt;&amp;lt;html&amp;gt&lt;/tt&gt;-prefixed) HTML defining<a name="line.993"></a>
<FONT color="green">994</FONT>         *          the tick's label.<a name="line.994"></a>
<FONT color="green">995</FONT>         * <a name="line.995"></a>
<FONT color="green">996</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.996"></a>
<FONT color="green">997</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.997"></a>
<FONT color="green">998</FONT>         * <a name="line.998"></a>
<FONT color="green">999</FONT>         */<a name="line.999"></a>
<FONT color="green">1000</FONT>        public void addTick(double tickPosition, String tickLabel) {<a name="line.1000"></a>
<FONT color="green">1001</FONT>          addTick(tickPosition, tickLabel, GChart.NAI, GChart.NAI);<a name="line.1001"></a>
<FONT color="green">1002</FONT>        }<a name="line.1002"></a>
<FONT color="green">1003</FONT>    <a name="line.1003"></a>
<FONT color="green">1004</FONT>        /**<a name="line.1004"></a>
<FONT color="green">1005</FONT>         * Adds a widget-defined tick label at the specified position, whose width<a name="line.1005"></a>
<FONT color="green">1006</FONT>         * and height are within the specified upper-bounds.<a name="line.1006"></a>
<FONT color="green">1007</FONT>         * &lt;p&gt;<a name="line.1007"></a>
<FONT color="green">1008</FONT>         * <a name="line.1008"></a>
<FONT color="green">1009</FONT>         * This method is similar to &lt;tt&gt;addTick(double,String,int,int)&lt;/tt&gt; except<a name="line.1009"></a>
<FONT color="green">1010</FONT>         * that it uses a widget, rather than a string, to define the tick's label.<a name="line.1010"></a>
<FONT color="green">1011</FONT>         * Although the string-based method is faster on first chart rendering, and<a name="line.1011"></a>
<FONT color="green">1012</FONT>         * uses less memory, the widget-based method allows you to change the label<a name="line.1012"></a>
<FONT color="green">1013</FONT>         * independently of the chart--potentially bypassing (or speeding up)<a name="line.1013"></a>
<FONT color="green">1014</FONT>         * expensive chart updates later on.<a name="line.1014"></a>
<FONT color="green">1015</FONT>         * &lt;p&gt;<a name="line.1015"></a>
<FONT color="green">1016</FONT>         * <a name="line.1016"></a>
<FONT color="green">1017</FONT>         * You might use a widget-based tick label to pop up a dialog that allows<a name="line.1017"></a>
<FONT color="green">1018</FONT>         * the user to edit the parameters defining the axis (min, max, etc.)<a name="line.1018"></a>
<FONT color="green">1019</FONT>         * whenever they click on one of the tick labels on that axis, to define<a name="line.1019"></a>
<FONT color="green">1020</FONT>         * hovertext that appears when the user mouses over a tick label, to use<a name="line.1020"></a>
<FONT color="green">1021</FONT>         * images for your tick labels, etc.<a name="line.1021"></a>
<FONT color="green">1022</FONT>         * <a name="line.1022"></a>
<FONT color="green">1023</FONT>         * @param tickPosition<a name="line.1023"></a>
<FONT color="green">1024</FONT>         *          the position, in model units, along this axis at which the tick<a name="line.1024"></a>
<FONT color="green">1025</FONT>         *          is displayed. For example, if the axis range goes from 0 to 1, a<a name="line.1025"></a>
<FONT color="green">1026</FONT>         *          tick at position 0.5 would appear in the middle of the axis.<a name="line.1026"></a>
<FONT color="green">1027</FONT>         * <a name="line.1027"></a>
<FONT color="green">1028</FONT>         * @param tickWidget<a name="line.1028"></a>
<FONT color="green">1029</FONT>         *          the label for this tick, as defined by any GWT Widget.<a name="line.1029"></a>
<FONT color="green">1030</FONT>         * <a name="line.1030"></a>
<FONT color="green">1031</FONT>         * @param widthUpperBound<a name="line.1031"></a>
<FONT color="green">1032</FONT>         *          an upper bound on the width of the widget, in pixels. If this<a name="line.1032"></a>
<FONT color="green">1033</FONT>         *          and the next parameter are omitted, GChart will use<a name="line.1033"></a>
<FONT color="green">1034</FONT>         *          &lt;tt&gt;DEFAULT_WIDGET_WIDTH_UPPERBOUND&lt;/tt&gt;.<a name="line.1034"></a>
<FONT color="green">1035</FONT>         * <a name="line.1035"></a>
<FONT color="green">1036</FONT>         * @param heightUpperBound<a name="line.1036"></a>
<FONT color="green">1037</FONT>         *          an upper bound on the height of the widget, in pixels. If this<a name="line.1037"></a>
<FONT color="green">1038</FONT>         *          and the previous parameter are omitted, GChart will use &lt;tt&gt;<a name="line.1038"></a>
<FONT color="green">1039</FONT>         *  DEFAULT_WIDGET_HEIGHT_UPPERBOUND&lt;/tt&gt;<a name="line.1039"></a>
<FONT color="green">1040</FONT>         * <a name="line.1040"></a>
<FONT color="green">1041</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.1041"></a>
<FONT color="green">1042</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.1042"></a>
<FONT color="green">1043</FONT>         * @see Curve.Point#setAnnotationWidget setAnnotationWidget<a name="line.1043"></a>
<FONT color="green">1044</FONT>         * @see #DEFAULT_WIDGET_WIDTH_UPPERBOUND DEFAULT_WIDGET_WIDTH_UPPERBOUND<a name="line.1044"></a>
<FONT color="green">1045</FONT>         * @see #DEFAULT_WIDGET_HEIGHT_UPPERBOUND DEFAULT_WIDGET_HEIGHT_UPPERBOUND<a name="line.1045"></a>
<FONT color="green">1046</FONT>         */<a name="line.1046"></a>
<FONT color="green">1047</FONT>        public void addTick(double tickPosition, Widget tickWidget,<a name="line.1047"></a>
<FONT color="green">1048</FONT>            int widthUpperBound, int heightUpperBound) {<a name="line.1048"></a>
<FONT color="green">1049</FONT>          chartDecorationsChanged = true;<a name="line.1049"></a>
<FONT color="green">1050</FONT>          if (GChart.NAI != tickCount) { // clear out any auto-generated ticks<a name="line.1050"></a>
<FONT color="green">1051</FONT>            Curve cTicks = getSystemCurve(ticksId);<a name="line.1051"></a>
<FONT color="green">1052</FONT>            cTicks.clearPoints();<a name="line.1052"></a>
<FONT color="green">1053</FONT>            tickCount = GChart.NAI;<a name="line.1053"></a>
<FONT color="green">1054</FONT>          }<a name="line.1054"></a>
<FONT color="green">1055</FONT>          addTickAsPoint(tickPosition, null, tickWidget, widthUpperBound,<a name="line.1055"></a>
<FONT color="green">1056</FONT>              heightUpperBound);<a name="line.1056"></a>
<FONT color="green">1057</FONT>        }<a name="line.1057"></a>
<FONT color="green">1058</FONT>    <a name="line.1058"></a>
<FONT color="green">1059</FONT>        /**<a name="line.1059"></a>
<FONT color="green">1060</FONT>         * Adds a Widget-defined tick label at the specified position. Convenience<a name="line.1060"></a>
<FONT color="green">1061</FONT>         * method equivalent to &lt;tt&gt;addTick(tickPosition, tickWidget,<a name="line.1061"></a>
<FONT color="green">1062</FONT>         *  DEFAULT_WIDGET_WIDTH_UPPERBOUND,<a name="line.1062"></a>
<FONT color="green">1063</FONT>         *  DEFAULT_WIDGET_HEIGHT_UPPERBOUND)&lt;/tt&gt;.<a name="line.1063"></a>
<FONT color="green">1064</FONT>         * <a name="line.1064"></a>
<FONT color="green">1065</FONT>         * @param tickPosition<a name="line.1065"></a>
<FONT color="green">1066</FONT>         *          the position, in model units, along this axis at which the tick<a name="line.1066"></a>
<FONT color="green">1067</FONT>         *          is displayed. For example, if the axis range goes from 0 to 1, a<a name="line.1067"></a>
<FONT color="green">1068</FONT>         *          tick at position 0.5 would appear in the middle of the axis.<a name="line.1068"></a>
<FONT color="green">1069</FONT>         * <a name="line.1069"></a>
<FONT color="green">1070</FONT>         * @param tickWidget<a name="line.1070"></a>
<FONT color="green">1071</FONT>         *          the label for this tick, as defined by any GWT Widget.<a name="line.1071"></a>
<FONT color="green">1072</FONT>         * <a name="line.1072"></a>
<FONT color="green">1073</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.1073"></a>
<FONT color="green">1074</FONT>         * <a name="line.1074"></a>
<FONT color="green">1075</FONT>         */<a name="line.1075"></a>
<FONT color="green">1076</FONT>        public void addTick(double tickPosition, Widget tickWidget) {<a name="line.1076"></a>
<FONT color="green">1077</FONT>          addTick(tickPosition, tickWidget, DEFAULT_WIDGET_WIDTH_UPPERBOUND,<a name="line.1077"></a>
<FONT color="green">1078</FONT>              DEFAULT_WIDGET_HEIGHT_UPPERBOUND);<a name="line.1078"></a>
<FONT color="green">1079</FONT>        }<a name="line.1079"></a>
<FONT color="green">1080</FONT>    <a name="line.1080"></a>
<FONT color="green">1081</FONT>        /**<a name="line.1081"></a>
<FONT color="green">1082</FONT>         * <a name="line.1082"></a>
<FONT color="green">1083</FONT>         * Removes all ticks from this axis. Specifically, erases any ticks that<a name="line.1083"></a>
<FONT color="green">1084</FONT>         * were explicitly specified via &lt;tt&gt;addTick&lt;/tt&gt;, and also sets the tick<a name="line.1084"></a>
<FONT color="green">1085</FONT>         * count to 0.<a name="line.1085"></a>
<FONT color="green">1086</FONT>         * &lt;p&gt;<a name="line.1086"></a>
<FONT color="green">1087</FONT>         * <a name="line.1087"></a>
<FONT color="green">1088</FONT>         * @see #setTickCount setTickCount<a name="line.1088"></a>
<FONT color="green">1089</FONT>         * @see #addTick(double) addTick(double)<a name="line.1089"></a>
<FONT color="green">1090</FONT>         * @see #addTick(double,String) addTick(double,String)<a name="line.1090"></a>
<FONT color="green">1091</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.1091"></a>
<FONT color="green">1092</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.1092"></a>
<FONT color="green">1093</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.1093"></a>
<FONT color="green">1094</FONT>         * <a name="line.1094"></a>
<FONT color="green">1095</FONT>         */<a name="line.1095"></a>
<FONT color="green">1096</FONT>        public void clearTicks() {<a name="line.1096"></a>
<FONT color="green">1097</FONT>          chartDecorationsChanged = true;<a name="line.1097"></a>
<FONT color="green">1098</FONT>          tickCount = GChart.NAI;<a name="line.1098"></a>
<FONT color="green">1099</FONT>          Curve c = getSystemCurve(ticksId);<a name="line.1099"></a>
<FONT color="green">1100</FONT>          c.clearPoints();<a name="line.1100"></a>
<FONT color="green">1101</FONT>        }<a name="line.1101"></a>
<FONT color="green">1102</FONT>    <a name="line.1102"></a>
<FONT color="green">1103</FONT>        /**<a name="line.1103"></a>
<FONT color="green">1104</FONT>         * Converts a pixel, client-window coordinate position along this axis into<a name="line.1104"></a>
<FONT color="green">1105</FONT>         * the model units associated with this axis.<a name="line.1105"></a>
<FONT color="green">1106</FONT>         * &lt;p&gt;<a name="line.1106"></a>
<FONT color="green">1107</FONT>         * <a name="line.1107"></a>
<FONT color="green">1108</FONT>         * For example, if the client coordinate associated with this axis' midpoint<a name="line.1108"></a>
<FONT color="green">1109</FONT>         * were passed to this method, it would return<a name="line.1109"></a>
<FONT color="green">1110</FONT>         * &lt;tt&gt;(getAxisMin() + getAxisMax())/2.0&lt;/tt&gt;.<a name="line.1110"></a>
<FONT color="green">1111</FONT>         * &lt;p&gt;<a name="line.1111"></a>
<FONT color="green">1112</FONT>         * <a name="line.1112"></a>
<FONT color="green">1113</FONT>         * &lt;small&gt; Note that the client/model coordinate mapping used is as of the<a name="line.1113"></a>
<FONT color="green">1114</FONT>         * last &lt;tt&gt;update&lt;/tt&gt;. Before the first &lt;tt&gt;update&lt;/tt&gt;, this method<a name="line.1114"></a>
<FONT color="green">1115</FONT>         * returns &lt;tt&gt;GChart.NaN&lt;/tt&gt;. This method also invokes either<a name="line.1115"></a>
<FONT color="green">1116</FONT>         * &lt;tt&gt;getAbsoluteTop&lt;/tt&gt; (for the y or y2 axis) or<a name="line.1116"></a>
<FONT color="green">1117</FONT>         * &lt;tt&gt;getAbsoluteLeft&lt;/tt&gt; (for the x axis), and these GWT methods return 0<a name="line.1117"></a>
<FONT color="green">1118</FONT>         * if the chart isn't actually rendered within the browser. So, results<a name="line.1118"></a>
<FONT color="green">1119</FONT>         * likely won't be useful to you until after the page containing your chart<a name="line.1119"></a>
<FONT color="green">1120</FONT>         * becomes visible to the user. Since most applications are expected to<a name="line.1120"></a>
<FONT color="green">1121</FONT>         * invoke this method in response to the user mousing over the page, these<a name="line.1121"></a>
<FONT color="green">1122</FONT>         * requirements should usually be satisfied. &lt;/small&gt;<a name="line.1122"></a>
<FONT color="green">1123</FONT>         * &lt;p&gt;<a name="line.1123"></a>
<FONT color="green">1124</FONT>         * <a name="line.1124"></a>
<FONT color="green">1125</FONT>         * &lt;small&gt; Saurabh Hirani in &lt;a href=<a name="line.1125"></a>
<FONT color="green">1126</FONT>         * "http://groups.google.com/group/Google-Web-Toolkit/msg/80301715acb6f719"<a name="line.1126"></a>
<FONT color="green">1127</FONT>         * &gt; this GWT Forum post&lt;/a&gt; and in GChart &lt;a<a name="line.1127"></a>
<FONT color="green">1128</FONT>         * href="http://code.google.com/p/gchart/issues/detail?id=21"&gt;issue #22&lt;/a&gt;<a name="line.1128"></a>
<FONT color="green">1129</FONT>         * most recently suggested the need for client to model coordinate mapping.<a name="line.1129"></a>
<FONT color="green">1130</FONT>         * Client to model conversion was requested earlier in GChart &lt;a<a name="line.1130"></a>
<FONT color="green">1131</FONT>         * href="http://code.google.com/p/gchart/issues/detail?id=9"&gt;issue #9&lt;/a&gt;<a name="line.1131"></a>
<FONT color="green">1132</FONT>         * from &lt;a href="http://yoxel.com"&gt;yoxel.com&lt;/a&gt;. &lt;/small&gt;<a name="line.1132"></a>
<FONT color="green">1133</FONT>         * <a name="line.1133"></a>
<FONT color="green">1134</FONT>         * @param clientCoordinate<a name="line.1134"></a>
<FONT color="green">1135</FONT>         *          a pixel-based coordinate that defines the dimension associated<a name="line.1135"></a>
<FONT color="green">1136</FONT>         *          with this axis in the standard client window coordinates of GWT.<a name="line.1136"></a>
<FONT color="green">1137</FONT>         * <a name="line.1137"></a>
<FONT color="green">1138</FONT>         * @return the location defined by the client-coordinate argument, but<a name="line.1138"></a>
<FONT color="green">1139</FONT>         *         converted into the model units associated with this axis.<a name="line.1139"></a>
<FONT color="green">1140</FONT>         * <a name="line.1140"></a>
<FONT color="green">1141</FONT>         * @see #getMouseCoordinate getMouseCoordinate<a name="line.1141"></a>
<FONT color="green">1142</FONT>         * @see #modelToClient modelToClient<a name="line.1142"></a>
<FONT color="green">1143</FONT>         * @see #pixelToModel pixelToModel<a name="line.1143"></a>
<FONT color="green">1144</FONT>         * @see #modelToPixel modelToPixel<a name="line.1144"></a>
<FONT color="green">1145</FONT>         * <a name="line.1145"></a>
<FONT color="green">1146</FONT>         * <a name="line.1146"></a>
<FONT color="green">1147</FONT>         */<a name="line.1147"></a>
<FONT color="green">1148</FONT>        public abstract double clientToModel(int clientCoordinate);<a name="line.1148"></a>
<FONT color="green">1149</FONT>    <a name="line.1149"></a>
<FONT color="green">1150</FONT>        // these are used in formatting tick positions into tick labels:<a name="line.1150"></a>
<FONT color="green">1151</FONT>        private NumberFormat numberFormat =<a name="line.1151"></a>
<FONT color="green">1152</FONT>            NumberFormat.getFormat(DEFAULT_TICK_LABEL_FORMAT);<a name="line.1152"></a>
<FONT color="green">1153</FONT>        private DateTimeFormat dateFormat =<a name="line.1153"></a>
<FONT color="green">1154</FONT>            DateTimeFormat.getShortDateTimeFormat();<a name="line.1154"></a>
<FONT color="green">1155</FONT>        private final int NUMBER_FORMAT_TYPE = 0;<a name="line.1155"></a>
<FONT color="green">1156</FONT>        private final int DATE_FORMAT_TYPE = 1;<a name="line.1156"></a>
<FONT color="green">1157</FONT>        private final int LOG10INVERSE_FORMAT_TYPE = 2;<a name="line.1157"></a>
<FONT color="green">1158</FONT>        private final int LOG2INVERSE_FORMAT_TYPE = 3;<a name="line.1158"></a>
<FONT color="green">1159</FONT>        private int tickLabelFormatType = NUMBER_FORMAT_TYPE;<a name="line.1159"></a>
<FONT color="green">1160</FONT>    <a name="line.1160"></a>
<FONT color="green">1161</FONT>        /**<a name="line.1161"></a>
<FONT color="green">1162</FONT>         * <a name="line.1162"></a>
<FONT color="green">1163</FONT>         * Applies this axis' tick label format to format a given value.<a name="line.1163"></a>
<FONT color="green">1164</FONT>         * <a name="line.1164"></a>
<FONT color="green">1165</FONT>         * @return the value formated as per this axis' currently specified tick<a name="line.1165"></a>
<FONT color="green">1166</FONT>         *         label format.<a name="line.1166"></a>
<FONT color="green">1167</FONT>         * <a name="line.1167"></a>
<FONT color="green">1168</FONT>         * @see #setTickLabelFormat(String) setTickLabelFormat<a name="line.1168"></a>
<FONT color="green">1169</FONT>         * <a name="line.1169"></a>
<FONT color="green">1170</FONT>         */<a name="line.1170"></a>
<FONT color="green">1171</FONT>        public String formatAsTickLabel(double value) {<a name="line.1171"></a>
<FONT color="green">1172</FONT>          String result = null;<a name="line.1172"></a>
<FONT color="green">1173</FONT>          switch (tickLabelFormatType) {<a name="line.1173"></a>
<FONT color="green">1174</FONT>          case NUMBER_FORMAT_TYPE:  <a name="line.1174"></a>
<FONT color="green">1175</FONT>            result = numberFormat.format(value);<a name="line.1175"></a>
<FONT color="green">1176</FONT>            break;<a name="line.1176"></a>
<FONT color="green">1177</FONT>          case DATE_FORMAT_TYPE:<a name="line.1177"></a>
<FONT color="green">1178</FONT>            Date transDate = new Date((long) value);<a name="line.1178"></a>
<FONT color="green">1179</FONT>            result = dateFormat.format(transDate);<a name="line.1179"></a>
<FONT color="green">1180</FONT>            break;<a name="line.1180"></a>
<FONT color="green">1181</FONT>          case LOG10INVERSE_FORMAT_TYPE:<a name="line.1181"></a>
<FONT color="green">1182</FONT>            value = Math.pow(10., value);<a name="line.1182"></a>
<FONT color="green">1183</FONT>            result = numberFormat.format(value);<a name="line.1183"></a>
<FONT color="green">1184</FONT>            break;<a name="line.1184"></a>
<FONT color="green">1185</FONT>          case LOG2INVERSE_FORMAT_TYPE:<a name="line.1185"></a>
<FONT color="green">1186</FONT>            value = Math.pow(2., value);<a name="line.1186"></a>
<FONT color="green">1187</FONT>            result = numberFormat.format(value);<a name="line.1187"></a>
<FONT color="green">1188</FONT>            break;<a name="line.1188"></a>
<FONT color="green">1189</FONT>          default:<a name="line.1189"></a>
<FONT color="green">1190</FONT>            throw new IllegalStateException("Invalid tick label format type:" +<a name="line.1190"></a>
<FONT color="green">1191</FONT>              tickLabelFormatType + ". Likely cause: a GChart bug.");<a name="line.1191"></a>
<FONT color="green">1192</FONT>          }<a name="line.1192"></a>
<FONT color="green">1193</FONT>          return result;<a name="line.1193"></a>
<FONT color="green">1194</FONT>        }<a name="line.1194"></a>
<FONT color="green">1195</FONT>    <a name="line.1195"></a>
<FONT color="green">1196</FONT>        /**<a name="line.1196"></a>
<FONT color="green">1197</FONT>         * @deprecated<a name="line.1197"></a>
<FONT color="green">1198</FONT>         * <a name="line.1198"></a>
<FONT color="green">1199</FONT>         *             Equivalent to the better-named formatAsTickLabel.<a name="line.1199"></a>
<FONT color="green">1200</FONT>         * <a name="line.1200"></a>
<FONT color="green">1201</FONT>         *             &lt;p&gt;<a name="line.1201"></a>
<FONT color="green">1202</FONT>         * <a name="line.1202"></a>
<FONT color="green">1203</FONT>         * @see #formatAsTickLabel formatAsTickLabel<a name="line.1203"></a>
<FONT color="green">1204</FONT>         * <a name="line.1204"></a>
<FONT color="green">1205</FONT>         */<a name="line.1205"></a>
<FONT color="green">1206</FONT>        public String formatNumberAsTickLabel(double value) {<a name="line.1206"></a>
<FONT color="green">1207</FONT>          return formatAsTickLabel(value);<a name="line.1207"></a>
<FONT color="green">1208</FONT>        }<a name="line.1208"></a>
<FONT color="green">1209</FONT>    <a name="line.1209"></a>
<FONT color="green">1210</FONT>        /**<a name="line.1210"></a>
<FONT color="green">1211</FONT>         * Returns the previously specified label of this axis.<a name="line.1211"></a>
<FONT color="green">1212</FONT>         * <a name="line.1212"></a>
<FONT color="green">1213</FONT>         * @return the Widget used as the label of this axis<a name="line.1213"></a>
<FONT color="green">1214</FONT>         * <a name="line.1214"></a>
<FONT color="green">1215</FONT>         * @see #setAxisLabel setAxisLabel<a name="line.1215"></a>
<FONT color="green">1216</FONT>         * <a name="line.1216"></a>
<FONT color="green">1217</FONT>         */<a name="line.1217"></a>
<FONT color="green">1218</FONT>        public Widget getAxisLabel() {<a name="line.1218"></a>
<FONT color="green">1219</FONT>          return axisLabel;<a name="line.1219"></a>
<FONT color="green">1220</FONT>        }<a name="line.1220"></a>
<FONT color="green">1221</FONT>    <a name="line.1221"></a>
<FONT color="green">1222</FONT>        /**<a name="line.1222"></a>
<FONT color="green">1223</FONT>         * Returns the thickness of the axis-label-holding region adjacent to the<a name="line.1223"></a>
<FONT color="green">1224</FONT>         * region allocated for this axis' tick labels.<a name="line.1224"></a>
<FONT color="green">1225</FONT>         * &lt;p&gt;<a name="line.1225"></a>
<FONT color="green">1226</FONT>         *<a name="line.1226"></a>
<FONT color="green">1227</FONT>         * If the axis label thickness is specified explicitly, that value<a name="line.1227"></a>
<FONT color="green">1228</FONT>         * is returned. Otherwise, with an undefined (&lt;tt&gt;GChart.NAI&lt;/tt&gt;)<a name="line.1228"></a>
<FONT color="green">1229</FONT>         * axis label thickness, an heuristic based on the text or HTML<a name="line.1229"></a>
<FONT color="green">1230</FONT>         * defining the axis label, and an estimate of character size, is<a name="line.1230"></a>
<FONT color="green">1231</FONT>         * used to estimate axis width.<a name="line.1231"></a>
<FONT color="green">1232</FONT>         * <a name="line.1232"></a>
<FONT color="green">1233</FONT>         * &lt;p&gt;<a name="line.1233"></a>
<FONT color="green">1234</FONT>         * <a name="line.1234"></a>
<FONT color="green">1235</FONT>         * @return the thickness of the axis-label-holding region, in pixels.<a name="line.1235"></a>
<FONT color="green">1236</FONT>         * <a name="line.1236"></a>
<FONT color="green">1237</FONT>         * @see #setAxisLabelThickness setAxisLabelThickness<a name="line.1237"></a>
<FONT color="green">1238</FONT>         * <a name="line.1238"></a>
<FONT color="green">1239</FONT>         */<a name="line.1239"></a>
<FONT color="green">1240</FONT>        public int getAxisLabelThickness() {<a name="line.1240"></a>
<FONT color="green">1241</FONT>          int result = 0;<a name="line.1241"></a>
<FONT color="green">1242</FONT>          // Base class implementation is for y axes (x-axis will override).<a name="line.1242"></a>
<FONT color="green">1243</FONT>          final int EXTRA_CHARWIDTH = 2; // 1-char padding on each side<a name="line.1243"></a>
<FONT color="green">1244</FONT>          final int DEF_CHARWIDTH = 1; // when widget has no text<a name="line.1244"></a>
<FONT color="green">1245</FONT>          if (GChart.NAI != axisLabelThickness)<a name="line.1245"></a>
<FONT color="green">1246</FONT>            result = axisLabelThickness;<a name="line.1246"></a>
<FONT color="green">1247</FONT>          else if (null == getAxisLabel())<a name="line.1247"></a>
<FONT color="green">1248</FONT>            result = 0;<a name="line.1248"></a>
<FONT color="green">1249</FONT>          else if (getAxisLabel() instanceof HasHTML) {<a name="line.1249"></a>
<FONT color="green">1250</FONT>            int charWidth = htmlWidth(<a name="line.1250"></a>
<FONT color="green">1251</FONT>                ((HasHTML) (getAxisLabel())).getHTML());<a name="line.1251"></a>
<FONT color="green">1252</FONT>            result = (int) Math.round((charWidth + EXTRA_CHARWIDTH)<a name="line.1252"></a>
<FONT color="green">1253</FONT>                * getTickLabelFontSize()<a name="line.1253"></a>
<FONT color="green">1254</FONT>                * TICK_CHARWIDTH_TO_FONTSIZE_LOWERBOUND);<a name="line.1254"></a>
<FONT color="green">1255</FONT>          } else if (getAxisLabel() instanceof HasText) {<a name="line.1255"></a>
<FONT color="green">1256</FONT>            String text = ((HasText) (getAxisLabel())).getText();<a name="line.1256"></a>
<FONT color="green">1257</FONT>            result = (int) Math.round((EXTRA_CHARWIDTH +<a name="line.1257"></a>
<FONT color="green">1258</FONT>                ((null == text) ? 0 : text.length()))<a name="line.1258"></a>
<FONT color="green">1259</FONT>                * getTickLabelFontSize()<a name="line.1259"></a>
<FONT color="green">1260</FONT>                * TICK_CHARWIDTH_TO_FONTSIZE_LOWERBOUND);<a name="line.1260"></a>
<FONT color="green">1261</FONT>          } else {<a name="line.1261"></a>
<FONT color="green">1262</FONT>            // non-text widget. Not a clue, just use def width<a name="line.1262"></a>
<FONT color="green">1263</FONT>            result = (int) Math.round((DEF_CHARWIDTH + EXTRA_CHARWIDTH)<a name="line.1263"></a>
<FONT color="green">1264</FONT>                * getTickLabelFontSize()<a name="line.1264"></a>
<FONT color="green">1265</FONT>                * TICK_CHARWIDTH_TO_FONTSIZE_LOWERBOUND);<a name="line.1265"></a>
<FONT color="green">1266</FONT>          }<a name="line.1266"></a>
<FONT color="green">1267</FONT>          return result;<a name="line.1267"></a>
<FONT color="green">1268</FONT>        }<a name="line.1268"></a>
<FONT color="green">1269</FONT>    <a name="line.1269"></a>
<FONT color="green">1270</FONT>        /**<a name="line.1270"></a>
<FONT color="green">1271</FONT>         * Returns the maximum value displayed on this axis. If the explicitly<a name="line.1271"></a>
<FONT color="green">1272</FONT>         * specified maximum value is undefined (&lt;tt&gt;Double.NaN&lt;/tt&gt;) the maximum<a name="line.1272"></a>
<FONT color="green">1273</FONT>         * value returned by this function is calculated as the maximum of all of<a name="line.1273"></a>
<FONT color="green">1274</FONT>         * the values either displayed on this axis via points on a curve, or<a name="line.1274"></a>
<FONT color="green">1275</FONT>         * explicitly specified via tick positions.<a name="line.1275"></a>
<FONT color="green">1276</FONT>         * <a name="line.1276"></a>
<FONT color="green">1277</FONT>         * @return maximum value visible on this axis, in "model units" (arbitrary,<a name="line.1277"></a>
<FONT color="green">1278</FONT>         *         application-specific, units)<a name="line.1278"></a>
<FONT color="green">1279</FONT>         * <a name="line.1279"></a>
<FONT color="green">1280</FONT>         * @see #setAxisMax setAxisMax<a name="line.1280"></a>
<FONT color="green">1281</FONT>         * @see #getDataMin getDataMin<a name="line.1281"></a>
<FONT color="green">1282</FONT>         * @see #getDataMax getDataMax<a name="line.1282"></a>
<FONT color="green">1283</FONT>         */<a name="line.1283"></a>
<FONT color="green">1284</FONT>        public double getAxisMax() {<a name="line.1284"></a>
<FONT color="green">1285</FONT>    <a name="line.1285"></a>
<FONT color="green">1286</FONT>          if (!(axisMax != axisMax)) { // x!=x is a faster isNaN<a name="line.1286"></a>
<FONT color="green">1287</FONT>            return axisMax;<a name="line.1287"></a>
<FONT color="green">1288</FONT>          } else if (GChart.NAI != tickCount) {<a name="line.1288"></a>
<FONT color="green">1289</FONT>            return getDataMax();<a name="line.1289"></a>
<FONT color="green">1290</FONT>          } else {<a name="line.1290"></a>
<FONT color="green">1291</FONT>            return Math.max(getDataMax(), getTickMax());<a name="line.1291"></a>
<FONT color="green">1292</FONT>          }<a name="line.1292"></a>
<FONT color="green">1293</FONT>        }<a name="line.1293"></a>
<FONT color="green">1294</FONT>    <a name="line.1294"></a>
<FONT color="green">1295</FONT>        /**<a name="line.1295"></a>
<FONT color="green">1296</FONT>         * <a name="line.1296"></a>
<FONT color="green">1297</FONT>         * Returns the minimum value displayed on this axis. If the minimum value is<a name="line.1297"></a>
<FONT color="green">1298</FONT>         * undefined (&lt;tt&gt;Double.NaN&lt;/tt&gt;) the minimum value returned by this<a name="line.1298"></a>
<FONT color="green">1299</FONT>         * function is the minimum of all of the values either displayed on this<a name="line.1299"></a>
<FONT color="green">1300</FONT>         * axis via points on a curve, or explicitly specified via tick positions.<a name="line.1300"></a>
<FONT color="green">1301</FONT>         * <a name="line.1301"></a>
<FONT color="green">1302</FONT>         * @return minimum value visible on this axis, in "model units" (arbitrary,<a name="line.1302"></a>
<FONT color="green">1303</FONT>         *         application-specific, units)<a name="line.1303"></a>
<FONT color="green">1304</FONT>         * <a name="line.1304"></a>
<FONT color="green">1305</FONT>         * @see #setAxisMin setAxisMin<a name="line.1305"></a>
<FONT color="green">1306</FONT>         */<a name="line.1306"></a>
<FONT color="green">1307</FONT>        public double getAxisMin() {<a name="line.1307"></a>
<FONT color="green">1308</FONT>          if (!(axisMin != axisMin)) { // x!=x is a faster isNaN<a name="line.1308"></a>
<FONT color="green">1309</FONT>            return axisMin; // explicitly set<a name="line.1309"></a>
<FONT color="green">1310</FONT>          } else if (GChart.NAI != tickCount) {<a name="line.1310"></a>
<FONT color="green">1311</FONT>            return getDataMin();<a name="line.1311"></a>
<FONT color="green">1312</FONT>          } else {<a name="line.1312"></a>
<FONT color="green">1313</FONT>            return Math.min(getDataMin(), getTickMin());<a name="line.1313"></a>
<FONT color="green">1314</FONT>          }<a name="line.1314"></a>
<FONT color="green">1315</FONT>        }<a name="line.1315"></a>
<FONT color="green">1316</FONT>    <a name="line.1316"></a>
<FONT color="green">1317</FONT>        /**<a name="line.1317"></a>
<FONT color="green">1318</FONT>         * Is axis line visible on the chart? Note that this property only<a name="line.1318"></a>
<FONT color="green">1319</FONT>         * determines the visibility of the axis line itself. It does not control<a name="line.1319"></a>
<FONT color="green">1320</FONT>         * the visibility of the tick marks or tick labels along this axis.<a name="line.1320"></a>
<FONT color="green">1321</FONT>         * &lt;p&gt;<a name="line.1321"></a>
<FONT color="green">1322</FONT>         * <a name="line.1322"></a>
<FONT color="green">1323</FONT>         * @return true if the axis line is visible, false otherwise.<a name="line.1323"></a>
<FONT color="green">1324</FONT>         * <a name="line.1324"></a>
<FONT color="green">1325</FONT>         * @see #setAxisVisible setAxisVisible<a name="line.1325"></a>
<FONT color="green">1326</FONT>         * <a name="line.1326"></a>
<FONT color="green">1327</FONT>         */<a name="line.1327"></a>
<FONT color="green">1328</FONT>        public boolean getAxisVisible() {<a name="line.1328"></a>
<FONT color="green">1329</FONT>          return axisVisible;<a name="line.1329"></a>
<FONT color="green">1330</FONT>        }<a name="line.1330"></a>
<FONT color="green">1331</FONT>    <a name="line.1331"></a>
<FONT color="green">1332</FONT>        /**<a name="line.1332"></a>
<FONT color="green">1333</FONT>         * The maximum number of "axis lengths" a point can be off this axis before<a name="line.1333"></a>
<FONT color="green">1334</FONT>         * it is completely dropped from the chart's rendering.<a name="line.1334"></a>
<FONT color="green">1335</FONT>         * <a name="line.1335"></a>
<FONT color="green">1336</FONT>         * @return the out of bounds multiplier.<a name="line.1336"></a>
<FONT color="green">1337</FONT>         * <a name="line.1337"></a>
<FONT color="green">1338</FONT>         * @see #setOutOfBoundsMultiplier setOutOfBoundsMultiplier<a name="line.1338"></a>
<FONT color="green">1339</FONT>         * <a name="line.1339"></a>
<FONT color="green">1340</FONT>         */<a name="line.1340"></a>
<FONT color="green">1341</FONT>        public double getOutOfBoundsMultiplier() {<a name="line.1341"></a>
<FONT color="green">1342</FONT>          return outOfBoundsMultiplier;<a name="line.1342"></a>
<FONT color="green">1343</FONT>        }<a name="line.1343"></a>
<FONT color="green">1344</FONT>    <a name="line.1344"></a>
<FONT color="green">1345</FONT>        /**<a name="line.1345"></a>
<FONT color="green">1346</FONT>         * Returns the maximum data value associated with values represented on this<a name="line.1346"></a>
<FONT color="green">1347</FONT>         * axis. For example, for the left y-axis, this would be the largest y-value<a name="line.1347"></a>
<FONT color="green">1348</FONT>         * of all points contained in curves that are displayed on the left y-axis.<a name="line.1348"></a>
<FONT color="green">1349</FONT>         * <a name="line.1349"></a>
<FONT color="green">1350</FONT>         * @return the maximum value associated with values mapped onto this axis.<a name="line.1350"></a>
<FONT color="green">1351</FONT>         * <a name="line.1351"></a>
<FONT color="green">1352</FONT>         * @see #getDataMin getDataMin<a name="line.1352"></a>
<FONT color="green">1353</FONT>         * @see #getAxisMax getAxisMax<a name="line.1353"></a>
<FONT color="green">1354</FONT>         * @see #getAxisMin getAxisMin<a name="line.1354"></a>
<FONT color="green">1355</FONT>         * <a name="line.1355"></a>
<FONT color="green">1356</FONT>         */<a name="line.1356"></a>
<FONT color="green">1357</FONT>        public abstract double getDataMax();<a name="line.1357"></a>
<FONT color="green">1358</FONT>    <a name="line.1358"></a>
<FONT color="green">1359</FONT>        /**<a name="line.1359"></a>
<FONT color="green">1360</FONT>         * Returns the minimum data value associated with values represented on this<a name="line.1360"></a>
<FONT color="green">1361</FONT>         * axis. For example, for the left y-axis, this would be the smallest<a name="line.1361"></a>
<FONT color="green">1362</FONT>         * y-value of all points contained in curves that are displayed on the left<a name="line.1362"></a>
<FONT color="green">1363</FONT>         * y-axis.<a name="line.1363"></a>
<FONT color="green">1364</FONT>         * <a name="line.1364"></a>
<FONT color="green">1365</FONT>         * @return the minimum value associated with values mapped onto this axis.<a name="line.1365"></a>
<FONT color="green">1366</FONT>         * <a name="line.1366"></a>
<FONT color="green">1367</FONT>         * @see #getDataMax getDataMax<a name="line.1367"></a>
<FONT color="green">1368</FONT>         * @see #getAxisMax getAxisMax<a name="line.1368"></a>
<FONT color="green">1369</FONT>         * @see #getAxisMin getAxisMax<a name="line.1369"></a>
<FONT color="green">1370</FONT>         * <a name="line.1370"></a>
<FONT color="green">1371</FONT>         */<a name="line.1371"></a>
<FONT color="green">1372</FONT>        public abstract double getDataMin();<a name="line.1372"></a>
<FONT color="green">1373</FONT>    <a name="line.1373"></a>
<FONT color="green">1374</FONT>        /**<a name="line.1374"></a>
<FONT color="green">1375</FONT>         * Returns the gridline setting previously made with<a name="line.1375"></a>
<FONT color="green">1376</FONT>         * &lt;tt&gt;setHasGridlines&lt;/tt&gt;.<a name="line.1376"></a>
<FONT color="green">1377</FONT>         * <a name="line.1377"></a>
<FONT color="green">1378</FONT>         * @return true if gridlines have been enabled, false if not.<a name="line.1378"></a>
<FONT color="green">1379</FONT>         * <a name="line.1379"></a>
<FONT color="green">1380</FONT>         * @see #setHasGridlines setHasGridlines<a name="line.1380"></a>
<FONT color="green">1381</FONT>         * <a name="line.1381"></a>
<FONT color="green">1382</FONT>         */<a name="line.1382"></a>
<FONT color="green">1383</FONT>        public boolean getHasGridlines() {<a name="line.1383"></a>
<FONT color="green">1384</FONT>          return hasGridlines;<a name="line.1384"></a>
<FONT color="green">1385</FONT>        }<a name="line.1385"></a>
<FONT color="green">1386</FONT>    <a name="line.1386"></a>
<FONT color="green">1387</FONT>        /**<a name="line.1387"></a>
<FONT color="green">1388</FONT>         * Returns the coordinate along this axis that is associated with the last<a name="line.1388"></a>
<FONT color="green">1389</FONT>         * "GChart-tracked" mouse location.<a name="line.1389"></a>
<FONT color="green">1390</FONT>         * &lt;p&gt;<a name="line.1390"></a>
<FONT color="green">1391</FONT>         * <a name="line.1391"></a>
<FONT color="green">1392</FONT>         * The coordinate returned is in the "scale" associated with the axis. For<a name="line.1392"></a>
<FONT color="green">1393</FONT>         * example, if the axis mininum is 0 and the maximum is 100, and the mouse<a name="line.1393"></a>
<FONT color="green">1394</FONT>         * is at the axis midpoint, this method would return 50.<a name="line.1394"></a>
<FONT color="green">1395</FONT>         * &lt;p&gt;<a name="line.1395"></a>
<FONT color="green">1396</FONT>         * <a name="line.1396"></a>
<FONT color="green">1397</FONT>         * The main intended use for this method is to allow you to create points<a name="line.1397"></a>
<FONT color="green">1398</FONT>         * that, if they have x and y coordinates defined by calling this method on<a name="line.1398"></a>
<FONT color="green">1399</FONT>         * appropriate axes, will be positioned on the chart at the last<a name="line.1399"></a>
<FONT color="green">1400</FONT>         * GChart-tracked mouse location.<a name="line.1400"></a>
<FONT color="green">1401</FONT>         * &lt;p&gt;<a name="line.1401"></a>
<FONT color="green">1402</FONT>         * <a name="line.1402"></a>
<FONT color="green">1403</FONT>         * As the user moves their mouse over the chart, GChart watches those mouse<a name="line.1403"></a>
<FONT color="green">1404</FONT>         * moves and updates it's currently "tracked" mouse location. That<a name="line.1404"></a>
<FONT color="green">1405</FONT>         * internally maintained position is the basis for the value returned by<a name="line.1405"></a>
<FONT color="green">1406</FONT>         * this method. Note that the actual, physical, mouse cursor position could<a name="line.1406"></a>
<FONT color="green">1407</FONT>         * differ from this GChart-tracked position because:<a name="line.1407"></a>
<FONT color="green">1408</FONT>         * <a name="line.1408"></a>
<FONT color="green">1409</FONT>         * &lt;p&gt;<a name="line.1409"></a>
<FONT color="green">1410</FONT>         * <a name="line.1410"></a>
<FONT color="green">1411</FONT>         * &lt;ol&gt;<a name="line.1411"></a>
<FONT color="green">1412</FONT>         * <a name="line.1412"></a>
<FONT color="green">1413</FONT>         * &lt;li&gt;The mouse has moved off the chart, and it's GChart-tracked location<a name="line.1413"></a>
<FONT color="green">1414</FONT>         * has become undefined (this method returns &lt;tt&gt;Double.NaN&lt;/tt&gt; in that<a name="line.1414"></a>
<FONT color="green">1415</FONT>         * case)<a name="line.1415"></a>
<FONT color="green">1416</FONT>         * <a name="line.1416"></a>
<FONT color="green">1417</FONT>         * &lt;li&gt;You have invoked &lt;tt&gt;setHoverTouchingEnabled(false)&lt;/tt&gt; which means<a name="line.1417"></a>
<FONT color="green">1418</FONT>         * that mouse moves are no longer tracked, so the last GChart-tracked mouse<a name="line.1418"></a>
<FONT color="green">1419</FONT>         * location will be the last position that the user clicked on.<a name="line.1419"></a>
<FONT color="green">1420</FONT>         * <a name="line.1420"></a>
<FONT color="green">1421</FONT>         * &lt;li&gt;You have popped up a modal dialog that "eats" mouse moves so GChart<a name="line.1421"></a>
<FONT color="green">1422</FONT>         * no longer sees them. In that case, the GChart-tracked mouse location is<a name="line.1422"></a>
<FONT color="green">1423</FONT>         * the location the mouse was at when the modal dialog popped up.<a name="line.1423"></a>
<FONT color="green">1424</FONT>         * <a name="line.1424"></a>
<FONT color="green">1425</FONT>         * &lt;li&gt;You are mousing over the opened hover widget (popup). Note that, to<a name="line.1425"></a>
<FONT color="green">1426</FONT>         * prevent the user from accidentally "touching" nearby points while<a name="line.1426"></a>
<FONT color="green">1427</FONT>         * interacting with the opened hover widget, GChart ignores mouse moves over<a name="line.1427"></a>
<FONT color="green">1428</FONT>         * the opened hover widget.<a name="line.1428"></a>
<FONT color="green">1429</FONT>         * <a name="line.1429"></a>
<FONT color="green">1430</FONT>         * &lt;li&gt;Other, similar, reasons.<a name="line.1430"></a>
<FONT color="green">1431</FONT>         * <a name="line.1431"></a>
<FONT color="green">1432</FONT>         * &lt;/ol&gt;<a name="line.1432"></a>
<FONT color="green">1433</FONT>         * &lt;p&gt;<a name="line.1433"></a>
<FONT color="green">1434</FONT>         * <a name="line.1434"></a>
<FONT color="green">1435</FONT>         * In other words, this routine tells you where, for hit testing and hover<a name="line.1435"></a>
<FONT color="green">1436</FONT>         * selection feedback purposes, GChart considers the mouse to be, not the<a name="line.1436"></a>
<FONT color="green">1437</FONT>         * actual physical location of the mouse. Despite the potential for<a name="line.1437"></a>
<FONT color="green">1438</FONT>         * differences, in most cases, with the default setting of<a name="line.1438"></a>
<FONT color="green">1439</FONT>         * &lt;tt&gt;setHoverTouchingEnabled(true)&lt;/tt&gt;, and when you are not over the<a name="line.1439"></a>
<FONT color="green">1440</FONT>         * opened hover widget, you can use the value returned by this method as if<a name="line.1440"></a>
<FONT color="green">1441</FONT>         * it represented the physical mouse location.<a name="line.1441"></a>
<FONT color="green">1442</FONT>         * &lt;p&gt;<a name="line.1442"></a>
<FONT color="green">1443</FONT>         * <a name="line.1443"></a>
<FONT color="green">1444</FONT>         * For an example that uses this method to create points at the current<a name="line.1444"></a>
<FONT color="green">1445</FONT>         * mouse location within a very simple line chart editor, see &lt;a<a name="line.1445"></a>
<FONT color="green">1446</FONT>         * href="package-summary.html#GChartExample22a"&gt;the Chart Gallery's<a name="line.1446"></a>
<FONT color="green">1447</FONT>         * GChartExample22a&lt;/a&gt;.<a name="line.1447"></a>
<FONT color="green">1448</FONT>         * &lt;p&gt;<a name="line.1448"></a>
<FONT color="green">1449</FONT>         * <a name="line.1449"></a>
<FONT color="green">1450</FONT>         * <a name="line.1450"></a>
<FONT color="green">1451</FONT>         * @return the coordinate, projected along this axis, in the scale defined<a name="line.1451"></a>
<FONT color="green">1452</FONT>         *         by this axis, representing the position GChart has currently<a name="line.1452"></a>
<FONT color="green">1453</FONT>         *         "tracked" the mouse to, or &lt;tt&gt;Double.NaN&lt;/tt&gt; if GChart has<a name="line.1453"></a>
<FONT color="green">1454</FONT>         *         tracked the mouse right off the edge of the chart.<a name="line.1454"></a>
<FONT color="green">1455</FONT>         * <a name="line.1455"></a>
<FONT color="green">1456</FONT>         * @see #clientToModel clientToModel<a name="line.1456"></a>
<FONT color="green">1457</FONT>         * @see #modelToClient modelToClient<a name="line.1457"></a>
<FONT color="green">1458</FONT>         * @see #pixelToModel pixelToModel<a name="line.1458"></a>
<FONT color="green">1459</FONT>         * @see #modelToPixel modelToPixel<a name="line.1459"></a>
<FONT color="green">1460</FONT>         * @see GChart#setHoverTouchingEnabled setHoverTouchingEnabled<a name="line.1460"></a>
<FONT color="green">1461</FONT>         * <a name="line.1461"></a>
<FONT color="green">1462</FONT>         */<a name="line.1462"></a>
<FONT color="green">1463</FONT>        public abstract double getMouseCoordinate();<a name="line.1463"></a>
<FONT color="green">1464</FONT>    <a name="line.1464"></a>
<FONT color="green">1465</FONT>        /**<a name="line.1465"></a>
<FONT color="green">1466</FONT>         * Returns the number of visible curves displayed on this axis.<a name="line.1466"></a>
<FONT color="green">1467</FONT>         * &lt;p&gt;<a name="line.1467"></a>
<FONT color="green">1468</FONT>         * <a name="line.1468"></a>
<FONT color="green">1469</FONT>         * @return the number of visible curves on this axis, or &lt;tt&gt;0&lt;/tt&gt; if there<a name="line.1469"></a>
<FONT color="green">1470</FONT>         *         are no visible curves on this axis.<a name="line.1470"></a>
<FONT color="green">1471</FONT>         * <a name="line.1471"></a>
<FONT color="green">1472</FONT>         * @see Axis#setVisible setVisible<a name="line.1472"></a>
<FONT color="green">1473</FONT>         * <a name="line.1473"></a>
<FONT color="green">1474</FONT>         */<a name="line.1474"></a>
<FONT color="green">1475</FONT>        public int getNCurvesVisibleOnAxis() {<a name="line.1475"></a>
<FONT color="green">1476</FONT>          return nCurvesVisibleOnAxis;<a name="line.1476"></a>
<FONT color="green">1477</FONT>        }<a name="line.1477"></a>
<FONT color="green">1478</FONT>    <a name="line.1478"></a>
<FONT color="green">1479</FONT>        /**<a name="line.1479"></a>
<FONT color="green">1480</FONT>         * Returns the number of ticks on this axis.<a name="line.1480"></a>
<FONT color="green">1481</FONT>         * <a name="line.1481"></a>
<FONT color="green">1482</FONT>         * @return the number of ticks on this axis.<a name="line.1482"></a>
<FONT color="green">1483</FONT>         * <a name="line.1483"></a>
<FONT color="green">1484</FONT>         * @see #setTickCount setTickCount<a name="line.1484"></a>
<FONT color="green">1485</FONT>         * @see #addTick(double) addTick(double)<a name="line.1485"></a>
<FONT color="green">1486</FONT>         * @see #addTick(double,String) addTick(double,String)<a name="line.1486"></a>
<FONT color="green">1487</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.1487"></a>
<FONT color="green">1488</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.1488"></a>
<FONT color="green">1489</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.1489"></a>
<FONT color="green">1490</FONT>         * @see #clearTicks clearTicks<a name="line.1490"></a>
<FONT color="green">1491</FONT>         * <a name="line.1491"></a>
<FONT color="green">1492</FONT>         */<a name="line.1492"></a>
<FONT color="green">1493</FONT>        public int getTickCount() {<a name="line.1493"></a>
<FONT color="green">1494</FONT>          int result = tickCount;<a name="line.1494"></a>
<FONT color="green">1495</FONT>          if (GChart.NAI == tickCount) {<a name="line.1495"></a>
<FONT color="green">1496</FONT>            Curve c = getSystemCurve(ticksId);<a name="line.1496"></a>
<FONT color="green">1497</FONT>            result = c.getNPoints();<a name="line.1497"></a>
<FONT color="green">1498</FONT>          }<a name="line.1498"></a>
<FONT color="green">1499</FONT>          return result;<a name="line.1499"></a>
<FONT color="green">1500</FONT>    <a name="line.1500"></a>
<FONT color="green">1501</FONT>        }<a name="line.1501"></a>
<FONT color="green">1502</FONT>    <a name="line.1502"></a>
<FONT color="green">1503</FONT>        /**<a name="line.1503"></a>
<FONT color="green">1504</FONT>         * Returns the CSS font-weight specification to be used by this axis' tick<a name="line.1504"></a>
<FONT color="green">1505</FONT>         * labels.<a name="line.1505"></a>
<FONT color="green">1506</FONT>         * <a name="line.1506"></a>
<FONT color="green">1507</FONT>         * @return font-weight of this axis' tick labels<a name="line.1507"></a>
<FONT color="green">1508</FONT>         * <a name="line.1508"></a>
<FONT color="green">1509</FONT>         * @see #setTickLabelFontWeight setTickLabelFontWeight<a name="line.1509"></a>
<FONT color="green">1510</FONT>         */<a name="line.1510"></a>
<FONT color="green">1511</FONT>        public String getTickLabelFontWeight() {<a name="line.1511"></a>
<FONT color="green">1512</FONT>          return tickLabelFontWeight;<a name="line.1512"></a>
<FONT color="green">1513</FONT>        }<a name="line.1513"></a>
<FONT color="green">1514</FONT>    <a name="line.1514"></a>
<FONT color="green">1515</FONT>        /**<a name="line.1515"></a>
<FONT color="green">1516</FONT>         * Returns the color of the font used to display the text of the tick labels<a name="line.1516"></a>
<FONT color="green">1517</FONT>         * on this axis.<a name="line.1517"></a>
<FONT color="green">1518</FONT>         * <a name="line.1518"></a>
<FONT color="green">1519</FONT>         * <a name="line.1519"></a>
<FONT color="green">1520</FONT>         * @return CSS color string defining the color of the text of the tick<a name="line.1520"></a>
<FONT color="green">1521</FONT>         *         labels for this axis.<a name="line.1521"></a>
<FONT color="green">1522</FONT>         * <a name="line.1522"></a>
<FONT color="green">1523</FONT>         * @see #setTickLabelFontColor setTickLabelFontColor<a name="line.1523"></a>
<FONT color="green">1524</FONT>         * <a name="line.1524"></a>
<FONT color="green">1525</FONT>         * @see #DEFAULT_TICK_LABEL_FONT_COLOR DEFAULT_TICK_LABEL_FONT_COLOR<a name="line.1525"></a>
<FONT color="green">1526</FONT>         * <a name="line.1526"></a>
<FONT color="green">1527</FONT>         * <a name="line.1527"></a>
<FONT color="green">1528</FONT>         * <a name="line.1528"></a>
<FONT color="green">1529</FONT>         */<a name="line.1529"></a>
<FONT color="green">1530</FONT>        public String getTickLabelFontColor() {<a name="line.1530"></a>
<FONT color="green">1531</FONT>          return tickLabelFontColor;<a name="line.1531"></a>
<FONT color="green">1532</FONT>        }<a name="line.1532"></a>
<FONT color="green">1533</FONT>    <a name="line.1533"></a>
<FONT color="green">1534</FONT>        /**<a name="line.1534"></a>
<FONT color="green">1535</FONT>         * Returns the font-family of the font used to render tick labels on this<a name="line.1535"></a>
<FONT color="green">1536</FONT>         * axis.<a name="line.1536"></a>
<FONT color="green">1537</FONT>         * &lt;p&gt;<a name="line.1537"></a>
<FONT color="green">1538</FONT>         * <a name="line.1538"></a>
<FONT color="green">1539</FONT>         * @return the CSS font-family used to render the tick labels of this axis.<a name="line.1539"></a>
<FONT color="green">1540</FONT>         * <a name="line.1540"></a>
<FONT color="green">1541</FONT>         * @see #setTickLabelFontFamily setTickLabelFontFamily<a name="line.1541"></a>
<FONT color="green">1542</FONT>         */<a name="line.1542"></a>
<FONT color="green">1543</FONT>        public String getTickLabelFontFamily() {<a name="line.1543"></a>
<FONT color="green">1544</FONT>          return tickLabelFontFamily;<a name="line.1544"></a>
<FONT color="green">1545</FONT>        }<a name="line.1545"></a>
<FONT color="green">1546</FONT>    <a name="line.1546"></a>
<FONT color="green">1547</FONT>        /**<a name="line.1547"></a>
<FONT color="green">1548</FONT>         * Returns the CSS font size, in pixels, used for tick labels on this axis.<a name="line.1548"></a>
<FONT color="green">1549</FONT>         * <a name="line.1549"></a>
<FONT color="green">1550</FONT>         * @return the tick label font size in pixels<a name="line.1550"></a>
<FONT color="green">1551</FONT>         * <a name="line.1551"></a>
<FONT color="green">1552</FONT>         * @see #setTickLabelFontSize setTickLabelFontSize<a name="line.1552"></a>
<FONT color="green">1553</FONT>         */<a name="line.1553"></a>
<FONT color="green">1554</FONT>        public int getTickLabelFontSize() {<a name="line.1554"></a>
<FONT color="green">1555</FONT>          return tickLabelFontSize;<a name="line.1555"></a>
<FONT color="green">1556</FONT>        }<a name="line.1556"></a>
<FONT color="green">1557</FONT>    <a name="line.1557"></a>
<FONT color="green">1558</FONT>        /**<a name="line.1558"></a>
<FONT color="green">1559</FONT>         * Returns the font-style of the font used to render tick labels on this<a name="line.1559"></a>
<FONT color="green">1560</FONT>         * axis (typically either "italic" or "normal")<a name="line.1560"></a>
<FONT color="green">1561</FONT>         * <a name="line.1561"></a>
<FONT color="green">1562</FONT>         * @return the CSS font-style in which tick labels of this axis are<a name="line.1562"></a>
<FONT color="green">1563</FONT>         *         rendered.<a name="line.1563"></a>
<FONT color="green">1564</FONT>         * <a name="line.1564"></a>
<FONT color="green">1565</FONT>         * @see #setTickLabelFontStyle setTickLabelFontStyle<a name="line.1565"></a>
<FONT color="green">1566</FONT>         */<a name="line.1566"></a>
<FONT color="green">1567</FONT>        public String getTickLabelFontStyle() {<a name="line.1567"></a>
<FONT color="green">1568</FONT>          return tickLabelFontStyle;<a name="line.1568"></a>
<FONT color="green">1569</FONT>        }<a name="line.1569"></a>
<FONT color="green">1570</FONT>    <a name="line.1570"></a>
<FONT color="green">1571</FONT>        /**<a name="line.1571"></a>
<FONT color="green">1572</FONT>         * Returns the tick label numeric format string for this axis.<a name="line.1572"></a>
<FONT color="green">1573</FONT>         * <a name="line.1573"></a>
<FONT color="green">1574</FONT>         * @return numeric format used to generate tick labels.<a name="line.1574"></a>
<FONT color="green">1575</FONT>         * <a name="line.1575"></a>
<FONT color="green">1576</FONT>         * @see #setTickLabelFormat setTickLabelFormat<a name="line.1576"></a>
<FONT color="green">1577</FONT>         * <a name="line.1577"></a>
<FONT color="green">1578</FONT>         */<a name="line.1578"></a>
<FONT color="green">1579</FONT>        public String getTickLabelFormat() {<a name="line.1579"></a>
<FONT color="green">1580</FONT>          return tickLabelFormat;<a name="line.1580"></a>
<FONT color="green">1581</FONT>        }<a name="line.1581"></a>
<FONT color="green">1582</FONT>    <a name="line.1582"></a>
<FONT color="green">1583</FONT>        /**<a name="line.1583"></a>
<FONT color="green">1584</FONT>         * Returns the amount of padding (blank space) between the ticks and their<a name="line.1584"></a>
<FONT color="green">1585</FONT>         * labels.<a name="line.1585"></a>
<FONT color="green">1586</FONT>         * &lt;p&gt;<a name="line.1586"></a>
<FONT color="green">1587</FONT>         * <a name="line.1587"></a>
<FONT color="green">1588</FONT>         * @return amount of padding between ticks and their labels, in pixels.<a name="line.1588"></a>
<FONT color="green">1589</FONT>         * <a name="line.1589"></a>
<FONT color="green">1590</FONT>         * @see #setTickLabelPadding setTickLabelPadding<a name="line.1590"></a>
<FONT color="green">1591</FONT>         * <a name="line.1591"></a>
<FONT color="green">1592</FONT>         */<a name="line.1592"></a>
<FONT color="green">1593</FONT>        public int getTickLabelPadding() {<a name="line.1593"></a>
<FONT color="green">1594</FONT>          return tickLabelPadding;<a name="line.1594"></a>
<FONT color="green">1595</FONT>        }<a name="line.1595"></a>
<FONT color="green">1596</FONT>    <a name="line.1596"></a>
<FONT color="green">1597</FONT>        /*<a name="line.1597"></a>
<FONT color="green">1598</FONT>         * Does real work of public getTickLabelThickness; flag saves time<a name="line.1598"></a>
<FONT color="green">1599</FONT>         * during repeated calls made in updateChartDecorations.<a name="line.1599"></a>
<FONT color="green">1600</FONT>         * <a name="line.1600"></a>
<FONT color="green">1601</FONT>         */ <a name="line.1601"></a>
<FONT color="green">1602</FONT>        int getTickLabelThickness(boolean needsPopulation) {<a name="line.1602"></a>
<FONT color="green">1603</FONT>          int maxLength = 0;<a name="line.1603"></a>
<FONT color="green">1604</FONT>          int result;<a name="line.1604"></a>
<FONT color="green">1605</FONT>          if (tickLabelThickness != GChart.NAI)<a name="line.1605"></a>
<FONT color="green">1606</FONT>            result = tickLabelThickness;<a name="line.1606"></a>
<FONT color="green">1607</FONT>          else { // use an heuristic to estimate thickness<a name="line.1607"></a>
<FONT color="green">1608</FONT>            if (needsPopulation)<a name="line.1608"></a>
<FONT color="green">1609</FONT>              maybePopulateTicks();<a name="line.1609"></a>
<FONT color="green">1610</FONT>            Curve c = getSystemCurve(ticksId);<a name="line.1610"></a>
<FONT color="green">1611</FONT>            int nTicks = c.getNPoints();<a name="line.1611"></a>
<FONT color="green">1612</FONT>            for (int i = 0; i &lt; nTicks; i++) {<a name="line.1612"></a>
<FONT color="green">1613</FONT>              String tt = c.getPoint(i).getAnnotationText();<a name="line.1613"></a>
<FONT color="green">1614</FONT>              if (null != tt)<a name="line.1614"></a>
<FONT color="green">1615</FONT>                maxLength = Math.max(maxLength,<a name="line.1615"></a>
<FONT color="green">1616</FONT>                  Annotation.getNumberOfCharsWide(tt));<a name="line.1616"></a>
<FONT color="green">1617</FONT>            }<a name="line.1617"></a>
<FONT color="green">1618</FONT>            result = (int) Math.round(maxLength * tickLabelFontSize<a name="line.1618"></a>
<FONT color="green">1619</FONT>                * TICK_CHARWIDTH_TO_FONTSIZE_LOWERBOUND);<a name="line.1619"></a>
<FONT color="green">1620</FONT>          }<a name="line.1620"></a>
<FONT color="green">1621</FONT>          return result;<a name="line.1621"></a>
<FONT color="green">1622</FONT>        }<a name="line.1622"></a>
<FONT color="green">1623</FONT>    <a name="line.1623"></a>
<FONT color="green">1624</FONT>        /**<a name="line.1624"></a>
<FONT color="green">1625</FONT>         * Returns the thickness of the band adjacent to this axis that GChart will<a name="line.1625"></a>
<FONT color="green">1626</FONT>         * allocate to hold this axis' tick labels.<a name="line.1626"></a>
<FONT color="green">1627</FONT>         * &lt;p&gt;<a name="line.1627"></a>
<FONT color="green">1628</FONT>         * <a name="line.1628"></a>
<FONT color="green">1629</FONT>         * @return width of band, in pixels, GChart will reserve for this axis' tick<a name="line.1629"></a>
<FONT color="green">1630</FONT>         *         labels.<a name="line.1630"></a>
<FONT color="green">1631</FONT>         * <a name="line.1631"></a>
<FONT color="green">1632</FONT>         * @see #setTickLabelThickness setTickLabelThickness<a name="line.1632"></a>
<FONT color="green">1633</FONT>         * <a name="line.1633"></a>
<FONT color="green">1634</FONT>         */<a name="line.1634"></a>
<FONT color="green">1635</FONT>        public int getTickLabelThickness() {<a name="line.1635"></a>
<FONT color="green">1636</FONT>          int result = getTickLabelThickness(true);<a name="line.1636"></a>
<FONT color="green">1637</FONT>          return result;<a name="line.1637"></a>
<FONT color="green">1638</FONT>        }<a name="line.1638"></a>
<FONT color="green">1639</FONT>    <a name="line.1639"></a>
<FONT color="green">1640</FONT>        /**<a name="line.1640"></a>
<FONT color="green">1641</FONT>         * Returns the ratio of the number of ticks to the number of ticks that have<a name="line.1641"></a>
<FONT color="green">1642</FONT>         * an associated gridline.<a name="line.1642"></a>
<FONT color="green">1643</FONT>         * <a name="line.1643"></a>
<FONT color="green">1644</FONT>         * @return number of ticks per gridline for this axis<a name="line.1644"></a>
<FONT color="green">1645</FONT>         * <a name="line.1645"></a>
<FONT color="green">1646</FONT>         * @see #setTicksPerGridline setTicksPerGridline<a name="line.1646"></a>
<FONT color="green">1647</FONT>         * <a name="line.1647"></a>
<FONT color="green">1648</FONT>         */<a name="line.1648"></a>
<FONT color="green">1649</FONT>        public int getTicksPerGridline() {<a name="line.1649"></a>
<FONT color="green">1650</FONT>          return ticksPerGridline;<a name="line.1650"></a>
<FONT color="green">1651</FONT>        }<a name="line.1651"></a>
<FONT color="green">1652</FONT>    <a name="line.1652"></a>
<FONT color="green">1653</FONT>        /**<a name="line.1653"></a>
<FONT color="green">1654</FONT>         * Returns the ratio of the number of ticks to the number of labeled ticks.<a name="line.1654"></a>
<FONT color="green">1655</FONT>         * <a name="line.1655"></a>
<FONT color="green">1656</FONT>         * @return number of ticks per label.<a name="line.1656"></a>
<FONT color="green">1657</FONT>         * <a name="line.1657"></a>
<FONT color="green">1658</FONT>         * @see #setTicksPerLabel setTicksPerLabel<a name="line.1658"></a>
<FONT color="green">1659</FONT>         * <a name="line.1659"></a>
<FONT color="green">1660</FONT>         */<a name="line.1660"></a>
<FONT color="green">1661</FONT>        public int getTicksPerLabel() {<a name="line.1661"></a>
<FONT color="green">1662</FONT>          return ticksPerLabel;<a name="line.1662"></a>
<FONT color="green">1663</FONT>        }<a name="line.1663"></a>
<FONT color="green">1664</FONT>    <a name="line.1664"></a>
<FONT color="green">1665</FONT>        /**<a name="line.1665"></a>
<FONT color="green">1666</FONT>         * Returns the length of ticks for this axis.<a name="line.1666"></a>
<FONT color="green">1667</FONT>         * <a name="line.1667"></a>
<FONT color="green">1668</FONT>         * @return the length of this axis' ticks, in pixels.<a name="line.1668"></a>
<FONT color="green">1669</FONT>         * <a name="line.1669"></a>
<FONT color="green">1670</FONT>         * @see #setTickLength setTickLength<a name="line.1670"></a>
<FONT color="green">1671</FONT>         */<a name="line.1671"></a>
<FONT color="green">1672</FONT>        public int getTickLength() {<a name="line.1672"></a>
<FONT color="green">1673</FONT>          return tickLength;<a name="line.1673"></a>
<FONT color="green">1674</FONT>        }<a name="line.1674"></a>
<FONT color="green">1675</FONT>    <a name="line.1675"></a>
<FONT color="green">1676</FONT>        /*<a name="line.1676"></a>
<FONT color="green">1677</FONT>         * GChart adds a pixel to even, centered, tick lengths (only<a name="line.1677"></a>
<FONT color="green">1678</FONT>         * odd-length HTML ticks can be exactly centered on 1px axis)<a name="line.1678"></a>
<FONT color="green">1679</FONT>         * <a name="line.1679"></a>
<FONT color="green">1680</FONT>         */ <a name="line.1680"></a>
<FONT color="green">1681</FONT>        int getActualTickLength() {<a name="line.1681"></a>
<FONT color="green">1682</FONT>          int result = tickLength;<a name="line.1682"></a>
<FONT color="green">1683</FONT>          if (TickLocation.CENTERED == tickLocation &amp;&amp; 0 == (tickLength % 2)<a name="line.1683"></a>
<FONT color="green">1684</FONT>              &amp;&amp; tickLength &gt; 0)<a name="line.1684"></a>
<FONT color="green">1685</FONT>            result++;<a name="line.1685"></a>
<FONT color="green">1686</FONT>          return result;<a name="line.1686"></a>
<FONT color="green">1687</FONT>        }<a name="line.1687"></a>
<FONT color="green">1688</FONT>    <a name="line.1688"></a>
<FONT color="green">1689</FONT>        /**<a name="line.1689"></a>
<FONT color="green">1690</FONT>         * Returns relative location of ticks on this axis.<a name="line.1690"></a>
<FONT color="green">1691</FONT>         * &lt;p&gt;<a name="line.1691"></a>
<FONT color="green">1692</FONT>         * <a name="line.1692"></a>
<FONT color="green">1693</FONT>         * @see #setTickLocation setTickLocation<a name="line.1693"></a>
<FONT color="green">1694</FONT>         * <a name="line.1694"></a>
<FONT color="green">1695</FONT>         * @return &lt;tt&gt;TickLocation.INSIDE&lt;/tt&gt;, &lt;tt&gt;TickLocation.OUTSIDE&lt;/tt&gt;, or<a name="line.1695"></a>
<FONT color="green">1696</FONT>         *         &lt;tt&gt;TickLocation.CENTERED&lt;/tt&gt;<a name="line.1696"></a>
<FONT color="green">1697</FONT>         * <a name="line.1697"></a>
<FONT color="green">1698</FONT>         */<a name="line.1698"></a>
<FONT color="green">1699</FONT>        public TickLocation getTickLocation() {<a name="line.1699"></a>
<FONT color="green">1700</FONT>          return tickLocation;<a name="line.1700"></a>
<FONT color="green">1701</FONT>        }<a name="line.1701"></a>
<FONT color="green">1702</FONT>    <a name="line.1702"></a>
<FONT color="green">1703</FONT>        /**<a name="line.1703"></a>
<FONT color="green">1704</FONT>         * Returns the amount of space along the axis reserved for the tick marks<a name="line.1704"></a>
<FONT color="green">1705</FONT>         * themselves, in pixels.<a name="line.1705"></a>
<FONT color="green">1706</FONT>         * &lt;p&gt;<a name="line.1706"></a>
<FONT color="green">1707</FONT>         * <a name="line.1707"></a>
<FONT color="green">1708</FONT>         * This equals the length of the part of the tick that is outside of the<a name="line.1708"></a>
<FONT color="green">1709</FONT>         * plot area.<a name="line.1709"></a>
<FONT color="green">1710</FONT>         * <a name="line.1710"></a>
<FONT color="green">1711</FONT>         * @see #setTickLength setTickLength<a name="line.1711"></a>
<FONT color="green">1712</FONT>         * @see #setTickLabelPadding setTickLabelPadding<a name="line.1712"></a>
<FONT color="green">1713</FONT>         * @see #setTickLocation setTickLocation<a name="line.1713"></a>
<FONT color="green">1714</FONT>         * <a name="line.1714"></a>
<FONT color="green">1715</FONT>         * @return the space GChart will allocate just outside the axis to hold any<a name="line.1715"></a>
<FONT color="green">1716</FONT>         *         tick marks.<a name="line.1716"></a>
<FONT color="green">1717</FONT>         * <a name="line.1717"></a>
<FONT color="green">1718</FONT>         */<a name="line.1718"></a>
<FONT color="green">1719</FONT>    <a name="line.1719"></a>
<FONT color="green">1720</FONT>        public int getTickSpace() {<a name="line.1720"></a>
<FONT color="green">1721</FONT>          int result;<a name="line.1721"></a>
<FONT color="green">1722</FONT>          if (TickLocation.CENTERED == tickLocation)<a name="line.1722"></a>
<FONT color="green">1723</FONT>            result = (tickLength + 1) / 2; // round up to nearest pixel<a name="line.1723"></a>
<FONT color="green">1724</FONT>          else if (TickLocation.OUTSIDE == tickLocation)<a name="line.1724"></a>
<FONT color="green">1725</FONT>            result = tickLength;<a name="line.1725"></a>
<FONT color="green">1726</FONT>          else // TickLocation.INSIDE<a name="line.1726"></a>
<FONT color="green">1727</FONT>            result = 0;<a name="line.1727"></a>
<FONT color="green">1728</FONT>    <a name="line.1728"></a>
<FONT color="green">1729</FONT>          return result;<a name="line.1729"></a>
<FONT color="green">1730</FONT>        }<a name="line.1730"></a>
<FONT color="green">1731</FONT>    <a name="line.1731"></a>
<FONT color="green">1732</FONT>        /**<a name="line.1732"></a>
<FONT color="green">1733</FONT>         * Returns the thickness of ticks for this axis.<a name="line.1733"></a>
<FONT color="green">1734</FONT>         * <a name="line.1734"></a>
<FONT color="green">1735</FONT>         * @return the thickness of this axis' ticks, in pixels.<a name="line.1735"></a>
<FONT color="green">1736</FONT>         * <a name="line.1736"></a>
<FONT color="green">1737</FONT>         * @see #setTickThickness setTickThickness<a name="line.1737"></a>
<FONT color="green">1738</FONT>         * @see #getTickLength getTickLength<a name="line.1738"></a>
<FONT color="green">1739</FONT>         */<a name="line.1739"></a>
<FONT color="green">1740</FONT>        public int getTickThickness() {<a name="line.1740"></a>
<FONT color="green">1741</FONT>          return tickThickness;<a name="line.1741"></a>
<FONT color="green">1742</FONT>        }<a name="line.1742"></a>
<FONT color="green">1743</FONT>    <a name="line.1743"></a>
<FONT color="green">1744</FONT>        /**<a name="line.1744"></a>
<FONT color="green">1745</FONT>         * Converts a coordinate position in the model units associated with this<a name="line.1745"></a>
<FONT color="green">1746</FONT>         * axis into a corresponding coordinate position expressed in standard GWT<a name="line.1746"></a>
<FONT color="green">1747</FONT>         * client-window pixel coordinates.<a name="line.1747"></a>
<FONT color="green">1748</FONT>         * &lt;p&gt;<a name="line.1748"></a>
<FONT color="green">1749</FONT>         * <a name="line.1749"></a>
<FONT color="green">1750</FONT>         * For example, consider a completely undecorated chart (no axes, tick<a name="line.1750"></a>
<FONT color="green">1751</FONT>         * labels, legend keys, etc.) that exactly fills a 1000px wide client<a name="line.1751"></a>
<FONT color="green">1752</FONT>         * window, and whose x-axis min and max are 0 and 100. Then<a name="line.1752"></a>
<FONT color="green">1753</FONT>         * &lt;tt&gt;getXAxis().modelToClient(50)&lt;/tt&gt; would return &lt;tt&gt;500&lt;/tt&gt;.<a name="line.1753"></a>
<FONT color="green">1754</FONT>         * &lt;p&gt;<a name="line.1754"></a>
<FONT color="green">1755</FONT>         * <a name="line.1755"></a>
<FONT color="green">1756</FONT>         * &lt;small&gt; Note that the client/model coordinate mapping used is as of the<a name="line.1756"></a>
<FONT color="green">1757</FONT>         * last &lt;tt&gt;update&lt;/tt&gt;. Before the first &lt;tt&gt;update&lt;/tt&gt;, this method<a name="line.1757"></a>
<FONT color="green">1758</FONT>         * returns &lt;tt&gt;GChart.NaN&lt;/tt&gt;. This method also invokes either<a name="line.1758"></a>
<FONT color="green">1759</FONT>         * &lt;tt&gt;getAbsoluteTop&lt;/tt&gt; (for the y or y2 axis) or<a name="line.1759"></a>
<FONT color="green">1760</FONT>         * &lt;tt&gt;getAbsoluteLeft&lt;/tt&gt; (for the x axis), and these GWT methods return 0<a name="line.1760"></a>
<FONT color="green">1761</FONT>         * if the chart isn't actually rendered within the browser. So, results<a name="line.1761"></a>
<FONT color="green">1762</FONT>         * likely won't be useful to you until after the page containing your chart<a name="line.1762"></a>
<FONT color="green">1763</FONT>         * becomes visible to the user. Since most applications are expected to<a name="line.1763"></a>
<FONT color="green">1764</FONT>         * invoke this method in response to the user mousing over the page, these<a name="line.1764"></a>
<FONT color="green">1765</FONT>         * requirements should usually be satisfied. &lt;/small&gt;<a name="line.1765"></a>
<FONT color="green">1766</FONT>         * <a name="line.1766"></a>
<FONT color="green">1767</FONT>         * @param modelCoordinate<a name="line.1767"></a>
<FONT color="green">1768</FONT>         *          the position along this axis defined in the model units<a name="line.1768"></a>
<FONT color="green">1769</FONT>         *          associated with this axis.<a name="line.1769"></a>
<FONT color="green">1770</FONT>         * <a name="line.1770"></a>
<FONT color="green">1771</FONT>         * @return a pixel-based coordinate that defines the position associated<a name="line.1771"></a>
<FONT color="green">1772</FONT>         *         with the argument in the standard pixel, client window,<a name="line.1772"></a>
<FONT color="green">1773</FONT>         *         coordinates of GWT.<a name="line.1773"></a>
<FONT color="green">1774</FONT>         * <a name="line.1774"></a>
<FONT color="green">1775</FONT>         * @see #getMouseCoordinate getMouseCoordinate<a name="line.1775"></a>
<FONT color="green">1776</FONT>         * @see #clientToModel clientToModel<a name="line.1776"></a>
<FONT color="green">1777</FONT>         * @see #pixelToModel pixelToModel<a name="line.1777"></a>
<FONT color="green">1778</FONT>         * @see #modelToPixel modelToPixel<a name="line.1778"></a>
<FONT color="green">1779</FONT>         * @see #modelToPlotAreaPixel modelToPlotAreaPixel<a name="line.1779"></a>
<FONT color="green">1780</FONT>         * <a name="line.1780"></a>
<FONT color="green">1781</FONT>         */<a name="line.1781"></a>
<FONT color="green">1782</FONT>        public abstract double modelToClient(double modelCoordinate);<a name="line.1782"></a>
<FONT color="green">1783</FONT>    <a name="line.1783"></a>
<FONT color="green">1784</FONT>        /**<a name="line.1784"></a>
<FONT color="green">1785</FONT>         * Converts a coordinate position in the model units associated with this<a name="line.1785"></a>
<FONT color="green">1786</FONT>         * axis into a corresponding coordinate position expressed in GChart's<a name="line.1786"></a>
<FONT color="green">1787</FONT>         * decorated chart pixel coordinates.<a name="line.1787"></a>
<FONT color="green">1788</FONT>         * &lt;p&gt;<a name="line.1788"></a>
<FONT color="green">1789</FONT>         * <a name="line.1789"></a>
<FONT color="green">1790</FONT>         * These coordinates have their origin at the upper left corner of the<a name="line.1790"></a>
<FONT color="green">1791</FONT>         * decorated GChart, and x pixel-coordinates that increase as you move<a name="line.1791"></a>
<FONT color="green">1792</FONT>         * right, and y pixel-coordinates that increase as you move down. They are<a name="line.1792"></a>
<FONT color="green">1793</FONT>         * related to GWT's standard client window coordinates via the following<a name="line.1793"></a>
<FONT color="green">1794</FONT>         * equations:<a name="line.1794"></a>
<FONT color="green">1795</FONT>         * <a name="line.1795"></a>
<FONT color="green">1796</FONT>         * &lt;pre&gt;<a name="line.1796"></a>
<FONT color="green">1797</FONT>         * xClient = plotPanel.getAbsoluteLeft() - Window.getScrollLeft() + xPixel;<a name="line.1797"></a>
<FONT color="green">1798</FONT>         * yClient = plotPanel.getAbsoluteTop() - Window.getScrollTop() + yPixel;<a name="line.1798"></a>
<FONT color="green">1799</FONT>         * &lt;/pre&gt;<a name="line.1799"></a>
<FONT color="green">1800</FONT>         * &lt;p&gt;<a name="line.1800"></a>
<FONT color="green">1801</FONT>         * <a name="line.1801"></a>
<FONT color="green">1802</FONT>         * In the above &lt;tt&gt;plotPanel&lt;/tt&gt; is an internal &lt;tt&gt;AbsolutePanel&lt;/tt&gt;<a name="line.1802"></a>
<FONT color="green">1803</FONT>         * GChart creates to hold the entire, decorated, chart. Apart from borders<a name="line.1803"></a>
<FONT color="green">1804</FONT>         * and such applied to the GChart as a whole, its absolute top and left<a name="line.1804"></a>
<FONT color="green">1805</FONT>         * positions should be the same as those of the GChart itself.<a name="line.1805"></a>
<FONT color="green">1806</FONT>         * &lt;p&gt;<a name="line.1806"></a>
<FONT color="green">1807</FONT>         * <a name="line.1807"></a>
<FONT color="green">1808</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; In applications that continuously track mouse moves over the<a name="line.1808"></a>
<FONT color="green">1809</FONT>         * chart, and where absolute and scroll positions cannot change, you can<a name="line.1809"></a>
<FONT color="green">1810</FONT>         * gain a significant performance boost by computing the difference between<a name="line.1810"></a>
<FONT color="green">1811</FONT>         * pixel and client coordinates once (<a name="line.1811"></a>
<FONT color="green">1812</FONT>         * &lt;tt&gt;modelToPixel(axisMin)-modelToClient(axisMin)&lt;/tt&gt;) and then adding<a name="line.1812"></a>
<FONT color="green">1813</FONT>         * that difference to the client coordinates to get the pixel coordinates,<a name="line.1813"></a>
<FONT color="green">1814</FONT>         * and then using &lt;tt&gt;pixelToModel&lt;/tt&gt;, instead of using<a name="line.1814"></a>
<FONT color="green">1815</FONT>         * &lt;tt&gt;clientToModel&lt;/tt&gt; directly, which must repeatedly call GWT's scroll<a name="line.1815"></a>
<FONT color="green">1816</FONT>         * and absolute position methods.<a name="line.1816"></a>
<FONT color="green">1817</FONT>         * &lt;p&gt;<a name="line.1817"></a>
<FONT color="green">1818</FONT>         * <a name="line.1818"></a>
<FONT color="green">1819</FONT>         * For example, for a completely undecorated chart (no tick labels, legend<a name="line.1819"></a>
<FONT color="green">1820</FONT>         * keys, etc.) the plot area takes up the entire chart. In that case, if the<a name="line.1820"></a>
<FONT color="green">1821</FONT>         * pixel units of the plot area range from &lt;tt&gt;0...100&lt;/tt&gt; along this axis,<a name="line.1821"></a>
<FONT color="green">1822</FONT>         * and the model coordinates range from &lt;tt&gt;0...10&lt;/tt&gt; along this axis,<a name="line.1822"></a>
<FONT color="green">1823</FONT>         * then &lt;tt&gt;modelToPixel(modelCoordinate)&lt;/tt&gt; returns<a name="line.1823"></a>
<FONT color="green">1824</FONT>         * &lt;tt&gt;10*modelCoordinate&lt;/tt&gt;.<a name="line.1824"></a>
<FONT color="green">1825</FONT>         * &lt;p&gt;<a name="line.1825"></a>
<FONT color="green">1826</FONT>         * <a name="line.1826"></a>
<FONT color="green">1827</FONT>         * The model/pixel mapping is as of the last &lt;tt&gt;update&lt;/tt&gt;; this method<a name="line.1827"></a>
<FONT color="green">1828</FONT>         * returns &lt;tt&gt;Double.NaN&lt;/tt&gt; before the first &lt;tt&gt;update&lt;/tt&gt;. Note that,<a name="line.1828"></a>
<FONT color="green">1829</FONT>         * unlike &lt;tt&gt;clientToModel&lt;/tt&gt; and &lt;tt&gt;modelToClient&lt;/tt&gt;, the GChart does<a name="line.1829"></a>
<FONT color="green">1830</FONT>         * &lt;i&gt;not&lt;/i&gt; need to be actually rendered within the browser for you to use<a name="line.1830"></a>
<FONT color="green">1831</FONT>         * this method--a call to update is sufficient.<a name="line.1831"></a>
<FONT color="green">1832</FONT>         * &lt;p&gt;<a name="line.1832"></a>
<FONT color="green">1833</FONT>         * <a name="line.1833"></a>
<FONT color="green">1834</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; If you need to access this mapping before the first real<a name="line.1834"></a>
<FONT color="green">1835</FONT>         * update, you can explicitly specify the min and max of this axis via<a name="line.1835"></a>
<FONT color="green">1836</FONT>         * &lt;tt&gt;setAxisMin&lt;/tt&gt; and &lt;tt&gt;setAxisMax&lt;/tt&gt;, and then call<a name="line.1836"></a>
<FONT color="green">1837</FONT>         * &lt;tt&gt;update&lt;/tt&gt; before adding any curves to the chart (which, since the<a name="line.1837"></a>
<FONT color="green">1838</FONT>         * chart is empty, should be very fast). This approach will allow you to<a name="line.1838"></a>
<FONT color="green">1839</FONT>         * convert between model and pixel coordinates before the first real update,<a name="line.1839"></a>
<FONT color="green">1840</FONT>         * and before the chart is rendered in the browser.<a name="line.1840"></a>
<FONT color="green">1841</FONT>         * &lt;p&gt;<a name="line.1841"></a>
<FONT color="green">1842</FONT>         * <a name="line.1842"></a>
<FONT color="green">1843</FONT>         * @param modelCoordinate<a name="line.1843"></a>
<FONT color="green">1844</FONT>         *          a position on this axis expressed in the model units associated<a name="line.1844"></a>
<FONT color="green">1845</FONT>         *          with this axis.<a name="line.1845"></a>
<FONT color="green">1846</FONT>         * <a name="line.1846"></a>
<FONT color="green">1847</FONT>         * @return the distance, in pixels, from the left edge (for the x axis) or<a name="line.1847"></a>
<FONT color="green">1848</FONT>         *         top edge (for the y or y2 axis) of the decorated chart to the<a name="line.1848"></a>
<FONT color="green">1849</FONT>         *         given position on this axis.<a name="line.1849"></a>
<FONT color="green">1850</FONT>         * <a name="line.1850"></a>
<FONT color="green">1851</FONT>         * @see #getMouseCoordinate getMouseCoordinate<a name="line.1851"></a>
<FONT color="green">1852</FONT>         * @see #clientToModel clientToModel<a name="line.1852"></a>
<FONT color="green">1853</FONT>         * @see #modelToClient modelToClient<a name="line.1853"></a>
<FONT color="green">1854</FONT>         * @see #modelToPlotAreaPixel modelToPlotAreaPixel<a name="line.1854"></a>
<FONT color="green">1855</FONT>         * @see #pixelToModel pixelToModel<a name="line.1855"></a>
<FONT color="green">1856</FONT>         * <a name="line.1856"></a>
<FONT color="green">1857</FONT>         */<a name="line.1857"></a>
<FONT color="green">1858</FONT>        public abstract double modelToPixel(double modelCoordinate);<a name="line.1858"></a>
<FONT color="green">1859</FONT>    <a name="line.1859"></a>
<FONT color="green">1860</FONT>        /**<a name="line.1860"></a>
<FONT color="green">1861</FONT>         * Converts a coordinate position in the model units associated with this<a name="line.1861"></a>
<FONT color="green">1862</FONT>         * axis into a corresponding coordinate position expressed in GChart's plot<a name="line.1862"></a>
<FONT color="green">1863</FONT>         * area pixel coordinates.<a name="line.1863"></a>
<FONT color="green">1864</FONT>         * &lt;p&gt;<a name="line.1864"></a>
<FONT color="green">1865</FONT>         * <a name="line.1865"></a>
<FONT color="green">1866</FONT>         * These coordinates have their origin at the upper left corner of the plot<a name="line.1866"></a>
<FONT color="green">1867</FONT>         * area, and x pixel-coordinates that increase as you move right, and y<a name="line.1867"></a>
<FONT color="green">1868</FONT>         * pixel-coordinates that increase as you move down.<a name="line.1868"></a>
<FONT color="green">1869</FONT>         * &lt;p&gt;<a name="line.1869"></a>
<FONT color="green">1870</FONT>         * <a name="line.1870"></a>
<FONT color="green">1871</FONT>         * The plot area is the rectangular region bounded by the chart's axes, and<a name="line.1871"></a>
<FONT color="green">1872</FONT>         * with a size specified via &lt;tt&gt;setChartSize&lt;/tt&gt;, where the chart's curves<a name="line.1872"></a>
<FONT color="green">1873</FONT>         * are typically displayed.<a name="line.1873"></a>
<FONT color="green">1874</FONT>         * &lt;p&gt;<a name="line.1874"></a>
<FONT color="green">1875</FONT>         * <a name="line.1875"></a>
<FONT color="green">1876</FONT>         * Apart from a shift in the origin of the pixel coordinates used, this<a name="line.1876"></a>
<FONT color="green">1877</FONT>         * method works just like &lt;tt&gt;modelToPixel&lt;/tt&gt;; see that method for<a name="line.1877"></a>
<FONT color="green">1878</FONT>         * additional details, tips, and restrictions.<a name="line.1878"></a>
<FONT color="green">1879</FONT>         * <a name="line.1879"></a>
<FONT color="green">1880</FONT>         * @param modelCoordinate<a name="line.1880"></a>
<FONT color="green">1881</FONT>         *          a position on this axis expressed in the model units associated<a name="line.1881"></a>
<FONT color="green">1882</FONT>         *          with this axis.<a name="line.1882"></a>
<FONT color="green">1883</FONT>         * <a name="line.1883"></a>
<FONT color="green">1884</FONT>         * @return the distance, in pixels, from the left edge (for the x axis) or<a name="line.1884"></a>
<FONT color="green">1885</FONT>         *         top edge (for the y or y2 axis) of the plot area to the given<a name="line.1885"></a>
<FONT color="green">1886</FONT>         *         position on this axis.<a name="line.1886"></a>
<FONT color="green">1887</FONT>         * <a name="line.1887"></a>
<FONT color="green">1888</FONT>         * @see #getMouseCoordinate getMouseCoordinate<a name="line.1888"></a>
<FONT color="green">1889</FONT>         * @see #plotAreaPixelToModel plotAreaPixelToModel<a name="line.1889"></a>
<FONT color="green">1890</FONT>         * @see #modelToPixel modelToPixel<a name="line.1890"></a>
<FONT color="green">1891</FONT>         * @see #setChartSize setChartSize<a name="line.1891"></a>
<FONT color="green">1892</FONT>         * <a name="line.1892"></a>
<FONT color="green">1893</FONT>         */<a name="line.1893"></a>
<FONT color="green">1894</FONT>        public abstract double modelToPlotAreaPixel(double modelCoordinate);<a name="line.1894"></a>
<FONT color="green">1895</FONT>    <a name="line.1895"></a>
<FONT color="green">1896</FONT>        /**<a name="line.1896"></a>
<FONT color="green">1897</FONT>         * Converts a coordinate position in GChart's decorated chart pixel<a name="line.1897"></a>
<FONT color="green">1898</FONT>         * coordinates into the model units associated with this axis.<a name="line.1898"></a>
<FONT color="green">1899</FONT>         * &lt;p&gt;<a name="line.1899"></a>
<FONT color="green">1900</FONT>         * <a name="line.1900"></a>
<FONT color="green">1901</FONT>         * GChart's decorated chart pixel coordinates have their origin at the upper<a name="line.1901"></a>
<FONT color="green">1902</FONT>         * left corner of the decorated GChart, and x pixel-coordinates that<a name="line.1902"></a>
<FONT color="green">1903</FONT>         * increase as you move right, and y pixel-coordinates that increase as you<a name="line.1903"></a>
<FONT color="green">1904</FONT>         * move down. They are related to GWT's standard client window coordinates<a name="line.1904"></a>
<FONT color="green">1905</FONT>         * via the following equations:<a name="line.1905"></a>
<FONT color="green">1906</FONT>         * <a name="line.1906"></a>
<FONT color="green">1907</FONT>         * &lt;pre&gt;<a name="line.1907"></a>
<FONT color="green">1908</FONT>         * xClient = plotPanel.getAbsoluteLeft() - Window.getScrollLeft() + xPixel;<a name="line.1908"></a>
<FONT color="green">1909</FONT>         * yClient = plotPanel.getAbsoluteTop() - Window.getScrollTop() + yPixel;<a name="line.1909"></a>
<FONT color="green">1910</FONT>         * &lt;/pre&gt;<a name="line.1910"></a>
<FONT color="green">1911</FONT>         * &lt;p&gt;<a name="line.1911"></a>
<FONT color="green">1912</FONT>         * <a name="line.1912"></a>
<FONT color="green">1913</FONT>         * In the above &lt;tt&gt;plotPanel&lt;/tt&gt; is an internal &lt;tt&gt;AbsolutePanel&lt;/tt&gt;<a name="line.1913"></a>
<FONT color="green">1914</FONT>         * GChart creates to hold the entire, decorated, chart. Apart from borders<a name="line.1914"></a>
<FONT color="green">1915</FONT>         * and such applied to the GChart as a whole, its absolute top and left<a name="line.1915"></a>
<FONT color="green">1916</FONT>         * positions should be the same as those of the GChart itself.<a name="line.1916"></a>
<FONT color="green">1917</FONT>         * &lt;p&gt;<a name="line.1917"></a>
<FONT color="green">1918</FONT>         * <a name="line.1918"></a>
<FONT color="green">1919</FONT>         * For example, for a completely undecorated chart (no tick labels, legend<a name="line.1919"></a>
<FONT color="green">1920</FONT>         * keys, etc.) the plot area takes up the entire chart. In that case, if the<a name="line.1920"></a>
<FONT color="green">1921</FONT>         * pixel units of the plot area range from &lt;tt&gt;0...100&lt;/tt&gt; along this axis,<a name="line.1921"></a>
<FONT color="green">1922</FONT>         * and the model coordinates range from &lt;tt&gt;0...10&lt;/tt&gt; along this axis,<a name="line.1922"></a>
<FONT color="green">1923</FONT>         * then &lt;tt&gt;pixelToModel(pixelCoordinate)&lt;/tt&gt; returns<a name="line.1923"></a>
<FONT color="green">1924</FONT>         * &lt;tt&gt;pixelCoordinate/10.&lt;/tt&gt;.<a name="line.1924"></a>
<FONT color="green">1925</FONT>         * &lt;p&gt;<a name="line.1925"></a>
<FONT color="green">1926</FONT>         * <a name="line.1926"></a>
<FONT color="green">1927</FONT>         * The model/pixel mapping is as of the last &lt;tt&gt;update&lt;/tt&gt;; this method<a name="line.1927"></a>
<FONT color="green">1928</FONT>         * returns &lt;tt&gt;Double.NaN&lt;/tt&gt; before the first &lt;tt&gt;update&lt;/tt&gt;. Note that,<a name="line.1928"></a>
<FONT color="green">1929</FONT>         * unlike &lt;tt&gt;clientToModel&lt;/tt&gt; and &lt;tt&gt;modelToClient&lt;/tt&gt;, the GChart does<a name="line.1929"></a>
<FONT color="green">1930</FONT>         * &lt;i&gt;not&lt;/i&gt; need to be actually rendered within the browser for you to use<a name="line.1930"></a>
<FONT color="green">1931</FONT>         * this method.<a name="line.1931"></a>
<FONT color="green">1932</FONT>         * &lt;p&gt;<a name="line.1932"></a>
<FONT color="green">1933</FONT>         * <a name="line.1933"></a>
<FONT color="green">1934</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; If you need to access this mapping before the first real<a name="line.1934"></a>
<FONT color="green">1935</FONT>         * update, you can explicitly specify the min and max of this axis via<a name="line.1935"></a>
<FONT color="green">1936</FONT>         * &lt;tt&gt;setAxisMin&lt;/tt&gt; and &lt;tt&gt;setAxisMax&lt;/tt&gt;, and then call<a name="line.1936"></a>
<FONT color="green">1937</FONT>         * &lt;tt&gt;update&lt;/tt&gt; before adding any curves to the chart (which, since the<a name="line.1937"></a>
<FONT color="green">1938</FONT>         * chart is empty, should be very fast). This approach will allow you to<a name="line.1938"></a>
<FONT color="green">1939</FONT>         * convert between model and pixel coordinates before the first real update,<a name="line.1939"></a>
<FONT color="green">1940</FONT>         * and before the chart is rendered in the browser.<a name="line.1940"></a>
<FONT color="green">1941</FONT>         * &lt;p&gt;<a name="line.1941"></a>
<FONT color="green">1942</FONT>         * <a name="line.1942"></a>
<FONT color="green">1943</FONT>         * @param pixelCoordinate<a name="line.1943"></a>
<FONT color="green">1944</FONT>         *          the distance, in pixels, from the left edge (for the x axis) or<a name="line.1944"></a>
<FONT color="green">1945</FONT>         *          top edge (for the y or y2 axis) of the decorated chart to a<a name="line.1945"></a>
<FONT color="green">1946</FONT>         *          point on this axis.<a name="line.1946"></a>
<FONT color="green">1947</FONT>         * <a name="line.1947"></a>
<FONT color="green">1948</FONT>         * @return that same position on this axis expressed in the the model units<a name="line.1948"></a>
<FONT color="green">1949</FONT>         *         associated with this axis.<a name="line.1949"></a>
<FONT color="green">1950</FONT>         * <a name="line.1950"></a>
<FONT color="green">1951</FONT>         * @see #getMouseCoordinate getMouseCoordinate<a name="line.1951"></a>
<FONT color="green">1952</FONT>         * @see #clientToModel clientToModel<a name="line.1952"></a>
<FONT color="green">1953</FONT>         * @see #modelToClient modelToClient<a name="line.1953"></a>
<FONT color="green">1954</FONT>         * @see #modelToPixel modelToPixel<a name="line.1954"></a>
<FONT color="green">1955</FONT>         * @see #plotAreaPixelToModel plotAreaPixelToModel<a name="line.1955"></a>
<FONT color="green">1956</FONT>         * <a name="line.1956"></a>
<FONT color="green">1957</FONT>         */<a name="line.1957"></a>
<FONT color="green">1958</FONT>        public abstract double pixelToModel(int pixelCoordinate);<a name="line.1958"></a>
<FONT color="green">1959</FONT>    <a name="line.1959"></a>
<FONT color="green">1960</FONT>        /**<a name="line.1960"></a>
<FONT color="green">1961</FONT>         * Converts a coordinate position in GChart's plot area pixel coordinates<a name="line.1961"></a>
<FONT color="green">1962</FONT>         * into the model units associated with this axis.<a name="line.1962"></a>
<FONT color="green">1963</FONT>         * &lt;p&gt;<a name="line.1963"></a>
<FONT color="green">1964</FONT>         * <a name="line.1964"></a>
<FONT color="green">1965</FONT>         * GChart's plot area pixel coordinates have their origin at the upper left<a name="line.1965"></a>
<FONT color="green">1966</FONT>         * corner of the plot area, and x pixel-coordinates that increase as you<a name="line.1966"></a>
<FONT color="green">1967</FONT>         * move right, and y pixel-coordinates that increase as you move down.<a name="line.1967"></a>
<FONT color="green">1968</FONT>         * &lt;p&gt;<a name="line.1968"></a>
<FONT color="green">1969</FONT>         * <a name="line.1969"></a>
<FONT color="green">1970</FONT>         * The plot area is the rectangular region bounded by the chart's axes, and<a name="line.1970"></a>
<FONT color="green">1971</FONT>         * with a size specified via &lt;tt&gt;setChartSize&lt;/tt&gt;, where the chart's curves<a name="line.1971"></a>
<FONT color="green">1972</FONT>         * are typically displayed.<a name="line.1972"></a>
<FONT color="green">1973</FONT>         * &lt;p&gt;<a name="line.1973"></a>
<FONT color="green">1974</FONT>         * <a name="line.1974"></a>
<FONT color="green">1975</FONT>         * Apart from a shift in the origin of the pixel coordinates used, this<a name="line.1975"></a>
<FONT color="green">1976</FONT>         * method works just like &lt;tt&gt;pixelToModel&lt;/tt&gt;; see that method for<a name="line.1976"></a>
<FONT color="green">1977</FONT>         * additional details, tips, and restrictions.<a name="line.1977"></a>
<FONT color="green">1978</FONT>         * <a name="line.1978"></a>
<FONT color="green">1979</FONT>         * @param pixelCoordinate<a name="line.1979"></a>
<FONT color="green">1980</FONT>         *          the distance, in pixels, from the left edge (for the x axis) or<a name="line.1980"></a>
<FONT color="green">1981</FONT>         *          top edge (for the y or y2 axis) of the plot area to a point on<a name="line.1981"></a>
<FONT color="green">1982</FONT>         *          this axis.<a name="line.1982"></a>
<FONT color="green">1983</FONT>         * <a name="line.1983"></a>
<FONT color="green">1984</FONT>         * @return that same position on this axis expressed in the the model units<a name="line.1984"></a>
<FONT color="green">1985</FONT>         *         associated with this axis.<a name="line.1985"></a>
<FONT color="green">1986</FONT>         * <a name="line.1986"></a>
<FONT color="green">1987</FONT>         * @see #modelToPlotAreaPixel modelToPlotAreaPixel<a name="line.1987"></a>
<FONT color="green">1988</FONT>         * @see #clientToModel clientToModel<a name="line.1988"></a>
<FONT color="green">1989</FONT>         * @see #pixelToModel pixelToModel<a name="line.1989"></a>
<FONT color="green">1990</FONT>         * @see #setChartSize setChartSize<a name="line.1990"></a>
<FONT color="green">1991</FONT>         * <a name="line.1991"></a>
<FONT color="green">1992</FONT>         */<a name="line.1992"></a>
<FONT color="green">1993</FONT>        public abstract double plotAreaPixelToModel(int pixelCoordinate);<a name="line.1993"></a>
<FONT color="green">1994</FONT>    <a name="line.1994"></a>
<FONT color="green">1995</FONT>        /**<a name="line.1995"></a>
<FONT color="green">1996</FONT>         * Specifies the label of this axis.<a name="line.1996"></a>
<FONT color="green">1997</FONT>         * &lt;p&gt;<a name="line.1997"></a>
<FONT color="green">1998</FONT>         * <a name="line.1998"></a>
<FONT color="green">1999</FONT>         * This label will be positioned just outside of, and centered lengthwise<a name="line.1999"></a>
<FONT color="green">2000</FONT>         * on, the region adjacent to this axis that GChart reserves for this axis'<a name="line.2000"></a>
<FONT color="green">2001</FONT>         * tick labels.<a name="line.2001"></a>
<FONT color="green">2002</FONT>         * <a name="line.2002"></a>
<FONT color="green">2003</FONT>         * @param axisLabel<a name="line.2003"></a>
<FONT color="green">2004</FONT>         *          a Widget to use as the label of the entire axis.<a name="line.2004"></a>
<FONT color="green">2005</FONT>         * <a name="line.2005"></a>
<FONT color="green">2006</FONT>         * @see #getAxisLabel getAxisLabel<a name="line.2006"></a>
<FONT color="green">2007</FONT>         * @see #setTickLabelThickness setTickLabelThickness<a name="line.2007"></a>
<FONT color="green">2008</FONT>         * @see #setAxisLabelThickness setAxisLabelThickness<a name="line.2008"></a>
<FONT color="green">2009</FONT>         * <a name="line.2009"></a>
<FONT color="green">2010</FONT>         */<a name="line.2010"></a>
<FONT color="green">2011</FONT>    <a name="line.2011"></a>
<FONT color="green">2012</FONT>        public void setAxisLabel(Widget axisLabel) {<a name="line.2012"></a>
<FONT color="green">2013</FONT>          this.axisLabel = axisLabel;<a name="line.2013"></a>
<FONT color="green">2014</FONT>          chartDecorationsChanged = true;<a name="line.2014"></a>
<FONT color="green">2015</FONT>        }<a name="line.2015"></a>
<FONT color="green">2016</FONT>    <a name="line.2016"></a>
<FONT color="green">2017</FONT>        /**<a name="line.2017"></a>
<FONT color="green">2018</FONT>         * Convenience method equivalent to &lt;tt&gt;setAxisLabel(new HTML(html))&lt;/tt&gt;<a name="line.2018"></a>
<FONT color="green">2019</FONT>         * <a name="line.2019"></a>
<FONT color="green">2020</FONT>         * @param html<a name="line.2020"></a>
<FONT color="green">2021</FONT>         *          HTML text used to define the axis label<a name="line.2021"></a>
<FONT color="green">2022</FONT>         * <a name="line.2022"></a>
<FONT color="green">2023</FONT>         * @see #setAxisLabel(Widget) setAxisLabel(Widget)<a name="line.2023"></a>
<FONT color="green">2024</FONT>         */<a name="line.2024"></a>
<FONT color="green">2025</FONT>        public void setAxisLabel(String html) {<a name="line.2025"></a>
<FONT color="green">2026</FONT>          setAxisLabel(new HTML(html));<a name="line.2026"></a>
<FONT color="green">2027</FONT>        }<a name="line.2027"></a>
<FONT color="green">2028</FONT>    <a name="line.2028"></a>
<FONT color="green">2029</FONT>        /**<a name="line.2029"></a>
<FONT color="green">2030</FONT>         * Sets the thickness of the axis-label-holding region adjacent to the<a name="line.2030"></a>
<FONT color="green">2031</FONT>         * region allocated for tick labels.<a name="line.2031"></a>
<FONT color="green">2032</FONT>         * &lt;p&gt;<a name="line.2032"></a>
<FONT color="green">2033</FONT>         * <a name="line.2033"></a>
<FONT color="green">2034</FONT>         * The axis label widget will be centered in this region. Choose a thickness<a name="line.2034"></a>
<FONT color="green">2035</FONT>         * large enough to hold the largest font size you want users to be able to<a name="line.2035"></a>
<FONT color="green">2036</FONT>         * zoom up to without the axis label spilling over into adjacent regions.<a name="line.2036"></a>
<FONT color="green">2037</FONT>         * &lt;p&gt;<a name="line.2037"></a>
<FONT color="green">2038</FONT>         * <a name="line.2038"></a>
<FONT color="green">2039</FONT>         * If the axis label thickness is &lt;tt&gt;GChart.NAI&lt;/tt&gt; (the default),<a name="line.2039"></a>
<FONT color="green">2040</FONT>         * and the widget defining the axis label implements<a name="line.2040"></a>
<FONT color="green">2041</FONT>         * &lt;tt&gt;HasHTML&lt;/tt&gt; (or &lt;tt&gt;HasText&lt;/tt&gt;) then GChart uses a<a name="line.2041"></a>
<FONT color="green">2042</FONT>         * thickness based on the estimated number of non-tag characters in<a name="line.2042"></a>
<FONT color="green">2043</FONT>         * the first &lt;tt&gt;&amp;lt;br&amp;gt;&lt;/tt&gt;, &lt;tt&gt;&amp;lt;li&amp;gt;&lt;/tt&gt; or<a name="line.2043"></a>
<FONT color="green">2044</FONT>         * &lt;tt&gt;&amp;lt;tr&amp;gt;&lt;/tt&gt; delimited line for y-axis labels, and based<a name="line.2044"></a>
<FONT color="green">2045</FONT>         * on the estimated number of &lt;tt&gt;&amp;lt;br&amp;gt;&lt;/tt&gt;,<a name="line.2045"></a>
<FONT color="green">2046</FONT>         * &lt;tt&gt;&amp;lt;li&amp;gt;&lt;/tt&gt; or &lt;tt&gt;&amp;lt;tr&amp;gt;&lt;/tt&gt; delimited text lines<a name="line.2046"></a>
<FONT color="green">2047</FONT>         * for x-axis labels.  &lt;p&gt;<a name="line.2047"></a>
<FONT color="green">2048</FONT>         * <a name="line.2048"></a>
<FONT color="green">2049</FONT>         * <a name="line.2049"></a>
<FONT color="green">2050</FONT>         * @param thickness<a name="line.2050"></a>
<FONT color="green">2051</FONT>         *          the thickness of the axis-label-holding region, in pixels, or<a name="line.2051"></a>
<FONT color="green">2052</FONT>         *          &lt;tt&gt;GChart.NAI&lt;/tt&gt; to use GChart's character-based default<a name="line.2052"></a>
<FONT color="green">2053</FONT>         *          thickness estimates.<a name="line.2053"></a>
<FONT color="green">2054</FONT>         * <a name="line.2054"></a>
<FONT color="green">2055</FONT>         * @see #getAxisLabelThickness getAxisLabelThickness<a name="line.2055"></a>
<FONT color="green">2056</FONT>         * @see #setAxisLabel setAxisLabel<a name="line.2056"></a>
<FONT color="green">2057</FONT>         */<a name="line.2057"></a>
<FONT color="green">2058</FONT>        public void setAxisLabelThickness(int thickness) {<a name="line.2058"></a>
<FONT color="green">2059</FONT>          axisLabelThickness = thickness;<a name="line.2059"></a>
<FONT color="green">2060</FONT>          chartDecorationsChanged = true;<a name="line.2060"></a>
<FONT color="green">2061</FONT>        }<a name="line.2061"></a>
<FONT color="green">2062</FONT>    <a name="line.2062"></a>
<FONT color="green">2063</FONT>        /**<a name="line.2063"></a>
<FONT color="green">2064</FONT>         * Specifies the maximum value visible on this axis.<a name="line.2064"></a>
<FONT color="green">2065</FONT>         * &lt;p&gt;<a name="line.2065"></a>
<FONT color="green">2066</FONT>         * <a name="line.2066"></a>
<FONT color="green">2067</FONT>         * Aspects of the chart rendered beyond this maximum will be clipped if the<a name="line.2067"></a>
<FONT color="green">2068</FONT>         * chart's &lt;tt&gt;clipToPlotArea&lt;/tt&gt; property is &lt;tt&gt;true&lt;/tt&gt;.<a name="line.2068"></a>
<FONT color="green">2069</FONT>         * <a name="line.2069"></a>
<FONT color="green">2070</FONT>         * &lt;p&gt;<a name="line.2070"></a>
<FONT color="green">2071</FONT>         * <a name="line.2071"></a>
<FONT color="green">2072</FONT>         * If &lt;tt&gt;Double.NaN&lt;/tt&gt; is specified, this maximum is auto-determined as<a name="line.2072"></a>
<FONT color="green">2073</FONT>         * described in &lt;tt&gt;getAxisMax&lt;/tt&gt;.<a name="line.2073"></a>
<FONT color="green">2074</FONT>         * <a name="line.2074"></a>
<FONT color="green">2075</FONT>         * &lt;p&gt;<a name="line.2075"></a>
<FONT color="green">2076</FONT>         * &lt;i&gt;Performance tip:&lt;/i&gt; Using auto-determined axis limits (via<a name="line.2076"></a>
<FONT color="green">2077</FONT>         * &lt;tt&gt;Double.NaN&lt;/tt&gt;) forces GChart, at the next update, to re-render many<a name="line.2077"></a>
<FONT color="green">2078</FONT>         * chart elements whenever the min or max data value displayed on this axis<a name="line.2078"></a>
<FONT color="green">2079</FONT>         * changes. These (often expensive) re-renderings can be avoided by using<a name="line.2079"></a>
<FONT color="green">2080</FONT>         * explicitly specified axis limits whenever possible.<a name="line.2080"></a>
<FONT color="green">2081</FONT>         * &lt;p&gt;<a name="line.2081"></a>
<FONT color="green">2082</FONT>         * <a name="line.2082"></a>
<FONT color="green">2083</FONT>         * @param max<a name="line.2083"></a>
<FONT color="green">2084</FONT>         *          maximum value visible on this axis, in "model units" (arbitrary,<a name="line.2084"></a>
<FONT color="green">2085</FONT>         *          application-specific, units) or &lt;tt&gt;Double.NaN&lt;/tt&gt; (the default<a name="line.2085"></a>
<FONT color="green">2086</FONT>         *          value) to use an auto-determined maximum.<a name="line.2086"></a>
<FONT color="green">2087</FONT>         * <a name="line.2087"></a>
<FONT color="green">2088</FONT>         * @see #getAxisMax getAxisMax<a name="line.2088"></a>
<FONT color="green">2089</FONT>         * @see #getDataMin getDataMin<a name="line.2089"></a>
<FONT color="green">2090</FONT>         * @see #getDataMax getDataMax<a name="line.2090"></a>
<FONT color="green">2091</FONT>         * @see GChart#setClipToPlotArea GChart.setClipToPlotArea<a name="line.2091"></a>
<FONT color="green">2092</FONT>         * @see Curve#setClipToPlotArea Curve.setClipToPlotArea<a name="line.2092"></a>
<FONT color="green">2093</FONT>         * <a name="line.2093"></a>
<FONT color="green">2094</FONT>         */<a name="line.2094"></a>
<FONT color="green">2095</FONT>        public void setAxisMax(double max) {<a name="line.2095"></a>
<FONT color="green">2096</FONT>          chartDecorationsChanged = true;<a name="line.2096"></a>
<FONT color="green">2097</FONT>          this.axisMax = max;<a name="line.2097"></a>
<FONT color="green">2098</FONT>        }<a name="line.2098"></a>
<FONT color="green">2099</FONT>    <a name="line.2099"></a>
<FONT color="green">2100</FONT>        /**<a name="line.2100"></a>
<FONT color="green">2101</FONT>         * Specifies the minimum value of this axis.<a name="line.2101"></a>
<FONT color="green">2102</FONT>         * &lt;p&gt;<a name="line.2102"></a>
<FONT color="green">2103</FONT>         * <a name="line.2103"></a>
<FONT color="green">2104</FONT>         * Aspects of the chart rendered at positions before this minimum value will<a name="line.2104"></a>
<FONT color="green">2105</FONT>         * be clipped if the chart's &lt;tt&gt;clipToPlotArea&lt;/tt&gt; property is<a name="line.2105"></a>
<FONT color="green">2106</FONT>         * &lt;tt&gt;true&lt;/tt&gt;.<a name="line.2106"></a>
<FONT color="green">2107</FONT>         * &lt;p&gt;<a name="line.2107"></a>
<FONT color="green">2108</FONT>         * <a name="line.2108"></a>
<FONT color="green">2109</FONT>         * If &lt;tt&gt;Double.NaN&lt;/tt&gt; is specified, this minimum is auto-determined as<a name="line.2109"></a>
<FONT color="green">2110</FONT>         * described in &lt;tt&gt;getAxisMin&lt;/tt&gt;.<a name="line.2110"></a>
<FONT color="green">2111</FONT>         * <a name="line.2111"></a>
<FONT color="green">2112</FONT>         * &lt;p&gt;<a name="line.2112"></a>
<FONT color="green">2113</FONT>         * &lt;i&gt;Performance tip:&lt;/i&gt; Using auto-determined axis limits (via<a name="line.2113"></a>
<FONT color="green">2114</FONT>         * &lt;tt&gt;Double.NaN&lt;/tt&gt;) forces GChart, at the next update, to re-render many<a name="line.2114"></a>
<FONT color="green">2115</FONT>         * chart elements whenever the min or max data value displayed on this axis<a name="line.2115"></a>
<FONT color="green">2116</FONT>         * changes. These (often expensive) re-renderings can be avoided by using<a name="line.2116"></a>
<FONT color="green">2117</FONT>         * explicitly specified axis limits whenever possible.<a name="line.2117"></a>
<FONT color="green">2118</FONT>         * &lt;p&gt;<a name="line.2118"></a>
<FONT color="green">2119</FONT>         * <a name="line.2119"></a>
<FONT color="green">2120</FONT>         * @param min<a name="line.2120"></a>
<FONT color="green">2121</FONT>         *          minimum value visible on this axis, in "model units" (arbitrary,<a name="line.2121"></a>
<FONT color="green">2122</FONT>         *          application-specific, units), or Double.NaN (the default) to use<a name="line.2122"></a>
<FONT color="green">2123</FONT>         *          an auto-determined minimum.<a name="line.2123"></a>
<FONT color="green">2124</FONT>         * <a name="line.2124"></a>
<FONT color="green">2125</FONT>         * @see #getAxisMin getAxisMin<a name="line.2125"></a>
<FONT color="green">2126</FONT>         * @see #getDataMin getDataMin<a name="line.2126"></a>
<FONT color="green">2127</FONT>         * @see #getDataMax getDataMax<a name="line.2127"></a>
<FONT color="green">2128</FONT>         * <a name="line.2128"></a>
<FONT color="green">2129</FONT>         */<a name="line.2129"></a>
<FONT color="green">2130</FONT>        public void setAxisMin(double min) {<a name="line.2130"></a>
<FONT color="green">2131</FONT>          // min can change axis label width ==&gt; changes position of plot area<a name="line.2131"></a>
<FONT color="green">2132</FONT>          chartDecorationsChanged = true;<a name="line.2132"></a>
<FONT color="green">2133</FONT>          this.axisMin = min;<a name="line.2133"></a>
<FONT color="green">2134</FONT>        }<a name="line.2134"></a>
<FONT color="green">2135</FONT>    <a name="line.2135"></a>
<FONT color="green">2136</FONT>        /**<a name="line.2136"></a>
<FONT color="green">2137</FONT>         * Defines if this axis is visible. Note that this property only defines the<a name="line.2137"></a>
<FONT color="green">2138</FONT>         * visibility of the axis line itself, it does not control the visibility of<a name="line.2138"></a>
<FONT color="green">2139</FONT>         * tick marks or tick labels associated with the axis.<a name="line.2139"></a>
<FONT color="green">2140</FONT>         * &lt;p&gt;<a name="line.2140"></a>
<FONT color="green">2141</FONT>         * <a name="line.2141"></a>
<FONT color="green">2142</FONT>         * &lt;i&gt;Tip:&lt;/i&gt;Tick marks can be made invisible by using<a name="line.2142"></a>
<FONT color="green">2143</FONT>         * &lt;tt&gt;setTickThickness&lt;/tt&gt; to set the tick thickness to 0. Tick labels can<a name="line.2143"></a>
<FONT color="green">2144</FONT>         * be made invisible by using &lt;tt&gt;setTickLabelFontColor&lt;/tt&gt; to set the tick<a name="line.2144"></a>
<FONT color="green">2145</FONT>         * label color to the chart's background color.<a name="line.2145"></a>
<FONT color="green">2146</FONT>         * &lt;p&gt;<a name="line.2146"></a>
<FONT color="green">2147</FONT>         * <a name="line.2147"></a>
<FONT color="green">2148</FONT>         * @param axisVisible<a name="line.2148"></a>
<FONT color="green">2149</FONT>         *          false to hide axis, true to show it.<a name="line.2149"></a>
<FONT color="green">2150</FONT>         * <a name="line.2150"></a>
<FONT color="green">2151</FONT>         * @see #setTickThickness setTickThickness<a name="line.2151"></a>
<FONT color="green">2152</FONT>         * @see #setTickLabelFontColor setTickLabelFontColor<a name="line.2152"></a>
<FONT color="green">2153</FONT>         * @see #getAxisVisible getAxisVisible<a name="line.2153"></a>
<FONT color="green">2154</FONT>         */<a name="line.2154"></a>
<FONT color="green">2155</FONT>        public void setAxisVisible(boolean axisVisible) {<a name="line.2155"></a>
<FONT color="green">2156</FONT>          chartDecorationsChanged = true;<a name="line.2156"></a>
<FONT color="green">2157</FONT>          this.axisVisible = axisVisible;<a name="line.2157"></a>
<FONT color="green">2158</FONT>        }<a name="line.2158"></a>
<FONT color="green">2159</FONT>    <a name="line.2159"></a>
<FONT color="green">2160</FONT>        /**<a name="line.2160"></a>
<FONT color="green">2161</FONT>         * <a name="line.2161"></a>
<FONT color="green">2162</FONT>         * Defines the maximum number of "axis lengths" a point can be off this axis<a name="line.2162"></a>
<FONT color="green">2163</FONT>         * before it is completely dropped from the chart's rendering.<a name="line.2163"></a>
<FONT color="green">2164</FONT>         * &lt;p&gt;<a name="line.2164"></a>
<FONT color="green">2165</FONT>         * <a name="line.2165"></a>
<FONT color="green">2166</FONT>         * Note that any connecting lines to/from such out of bounds points will<a name="line.2166"></a>
<FONT color="green">2167</FONT>         * also be dropped.<a name="line.2167"></a>
<FONT color="green">2168</FONT>         * &lt;p&gt;<a name="line.2168"></a>
<FONT color="green">2169</FONT>         * <a name="line.2169"></a>
<FONT color="green">2170</FONT>         * The exact formulas that define how this &lt;tt&gt;outOfBoundsMultiplier&lt;/tt&gt; is<a name="line.2170"></a>
<FONT color="green">2171</FONT>         * related to these lower and upper "point dropping" bounds is:<a name="line.2171"></a>
<FONT color="green">2172</FONT>         * &lt;p&gt;<a name="line.2172"></a>
<FONT color="green">2173</FONT>         * <a name="line.2173"></a>
<FONT color="green">2174</FONT>         * &lt;pre&gt;<a name="line.2174"></a>
<FONT color="green">2175</FONT>         *   lowerBound = axisMin - outOfBoundsMultiplier*(axisMax-axisMin)<a name="line.2175"></a>
<FONT color="green">2176</FONT>         *   upperBound = axisMax + outOfBoundsMultiplier*(axisMax-axisMin)<a name="line.2176"></a>
<FONT color="green">2177</FONT>         * &lt;/pre&gt;<a name="line.2177"></a>
<FONT color="green">2178</FONT>         * <a name="line.2178"></a>
<FONT color="green">2179</FONT>         * &lt;p&gt;<a name="line.2179"></a>
<FONT color="green">2180</FONT>         * Here &lt;tt&gt;axisMin&lt;/tt&gt; and &lt;tt&gt;axisMax&lt;/tt&gt; are the smallest and largest<a name="line.2180"></a>
<FONT color="green">2181</FONT>         * values visible in the plot area along this axis.<a name="line.2181"></a>
<FONT color="green">2182</FONT>         * <a name="line.2182"></a>
<FONT color="green">2183</FONT>         * &lt;p&gt;<a name="line.2183"></a>
<FONT color="green">2184</FONT>         * <a name="line.2184"></a>
<FONT color="green">2185</FONT>         * For example, if the out of bounds multiplier is &lt;tt&gt;10&lt;/tt&gt;, and if your<a name="line.2185"></a>
<FONT color="green">2186</FONT>         * axis range goes from &lt;tt&gt;1&lt;/tt&gt; to &lt;tt&gt;6&lt;/tt&gt;, points with coordinates<a name="line.2186"></a>
<FONT color="green">2187</FONT>         * less than &lt;tt&gt;-49 (1 - 10*(6-1)&lt;/tt&gt; or greater than<a name="line.2187"></a>
<FONT color="green">2188</FONT>         * &lt;tt&gt;56 (6 + 10*(6-1))&lt;/tt&gt; do not get rendered.<a name="line.2188"></a>
<FONT color="green">2189</FONT>         * &lt;p&gt;<a name="line.2189"></a>
<FONT color="green">2190</FONT>         * <a name="line.2190"></a>
<FONT color="green">2191</FONT>         * The out of bounds multiplier can be used to speed up the rendering of<a name="line.2191"></a>
<FONT color="green">2192</FONT>         * charts with many points far outside of the plot area. Such situations can<a name="line.2192"></a>
<FONT color="green">2193</FONT>         * arise, for example, in charts that manipulate axis limits in order to<a name="line.2193"></a>
<FONT color="green">2194</FONT>         * support pan and zoom. Because out of limits points, as well as any<a name="line.2194"></a>
<FONT color="green">2195</FONT>         * connecting lines to/from such points, are not rendered at all, much time<a name="line.2195"></a>
<FONT color="green">2196</FONT>         * is saved compared to mere clipping, which first renders each connecting<a name="line.2196"></a>
<FONT color="green">2197</FONT>         * line or filled region before clipping it.<a name="line.2197"></a>
<FONT color="green">2198</FONT>         * &lt;p&gt;<a name="line.2198"></a>
<FONT color="green">2199</FONT>         * <a name="line.2199"></a>
<FONT color="green">2200</FONT>         * Note that using this out of bounds multiplier, though faster than simple<a name="line.2200"></a>
<FONT color="green">2201</FONT>         * clipping, has the drawback that connecting lines from any dropped point<a name="line.2201"></a>
<FONT color="green">2202</FONT>         * that may intersect the plot area will not get drawn. Specific<a name="line.2202"></a>
<FONT color="green">2203</FONT>         * applications can avoid this problem by choosing their out of bounds<a name="line.2203"></a>
<FONT color="green">2204</FONT>         * multiplier large enough so that such dropped connecting lines are either<a name="line.2204"></a>
<FONT color="green">2205</FONT>         * very unlikely or impossible. For example, a time sequence chart with<a name="line.2205"></a>
<FONT color="green">2206</FONT>         * points spaced at regular pixel intervals along x could simply choose a<a name="line.2206"></a>
<FONT color="green">2207</FONT>         * multiplier larger than the fraction of the x-axis occupied by one of<a name="line.2207"></a>
<FONT color="green">2208</FONT>         * these intervals.<a name="line.2208"></a>
<FONT color="green">2209</FONT>         * &lt;p&gt;<a name="line.2209"></a>
<FONT color="green">2210</FONT>         * <a name="line.2210"></a>
<FONT color="green">2211</FONT>         * &lt;small&gt; &lt;i&gt;Note#1:&lt;/i&gt; In IE, attempting to render points at very large<a name="line.2211"></a>
<FONT color="green">2212</FONT>         * pixel coordinates (&gt;100,000px) could cause the browser to go into the<a name="line.2212"></a>
<FONT color="green">2213</FONT>         * "Not Responding" state. And, in FF2 and Chrome, rendering results for<a name="line.2213"></a>
<FONT color="green">2214</FONT>         * lines drawn to positions far off (in testing, problems were encountered<a name="line.2214"></a>
<FONT color="green">2215</FONT>         * at around 10,000px) the plot area are unreliable. If you prefer to simply<a name="line.2215"></a>
<FONT color="green">2216</FONT>         * never render such "far out" lines rather than deal with such anamolies,<a name="line.2216"></a>
<FONT color="green">2217</FONT>         * choose an &lt;tt&gt;outOfBoundsMultiplier&lt;/tt&gt; that excludes such problem<a name="line.2217"></a>
<FONT color="green">2218</FONT>         * points entirely.<a name="line.2218"></a>
<FONT color="green">2219</FONT>         * &lt;p&gt;<a name="line.2219"></a>
<FONT color="green">2220</FONT>         * <a name="line.2220"></a>
<FONT color="green">2221</FONT>         * &lt;i&gt;Note#2:&lt;/i&gt; Out of bounds checking on a chart that has no out of<a name="line.2221"></a>
<FONT color="green">2222</FONT>         * bounds points can slow chart rendering by up to 5% or so. If you have<a name="line.2222"></a>
<FONT color="green">2223</FONT>         * lots of out of bounds points you will easily regain this cost in saved<a name="line.2223"></a>
<FONT color="green">2224</FONT>         * rendering time, but if only a few points are out of bounds, it may be<a name="line.2224"></a>
<FONT color="green">2225</FONT>         * faster to disable out of bounds checking completely by setting this<a name="line.2225"></a>
<FONT color="green">2226</FONT>         * multiplier on every axis to &lt;tt&gt;Double.NaN&lt;/tt&gt; (this is GChart's<a name="line.2226"></a>
<FONT color="green">2227</FONT>         * default). &lt;/small&gt;<a name="line.2227"></a>
<FONT color="green">2228</FONT>         * <a name="line.2228"></a>
<FONT color="green">2229</FONT>         * @param outOfBoundsMultiplier<a name="line.2229"></a>
<FONT color="green">2230</FONT>         *          number of axis lengths beyond which points are not rendered or<a name="line.2230"></a>
<FONT color="green">2231</FONT>         *          &lt;tt&gt;Double.NaN&lt;/tt&gt; (the default) to render all points,<a name="line.2231"></a>
<FONT color="green">2232</FONT>         *          regardless of how far off the axis they are.<a name="line.2232"></a>
<FONT color="green">2233</FONT>         * <a name="line.2233"></a>
<FONT color="green">2234</FONT>         * @see GChart#setClipToPlotArea GChart.setClipToPlotArea<a name="line.2234"></a>
<FONT color="green">2235</FONT>         * @see Curve#setClipToPlotArea Curve.setClipToPlotArea<a name="line.2235"></a>
<FONT color="green">2236</FONT>         * @see #setClipToDecoratedChart setClipToDecoratedChart<a name="line.2236"></a>
<FONT color="green">2237</FONT>         * @see #getOutOfBoundsMultiplier getOutOfBoundsMultiplier<a name="line.2237"></a>
<FONT color="green">2238</FONT>         */<a name="line.2238"></a>
<FONT color="green">2239</FONT>    <a name="line.2239"></a>
<FONT color="green">2240</FONT>        public void setOutOfBoundsMultiplier(double outOfBoundsMultiplier) {<a name="line.2240"></a>
<FONT color="green">2241</FONT>          invalidateAccessibleCurves();<a name="line.2241"></a>
<FONT color="green">2242</FONT>          this.outOfBoundsMultiplier = outOfBoundsMultiplier;<a name="line.2242"></a>
<FONT color="green">2243</FONT>        }<a name="line.2243"></a>
<FONT color="green">2244</FONT>    <a name="line.2244"></a>
<FONT color="green">2245</FONT>        /**<a name="line.2245"></a>
<FONT color="green">2246</FONT>         * Specifies if this axis should have gridlines. When an axis has gridlines,<a name="line.2246"></a>
<FONT color="green">2247</FONT>         * tick marks with indexes &lt;tt&gt;0, N,<a name="line.2247"></a>
<FONT color="green">2248</FONT>         * * 2*N,...&lt;/tt&gt; where &lt;tt&gt;N&lt;/tt&gt; is the value of this axis'<a name="line.2248"></a>
<FONT color="green">2249</FONT>         * &lt;tt&gt;ticksPerGridline&lt;/tt&gt; property, are in effect extended across the<a name="line.2249"></a>
<FONT color="green">2250</FONT>         * entire chart.<a name="line.2250"></a>
<FONT color="green">2251</FONT>         * <a name="line.2251"></a>
<FONT color="green">2252</FONT>         * @param hasGridlines<a name="line.2252"></a>
<FONT color="green">2253</FONT>         *          true to display gridlines, false (the default) to not display<a name="line.2253"></a>
<FONT color="green">2254</FONT>         *          them.<a name="line.2254"></a>
<FONT color="green">2255</FONT>         * <a name="line.2255"></a>
<FONT color="green">2256</FONT>         * @see #getHasGridlines getHasGridlines<a name="line.2256"></a>
<FONT color="green">2257</FONT>         * @see #setTicksPerGridline setTicksPerGridline<a name="line.2257"></a>
<FONT color="green">2258</FONT>         * <a name="line.2258"></a>
<FONT color="green">2259</FONT>         */<a name="line.2259"></a>
<FONT color="green">2260</FONT>        public void setHasGridlines(boolean hasGridlines) {<a name="line.2260"></a>
<FONT color="green">2261</FONT>          chartDecorationsChanged = true;<a name="line.2261"></a>
<FONT color="green">2262</FONT>          this.hasGridlines = hasGridlines;<a name="line.2262"></a>
<FONT color="green">2263</FONT>        }<a name="line.2263"></a>
<FONT color="green">2264</FONT>    <a name="line.2264"></a>
<FONT color="green">2265</FONT>        /**<a name="line.2265"></a>
<FONT color="green">2266</FONT>         * Sets the number of ticks to be placed on this axis. The default tick<a name="line.2266"></a>
<FONT color="green">2267</FONT>         * count is 10. Ticks are always evenly spaced across the entire axis,<a name="line.2267"></a>
<FONT color="green">2268</FONT>         * unless explicitly specified via &lt;tt&gt;addTick&lt;/tt&gt;.<a name="line.2268"></a>
<FONT color="green">2269</FONT>         * &lt;p&gt;<a name="line.2269"></a>
<FONT color="green">2270</FONT>         * <a name="line.2270"></a>
<FONT color="green">2271</FONT>         * Note that setting the tick count overrides (erases) any ticks explicitly<a name="line.2271"></a>
<FONT color="green">2272</FONT>         * specified via &lt;tt&gt;addTick&lt;/tt&gt;.<a name="line.2272"></a>
<FONT color="green">2273</FONT>         * <a name="line.2273"></a>
<FONT color="green">2274</FONT>         * @param tickCount<a name="line.2274"></a>
<FONT color="green">2275</FONT>         *          the number of ticks for this axis.<a name="line.2275"></a>
<FONT color="green">2276</FONT>         * <a name="line.2276"></a>
<FONT color="green">2277</FONT>         * @see #getTickCount getTickCount<a name="line.2277"></a>
<FONT color="green">2278</FONT>         * @see #addTick(double) addTick(double)<a name="line.2278"></a>
<FONT color="green">2279</FONT>         * @see #addTick(double,String) addTick(double, String)<a name="line.2279"></a>
<FONT color="green">2280</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.2280"></a>
<FONT color="green">2281</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.2281"></a>
<FONT color="green">2282</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.2282"></a>
<FONT color="green">2283</FONT>         * @see #setTickLabelFormat setTickLabelFormat<a name="line.2283"></a>
<FONT color="green">2284</FONT>         * @see #setTickLabelFontSize setTickLabelFontSize<a name="line.2284"></a>
<FONT color="green">2285</FONT>         * @see #setTickLabelFontStyle setTickLabelFontStyle<a name="line.2285"></a>
<FONT color="green">2286</FONT>         * @see #setTickLabelFontColor setTickLabelFontColor<a name="line.2286"></a>
<FONT color="green">2287</FONT>         * @see #setTickLabelFontWeight setTickLabelFontWeight<a name="line.2287"></a>
<FONT color="green">2288</FONT>         * <a name="line.2288"></a>
<FONT color="green">2289</FONT>         */<a name="line.2289"></a>
<FONT color="green">2290</FONT>        public void setTickCount(int tickCount) {<a name="line.2290"></a>
<FONT color="green">2291</FONT>          chartDecorationsChanged = true;<a name="line.2291"></a>
<FONT color="green">2292</FONT>          // eliminate user specified ticks<a name="line.2292"></a>
<FONT color="green">2293</FONT>          getSystemCurve(ticksId).clearPoints();<a name="line.2293"></a>
<FONT color="green">2294</FONT>          this.tickCount = tickCount;<a name="line.2294"></a>
<FONT color="green">2295</FONT>        }<a name="line.2295"></a>
<FONT color="green">2296</FONT>    <a name="line.2296"></a>
<FONT color="green">2297</FONT>        /**<a name="line.2297"></a>
<FONT color="green">2298</FONT>         * Specifies the weight of the font used in this axis' tick labels.<a name="line.2298"></a>
<FONT color="green">2299</FONT>         * <a name="line.2299"></a>
<FONT color="green">2300</FONT>         * @param cssWeight<a name="line.2300"></a>
<FONT color="green">2301</FONT>         *          the weight of the font, such as bold, normal, light, 100, 200,<a name="line.2301"></a>
<FONT color="green">2302</FONT>         *          ... 900, for tick labels.<a name="line.2302"></a>
<FONT color="green">2303</FONT>         * <a name="line.2303"></a>
<FONT color="green">2304</FONT>         * @see #getTickLabelFontWeight getTickLabelFontWeight<a name="line.2304"></a>
<FONT color="green">2305</FONT>         * @see #setTickLabelFormat setTickLabelFormat<a name="line.2305"></a>
<FONT color="green">2306</FONT>         * @see #setTickCount setTickCount<a name="line.2306"></a>
<FONT color="green">2307</FONT>         * @see #addTick(double) addTick(double)<a name="line.2307"></a>
<FONT color="green">2308</FONT>         * @see #addTick(double,String) addTick(double,String)<a name="line.2308"></a>
<FONT color="green">2309</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.2309"></a>
<FONT color="green">2310</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.2310"></a>
<FONT color="green">2311</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.2311"></a>
<FONT color="green">2312</FONT>         * @see #setTickLabelFontStyle setTickLabelFontStyle<a name="line.2312"></a>
<FONT color="green">2313</FONT>         * @see #setTickLabelFontColor setTickLabelFontColor<a name="line.2313"></a>
<FONT color="green">2314</FONT>         * @see #setTickLabelFontSize setTickLabelFontSize<a name="line.2314"></a>
<FONT color="green">2315</FONT>         * @see #DEFAULT_TICK_LABEL_FONT_WEIGHT DEFAULT_TICK_LABEL_FONT_WEIGHT<a name="line.2315"></a>
<FONT color="green">2316</FONT>         * <a name="line.2316"></a>
<FONT color="green">2317</FONT>         */<a name="line.2317"></a>
<FONT color="green">2318</FONT>        public void setTickLabelFontWeight(String cssWeight) {<a name="line.2318"></a>
<FONT color="green">2319</FONT>          chartDecorationsChanged = true;<a name="line.2319"></a>
<FONT color="green">2320</FONT>          // assure that any existing ticks are updated with new weight<a name="line.2320"></a>
<FONT color="green">2321</FONT>          Curve c = getSystemCurve(ticksId);<a name="line.2321"></a>
<FONT color="green">2322</FONT>          int nPoints = c.getNPoints();<a name="line.2322"></a>
<FONT color="green">2323</FONT>          for (int i = 0; i &lt; nPoints; i++)<a name="line.2323"></a>
<FONT color="green">2324</FONT>            c.getPoint(i).setAnnotationFontWeight(cssWeight);<a name="line.2324"></a>
<FONT color="green">2325</FONT>          tickLabelFontWeight = cssWeight;<a name="line.2325"></a>
<FONT color="green">2326</FONT>        }<a name="line.2326"></a>
<FONT color="green">2327</FONT>    <a name="line.2327"></a>
<FONT color="green">2328</FONT>        /**<a name="line.2328"></a>
<FONT color="green">2329</FONT>         * Specifies the color of the font used to render tick labels for this axis.<a name="line.2329"></a>
<FONT color="green">2330</FONT>         * <a name="line.2330"></a>
<FONT color="green">2331</FONT>         * &lt;p&gt;<a name="line.2331"></a>
<FONT color="green">2332</FONT>         * For more information on standard CSS color specifications see the<a name="line.2332"></a>
<FONT color="green">2333</FONT>         * discussion in {@link Symbol#setBackgroundColor Symbol.setBackgroundColor}.<a name="line.2333"></a>
<FONT color="green">2334</FONT>         * &lt;p&gt;<a name="line.2334"></a>
<FONT color="green">2335</FONT>         * <a name="line.2335"></a>
<FONT color="green">2336</FONT>         * @param cssColor<a name="line.2336"></a>
<FONT color="green">2337</FONT>         *          color of the font used to display this axis' tick labels, in<a name="line.2337"></a>
<FONT color="green">2338</FONT>         *          standard CSS format.<a name="line.2338"></a>
<FONT color="green">2339</FONT>         * <a name="line.2339"></a>
<FONT color="green">2340</FONT>         * @see #getTickLabelFontColor getTickLabelFontColor<a name="line.2340"></a>
<FONT color="green">2341</FONT>         * @see #setTickLabelFormat setTickLabelFormat<a name="line.2341"></a>
<FONT color="green">2342</FONT>         * @see #setTickCount setTickCount<a name="line.2342"></a>
<FONT color="green">2343</FONT>         * @see #addTick(double) addTick(double)<a name="line.2343"></a>
<FONT color="green">2344</FONT>         * @see #addTick(double,String) addTick(double,String)<a name="line.2344"></a>
<FONT color="green">2345</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.2345"></a>
<FONT color="green">2346</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.2346"></a>
<FONT color="green">2347</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.2347"></a>
<FONT color="green">2348</FONT>         * @see #setTickLabelFontStyle setTickLabelFontStyle<a name="line.2348"></a>
<FONT color="green">2349</FONT>         * @see #setTickLabelFontWeight setTickLabelFontWeight<a name="line.2349"></a>
<FONT color="green">2350</FONT>         * @see #setTickLabelFontSize setTickLabelFontSize<a name="line.2350"></a>
<FONT color="green">2351</FONT>         * @see #DEFAULT_TICK_LABEL_FONT_COLOR DEFAULT_TICK_LABEL_FONT_COLOR<a name="line.2351"></a>
<FONT color="green">2352</FONT>         * <a name="line.2352"></a>
<FONT color="green">2353</FONT>         */<a name="line.2353"></a>
<FONT color="green">2354</FONT>        public void setTickLabelFontColor(String cssColor) {<a name="line.2354"></a>
<FONT color="green">2355</FONT>          chartDecorationsChanged = true;<a name="line.2355"></a>
<FONT color="green">2356</FONT>          Curve c = getSystemCurve(ticksId);<a name="line.2356"></a>
<FONT color="green">2357</FONT>          int nPoints = c.getNPoints();<a name="line.2357"></a>
<FONT color="green">2358</FONT>          for (int i = 0; i &lt; nPoints; i++)<a name="line.2358"></a>
<FONT color="green">2359</FONT>            c.getPoint(i).setAnnotationFontColor(cssColor);<a name="line.2359"></a>
<FONT color="green">2360</FONT>          tickLabelFontColor = cssColor;<a name="line.2360"></a>
<FONT color="green">2361</FONT>        }<a name="line.2361"></a>
<FONT color="green">2362</FONT>    <a name="line.2362"></a>
<FONT color="green">2363</FONT>        /**<a name="line.2363"></a>
<FONT color="green">2364</FONT>         * Specifies the CSS font-family of this axis' tick labels.<a name="line.2364"></a>
<FONT color="green">2365</FONT>         * &lt;p&gt;<a name="line.2365"></a>
<FONT color="green">2366</FONT>         * <a name="line.2366"></a>
<FONT color="green">2367</FONT>         * If &lt;tt&gt;null&lt;/tt&gt; (the default) tick labels will just use the font<a name="line.2367"></a>
<FONT color="green">2368</FONT>         * family specified via &lt;tt&gt;GChart.setFontFamily&lt;/tt&gt;.<a name="line.2368"></a>
<FONT color="green">2369</FONT>         * <a name="line.2369"></a>
<FONT color="green">2370</FONT>         * @param cssFontFamily<a name="line.2370"></a>
<FONT color="green">2371</FONT>         *          any valid CSS font-family, such as<a name="line.2371"></a>
<FONT color="green">2372</FONT>         *          &lt;tt&gt;"serif", "sans-serif", "monospace", "cursive",<a name="line.2372"></a>
<FONT color="green">2373</FONT>         *          "fantasy"&lt;/tt&gt; or &lt;tt&gt;"Arial, sans-serif" or<a name="line.2373"></a>
<FONT color="green">2374</FONT>         *          &lt;tt&gt;null&lt;/tt&gt; to use the font family specified by<a name="line.2374"></a>
<FONT color="green">2375</FONT>         *          &lt;tt&gt;GChart.setFontFamily&lt;/tt&gt;.<a name="line.2375"></a>
<FONT color="green">2376</FONT>         * <a name="line.2376"></a>
<FONT color="green">2377</FONT>         * @see #setFontFamily(String) GChart.setFontFamily<a name="line.2377"></a>
<FONT color="green">2378</FONT>         * @see #getTickLabelFontFamily getTickLabelFontFamily<a name="line.2378"></a>
<FONT color="green">2379</FONT>         * @see #setTickLabelFormat setTickLabelFormat<a name="line.2379"></a>
<FONT color="green">2380</FONT>         * @see #setTickCount setTickCount<a name="line.2380"></a>
<FONT color="green">2381</FONT>         * @see #addTick(double) addTick(double)<a name="line.2381"></a>
<FONT color="green">2382</FONT>         * @see #addTick(double,String) addTick(double,String)<a name="line.2382"></a>
<FONT color="green">2383</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.2383"></a>
<FONT color="green">2384</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.2384"></a>
<FONT color="green">2385</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.2385"></a>
<FONT color="green">2386</FONT>         * @see #setTickLabelFontColor setTickLabelFontColor<a name="line.2386"></a>
<FONT color="green">2387</FONT>         * @see #setTickLabelFontWeight setTickLabelFontWeight<a name="line.2387"></a>
<FONT color="green">2388</FONT>         * @see #setTickLabelFontSize setTickLabelFontSize<a name="line.2388"></a>
<FONT color="green">2389</FONT>         * @see #setTickLabelFontStyle setTickLabelFontStyle<a name="line.2389"></a>
<FONT color="green">2390</FONT>         * @see #DEFAULT_FONT_FAMILY DEFAULT_FONT_FAMILY<a name="line.2390"></a>
<FONT color="green">2391</FONT>         * <a name="line.2391"></a>
<FONT color="green">2392</FONT>         */<a name="line.2392"></a>
<FONT color="green">2393</FONT>        public void setTickLabelFontFamily(String cssFontFamily) {<a name="line.2393"></a>
<FONT color="green">2394</FONT>          chartDecorationsChanged = true;<a name="line.2394"></a>
<FONT color="green">2395</FONT>          Curve c = getSystemCurve(ticksId);<a name="line.2395"></a>
<FONT color="green">2396</FONT>          int nPoints = c.getNPoints();<a name="line.2396"></a>
<FONT color="green">2397</FONT>          for (int i = 0; i &lt; nPoints; i++)<a name="line.2397"></a>
<FONT color="green">2398</FONT>            c.getPoint(i).setAnnotationFontFamily(cssFontFamily);<a name="line.2398"></a>
<FONT color="green">2399</FONT>          tickLabelFontFamily = cssFontFamily;<a name="line.2399"></a>
<FONT color="green">2400</FONT>        }<a name="line.2400"></a>
<FONT color="green">2401</FONT>    <a name="line.2401"></a>
<FONT color="green">2402</FONT>        /**<a name="line.2402"></a>
<FONT color="green">2403</FONT>         * Specifies the CSS font-style of this axis' tick labels.<a name="line.2403"></a>
<FONT color="green">2404</FONT>         * <a name="line.2404"></a>
<FONT color="green">2405</FONT>         * @param cssStyle<a name="line.2405"></a>
<FONT color="green">2406</FONT>         *          any valid CSS font-style, namely, &lt;tt&gt;normal, italic,<a name="line.2406"></a>
<FONT color="green">2407</FONT>         *          oblique,&lt;/tt&gt; or &lt;tt&gt;inherit&lt;/tt&gt;.<a name="line.2407"></a>
<FONT color="green">2408</FONT>         * <a name="line.2408"></a>
<FONT color="green">2409</FONT>         * @see #getTickLabelFontStyle getTickLabelFontStyle<a name="line.2409"></a>
<FONT color="green">2410</FONT>         * @see #setTickLabelFormat setTickLabelFormat<a name="line.2410"></a>
<FONT color="green">2411</FONT>         * @see #setTickCount setTickCount<a name="line.2411"></a>
<FONT color="green">2412</FONT>         * @see #addTick(double) addTick(double)<a name="line.2412"></a>
<FONT color="green">2413</FONT>         * @see #addTick(double,String) addTick(double,String)<a name="line.2413"></a>
<FONT color="green">2414</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.2414"></a>
<FONT color="green">2415</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.2415"></a>
<FONT color="green">2416</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.2416"></a>
<FONT color="green">2417</FONT>         * @see #setTickLabelFontColor setTickLabelFontColor<a name="line.2417"></a>
<FONT color="green">2418</FONT>         * @see #setTickLabelFontWeight setTickLabelFontWeight<a name="line.2418"></a>
<FONT color="green">2419</FONT>         * @see #setTickLabelFontSize setTickLabelFontSize<a name="line.2419"></a>
<FONT color="green">2420</FONT>         * @see #DEFAULT_TICK_LABEL_FONT_STYLE DEFAULT_TICK_LABEL_FONT_STYLE<a name="line.2420"></a>
<FONT color="green">2421</FONT>         */<a name="line.2421"></a>
<FONT color="green">2422</FONT>        public void setTickLabelFontStyle(String cssStyle) {<a name="line.2422"></a>
<FONT color="green">2423</FONT>          chartDecorationsChanged = true;<a name="line.2423"></a>
<FONT color="green">2424</FONT>          Curve c = getSystemCurve(ticksId);<a name="line.2424"></a>
<FONT color="green">2425</FONT>          int nPoints = c.getNPoints();<a name="line.2425"></a>
<FONT color="green">2426</FONT>          for (int i = 0; i &lt; nPoints; i++)<a name="line.2426"></a>
<FONT color="green">2427</FONT>            c.getPoint(i).setAnnotationFontStyle(cssStyle);<a name="line.2427"></a>
<FONT color="green">2428</FONT>          tickLabelFontStyle = cssStyle;<a name="line.2428"></a>
<FONT color="green">2429</FONT>        }<a name="line.2429"></a>
<FONT color="green">2430</FONT>    <a name="line.2430"></a>
<FONT color="green">2431</FONT>        /**<a name="line.2431"></a>
<FONT color="green">2432</FONT>         * Sets the CSS font size for tick labels on this axis, in pixels.<a name="line.2432"></a>
<FONT color="green">2433</FONT>         * <a name="line.2433"></a>
<FONT color="green">2434</FONT>         * @param tickLabelFontSize<a name="line.2434"></a>
<FONT color="green">2435</FONT>         *          the font size of tick labels displayed on this axis.<a name="line.2435"></a>
<FONT color="green">2436</FONT>         * <a name="line.2436"></a>
<FONT color="green">2437</FONT>         * @see #getTickLabelFontSize getTickLabelFontSize<a name="line.2437"></a>
<FONT color="green">2438</FONT>         * @see #setTickLabelFormat setTickLabelFormat<a name="line.2438"></a>
<FONT color="green">2439</FONT>         * @see #setTickCount setTickCount<a name="line.2439"></a>
<FONT color="green">2440</FONT>         * @see #addTick(double) addTick(double)<a name="line.2440"></a>
<FONT color="green">2441</FONT>         * @see #addTick(double,String) addTick(double,String)<a name="line.2441"></a>
<FONT color="green">2442</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.2442"></a>
<FONT color="green">2443</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.2443"></a>
<FONT color="green">2444</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.2444"></a>
<FONT color="green">2445</FONT>         * @see #setTickLabelFontStyle setTickLabelFontStyle<a name="line.2445"></a>
<FONT color="green">2446</FONT>         * @see #setTickLabelFontColor setTickLabelFontColor<a name="line.2446"></a>
<FONT color="green">2447</FONT>         * @see #setTickLabelFontWeight setTickLabelFontWeight<a name="line.2447"></a>
<FONT color="green">2448</FONT>         * @see GChart#DEFAULT_TICK_LABEL_FONTSIZE DEFAULT_TICK_LABEL_FONTSIZE<a name="line.2448"></a>
<FONT color="green">2449</FONT>         * <a name="line.2449"></a>
<FONT color="green">2450</FONT>         */<a name="line.2450"></a>
<FONT color="green">2451</FONT>    <a name="line.2451"></a>
<FONT color="green">2452</FONT>        public void setTickLabelFontSize(int tickLabelFontSize) {<a name="line.2452"></a>
<FONT color="green">2453</FONT>          chartDecorationsChanged = true;<a name="line.2453"></a>
<FONT color="green">2454</FONT>          Curve c = getSystemCurve(ticksId);<a name="line.2454"></a>
<FONT color="green">2455</FONT>          int nPoints = c.getNPoints();<a name="line.2455"></a>
<FONT color="green">2456</FONT>          for (int i = 0; i &lt; nPoints; i++)<a name="line.2456"></a>
<FONT color="green">2457</FONT>            c.getPoint(i).setAnnotationFontSize(tickLabelFontSize);<a name="line.2457"></a>
<FONT color="green">2458</FONT>          this.tickLabelFontSize = tickLabelFontSize;<a name="line.2458"></a>
<FONT color="green">2459</FONT>        }<a name="line.2459"></a>
<FONT color="green">2460</FONT>    <a name="line.2460"></a>
<FONT color="green">2461</FONT>        /**<a name="line.2461"></a>
<FONT color="green">2462</FONT>         * Specifies a format string to be used in converting the numeric values<a name="line.2462"></a>
<FONT color="green">2463</FONT>         * associated with each tick on this axis into tick labels. This string must<a name="line.2463"></a>
<FONT color="green">2464</FONT>         * follow the conventions of the number format patterns used by the GWT &lt;a<a name="line.2464"></a>
<FONT color="green">2465</FONT>         * href="http://google-web-toolkit.googlecode.com/svn/javadoc/1.4/com/google/gwt/i18n/client/NumberFormat.html"<a name="line.2465"></a>
<FONT color="green">2466</FONT>         * &gt; NumberFormat&lt;/a&gt; class, &lt;i&gt;with three exceptions:&lt;/i&gt;<a name="line.2466"></a>
<FONT color="green">2467</FONT>         * &lt;p&gt;<a name="line.2467"></a>
<FONT color="green">2468</FONT>         * &lt;ol&gt;<a name="line.2468"></a>
<FONT color="green">2469</FONT>         * <a name="line.2469"></a>
<FONT color="green">2470</FONT>         * &lt;li&gt;&lt;i&gt;Log10 inverse prefix&lt;/i&gt;: If the string begins with the prefix<a name="line.2470"></a>
<FONT color="green">2471</FONT>         * &lt;tt&gt;=10^&lt;/tt&gt; the value is replaced with &lt;tt&gt;pow(10.,value)&lt;/tt&gt; and the<a name="line.2471"></a>
<FONT color="green">2472</FONT>         * so-transformed value is then formatted using the part of the format<a name="line.2472"></a>
<FONT color="green">2473</FONT>         * string that comes after this prefix, which must be a valid GWT<a name="line.2473"></a>
<FONT color="green">2474</FONT>         * &lt;tt&gt;NumberFormat&lt;/tt&gt; pattern (e.g. "##.##").<a name="line.2474"></a>
<FONT color="green">2475</FONT>         * &lt;p&gt;<a name="line.2475"></a>
<FONT color="green">2476</FONT>         * For an example of how to use this prefix to create a semi-log plot, see<a name="line.2476"></a>
<FONT color="green">2477</FONT>         * &lt;a href="package-summary.html#GChartExample04"&gt;the Chart Gallery's<a name="line.2477"></a>
<FONT color="green">2478</FONT>         * GChartExample04&lt;/a&gt;.<a name="line.2478"></a>
<FONT color="green">2479</FONT>         * &lt;p&gt;<a name="line.2479"></a>
<FONT color="green">2480</FONT>         * <a name="line.2480"></a>
<FONT color="green">2481</FONT>         * &lt;li&gt;&lt;i&gt;Log2 inverse prefix&lt;/i&gt;: If the string begins with the prefix<a name="line.2481"></a>
<FONT color="green">2482</FONT>         * &lt;tt&gt;=2^&lt;/tt&gt; the value is replaced with &lt;tt&gt;pow(2.,value)&lt;/tt&gt; and the<a name="line.2482"></a>
<FONT color="green">2483</FONT>         * so-transformed value is then formatted using the part of the format<a name="line.2483"></a>
<FONT color="green">2484</FONT>         * string that comes after this prefix, which must be a valid GWT<a name="line.2484"></a>
<FONT color="green">2485</FONT>         * &lt;tt&gt;NumberFormat&lt;/tt&gt; pattern.<a name="line.2485"></a>
<FONT color="green">2486</FONT>         * &lt;p&gt;<a name="line.2486"></a>
<FONT color="green">2487</FONT>         * <a name="line.2487"></a>
<FONT color="green">2488</FONT>         * &lt;li&gt;&lt;i&gt;Date casting prefix&lt;/i&gt;: If the string begins with the prefix<a name="line.2488"></a>
<FONT color="green">2489</FONT>         * &lt;tt&gt;=(Date)&lt;/tt&gt; the value is replaced with<a name="line.2489"></a>
<FONT color="green">2490</FONT>         * &lt;tt&gt;new Date((long) value)&lt;/tt&gt; and the so-transformed value is then<a name="line.2490"></a>
<FONT color="green">2491</FONT>         * formatted using the format string that comes after this prefix, which<a name="line.2491"></a>
<FONT color="green">2492</FONT>         * must be a valid GWT &lt;a href="http://google-web-toolkit.googlecode.com/svn/javadoc/1.4/com/google/gwt/i18n/client/DateTimeFormat.html"<a name="line.2492"></a>
<FONT color="green">2493</FONT>         * &gt; DateTimeFormat&lt;/a&gt; pattern (e.g. "yyyy-MM-dd&amp;nbsp;HH:mm"). For the<a name="line.2493"></a>
<FONT color="green">2494</FONT>         * special case format string of &lt;tt&gt;"=(Date)"&lt;/tt&gt; (just the date casting<a name="line.2494"></a>
<FONT color="green">2495</FONT>         * prefix) GChart uses the &lt;tt&gt;DateTimeFormat&lt;/tt&gt; returned by the<a name="line.2495"></a>
<FONT color="green">2496</FONT>         * &lt;tt&gt;DateTimeFormat.getShortDateTimeFormat&lt;/tt&gt; method.<a name="line.2496"></a>
<FONT color="green">2497</FONT>         * &lt;p&gt;<a name="line.2497"></a>
<FONT color="green">2498</FONT>         * <a name="line.2498"></a>
<FONT color="green">2499</FONT>         * Note that the values associated with this Axis must represent the number<a name="line.2499"></a>
<FONT color="green">2500</FONT>         * of milliseconds since January 1, 1970 (in the GMT time zone) whenever<a name="line.2500"></a>
<FONT color="green">2501</FONT>         * this date casting prefix is used.<a name="line.2501"></a>
<FONT color="green">2502</FONT>         * &lt;p&gt;<a name="line.2502"></a>
<FONT color="green">2503</FONT>         * <a name="line.2503"></a>
<FONT color="green">2504</FONT>         * For example, if the x-axis tick label format were<a name="line.2504"></a>
<FONT color="green">2505</FONT>         * "=(Date)MMM-dd-yyyy HH", then, for a tick located at the x position of 0,<a name="line.2505"></a>
<FONT color="green">2506</FONT>         * the tick label would be "Jan-01-1970 00" (on a client in the GMT time<a name="line.2506"></a>
<FONT color="green">2507</FONT>         * zone) and for a tick located at the x position of 25*60*60*1000 (one day<a name="line.2507"></a>
<FONT color="green">2508</FONT>         * + one hour, in milliseconds) the tick label would be "Jan-02-1970 01"<a name="line.2508"></a>
<FONT color="green">2509</FONT>         * (again, on a GMT-based client). Results would be shifted appropriately on<a name="line.2509"></a>
<FONT color="green">2510</FONT>         * clients in different time zones.<a name="line.2510"></a>
<FONT color="green">2511</FONT>         * &lt;p&gt;<a name="line.2511"></a>
<FONT color="green">2512</FONT>         * <a name="line.2512"></a>
<FONT color="green">2513</FONT>         * Note that if your chart is based on absolute, GMT-based, millisecond<a name="line.2513"></a>
<FONT color="green">2514</FONT>         * times then date labels will change when your chart is displayed on<a name="line.2514"></a>
<FONT color="green">2515</FONT>         * clients in different time zones. Sometimes, this is what you want. To<a name="line.2515"></a>
<FONT color="green">2516</FONT>         * keep the date labels the same in all time zones, convert date labels into<a name="line.2516"></a>
<FONT color="green">2517</FONT>         * Java &lt;tt&gt;Date&lt;/tt&gt; objects in your client-side code, then use the<a name="line.2517"></a>
<FONT color="green">2518</FONT>         * &lt;tt&gt;Date.getTime&lt;/tt&gt; method, also in your client-side code, to convert<a name="line.2518"></a>
<FONT color="green">2519</FONT>         * those dates into the millisecond values GChart requires. The &lt;a<a name="line.2519"></a>
<FONT color="green">2520</FONT>         * href="package-summary.html#GChartExample12"&gt; Chart Gallery's<a name="line.2520"></a>
<FONT color="green">2521</FONT>         * GChartExample12&lt;/a&gt; illustrates how to use this second approach to<a name="line.2521"></a>
<FONT color="green">2522</FONT>         * produce a time series chart whose date-time labels are the same in all<a name="line.2522"></a>
<FONT color="green">2523</FONT>         * time zones.<a name="line.2523"></a>
<FONT color="green">2524</FONT>         * <a name="line.2524"></a>
<FONT color="green">2525</FONT>         * &lt;p&gt;<a name="line.2525"></a>
<FONT color="green">2526</FONT>         * <a name="line.2526"></a>
<FONT color="green">2527</FONT>         * &lt;blockquote&gt;&lt;small&gt;<a name="line.2527"></a>
<FONT color="green">2528</FONT>         * <a name="line.2528"></a>
<FONT color="green">2529</FONT>         * Ben Martin describes an alternative (and more flexible) approach to<a name="line.2529"></a>
<FONT color="green">2530</FONT>         * formatting time series tick labels in his &lt;a<a name="line.2530"></a>
<FONT color="green">2531</FONT>         * href="http://www.linux.com/feature/132854"&gt;GChart tutorial&lt;/a&gt;. Ben's<a name="line.2531"></a>
<FONT color="green">2532</FONT>         * article, along with Malcolm Gorman's related &lt;a href=<a name="line.2532"></a>
<FONT color="green">2533</FONT>         * "http://groups.google.com/group/Google-Web-Toolkit/msg/6125ce39fd2339ac"<a name="line.2533"></a>
<FONT color="green">2534</FONT>         * &gt; GWT forum post&lt;/a&gt; were the origin of this date casting prefix. Thanks!<a name="line.2534"></a>
<FONT color="green">2535</FONT>         * &lt;/small&gt;&lt;/blockquote&gt;<a name="line.2535"></a>
<FONT color="green">2536</FONT>         * <a name="line.2536"></a>
<FONT color="green">2537</FONT>         * &lt;/ol&gt;<a name="line.2537"></a>
<FONT color="green">2538</FONT>         * <a name="line.2538"></a>
<FONT color="green">2539</FONT>         * &lt;p&gt;<a name="line.2539"></a>
<FONT color="green">2540</FONT>         * Though HTML text is not supported in the tick label format string, you<a name="line.2540"></a>
<FONT color="green">2541</FONT>         * can change the size, weight, style, and color of tick label text via the<a name="line.2541"></a>
<FONT color="green">2542</FONT>         * &lt;tt&gt;setTickLabelFont*&lt;/tt&gt; family of methods. You &lt;i&gt;can&lt;/i&gt; use HTML in<a name="line.2542"></a>
<FONT color="green">2543</FONT>         * tick labels (e.g. for a multi-line x-axis label) but but only if you<a name="line.2543"></a>
<FONT color="green">2544</FONT>         * define each tick label explicitly using the &lt;tt&gt;addTick&lt;/tt&gt; method.<a name="line.2544"></a>
<FONT color="green">2545</FONT>         * <a name="line.2545"></a>
<FONT color="green">2546</FONT>         * @param format<a name="line.2546"></a>
<FONT color="green">2547</FONT>         *          an appropriately prefixed GWT &lt;tt&gt;NumberFormat&lt;/tt&gt; compatible<a name="line.2547"></a>
<FONT color="green">2548</FONT>         *          or GWT &lt;tt&gt;DateTimeFormat&lt;/tt&gt; compatible format string that<a name="line.2548"></a>
<FONT color="green">2549</FONT>         *          defines how to convert tick values into tick labels.<a name="line.2549"></a>
<FONT color="green">2550</FONT>         * <a name="line.2550"></a>
<FONT color="green">2551</FONT>         * @see #setTickCount setTickCount<a name="line.2551"></a>
<FONT color="green">2552</FONT>         * @see #addTick(double) addTick(double)<a name="line.2552"></a>
<FONT color="green">2553</FONT>         * @see #addTick(double,String) addTick(double,String)<a name="line.2553"></a>
<FONT color="green">2554</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.2554"></a>
<FONT color="green">2555</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.2555"></a>
<FONT color="green">2556</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.2556"></a>
<FONT color="green">2557</FONT>         * @see #setTickLabelFontSize setTickLabelFontSize<a name="line.2557"></a>
<FONT color="green">2558</FONT>         * @see #setTickLabelFontStyle setTickLabelFontStyle<a name="line.2558"></a>
<FONT color="green">2559</FONT>         * @see #setTickLabelFontColor setTickLabelFontColor<a name="line.2559"></a>
<FONT color="green">2560</FONT>         * @see #setTickLabelFontWeight setTickLabelFontWeight<a name="line.2560"></a>
<FONT color="green">2561</FONT>         * @see #getTickLabelFormat getTickLabelFormat<a name="line.2561"></a>
<FONT color="green">2562</FONT>         */<a name="line.2562"></a>
<FONT color="green">2563</FONT>        public void setTickLabelFormat(String format) {<a name="line.2563"></a>
<FONT color="green">2564</FONT>          // interpret prefixes and create an appropriate formatter<a name="line.2564"></a>
<FONT color="green">2565</FONT>          if (!tickLabelFormat.equals(format)) {<a name="line.2565"></a>
<FONT color="green">2566</FONT>            chartDecorationsChanged = true;<a name="line.2566"></a>
<FONT color="green">2567</FONT>            if (format.startsWith("=(Date)")) {<a name="line.2567"></a>
<FONT color="green">2568</FONT>              String transFormat = format.substring("=(Date)".length());<a name="line.2568"></a>
<FONT color="green">2569</FONT>              if (transFormat.equals("")) // so "=(Date)" works<a name="line.2569"></a>
<FONT color="green">2570</FONT>                dateFormat = DateTimeFormat.getShortDateTimeFormat();<a name="line.2570"></a>
<FONT color="green">2571</FONT>              else<a name="line.2571"></a>
<FONT color="green">2572</FONT>                // e.g. "=(Date)mm/dd/yy hh:mm"<a name="line.2572"></a>
<FONT color="green">2573</FONT>                dateFormat = DateTimeFormat.getFormat(transFormat);<a name="line.2573"></a>
<FONT color="green">2574</FONT>              tickLabelFormatType = DATE_FORMAT_TYPE;<a name="line.2574"></a>
<FONT color="green">2575</FONT>            } else if (format.startsWith("=10^")) {<a name="line.2575"></a>
<FONT color="green">2576</FONT>              String transFormat = format.substring("=10^".length());<a name="line.2576"></a>
<FONT color="green">2577</FONT>              numberFormat = NumberFormat.getFormat(transFormat);<a name="line.2577"></a>
<FONT color="green">2578</FONT>              tickLabelFormatType = LOG10INVERSE_FORMAT_TYPE;<a name="line.2578"></a>
<FONT color="green">2579</FONT>            } else if (format.startsWith("=2^")) {<a name="line.2579"></a>
<FONT color="green">2580</FONT>              String transFormat = format.substring("=2^".length());<a name="line.2580"></a>
<FONT color="green">2581</FONT>              numberFormat = NumberFormat.getFormat(transFormat);<a name="line.2581"></a>
<FONT color="green">2582</FONT>              tickLabelFormatType = LOG2INVERSE_FORMAT_TYPE;<a name="line.2582"></a>
<FONT color="green">2583</FONT>            } else {<a name="line.2583"></a>
<FONT color="green">2584</FONT>              numberFormat = NumberFormat.getFormat(format);<a name="line.2584"></a>
<FONT color="green">2585</FONT>              tickLabelFormatType = NUMBER_FORMAT_TYPE;<a name="line.2585"></a>
<FONT color="green">2586</FONT>            }<a name="line.2586"></a>
<FONT color="green">2587</FONT>          }<a name="line.2587"></a>
<FONT color="green">2588</FONT>          // remember original format (for use with the getter)<a name="line.2588"></a>
<FONT color="green">2589</FONT>          tickLabelFormat = format;<a name="line.2589"></a>
<FONT color="green">2590</FONT>        }<a name="line.2590"></a>
<FONT color="green">2591</FONT>    <a name="line.2591"></a>
<FONT color="green">2592</FONT>        /**<a name="line.2592"></a>
<FONT color="green">2593</FONT>         * Specifies the number of pixels of padding (blank space) between the tick<a name="line.2593"></a>
<FONT color="green">2594</FONT>         * marks and their labels.<a name="line.2594"></a>
<FONT color="green">2595</FONT>         * &lt;p&gt;<a name="line.2595"></a>
<FONT color="green">2596</FONT>         * <a name="line.2596"></a>
<FONT color="green">2597</FONT>         * With the default of &lt;tt&gt;0&lt;/tt&gt;, each tick label is flush against its tick<a name="line.2597"></a>
<FONT color="green">2598</FONT>         * mark.<a name="line.2598"></a>
<FONT color="green">2599</FONT>         * <a name="line.2599"></a>
<FONT color="green">2600</FONT>         * @param tickLabelPadding<a name="line.2600"></a>
<FONT color="green">2601</FONT>         *          the amount of padding between tick labels and tick marks, in<a name="line.2601"></a>
<FONT color="green">2602</FONT>         *          pixels.<a name="line.2602"></a>
<FONT color="green">2603</FONT>         * <a name="line.2603"></a>
<FONT color="green">2604</FONT>         * @see #getTickLabelPadding getTickLabelPadding<a name="line.2604"></a>
<FONT color="green">2605</FONT>         * @see #setTickLength setTickLength<a name="line.2605"></a>
<FONT color="green">2606</FONT>         * @see #setTickLocation setTickLocation<a name="line.2606"></a>
<FONT color="green">2607</FONT>         * <a name="line.2607"></a>
<FONT color="green">2608</FONT>         */<a name="line.2608"></a>
<FONT color="green">2609</FONT>        public void setTickLabelPadding(int tickLabelPadding) {<a name="line.2609"></a>
<FONT color="green">2610</FONT>          chartDecorationsChanged = true;<a name="line.2610"></a>
<FONT color="green">2611</FONT>          // assure that any existing ticks are updated with new padding<a name="line.2611"></a>
<FONT color="green">2612</FONT>          Curve c = getSystemCurve(ticksId);<a name="line.2612"></a>
<FONT color="green">2613</FONT>          int nPoints = c.getNPoints();<a name="line.2613"></a>
<FONT color="green">2614</FONT>          for (int i = 0; i &lt; nPoints; i++) {<a name="line.2614"></a>
<FONT color="green">2615</FONT>             if (isHorizontalAxis)<a name="line.2615"></a>
<FONT color="green">2616</FONT>               c.getPoint(i).setAnnotationYShift(axisPosition * tickLabelPadding);<a name="line.2616"></a>
<FONT color="green">2617</FONT>             else<a name="line.2617"></a>
<FONT color="green">2618</FONT>               c.getPoint(i).setAnnotationXShift(axisPosition * tickLabelPadding);<a name="line.2618"></a>
<FONT color="green">2619</FONT>          }<a name="line.2619"></a>
<FONT color="green">2620</FONT>          this.tickLabelPadding = tickLabelPadding;<a name="line.2620"></a>
<FONT color="green">2621</FONT>        }<a name="line.2621"></a>
<FONT color="green">2622</FONT>    <a name="line.2622"></a>
<FONT color="green">2623</FONT>        /**<a name="line.2623"></a>
<FONT color="green">2624</FONT>         * Specifies the thickness of the region adjacent to this axis that GChart<a name="line.2624"></a>
<FONT color="green">2625</FONT>         * will reserve for purposes of holding this axis' tick labels.<a name="line.2625"></a>
<FONT color="green">2626</FONT>         * &lt;p&gt;<a name="line.2626"></a>
<FONT color="green">2627</FONT>         * <a name="line.2627"></a>
<FONT color="green">2628</FONT>         * For vertical axes, this represents the width of the widest tick label,<a name="line.2628"></a>
<FONT color="green">2629</FONT>         * for horizontal axes, this represents the height of highest tick label.<a name="line.2629"></a>
<FONT color="green">2630</FONT>         * &lt;p&gt;<a name="line.2630"></a>
<FONT color="green">2631</FONT>         * <a name="line.2631"></a>
<FONT color="green">2632</FONT>         * By default, this property has the special "undefined" value<a name="line.2632"></a>
<FONT color="green">2633</FONT>         * &lt;tt&gt;GChart.NAI&lt;/tt&gt;. With this value, the companion method<a name="line.2633"></a>
<FONT color="green">2634</FONT>         * &lt;tt&gt;getTickLabelThickness&lt;/tt&gt; uses a character-counting<a name="line.2634"></a>
<FONT color="green">2635</FONT>         * heuristic to estimate the thickness.<a name="line.2635"></a>
<FONT color="green">2636</FONT>         * <a name="line.2636"></a>
<FONT color="green">2637</FONT>         * @see #getTickLabelThickness getTickLabelThickness<a name="line.2637"></a>
<FONT color="green">2638</FONT>         * @see #setTickLabelFontSize setTickLabelFontSize<a name="line.2638"></a>
<FONT color="green">2639</FONT>         * @see #setTickLocation setTickLocation<a name="line.2639"></a>
<FONT color="green">2640</FONT>         * @see #setTickLabelPadding setTickLabelPadding<a name="line.2640"></a>
<FONT color="green">2641</FONT>         * @see #setAxisLabel setAxisLabel<a name="line.2641"></a>
<FONT color="green">2642</FONT>         * @see GChart#NAI NAI<a name="line.2642"></a>
<FONT color="green">2643</FONT>         * <a name="line.2643"></a>
<FONT color="green">2644</FONT>         */<a name="line.2644"></a>
<FONT color="green">2645</FONT>        public void setTickLabelThickness(int tickLabelThickness) {<a name="line.2645"></a>
<FONT color="green">2646</FONT>          chartDecorationsChanged = true;<a name="line.2646"></a>
<FONT color="green">2647</FONT>          this.tickLabelThickness = tickLabelThickness;<a name="line.2647"></a>
<FONT color="green">2648</FONT>        }<a name="line.2648"></a>
<FONT color="green">2649</FONT>    <a name="line.2649"></a>
<FONT color="green">2650</FONT>        /**<a name="line.2650"></a>
<FONT color="green">2651</FONT>         * Specifies the ratio of the number of tick marks on the axis, to the<a name="line.2651"></a>
<FONT color="green">2652</FONT>         * number of gridlines on the axis.<a name="line.2652"></a>
<FONT color="green">2653</FONT>         * &lt;p&gt;<a name="line.2653"></a>
<FONT color="green">2654</FONT>         * <a name="line.2654"></a>
<FONT color="green">2655</FONT>         * For example, with the default value of 1, every tick has an associated<a name="line.2655"></a>
<FONT color="green">2656</FONT>         * gridline, whereas with a &lt;tt&gt;ticksPerGridline&lt;/tt&gt; setting of 2, only the<a name="line.2656"></a>
<FONT color="green">2657</FONT>         * first, third, fifth, etc. ticks have gridlines.<a name="line.2657"></a>
<FONT color="green">2658</FONT>         * &lt;p&gt;<a name="line.2658"></a>
<FONT color="green">2659</FONT>         * <a name="line.2659"></a>
<FONT color="green">2660</FONT>         * This setting only has an impact when the axis' gridlines are turned on,<a name="line.2660"></a>
<FONT color="green">2661</FONT>         * that is, when this axis' &lt;tt&gt;getHasGridlines&lt;/tt&gt; method returns true.<a name="line.2661"></a>
<FONT color="green">2662</FONT>         * <a name="line.2662"></a>
<FONT color="green">2663</FONT>         * @see #setHasGridlines setHasGridlines<a name="line.2663"></a>
<FONT color="green">2664</FONT>         * @see #setTickCount setTickCount<a name="line.2664"></a>
<FONT color="green">2665</FONT>         * @see #addTick(double) addTick(double)<a name="line.2665"></a>
<FONT color="green">2666</FONT>         * @see #addTick(double,String) addTick(double,String)<a name="line.2666"></a>
<FONT color="green">2667</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.2667"></a>
<FONT color="green">2668</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.2668"></a>
<FONT color="green">2669</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.2669"></a>
<FONT color="green">2670</FONT>         * <a name="line.2670"></a>
<FONT color="green">2671</FONT>         * @param ticksPerGridline<a name="line.2671"></a>
<FONT color="green">2672</FONT>         *          the number of ticks on this axis per "gridline-extended" tick.<a name="line.2672"></a>
<FONT color="green">2673</FONT>         * <a name="line.2673"></a>
<FONT color="green">2674</FONT>         */<a name="line.2674"></a>
<FONT color="green">2675</FONT>        public void setTicksPerGridline(int ticksPerGridline) {<a name="line.2675"></a>
<FONT color="green">2676</FONT>          if (ticksPerGridline &lt;= 0)<a name="line.2676"></a>
<FONT color="green">2677</FONT>            throw new IllegalArgumentException("ticksPerGridline="<a name="line.2677"></a>
<FONT color="green">2678</FONT>                + ticksPerGridline + "; ticksPerGridline must be &gt; 0");<a name="line.2678"></a>
<FONT color="green">2679</FONT>          chartDecorationsChanged = true;<a name="line.2679"></a>
<FONT color="green">2680</FONT>          this.ticksPerGridline = ticksPerGridline;<a name="line.2680"></a>
<FONT color="green">2681</FONT>        }<a name="line.2681"></a>
<FONT color="green">2682</FONT>    <a name="line.2682"></a>
<FONT color="green">2683</FONT>        /**<a name="line.2683"></a>
<FONT color="green">2684</FONT>         * Specifies the ratio of the number of tick marks on the axis, to the<a name="line.2684"></a>
<FONT color="green">2685</FONT>         * number of labeled tick marks on the axis.<a name="line.2685"></a>
<FONT color="green">2686</FONT>         * &lt;p&gt;<a name="line.2686"></a>
<FONT color="green">2687</FONT>         * <a name="line.2687"></a>
<FONT color="green">2688</FONT>         * For example, with the default value of 1, every tick is labeled, whereas<a name="line.2688"></a>
<FONT color="green">2689</FONT>         * with a &lt;tt&gt;ticksPerLabel&lt;/tt&gt; setting of 2, only the first, third, fifth,<a name="line.2689"></a>
<FONT color="green">2690</FONT>         * etc. ticks are labeled.<a name="line.2690"></a>
<FONT color="green">2691</FONT>         * &lt;p&gt;<a name="line.2691"></a>
<FONT color="green">2692</FONT>         * <a name="line.2692"></a>
<FONT color="green">2693</FONT>         * This setting is only used when tick labels are specified implicitly via<a name="line.2693"></a>
<FONT color="green">2694</FONT>         * &lt;tt&gt;setTickCount&lt;/tt&gt;. It is ignored when tick positions and their labels<a name="line.2694"></a>
<FONT color="green">2695</FONT>         * are explicitly specified via &lt;tt&gt;addTick&lt;/tt&gt;.<a name="line.2695"></a>
<FONT color="green">2696</FONT>         * <a name="line.2696"></a>
<FONT color="green">2697</FONT>         * @see #setTickCount setTickCount<a name="line.2697"></a>
<FONT color="green">2698</FONT>         * @see #addTick(double) addTick(double)<a name="line.2698"></a>
<FONT color="green">2699</FONT>         * @see #addTick(double,String) addTick(double,String)<a name="line.2699"></a>
<FONT color="green">2700</FONT>         * @see #addTick(double,String,int,int) addTick(double,String,int,int)<a name="line.2700"></a>
<FONT color="green">2701</FONT>         * @see #addTick(double,Widget) addTick(double,Widget)<a name="line.2701"></a>
<FONT color="green">2702</FONT>         * @see #addTick(double,Widget,int,int) addTick(double,Widget,int,int)<a name="line.2702"></a>
<FONT color="green">2703</FONT>         * <a name="line.2703"></a>
<FONT color="green">2704</FONT>         * @param ticksPerLabel<a name="line.2704"></a>
<FONT color="green">2705</FONT>         *          the ratio of the number of ticks, to the number of labeled<a name="line.2705"></a>
<FONT color="green">2706</FONT>         *          ticks.<a name="line.2706"></a>
<FONT color="green">2707</FONT>         * <a name="line.2707"></a>
<FONT color="green">2708</FONT>         */<a name="line.2708"></a>
<FONT color="green">2709</FONT>        public void setTicksPerLabel(int ticksPerLabel) {<a name="line.2709"></a>
<FONT color="green">2710</FONT>          chartDecorationsChanged = true;<a name="line.2710"></a>
<FONT color="green">2711</FONT>          if (ticksPerLabel &lt;= 0)<a name="line.2711"></a>
<FONT color="green">2712</FONT>            throw new IllegalArgumentException("ticksPerLabel="<a name="line.2712"></a>
<FONT color="green">2713</FONT>                + ticksPerLabel + "; ticksPerLabel must be &gt; 0");<a name="line.2713"></a>
<FONT color="green">2714</FONT>          this.ticksPerLabel = ticksPerLabel;<a name="line.2714"></a>
<FONT color="green">2715</FONT>        }<a name="line.2715"></a>
<FONT color="green">2716</FONT>    <a name="line.2716"></a>
<FONT color="green">2717</FONT>        /**<a name="line.2717"></a>
<FONT color="green">2718</FONT>         * Sets this axis' tick length. Set the tick length to zero to eliminate the<a name="line.2718"></a>
<FONT color="green">2719</FONT>         * tick entirely.<a name="line.2719"></a>
<FONT color="green">2720</FONT>         * &lt;p&gt;<a name="line.2720"></a>
<FONT color="green">2721</FONT>         * <a name="line.2721"></a>
<FONT color="green">2722</FONT>         * @param tickLength<a name="line.2722"></a>
<FONT color="green">2723</FONT>         *          the length of the tick.<a name="line.2723"></a>
<FONT color="green">2724</FONT>         * <a name="line.2724"></a>
<FONT color="green">2725</FONT>         * @see #getTickLength getTickLength<a name="line.2725"></a>
<FONT color="green">2726</FONT>         * @see #setTickThickness setTickThickness<a name="line.2726"></a>
<FONT color="green">2727</FONT>         * @see #setTickLabelPadding setTickLabelPadding<a name="line.2727"></a>
<FONT color="green">2728</FONT>         * @see #setTickLocation setTickLocation<a name="line.2728"></a>
<FONT color="green">2729</FONT>         * <a name="line.2729"></a>
<FONT color="green">2730</FONT>         */<a name="line.2730"></a>
<FONT color="green">2731</FONT>        abstract public void setTickLength(int tickLength);<a name="line.2731"></a>
<FONT color="green">2732</FONT>    <a name="line.2732"></a>
<FONT color="green">2733</FONT>        /**<a name="line.2733"></a>
<FONT color="green">2734</FONT>         * Specifies the location of the tick marks relative to this axis, namely,<a name="line.2734"></a>
<FONT color="green">2735</FONT>         * if tick marks are outside, inside, or centered on this axis.<a name="line.2735"></a>
<FONT color="green">2736</FONT>         * &lt;p&gt;<a name="line.2736"></a>
<FONT color="green">2737</FONT>         * <a name="line.2737"></a>
<FONT color="green">2738</FONT>         * @see #getTickLocation getTickLocation<a name="line.2738"></a>
<FONT color="green">2739</FONT>         * @see #setTickThickness setTickThickness<a name="line.2739"></a>
<FONT color="green">2740</FONT>         * @see #setTickLength setTickLength<a name="line.2740"></a>
<FONT color="green">2741</FONT>         * @see #setTickLabelPadding setTickLabelPadding<a name="line.2741"></a>
<FONT color="green">2742</FONT>         * <a name="line.2742"></a>
<FONT color="green">2743</FONT>         * @param tickLocation<a name="line.2743"></a>
<FONT color="green">2744</FONT>         *          Specify either &lt;tt&gt;TickLocation.INSIDE&lt;/tt&gt;,<a name="line.2744"></a>
<FONT color="green">2745</FONT>         *          &lt;tt&gt;TickLocation.OUTSIDE&lt;/tt&gt;, or &lt;tt&gt;TickLocation.CENTERED&lt;/tt&gt;<a name="line.2745"></a>
<FONT color="green">2746</FONT>         * <a name="line.2746"></a>
<FONT color="green">2747</FONT>         */<a name="line.2747"></a>
<FONT color="green">2748</FONT>        public void setTickLocation(TickLocation tickLocation) {<a name="line.2748"></a>
<FONT color="green">2749</FONT>          this.tickLocation = tickLocation;<a name="line.2749"></a>
<FONT color="green">2750</FONT>          chartDecorationsChanged = true;<a name="line.2750"></a>
<FONT color="green">2751</FONT>          GChart.Symbol sym = getSystemCurve(ticksId).getSymbol();<a name="line.2751"></a>
<FONT color="green">2752</FONT>          if (isHorizontalAxis) {<a name="line.2752"></a>
<FONT color="green">2753</FONT>            sym.setSymbolType(<a name="line.2753"></a>
<FONT color="green">2754</FONT>               tickLocation.getXAxisSymbolType(axisPosition));<a name="line.2754"></a>
<FONT color="green">2755</FONT>            sym.setHeight(getActualTickLength());<a name="line.2755"></a>
<FONT color="green">2756</FONT>          } else {<a name="line.2756"></a>
<FONT color="green">2757</FONT>            sym.setSymbolType(<a name="line.2757"></a>
<FONT color="green">2758</FONT>               tickLocation.getYAxisSymbolType(axisPosition));<a name="line.2758"></a>
<FONT color="green">2759</FONT>            sym.setWidth(getActualTickLength());<a name="line.2759"></a>
<FONT color="green">2760</FONT>          }<a name="line.2760"></a>
<FONT color="green">2761</FONT>        }<a name="line.2761"></a>
<FONT color="green">2762</FONT>    <a name="line.2762"></a>
<FONT color="green">2763</FONT>        /**<a name="line.2763"></a>
<FONT color="green">2764</FONT>         * Sets this axis' tick thickness.<a name="line.2764"></a>
<FONT color="green">2765</FONT>         * &lt;p&gt;<a name="line.2765"></a>
<FONT color="green">2766</FONT>         * <a name="line.2766"></a>
<FONT color="green">2767</FONT>         * @param tickThickness<a name="line.2767"></a>
<FONT color="green">2768</FONT>         *          the thickness of the tick.<a name="line.2768"></a>
<FONT color="green">2769</FONT>         * <a name="line.2769"></a>
<FONT color="green">2770</FONT>         * @see #getTickThickness getTickThickness<a name="line.2770"></a>
<FONT color="green">2771</FONT>         * @see #setTickLength setTickLength<a name="line.2771"></a>
<FONT color="green">2772</FONT>         * @see #setTickLabelPadding setTickLabelPadding<a name="line.2772"></a>
<FONT color="green">2773</FONT>         * @see #setTickLocation setTickLocation<a name="line.2773"></a>
<FONT color="green">2774</FONT>         * <a name="line.2774"></a>
<FONT color="green">2775</FONT>         */<a name="line.2775"></a>
<FONT color="green">2776</FONT>        abstract public void setTickThickness(int tickThickness);<a name="line.2776"></a>
<FONT color="green">2777</FONT>    <a name="line.2777"></a>
<FONT color="green">2778</FONT>        void maybePopulateTicks() {<a name="line.2778"></a>
<FONT color="green">2779</FONT>          if (tickCount != GChart.NAI)<a name="line.2779"></a>
<FONT color="green">2780</FONT>            populateTicks();<a name="line.2780"></a>
<FONT color="green">2781</FONT>        }<a name="line.2781"></a>
<FONT color="green">2782</FONT>    <a name="line.2782"></a>
<FONT color="green">2783</FONT>        // fills in the tick positions when auto-generated.<a name="line.2783"></a>
<FONT color="green">2784</FONT>        private void populateTicks() {<a name="line.2784"></a>
<FONT color="green">2785</FONT>          getSystemCurve(ticksId).clearPoints();<a name="line.2785"></a>
<FONT color="green">2786</FONT>          /*<a name="line.2786"></a>
<FONT color="green">2787</FONT>           * TODO: It should be possible to control the visibility of each<a name="line.2787"></a>
<FONT color="green">2788</FONT>           * axis, including ticks and tick labels, independent of the<a name="line.2788"></a>
<FONT color="green">2789</FONT>           * specifications of the tick marks on that axis, and independent<a name="line.2789"></a>
<FONT color="green">2790</FONT>           * of if any curves are mapped to that axis or not. A<a name="line.2790"></a>
<FONT color="green">2791</FONT>           * setVisible(Boolean isVisible) as a three-way, with null being<a name="line.2791"></a>
<FONT color="green">2792</FONT>           * the current, dependent, defaults, and TRUE, FALSE explicitly<a name="line.2792"></a>
<FONT color="green">2793</FONT>           * making the entire axis, including tick marks and labels visible<a name="line.2793"></a>
<FONT color="green">2794</FONT>           * or not without having to zero the tick count, add dummy curve<a name="line.2794"></a>
<FONT color="green">2795</FONT>           * to the axis, etc. to control axis visibility is needed.<a name="line.2795"></a>
<FONT color="green">2796</FONT>           * <a name="line.2796"></a>
<FONT color="green">2797</FONT>           */ <a name="line.2797"></a>
<FONT color="green">2798</FONT>          if (XTICKS_ID == ticksId || // x, y ticks are drawn even<a name="line.2798"></a>
<FONT color="green">2799</FONT>              YTICKS_ID == ticksId || // if no curves are on these axes<a name="line.2799"></a>
<FONT color="green">2800</FONT>              0 &lt; getNCurvesVisibleOnAxis()) {<a name="line.2800"></a>
<FONT color="green">2801</FONT>            AxisLimits lim = getAxisLimits();<a name="line.2801"></a>
<FONT color="green">2802</FONT>            if (1 == tickCount)<a name="line.2802"></a>
<FONT color="green">2803</FONT>              addTickAsPoint(lim.max, formatAsTickLabel(lim.max),<a name="line.2803"></a>
<FONT color="green">2804</FONT>                             null, GChart.NAI, GChart.NAI);<a name="line.2804"></a>
<FONT color="green">2805</FONT>            else {<a name="line.2805"></a>
<FONT color="green">2806</FONT>              int tcm1 = tickCount - 1;<a name="line.2806"></a>
<FONT color="green">2807</FONT>              for (int i = 0; i &lt; tickCount; i++) {<a name="line.2807"></a>
<FONT color="green">2808</FONT>                // linear interpolation between min and max<a name="line.2808"></a>
<FONT color="green">2809</FONT>                double xOrY = (lim.min * (tcm1 - i) + i * lim.max) / tcm1;<a name="line.2809"></a>
<FONT color="green">2810</FONT>                if (0 == i % ticksPerLabel)<a name="line.2810"></a>
<FONT color="green">2811</FONT>                  addTickAsPoint(xOrY, formatAsTickLabel(xOrY),<a name="line.2811"></a>
<FONT color="green">2812</FONT>                                 null, GChart.NAI, GChart.NAI);<a name="line.2812"></a>
<FONT color="green">2813</FONT>                else<a name="line.2813"></a>
<FONT color="green">2814</FONT>                  addTickAsPoint(xOrY, null,<a name="line.2814"></a>
<FONT color="green">2815</FONT>                                 null, GChart.NAI, GChart.NAI);<a name="line.2815"></a>
<FONT color="green">2816</FONT>              }<a name="line.2816"></a>
<FONT color="green">2817</FONT>            }<a name="line.2817"></a>
<FONT color="green">2818</FONT>          }<a name="line.2818"></a>
<FONT color="green">2819</FONT>        }<a name="line.2819"></a>
<FONT color="green">2820</FONT>    <a name="line.2820"></a>
<FONT color="green">2821</FONT>        // fills in the gridlines; ticks are assumed already populated<a name="line.2821"></a>
<FONT color="green">2822</FONT>        void populateGridlines() {<a name="line.2822"></a>
<FONT color="green">2823</FONT>          Curve cTicks = getSystemCurve(ticksId);<a name="line.2823"></a>
<FONT color="green">2824</FONT>          Curve cGridlines = getSystemCurve(gridlinesId);<a name="line.2824"></a>
<FONT color="green">2825</FONT>          cGridlines.clearPoints();<a name="line.2825"></a>
<FONT color="green">2826</FONT>          int nTicks = cTicks.getNPoints();<a name="line.2826"></a>
<FONT color="green">2827</FONT>          for (int iTick = 0; iTick &lt; nTicks; iTick++) {<a name="line.2827"></a>
<FONT color="green">2828</FONT>            if (hasGridlines &amp;&amp; (iTick % ticksPerGridline) == 0) {<a name="line.2828"></a>
<FONT color="green">2829</FONT>              Curve.Point p = cTicks.getPoint(iTick);<a name="line.2829"></a>
<FONT color="green">2830</FONT>              cGridlines.addPoint(p.getX(), p.getY());<a name="line.2830"></a>
<FONT color="green">2831</FONT>            }<a name="line.2831"></a>
<FONT color="green">2832</FONT>          }<a name="line.2832"></a>
<FONT color="green">2833</FONT>        }<a name="line.2833"></a>
<FONT color="green">2834</FONT>    <a name="line.2834"></a>
<FONT color="green">2835</FONT>        protected void getAxisLimits(AxisLimits result) {<a name="line.2835"></a>
<FONT color="green">2836</FONT>          // so we get 1-unit changes between adjacent ticks<a name="line.2836"></a>
<FONT color="green">2837</FONT>          final int DEFAULT_AXIS_RANGE = DEFAULT_TICK_COUNT - 1;<a name="line.2837"></a>
<FONT color="green">2838</FONT>          double min = getAxisMin();<a name="line.2838"></a>
<FONT color="green">2839</FONT>          double max = getAxisMax();<a name="line.2839"></a>
<FONT color="green">2840</FONT>          /*<a name="line.2840"></a>
<FONT color="green">2841</FONT>           * Adjust min/max so that special cases, like one-point<a name="line.2841"></a>
<FONT color="green">2842</FONT>           * charts, do not have axes that shrink down to a point,<a name="line.2842"></a>
<FONT color="green">2843</FONT>           * which would create numerical and visual difficulties.<a name="line.2843"></a>
<FONT color="green">2844</FONT>           * <a name="line.2844"></a>
<FONT color="green">2845</FONT>           */ <a name="line.2845"></a>
<FONT color="green">2846</FONT>          if ((min != min) &amp;&amp; (max != max)) { // x!=x is a faster isNaN<a name="line.2846"></a>
<FONT color="green">2847</FONT>            // e.g. no data and no explicitly specified ticks<a name="line.2847"></a>
<FONT color="green">2848</FONT>            min = 0;<a name="line.2848"></a>
<FONT color="green">2849</FONT>            max = min + DEFAULT_AXIS_RANGE;<a name="line.2849"></a>
<FONT color="green">2850</FONT>          } else if ((min != min) &amp;&amp; !(max != max)) { <a name="line.2850"></a>
<FONT color="green">2851</FONT>            // e.g. no data but only max explicitly set<a name="line.2851"></a>
<FONT color="green">2852</FONT>            min = max - DEFAULT_AXIS_RANGE;<a name="line.2852"></a>
<FONT color="green">2853</FONT>          } else if (!(min != min) &amp;&amp; (max != max)) { <a name="line.2853"></a>
<FONT color="green">2854</FONT>            // e.g. no data but only min explicitly set<a name="line.2854"></a>
<FONT color="green">2855</FONT>            max = min + DEFAULT_AXIS_RANGE;<a name="line.2855"></a>
<FONT color="green">2856</FONT>          } else if (min == max) {<a name="line.2856"></a>
<FONT color="green">2857</FONT>            // e.g one data point only, or they set min=max<a name="line.2857"></a>
<FONT color="green">2858</FONT>            max = min + DEFAULT_AXIS_RANGE;<a name="line.2858"></a>
<FONT color="green">2859</FONT>          }<a name="line.2859"></a>
<FONT color="green">2860</FONT>          result.min = min;<a name="line.2860"></a>
<FONT color="green">2861</FONT>          result.max = max;<a name="line.2861"></a>
<FONT color="green">2862</FONT>        }<a name="line.2862"></a>
<FONT color="green">2863</FONT>    <a name="line.2863"></a>
<FONT color="green">2864</FONT>        AxisLimits getAxisLimits() {<a name="line.2864"></a>
<FONT color="green">2865</FONT>          getAxisLimits(currentLimits);<a name="line.2865"></a>
<FONT color="green">2866</FONT>          return currentLimits;<a name="line.2866"></a>
<FONT color="green">2867</FONT>        }<a name="line.2867"></a>
<FONT color="green">2868</FONT>    <a name="line.2868"></a>
<FONT color="green">2869</FONT>        void rememberLimits() {<a name="line.2869"></a>
<FONT color="green">2870</FONT>          getAxisLimits(previousLimits);<a name="line.2870"></a>
<FONT color="green">2871</FONT>        }<a name="line.2871"></a>
<FONT color="green">2872</FONT>    <a name="line.2872"></a>
<FONT color="green">2873</FONT>        boolean limitsChanged() {<a name="line.2873"></a>
<FONT color="green">2874</FONT>          boolean result = !getAxisLimits().equals(previousLimits);<a name="line.2874"></a>
<FONT color="green">2875</FONT>          return result;<a name="line.2875"></a>
<FONT color="green">2876</FONT>        }<a name="line.2876"></a>
<FONT color="green">2877</FONT>    <a name="line.2877"></a>
<FONT color="green">2878</FONT>        /* similar to getTickText, except for the tick position */<a name="line.2878"></a>
<FONT color="green">2879</FONT>        private double getTickPosition(Curve c, int iTick) {<a name="line.2879"></a>
<FONT color="green">2880</FONT>          double result;<a name="line.2880"></a>
<FONT color="green">2881</FONT>          if (isHorizontalAxis)<a name="line.2881"></a>
<FONT color="green">2882</FONT>            result = c.getPoint(iTick).getX();<a name="line.2882"></a>
<FONT color="green">2883</FONT>          else<a name="line.2883"></a>
<FONT color="green">2884</FONT>            result = c.getPoint(iTick).getY();<a name="line.2884"></a>
<FONT color="green">2885</FONT>          return result;<a name="line.2885"></a>
<FONT color="green">2886</FONT>        }<a name="line.2886"></a>
<FONT color="green">2887</FONT>    <a name="line.2887"></a>
<FONT color="green">2888</FONT>        // returns the largest, explicitly specified, tick position<a name="line.2888"></a>
<FONT color="green">2889</FONT>        private double getTickMax() {<a name="line.2889"></a>
<FONT color="green">2890</FONT>          double result = -Double.MAX_VALUE;<a name="line.2890"></a>
<FONT color="green">2891</FONT>          Curve c = getSystemCurve(ticksId);<a name="line.2891"></a>
<FONT color="green">2892</FONT>          int nTicks = c.getNPoints();<a name="line.2892"></a>
<FONT color="green">2893</FONT>          for (int i = 0; i &lt; nTicks; i++)<a name="line.2893"></a>
<FONT color="green">2894</FONT>            result = Math.max(result, getTickPosition(c, i));<a name="line.2894"></a>
<FONT color="green">2895</FONT>          return result;<a name="line.2895"></a>
<FONT color="green">2896</FONT>        }<a name="line.2896"></a>
<FONT color="green">2897</FONT>    <a name="line.2897"></a>
<FONT color="green">2898</FONT>        // returns the smallest, explicitly specified, tick position<a name="line.2898"></a>
<FONT color="green">2899</FONT>        private double getTickMin() {<a name="line.2899"></a>
<FONT color="green">2900</FONT>          double result = Double.MAX_VALUE;<a name="line.2900"></a>
<FONT color="green">2901</FONT>          Curve c = getSystemCurve(ticksId);<a name="line.2901"></a>
<FONT color="green">2902</FONT>          int nTicks = c.getNPoints();<a name="line.2902"></a>
<FONT color="green">2903</FONT>          for (int i = 0; i &lt; nTicks; i++)<a name="line.2903"></a>
<FONT color="green">2904</FONT>            result = Math.min(result, getTickPosition(c, i));<a name="line.2904"></a>
<FONT color="green">2905</FONT>          return result;<a name="line.2905"></a>
<FONT color="green">2906</FONT>        }<a name="line.2906"></a>
<FONT color="green">2907</FONT>    <a name="line.2907"></a>
<FONT color="green">2908</FONT>        // Same as max, except treats NaN/MAX_VALUE values as "not there"<a name="line.2908"></a>
<FONT color="green">2909</FONT>        protected double maxIgnoreNaNAndMaxValue(double x1, double x2) {<a name="line.2909"></a>
<FONT color="green">2910</FONT>          double result;<a name="line.2910"></a>
<FONT color="green">2911</FONT>          // x!=x is a faster isNaN<a name="line.2911"></a>
<FONT color="green">2912</FONT>          if ((x1 != x1) || Double.MAX_VALUE == x1 || -Double.MAX_VALUE == x1)<a name="line.2912"></a>
<FONT color="green">2913</FONT>            result = x2;<a name="line.2913"></a>
<FONT color="green">2914</FONT>          else if ((x2 != x2) || Double.MAX_VALUE == x2<a name="line.2914"></a>
<FONT color="green">2915</FONT>              || -Double.MAX_VALUE == x2)<a name="line.2915"></a>
<FONT color="green">2916</FONT>            result = x1;<a name="line.2916"></a>
<FONT color="green">2917</FONT>          else<a name="line.2917"></a>
<FONT color="green">2918</FONT>            result = Math.max(x1, x2);<a name="line.2918"></a>
<FONT color="green">2919</FONT>          return result;<a name="line.2919"></a>
<FONT color="green">2920</FONT>        }<a name="line.2920"></a>
<FONT color="green">2921</FONT>    <a name="line.2921"></a>
<FONT color="green">2922</FONT>        // Same as Math.min, except treats NaN/MAX_VALUE values as "not there"<a name="line.2922"></a>
<FONT color="green">2923</FONT>        protected double minIgnoreNaNAndMaxValue(double x1, double x2) {<a name="line.2923"></a>
<FONT color="green">2924</FONT>          double result;<a name="line.2924"></a>
<FONT color="green">2925</FONT>          // x!=x is a faster isNaN<a name="line.2925"></a>
<FONT color="green">2926</FONT>          if ((x1 != x1) || Double.MAX_VALUE == x1 || -Double.MAX_VALUE == x1)<a name="line.2926"></a>
<FONT color="green">2927</FONT>            result = x2;<a name="line.2927"></a>
<FONT color="green">2928</FONT>          else if ((x2 != x2) || Double.MAX_VALUE == x2<a name="line.2928"></a>
<FONT color="green">2929</FONT>              || -Double.MAX_VALUE == x2)<a name="line.2929"></a>
<FONT color="green">2930</FONT>            result = x1;<a name="line.2930"></a>
<FONT color="green">2931</FONT>          else<a name="line.2931"></a>
<FONT color="green">2932</FONT>            result = Math.min(x1, x2);<a name="line.2932"></a>
<FONT color="green">2933</FONT>          return result;<a name="line.2933"></a>
<FONT color="green">2934</FONT>        }<a name="line.2934"></a>
<FONT color="green">2935</FONT>    <a name="line.2935"></a>
<FONT color="green">2936</FONT>      } // end of class Axis<a name="line.2936"></a>
<FONT color="green">2937</FONT>    <a name="line.2937"></a>
<FONT color="green">2938</FONT>      // creates canvas Widgets GChart needs for its canvas-rendering option.<a name="line.2938"></a>
<FONT color="green">2939</FONT>      private static GChartCanvasFactory canvasFactory = null;<a name="line.2939"></a>
<FONT color="green">2940</FONT>    <a name="line.2940"></a>
<FONT color="green">2941</FONT>      /**<a name="line.2941"></a>
<FONT color="green">2942</FONT>       * <a name="line.2942"></a>
<FONT color="green">2943</FONT>       * Tells GChart how to create the canvas widgets it needs (specifically,<a name="line.2943"></a>
<FONT color="green">2944</FONT>       * widgets that implement GChart's &lt;tt&gt;GChartCanvasLite&lt;/tt&gt; interface) to<a name="line.2944"></a>
<FONT color="green">2945</FONT>       * render your charts using an external vector graphics library.<a name="line.2945"></a>
<FONT color="green">2946</FONT>       * &lt;p&gt;<a name="line.2946"></a>
<FONT color="green">2947</FONT>       * <a name="line.2947"></a>
<FONT color="green">2948</FONT>       * You must define a class that implements &lt;tt&gt;GChartCanvasFactory&lt;/tt&gt; and<a name="line.2948"></a>
<FONT color="green">2949</FONT>       * then pass an instance of that class to this method, if you want to have the<a name="line.2949"></a>
<FONT color="green">2950</FONT>       * fast, crisply drawn connecting lines, polygonal areas, and 2-D pie slices<a name="line.2950"></a>
<FONT color="green">2951</FONT>       * that only a vector graphics library can provide.<a name="line.2951"></a>
<FONT color="green">2952</FONT>       * &lt;p&gt;<a name="line.2952"></a>
<FONT color="green">2953</FONT>       * <a name="line.2953"></a>
<FONT color="green">2954</FONT>       * &lt;small&gt; &lt;i&gt;Note:&lt;/i&gt; If all of your charts only have rectangular elements<a name="line.2954"></a>
<FONT color="green">2955</FONT>       * (e.g. bar charts) GChart will continue to render those charts using HTML<a name="line.2955"></a>
<FONT color="green">2956</FONT>       * elements, even if a canvas factory is provided. Thus, there is no point to<a name="line.2956"></a>
<FONT color="green">2957</FONT>       * defining a canvas factory if all you use GChart for is bar charts, scatter<a name="line.2957"></a>
<FONT color="green">2958</FONT>       * plots without connecting lines between each point, banded-fill pie slices,<a name="line.2958"></a>
<FONT color="green">2959</FONT>       * and so on.<a name="line.2959"></a>
<FONT color="green">2960</FONT>       * &lt;p&gt;<a name="line.2960"></a>
<FONT color="green">2961</FONT>       * <a name="line.2961"></a>
<FONT color="green">2962</FONT>       * On the other hand, if you need continously connected lines, solid-fill pie<a name="line.2962"></a>
<FONT color="green">2963</FONT>       * slices, or solid-fill area charts (all of which will also need a<a name="line.2963"></a>
<FONT color="green">2964</FONT>       * &lt;tt&gt;setFillSpacing(0)&lt;/tt&gt; to specify continuous filling) you will gain<a name="line.2964"></a>
<FONT color="green">2965</FONT>       * substantial performance/quality improvements if you add a canvas factory.<a name="line.2965"></a>
<FONT color="green">2966</FONT>       * &lt;p&gt;<a name="line.2966"></a>
<FONT color="green">2967</FONT>       * &lt;/small&gt;<a name="line.2967"></a>
<FONT color="green">2968</FONT>       * <a name="line.2968"></a>
<FONT color="green">2969</FONT>       * In detail, to exploit browser-based vector graphics (Mozilla's canvas, IE's<a name="line.2969"></a>
<FONT color="green">2970</FONT>       * VML, etc.) rendering in your charts, you must:<a name="line.2970"></a>
<FONT color="green">2971</FONT>       * &lt;p&gt;<a name="line.2971"></a>
<FONT color="green">2972</FONT>       * <a name="line.2972"></a>
<FONT color="green">2973</FONT>       * &lt;ol&gt;<a name="line.2973"></a>
<FONT color="green">2974</FONT>       * <a name="line.2974"></a>
<FONT color="green">2975</FONT>       * &lt;li&gt;Import an external GWT canvas library, such as provided by the &lt;a<a name="line.2975"></a>
<FONT color="green">2976</FONT>       * href="http://code.google.com/p/google-web-toolkit-incubator/"&gt; GWT<a name="line.2976"></a>
<FONT color="green">2977</FONT>       * incubator project's&lt;/a&gt; &lt;tt&gt;GWTCanvas&lt;/tt&gt; class, into your project. For<a name="line.2977"></a>
<FONT color="green">2978</FONT>       * example, our GChart test application uses &lt;tt&gt;GWTCanvas&lt;/tt&gt; and imports it<a name="line.2978"></a>
<FONT color="green">2979</FONT>       * by adding this line to its &lt;tt&gt;.gwt.xml&lt;/tt&gt; file:<a name="line.2979"></a>
<FONT color="green">2980</FONT>       * &lt;p&gt;<a name="line.2980"></a>
<FONT color="green">2981</FONT>       * <a name="line.2981"></a>
<FONT color="green">2982</FONT>       * &lt;pre&gt;<a name="line.2982"></a>
<FONT color="green">2983</FONT>       *   &amp;lt;inherits name='com.google.gwt.widgetideas.GWTCanvas' /&amp;gt;<a name="line.2983"></a>
<FONT color="green">2984</FONT>       * &lt;/pre&gt;<a name="line.2984"></a>
<FONT color="green">2985</FONT>       * <a name="line.2985"></a>
<FONT color="green">2986</FONT>       * To make this work, we also had to add the &lt;a<a name="line.2986"></a>
<FONT color="green">2987</FONT>       * href="http://code.google.com/p/google-web-toolkit-incubator/"&gt;<a name="line.2987"></a>
<FONT color="green">2988</FONT>       * gwt-incubator.jar&lt;/a&gt; file (which contains &lt;tt&gt;GWTCanvas&lt;/tt&gt;) to our build<a name="line.2988"></a>
<FONT color="green">2989</FONT>       * path via Eclipse's "Configure Build Path..." command and to the libraries<a name="line.2989"></a>
<FONT color="green">2990</FONT>       * listed in the &lt;tt&gt;classpath=...&lt;/tt&gt; line of our ant build script's<a name="line.2990"></a>
<FONT color="green">2991</FONT>       * &lt;tt&gt;java&lt;/tt&gt; task.<a name="line.2991"></a>
<FONT color="green">2992</FONT>       * &lt;p&gt;<a name="line.2992"></a>
<FONT color="green">2993</FONT>       * <a name="line.2993"></a>
<FONT color="green">2994</FONT>       * &lt;small&gt;For more on the &lt;tt&gt;GWTCanvas&lt;/tt&gt; widget, see the &lt;a href=<a name="line.2994"></a>
<FONT color="green">2995</FONT>       * "http://code.google.com/p/google-web-toolkit-incubator/wiki/GWTCanvas"&gt;<a name="line.2995"></a>
<FONT color="green">2996</FONT>       * GWTCanvas Wiki page&lt;/a&gt; within the GWT incubator site.&lt;/small&gt;<a name="line.2996"></a>
<FONT color="green">2997</FONT>       * &lt;p&gt;<a name="line.2997"></a>
<FONT color="green">2998</FONT>       * <a name="line.2998"></a>
<FONT color="green">2999</FONT>       * &lt;li&gt;Implement a class that extends &lt;tt&gt;Widget&lt;/tt&gt; and implements the<a name="line.2999"></a>
<FONT color="green">3000</FONT>       * &lt;tt&gt;GChartCanvasLite&lt;/tt&gt; interface that GChart expects. Again, in GChart's<a name="line.3000"></a>
<FONT color="green">3001</FONT>       * &lt;tt&gt;GWTCanvas&lt;/tt&gt;-based test application we use:<a name="line.3001"></a>
<FONT color="green">3002</FONT>       * &lt;p&gt;<a name="line.3002"></a>
<FONT color="green">3003</FONT>       * <a name="line.3003"></a>
<FONT color="green">3004</FONT>       * {@code.sample ../../../../../../gcharttestapp/src/com/googlecode/gchart/gcharttestapp/client/GWTCanvasBasedCanvasLite.java}<a name="line.3004"></a>
<FONT color="green">3005</FONT>       * &lt;p&gt;<a name="line.3005"></a>
<FONT color="green">3006</FONT>       * <a name="line.3006"></a>
<FONT color="green">3007</FONT>       * &lt;li&gt;Create a &lt;tt&gt;GChartCanvasFactory&lt;/tt&gt; class that has a single<a name="line.3007"></a>
<FONT color="green">3008</FONT>       * &lt;tt&gt;create&lt;/tt&gt; method that returns new instances of your<a name="line.3008"></a>
<FONT color="green">3009</FONT>       * &lt;tt&gt;GChartCanvasLite&lt;/tt&gt; Widget. GChart's test application uses:<a name="line.3009"></a>
<FONT color="green">3010</FONT>       * &lt;p&gt;<a name="line.3010"></a>
<FONT color="green">3011</FONT>       * <a name="line.3011"></a>
<FONT color="green">3012</FONT>       * {@code.sample<a name="line.3012"></a>
<FONT color="green">3013</FONT>       * ../../../../../../gcharttestapp/src/com/googlecode/gchart/gcharttestapp/client/GWTCanvasBasedCanvasFactory.java}<a name="line.3013"></a>
<FONT color="green">3014</FONT>       * &lt;p&gt;<a name="line.3014"></a>
<FONT color="green">3015</FONT>       * <a name="line.3015"></a>
<FONT color="green">3016</FONT>       * &lt;li&gt;Finally pass an instance of that factory to GChart via a single<a name="line.3016"></a>
<FONT color="green">3017</FONT>       * invocation of &lt;tt&gt;setCanvasFactory&lt;/tt&gt;:<a name="line.3017"></a>
<FONT color="green">3018</FONT>       * <a name="line.3018"></a>
<FONT color="green">3019</FONT>       * &lt;pre&gt;<a name="line.3019"></a>
<FONT color="green">3020</FONT>       * static {<a name="line.3020"></a>
<FONT color="green">3021</FONT>       *   GChart.setCanvasFactory(new GWTCanvasBasedCanvasFactory());<a name="line.3021"></a>
<FONT color="green">3022</FONT>       * }<a name="line.3022"></a>
<FONT color="green">3023</FONT>       * &lt;/pre&gt;<a name="line.3023"></a>
<FONT color="green">3024</FONT>       * &lt;p&gt;<a name="line.3024"></a>
<FONT color="green">3025</FONT>       * <a name="line.3025"></a>
<FONT color="green">3026</FONT>       * &lt;small&gt;Because the above line essentially completes the definition of the<a name="line.3026"></a>
<FONT color="green">3027</FONT>       * GChart class (and thus should only be executed once per application) a good<a name="line.3027"></a>
<FONT color="green">3028</FONT>       * home for it is in a static initializer, as shown above. I recommend placing<a name="line.3028"></a>
<FONT color="green">3029</FONT>       * that initializer within your application's &lt;tt&gt;EntryPoint&lt;/tt&gt;<a name="line.3029"></a>
<FONT color="green">3030</FONT>       * class.&lt;/small&gt;<a name="line.3030"></a>
<FONT color="green">3031</FONT>       * &lt;/ol&gt;<a name="line.3031"></a>
<FONT color="green">3032</FONT>       * &lt;p&gt;<a name="line.3032"></a>
<FONT color="green">3033</FONT>       * <a name="line.3033"></a>
<FONT color="green">3034</FONT>       * &lt;i&gt;Note:&lt;/i&gt; To make things a bit simpler for you, the following code<a name="line.3034"></a>
<FONT color="green">3035</FONT>       * combines steps 2, 3, and 4 into a single chunk of easily pasted<a name="line.3035"></a>
<FONT color="green">3036</FONT>       * boilerplate:<a name="line.3036"></a>
<FONT color="green">3037</FONT>       * &lt;p&gt;<a name="line.3037"></a>
<FONT color="green">3038</FONT>       * <a name="line.3038"></a>
<FONT color="green">3039</FONT>       * &lt;small&gt;&lt;small&gt; {@code.sample<a name="line.3039"></a>
<FONT color="green">3040</FONT>       * ../../../../../../gchartdemoapp/src/com/googlecode/gchart/gchartdemoapp/client/GChartDemoApp.java#1} {@code.sample<a name="line.3040"></a>
<FONT color="green">3041</FONT>       * ../../../../../../gchartdemoapp/src/com/googlecode/gchart/gchartdemoapp/client/GChartDemoApp.java#2} &lt;/small&gt;&lt;/small&gt;<a name="line.3041"></a>
<FONT color="green">3042</FONT>       * &lt;p&gt;<a name="line.3042"></a>
<FONT color="green">3043</FONT>       * <a name="line.3043"></a>
<FONT color="green">3044</FONT>       * To see the above boilerplate within a working example application, follow<a name="line.3044"></a>
<FONT color="green">3045</FONT>       * the link at the bottom of GChart's &lt;a<a name="line.3045"></a>
<FONT color="green">3046</FONT>       * href="http://clientsidegchart.googlecode.com/svn/trunk/live-demo/v2_7/com.googlecode.gchart.gchartdemoapp.GChartDemoApp/GChartDemoApp.html"&gt;<a name="line.3046"></a>
<FONT color="green">3047</FONT>       * live demo page&lt;/a&gt; to examine its &lt;tt&gt;EntryPoint&lt;/tt&gt; class' code.<a name="line.3047"></a>
<FONT color="green">3048</FONT>       * &lt;p&gt;<a name="line.3048"></a>
<FONT color="green">3049</FONT>       * <a name="line.3049"></a>
<FONT color="green">3050</FONT>       * &lt;i&gt;GChart's mixed canvas and HTML rendering&lt;/i&gt;<a name="line.3050"></a>
<FONT color="green">3051</FONT>       * &lt;p&gt;<a name="line.3051"></a>
<FONT color="green">3052</FONT>       * <a name="line.3052"></a>
<FONT color="green">3053</FONT>       * &lt;small&gt;&lt;blockquote&gt;<a name="line.3053"></a>
<FONT color="green">3054</FONT>       * Even with an external canvas factory enabled, many aspects of your chart<a name="line.3054"></a>
<FONT color="green">3055</FONT>       * will remain HTML-rendered. In general, GChart only renders non-rectangular,<a name="line.3055"></a>
<FONT color="green">3056</FONT>       * "continuously filled" aspects of your chart using canvas. Other aspects,<a name="line.3056"></a>
<FONT color="green">3057</FONT>       * such as the bars on a bar chart, or the individual rectangular point<a name="line.3057"></a>
<FONT color="green">3058</FONT>       * markers on a line chart, as well as all chart text, will remain HTML<a name="line.3058"></a>
<FONT color="green">3059</FONT>       * rendered.<a name="line.3059"></a>
<FONT color="green">3060</FONT>       * &lt;p&gt;<a name="line.3060"></a>
<FONT color="green">3061</FONT>       * <a name="line.3061"></a>
<FONT color="green">3062</FONT>       * The rendering mode (HTML-only or HTML+canvas) for each curve is defined by<a name="line.3062"></a>
<FONT color="green">3063</FONT>       * if a canvas factory is available and if that curve uses the special<a name="line.3063"></a>
<FONT color="green">3064</FONT>       * &lt;tt&gt;setFillSpacing(0)&lt;/tt&gt; setting (meaning: "continuously filled"). So, to<a name="line.3064"></a>
<FONT color="green">3065</FONT>       * force any curve to be only HTML rendered, simply set this fill spacing to a<a name="line.3065"></a>
<FONT color="green">3066</FONT>       * value greater than &lt;tt&gt;0&lt;/tt&gt;.<a name="line.3066"></a>
<FONT color="green">3067</FONT>       * &lt;p&gt;<a name="line.3067"></a>
<FONT color="green">3068</FONT>       * <a name="line.3068"></a>
<FONT color="green">3069</FONT>       * HTML rendering offers some features not available with canvas rendering.<a name="line.3069"></a>
<FONT color="green">3070</FONT>       * For example, only HTML-rendered curves can overwrite the enclosing page<a name="line.3070"></a>
<FONT color="green">3071</FONT>       * without monopolizing mouse events within that curve's bounding rectangle,<a name="line.3071"></a>
<FONT color="green">3072</FONT>       * and only HTML-rendered curves can define their "fill" via an image. HTML<a name="line.3072"></a>
<FONT color="green">3073</FONT>       * rendered curves can sometimes even be more memory-efficent, provided the<a name="line.3073"></a>
<FONT color="green">3074</FONT>       * number of pixels greatly exceeds the number of HTML elements. And the HTML<a name="line.3074"></a>
<FONT color="green">3075</FONT>       * only rendering option provides a useful least common denominator/fall-back,<a name="line.3075"></a>
<FONT color="green">3076</FONT>       * supported by even the most obscure browsers.<a name="line.3076"></a>
<FONT color="green">3077</FONT>       * &lt;p&gt;<a name="line.3077"></a>
<FONT color="green">3078</FONT>       * <a name="line.3078"></a>
<FONT color="green">3079</FONT>       * Note that the internal curves that GChart uses to render tick marks,<a name="line.3079"></a>
<FONT color="green">3080</FONT>       * gridlines, etc. are never canvas rendered, because they only involve<a name="line.3080"></a>
<FONT color="green">3081</FONT>       * vertical or horizontal rectangles, which GChart always renders with HTML.<a name="line.3081"></a>
<FONT color="green">3082</FONT>       * &lt;/blockquote&gt;&lt;/small&gt;<a name="line.3082"></a>
<FONT color="green">3083</FONT>       * &lt;p&gt;<a name="line.3083"></a>
<FONT color="green">3084</FONT>       * <a name="line.3084"></a>
<FONT color="green">3085</FONT>       * Finally, if you are content with GChart's built-in HTML-based rendering, or<a name="line.3085"></a>
<FONT color="green">3086</FONT>       * if your charts only use rectangular elements (e.g. bar charts) you don't<a name="line.3086"></a>
<FONT color="green">3087</FONT>       * need to bother with any of the steps listed above. Your charts will then<a name="line.3087"></a>
<FONT color="green">3088</FONT>       * only depend on the standard GWT distribution and the 3,000 or so lines of<a name="line.3088"></a>
<FONT color="green">3089</FONT>       * pure GWT Java that implement GChart.<a name="line.3089"></a>
<FONT color="green">3090</FONT>       * &lt;p&gt;<a name="line.3090"></a>
<FONT color="green">3091</FONT>       * <a name="line.3091"></a>
<FONT color="green">3092</FONT>       * &lt;small&gt; &lt;i&gt;Important&lt;/i&gt;: GChart only uses your external canvas facility to<a name="line.3092"></a>
<FONT color="green">3093</FONT>       * draw a chart's non-rectangular aspects. Given how GChart works, a curve can<a name="line.3093"></a>
<FONT color="green">3094</FONT>       * only have non-rectangular aspects if &lt;tt&gt;setFillSpacing&lt;/tt&gt; has been set<a name="line.3094"></a>
<FONT color="green">3095</FONT>       * to &lt;tt&gt;0&lt;/tt&gt; (which implies "continuous filling"), and<a name="line.3095"></a>
<FONT color="green">3096</FONT>       * &lt;tt&gt;setFillThickness&lt;/tt&gt; has been set to a value &lt;tt&gt;&amp;gt;<a name="line.3096"></a>
<FONT color="green">3097</FONT>       * 0&lt;/tt&gt;. If you are not seeing crisp, canvas-rendered area, line, or pie<a name="line.3097"></a>
<FONT color="green">3098</FONT>       * charts, be sure to check these two settings on the curves in question.<a name="line.3098"></a>
<FONT color="green">3099</FONT>       * &lt;/small&gt;<a name="line.3099"></a>
<FONT color="green">3100</FONT>       * <a name="line.3100"></a>
<FONT color="green">3101</FONT>       * @see GChartCanvasFactory GChartCanvasFactory<a name="line.3101"></a>
<FONT color="green">3102</FONT>       * @see GChartCanvasLite GChartCanvasLite<a name="line.3102"></a>
<FONT color="green">3103</FONT>       * @see #getCanvasFactory getCanvasFactory<a name="line.3103"></a>
<FONT color="green">3104</FONT>       * @see GChart.Symbol#setFillSpacing setFillSpacing<a name="line.3104"></a>
<FONT color="green">3105</FONT>       * @see GChart.Symbol#setFillThickness setFillThickness<a name="line.3105"></a>
<FONT color="green">3106</FONT>       * <a name="line.3106"></a>
<FONT color="green">3107</FONT>       */<a name="line.3107"></a>
<FONT color="green">3108</FONT>      public static void setCanvasFactory(GChartCanvasFactory factory) {<a name="line.3108"></a>
<FONT color="green">3109</FONT>        canvasFactory = factory;<a name="line.3109"></a>
<FONT color="green">3110</FONT>      }<a name="line.3110"></a>
<FONT color="green">3111</FONT>    <a name="line.3111"></a>
<FONT color="green">3112</FONT>      /**<a name="line.3112"></a>
<FONT color="green">3113</FONT>       * Returns the GChart class' canvas factory, or &lt;tt&gt;null&lt;/tt&gt; if no canvas<a name="line.3113"></a>
<FONT color="green">3114</FONT>       * factory has been specified.<a name="line.3114"></a>
<FONT color="green">3115</FONT>       * <a name="line.3115"></a>
<FONT color="green">3116</FONT>       * @return the previously specified canvas factory<a name="line.3116"></a>
<FONT color="green">3117</FONT>       * <a name="line.3117"></a>
<FONT color="green">3118</FONT>       * @see #setCanvasFactory setCanvasFactory<a name="line.3118"></a>
<FONT color="green">3119</FONT>       * <a name="line.3119"></a>
<FONT color="green">3120</FONT>       */<a name="line.3120"></a>
<FONT color="green">3121</FONT>      public static GChartCanvasFactory getCanvasFactory() {<a name="line.3121"></a>
<FONT color="green">3122</FONT>        return canvasFactory;<a name="line.3122"></a>
<FONT color="green">3123</FONT>      }<a name="line.3123"></a>
<FONT color="green">3124</FONT>    <a name="line.3124"></a>
<FONT color="green">3125</FONT>      /**<a name="line.3125"></a>
<FONT color="green">3126</FONT>       * Represents a curve on a chart, which includes information such as the x,y<a name="line.3126"></a>
<FONT color="green">3127</FONT>       * coordinates of each point, the symbol used to represent points on the<a name="line.3127"></a>
<FONT color="green">3128</FONT>       * curve, etc.<a name="line.3128"></a>
<FONT color="green">3129</FONT>       * &lt;p&gt;<a name="line.3129"></a>
<FONT color="green">3130</FONT>       * To create a new curve, use the &lt;tt&gt;GChart.addCurve&lt;/tt&gt; method.<a name="line.3130"></a>
<FONT color="green">3131</FONT>       * <a name="line.3131"></a>
<FONT color="green">3132</FONT>       * @see GChart#addCurve() addCurve()<a name="line.3132"></a>
<FONT color="green">3133</FONT>       * <a name="line.3133"></a>
<FONT color="green">3134</FONT>       */<a name="line.3134"></a>
<FONT color="green">3135</FONT>      public class Curve {<a name="line.3135"></a>
<FONT color="green">3136</FONT>        private boolean isVisible = true;<a name="line.3136"></a>
<FONT color="green">3137</FONT>        // a generic, user-defined, auxiliary curve-related object<a name="line.3137"></a>
<FONT color="green">3138</FONT>        private Object curveData = null;    <a name="line.3138"></a>
<FONT color="green">3139</FONT>        private Boolean clipToPlotArea = null;<a name="line.3139"></a>
<FONT color="green">3140</FONT>        private String legendHTML = null;<a name="line.3140"></a>
<FONT color="green">3141</FONT>        private ArrayList&lt;Point&gt; points = new ArrayList&lt;Point&gt;();<a name="line.3141"></a>
<FONT color="green">3142</FONT>        // symbol defines how every point on this curve is rendered<a name="line.3142"></a>
<FONT color="green">3143</FONT>        private Symbol symbol = new Symbol(this);<a name="line.3143"></a>
<FONT color="green">3144</FONT>        /*<a name="line.3144"></a>
<FONT color="green">3145</FONT>         * Pixel amounts the panels holding this curve's rendering are<a name="line.3145"></a>
<FONT color="green">3146</FONT>         * shifted (to shift rendering panel position without re-rendering).<a name="line.3146"></a>
<FONT color="green">3147</FONT>         *<a name="line.3147"></a>
<FONT color="green">3148</FONT>         */ <a name="line.3148"></a>
<FONT color="green">3149</FONT>        private int xShift = 0;<a name="line.3149"></a>
<FONT color="green">3150</FONT>        private int yShift = 0;<a name="line.3150"></a>
<FONT color="green">3151</FONT>        boolean xOrYShiftChanged = false;<a name="line.3151"></a>
<FONT color="green">3152</FONT>    <a name="line.3152"></a>
<FONT color="green">3153</FONT>        private YAxisId yAxisId = Y_AXIS;<a name="line.3153"></a>
<FONT color="green">3154</FONT>        private boolean isValidated = false;<a name="line.3154"></a>
<FONT color="green">3155</FONT>    <a name="line.3155"></a>
<FONT color="green">3156</FONT>        boolean isValidated() {<a name="line.3156"></a>
<FONT color="green">3157</FONT>          return isValidated;<a name="line.3157"></a>
<FONT color="green">3158</FONT>        }<a name="line.3158"></a>
<FONT color="green">3159</FONT>    <a name="line.3159"></a>
<FONT color="green">3160</FONT>        /*<a name="line.3160"></a>
<FONT color="green">3161</FONT>         * TestGChart14d revealed that curves.indexOf(curve) could, due to its<a name="line.3161"></a>
<FONT color="green">3162</FONT>         * sequential search, create a performance bug if the chart had over 100<a name="line.3162"></a>
<FONT color="green">3163</FONT>         * curves (e.g. the 160 pie chart slices/curves of TestGChart14d) &lt;p&gt;<a name="line.3163"></a>
<FONT color="green">3164</FONT>         * <a name="line.3164"></a>
<FONT color="green">3165</FONT>         * With a little extra bookkeeping during add/remove curve to call these<a name="line.3165"></a>
<FONT color="green">3166</FONT>         * methods (and the extra int) this problem was corrected.<a name="line.3166"></a>
<FONT color="green">3167</FONT>         */<a name="line.3167"></a>
<FONT color="green">3168</FONT>        private int indexOf = GChart.NAI;<a name="line.3168"></a>
<FONT color="green">3169</FONT>    <a name="line.3169"></a>
<FONT color="green">3170</FONT>        void incrementIndex() {<a name="line.3170"></a>
<FONT color="green">3171</FONT>          indexOf++;<a name="line.3171"></a>
<FONT color="green">3172</FONT>        }<a name="line.3172"></a>
<FONT color="green">3173</FONT>    <a name="line.3173"></a>
<FONT color="green">3174</FONT>        void decrementIndex() {<a name="line.3174"></a>
<FONT color="green">3175</FONT>          indexOf--;<a name="line.3175"></a>
<FONT color="green">3176</FONT>        }<a name="line.3176"></a>
<FONT color="green">3177</FONT>    <a name="line.3177"></a>
<FONT color="green">3178</FONT>        void clearIndex() {<a name="line.3178"></a>
<FONT color="green">3179</FONT>          indexOf = GChart.NAI;<a name="line.3179"></a>
<FONT color="green">3180</FONT>        }<a name="line.3180"></a>
<FONT color="green">3181</FONT>    <a name="line.3181"></a>
<FONT color="green">3182</FONT>        int getIndexOf() {<a name="line.3182"></a>
<FONT color="green">3183</FONT>          return indexOf;<a name="line.3183"></a>
<FONT color="green">3184</FONT>        }<a name="line.3184"></a>
<FONT color="green">3185</FONT>    <a name="line.3185"></a>
<FONT color="green">3186</FONT>        /*<a name="line.3186"></a>
<FONT color="green">3187</FONT>         * No public constructor because curves are always contained within, and<a name="line.3187"></a>
<FONT color="green">3188</FONT>         * managed by, their containing GChart via its addCurve, removeCurve, and<a name="line.3188"></a>
<FONT color="green">3189</FONT>         * related methods.<a name="line.3189"></a>
<FONT color="green">3190</FONT>         * <a name="line.3190"></a>
<FONT color="green">3191</FONT>         */<a name="line.3191"></a>
<FONT color="green">3192</FONT>        Curve(int indexOf) {<a name="line.3192"></a>
<FONT color="green">3193</FONT>          super();<a name="line.3193"></a>
<FONT color="green">3194</FONT>          this.indexOf = indexOf;<a name="line.3194"></a>
<FONT color="green">3195</FONT>        }<a name="line.3195"></a>
<FONT color="green">3196</FONT>    <a name="line.3196"></a>
<FONT color="green">3197</FONT>        /**<a name="line.3197"></a>
<FONT color="green">3198</FONT>         * Adds a new point to the curve, at the end of the current list of points,<a name="line.3198"></a>
<FONT color="green">3199</FONT>         * with the specified coordinates in model-units (arbitrary,<a name="line.3199"></a>
<FONT color="green">3200</FONT>         * application-specific, units).<a name="line.3200"></a>
<FONT color="green">3201</FONT>         * &lt;p&gt;<a name="line.3201"></a>
<FONT color="green">3202</FONT>         * <a name="line.3202"></a>
<FONT color="green">3203</FONT>         * GChart gives a special interpretation to the following values:<a name="line.3203"></a>
<FONT color="green">3204</FONT>         * &lt;p&gt;<a name="line.3204"></a>
<FONT color="green">3205</FONT>         * <a name="line.3205"></a>
<FONT color="green">3206</FONT>         * &lt;ol&gt;<a name="line.3206"></a>
<FONT color="green">3207</FONT>         * <a name="line.3207"></a>
<FONT color="green">3208</FONT>         * &lt;li&gt;If &lt;tt&gt;-Double.MAX_VALUE&lt;/tt&gt; is specified for either x or y, the<a name="line.3208"></a>
<FONT color="green">3209</FONT>         * point acts as if it were placed at the leftmost or bottommost x or y<a name="line.3209"></a>
<FONT color="green">3210</FONT>         * position within the plot area.<a name="line.3210"></a>
<FONT color="green">3211</FONT>         * &lt;p&gt;<a name="line.3211"></a>
<FONT color="green">3212</FONT>         * <a name="line.3212"></a>
<FONT color="green">3213</FONT>         * &lt;li&gt;Similarly, if &lt;tt&gt;Double.MAX_VALUE&lt;/tt&gt; is specified for either x or<a name="line.3213"></a>
<FONT color="green">3214</FONT>         * y, the point acts as if it were placed at the rightmost x or topmost y<a name="line.3214"></a>
<FONT color="green">3215</FONT>         * position within the plot area.<a name="line.3215"></a>
<FONT color="green">3216</FONT>         * &lt;p&gt;<a name="line.3216"></a>
<FONT color="green">3217</FONT>         * <a name="line.3217"></a>
<FONT color="green">3218</FONT>         * &lt;li&gt;If &lt;tt&gt;Double.NaN&lt;/tt&gt; is specified for either x or y, the point is<a name="line.3218"></a>
<FONT color="green">3219</FONT>         * created, but it will not be visible in the charting region.<a name="line.3219"></a>
<FONT color="green">3220</FONT>         * &lt;p&gt;<a name="line.3220"></a>
<FONT color="green">3221</FONT>         * <a name="line.3221"></a>
<FONT color="green">3222</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; Connecting lines to/from such &lt;tt&gt;Double.NaN&lt;/tt&gt; points are<a name="line.3222"></a>
<FONT color="green">3223</FONT>         * elided, so you can use such a point to create a break in an otherwise<a name="line.3223"></a>
<FONT color="green">3224</FONT>         * connected curve.<a name="line.3224"></a>
<FONT color="green">3225</FONT>         * &lt;/ol&gt;<a name="line.3225"></a>
<FONT color="green">3226</FONT>         * &lt;p&gt;<a name="line.3226"></a>
<FONT color="green">3227</FONT>         * <a name="line.3227"></a>
<FONT color="green">3228</FONT>         * @param x<a name="line.3228"></a>
<FONT color="green">3229</FONT>         *          the x-coordinate of the new point<a name="line.3229"></a>
<FONT color="green">3230</FONT>         * @param y<a name="line.3230"></a>
<FONT color="green">3231</FONT>         *          the y-coordinate of the new point<a name="line.3231"></a>
<FONT color="green">3232</FONT>         * <a name="line.3232"></a>
<FONT color="green">3233</FONT>         * @see #getPoint getPoint<a name="line.3233"></a>
<FONT color="green">3234</FONT>         * @see #addPoint(int,double,double) addPoint(int,double,double)<a name="line.3234"></a>
<FONT color="green">3235</FONT>         * @see #removePoint removePoint<a name="line.3235"></a>
<FONT color="green">3236</FONT>         * @see #clearPoints clearPoints<a name="line.3236"></a>
<FONT color="green">3237</FONT>         * @see #getNPoints getNPoints<a name="line.3237"></a>
<FONT color="green">3238</FONT>         */<a name="line.3238"></a>
<FONT color="green">3239</FONT>        public void addPoint(double x, double y) {<a name="line.3239"></a>
<FONT color="green">3240</FONT>          invalidate();<a name="line.3240"></a>
<FONT color="green">3241</FONT>          points.add(new Point(x, y));<a name="line.3241"></a>
<FONT color="green">3242</FONT>        }<a name="line.3242"></a>
<FONT color="green">3243</FONT>    <a name="line.3243"></a>
<FONT color="green">3244</FONT>        /**<a name="line.3244"></a>
<FONT color="green">3245</FONT>         * Adds a new point at the specified position in the point sequence,<a name="line.3245"></a>
<FONT color="green">3246</FONT>         * increasing the indexes of existing points at or after the specified<a name="line.3246"></a>
<FONT color="green">3247</FONT>         * position by 1.<a name="line.3247"></a>
<FONT color="green">3248</FONT>         * <a name="line.3248"></a>
<FONT color="green">3249</FONT>         * @param iPoint<a name="line.3249"></a>
<FONT color="green">3250</FONT>         *          the position that the new point will occupy<a name="line.3250"></a>
<FONT color="green">3251</FONT>         * @param x<a name="line.3251"></a>
<FONT color="green">3252</FONT>         *          the x-coordinate of the new point (model units)<a name="line.3252"></a>
<FONT color="green">3253</FONT>         * @param y<a name="line.3253"></a>
<FONT color="green">3254</FONT>         *          the y-coordinate of the new point (model units)<a name="line.3254"></a>
<FONT color="green">3255</FONT>         * <a name="line.3255"></a>
<FONT color="green">3256</FONT>         * @see #getPoint getPoint<a name="line.3256"></a>
<FONT color="green">3257</FONT>         * @see #addPoint(double, double) addPoint(double,double)<a name="line.3257"></a>
<FONT color="green">3258</FONT>         * @see #removePoint removePoint<a name="line.3258"></a>
<FONT color="green">3259</FONT>         * @see #clearPoints clearPoints<a name="line.3259"></a>
<FONT color="green">3260</FONT>         * @see #getNPoints getNPoints<a name="line.3260"></a>
<FONT color="green">3261</FONT>         */<a name="line.3261"></a>
<FONT color="green">3262</FONT>        public void addPoint(int iPoint, double x, double y) {<a name="line.3262"></a>
<FONT color="green">3263</FONT>          invalidate();<a name="line.3263"></a>
<FONT color="green">3264</FONT>          points.add(iPoint, new Point(x, y));<a name="line.3264"></a>
<FONT color="green">3265</FONT>        }<a name="line.3265"></a>
<FONT color="green">3266</FONT>    <a name="line.3266"></a>
<FONT color="green">3267</FONT>        /**<a name="line.3267"></a>
<FONT color="green">3268</FONT>         * Removes every point this curve contains.<a name="line.3268"></a>
<FONT color="green">3269</FONT>         * <a name="line.3269"></a>
<FONT color="green">3270</FONT>         * @see Point Point<a name="line.3270"></a>
<FONT color="green">3271</FONT>         * @see #getPoint getPoint<a name="line.3271"></a>
<FONT color="green">3272</FONT>         * @see #addPoint(double, double) addPoint(double,double)<a name="line.3272"></a>
<FONT color="green">3273</FONT>         * @see #addPoint(int,double,double) addPoint(int,double,double)<a name="line.3273"></a>
<FONT color="green">3274</FONT>         * @see #removePoint removePoint<a name="line.3274"></a>
<FONT color="green">3275</FONT>         * @see #getNPoints getNPoints<a name="line.3275"></a>
<FONT color="green">3276</FONT>         */<a name="line.3276"></a>
<FONT color="green">3277</FONT>        public void clearPoints() {<a name="line.3277"></a>
<FONT color="green">3278</FONT>          if (this == getTouchedCurve())<a name="line.3278"></a>
<FONT color="green">3279</FONT>            plotPanel.touch(null);<a name="line.3279"></a>
<FONT color="green">3280</FONT>          invalidate();<a name="line.3280"></a>
<FONT color="green">3281</FONT>          points.clear();<a name="line.3281"></a>
<FONT color="green">3282</FONT>        }<a name="line.3282"></a>
<FONT color="green">3283</FONT>    <a name="line.3283"></a>
<FONT color="green">3284</FONT>        /*<a name="line.3284"></a>
<FONT color="green">3285</FONT>         * Locates index of vertical or horizontal hit-testing band that the given<a name="line.3285"></a>
<FONT color="green">3286</FONT>         * point appears in. The first and last "pseudo-bands" are devoted to<a name="line.3286"></a>
<FONT color="green">3287</FONT>         * holding all points that fall either to the left of or to the right of (or<a name="line.3287"></a>
<FONT color="green">3288</FONT>         * above or below for horizontal banding) the first or last "normal" band<a name="line.3288"></a>
<FONT color="green">3289</FONT>         * covering the plot area's containing "box". &lt;p&gt;<a name="line.3289"></a>
<FONT color="green">3290</FONT>         * <a name="line.3290"></a>
<FONT color="green">3291</FONT>         * Note that some points just slightly off the right or bottom edge may not<a name="line.3291"></a>
<FONT color="green">3292</FONT>         * end up in a pseudo-band, due to the fact that the chart width (or height)<a name="line.3292"></a>
<FONT color="green">3293</FONT>         * need not be an even multiple of the (fixed) band thickness (the<a name="line.3293"></a>
<FONT color="green">3294</FONT>         * "last band sticking out a bit" effect).<a name="line.3294"></a>
<FONT color="green">3295</FONT>         */<a name="line.3295"></a>
<FONT color="green">3296</FONT>        private int getBand(int iPoint, double bandThickness) {<a name="line.3296"></a>
<FONT color="green">3297</FONT>          int result = GChart.NAI;<a name="line.3297"></a>
<FONT color="green">3298</FONT>          SymbolType symType = getSymbol().getSymbolType();<a name="line.3298"></a>
<FONT color="green">3299</FONT>          double xPx = symType.getCenterX(plotPanel, getSymbol(), iPoint);<a name="line.3299"></a>
<FONT color="green">3300</FONT>          if (xPx != xPx)<a name="line.3300"></a>
<FONT color="green">3301</FONT>            return result; // NaN points not in any band<a name="line.3301"></a>
<FONT color="green">3302</FONT>          double yPx = symType.getCenterY(plotPanel, getSymbol(), iPoint,<a name="line.3302"></a>
<FONT color="green">3303</FONT>              onY2());<a name="line.3303"></a>
<FONT color="green">3304</FONT>          if (yPx != yPx)<a name="line.3304"></a>
<FONT color="green">3305</FONT>            return result; // NaN points not in any band<a name="line.3305"></a>
<FONT color="green">3306</FONT>    <a name="line.3306"></a>
<FONT color="green">3307</FONT>          // now, we've got a point with x,y values in some sort of band<a name="line.3307"></a>
<FONT color="green">3308</FONT>    <a name="line.3308"></a>
<FONT color="green">3309</FONT>          if (getSymbol().isHorizontallyBanded()) {<a name="line.3309"></a>
<FONT color="green">3310</FONT>            if (yPx &lt; 0)<a name="line.3310"></a>
<FONT color="green">3311</FONT>              result = 0; // point above plot-area<a name="line.3311"></a>
<FONT color="green">3312</FONT>            else if (yPx &gt;= (bandList.length - EXTRA_BANDS) * bandThickness)<a name="line.3312"></a>
<FONT color="green">3313</FONT>              result = bandList.length - 1; // point below plot-area<a name="line.3313"></a>
<FONT color="green">3314</FONT>            else<a name="line.3314"></a>
<FONT color="green">3315</FONT>              // inside a normal, chart-covering, band<a name="line.3315"></a>
<FONT color="green">3316</FONT>              result = 1 + (int) Math.floor(yPx / bandThickness);<a name="line.3316"></a>
<FONT color="green">3317</FONT>          } else { // vertically banded<a name="line.3317"></a>
<FONT color="green">3318</FONT>            if (xPx &lt; 0)<a name="line.3318"></a>
<FONT color="green">3319</FONT>              result = 0; // to the left of plot-area<a name="line.3319"></a>
<FONT color="green">3320</FONT>            else if (xPx &gt;= (bandList.length - EXTRA_BANDS) * bandThickness)<a name="line.3320"></a>
<FONT color="green">3321</FONT>              result = bandList.length - 1; // to the right<a name="line.3321"></a>
<FONT color="green">3322</FONT>            else<a name="line.3322"></a>
<FONT color="green">3323</FONT>              // within one of the real bands covering the plot-area<a name="line.3323"></a>
<FONT color="green">3324</FONT>              result = 1 + (int) Math.floor(xPx / bandThickness);<a name="line.3324"></a>
<FONT color="green">3325</FONT>          }<a name="line.3325"></a>
<FONT color="green">3326</FONT>          return result;<a name="line.3326"></a>
<FONT color="green">3327</FONT>        }<a name="line.3327"></a>
<FONT color="green">3328</FONT>    <a name="line.3328"></a>
<FONT color="green">3329</FONT>        // Off-the-plot-area points in either 'too small' or 'too large' bands<a name="line.3329"></a>
<FONT color="green">3330</FONT>        private final int EXTRA_BANDS = 2;    <a name="line.3330"></a>
<FONT color="green">3331</FONT>        /*<a name="line.3331"></a>
<FONT color="green">3332</FONT>         * Number of hit-test bands for this curve, for a given band thickness.<a name="line.3332"></a>
<FONT color="green">3333</FONT>         * <a name="line.3333"></a>
<FONT color="green">3334</FONT>         */<a name="line.3334"></a>
<FONT color="green">3335</FONT>        private int getNBands(double bandThickness) {<a name="line.3335"></a>
<FONT color="green">3336</FONT>          int result = EXTRA_BANDS;<a name="line.3336"></a>
<FONT color="green">3337</FONT>          if (getSymbol().isHorizontallyBanded())<a name="line.3337"></a>
<FONT color="green">3338</FONT>            result += (int) Math.ceil(getYChartSize() / bandThickness);<a name="line.3338"></a>
<FONT color="green">3339</FONT>          else<a name="line.3339"></a>
<FONT color="green">3340</FONT>            result += (int) Math.ceil(getXChartSize() / bandThickness);<a name="line.3340"></a>
<FONT color="green">3341</FONT>          return result;<a name="line.3341"></a>
<FONT color="green">3342</FONT>        }<a name="line.3342"></a>
<FONT color="green">3343</FONT>    <a name="line.3343"></a>
<FONT color="green">3344</FONT>        // index of first point in each band<a name="line.3344"></a>
<FONT color="green">3345</FONT>        private int[] bandList = null; <a name="line.3345"></a>
<FONT color="green">3346</FONT>        private double bandThickness = Double.NaN;<a name="line.3346"></a>
<FONT color="green">3347</FONT>        void clearBandList() {<a name="line.3347"></a>
<FONT color="green">3348</FONT>          bandList = null;<a name="line.3348"></a>
<FONT color="green">3349</FONT>        }<a name="line.3349"></a>
<FONT color="green">3350</FONT>    <a name="line.3350"></a>
<FONT color="green">3351</FONT>        /*<a name="line.3351"></a>
<FONT color="green">3352</FONT>         * Separates points on this curve into bins associated with successive<a name="line.3352"></a>
<FONT color="green">3353</FONT>         * vertical (or horizontal) bands across the plot area. &lt;p&gt;<a name="line.3353"></a>
<FONT color="green">3354</FONT>         * <a name="line.3354"></a>
<FONT color="green">3355</FONT>         * Because busy charts typically distribute points evenly across the<a name="line.3355"></a>
<FONT color="green">3356</FONT>         * plot area, by jumping to the appropriate band's list, we can<a name="line.3356"></a>
<FONT color="green">3357</FONT>         * (usually) greatly accelerate worst case mouse hit testing. And<a name="line.3357"></a>
<FONT color="green">3358</FONT>         * because the bin organizing step only requires a single pass over<a name="line.3358"></a>
<FONT color="green">3359</FONT>         * all the points (and less than a two int memory overhead per<a name="line.3359"></a>
<FONT color="green">3360</FONT>         * point) it should almost always be a "good deal" performance-wise<a name="line.3360"></a>
<FONT color="green">3361</FONT>         * (compared to a simple full point-list scan with every hit<a name="line.3361"></a>
<FONT color="green">3362</FONT>         * test).&lt;p&gt;<a name="line.3362"></a>
<FONT color="green">3363</FONT>         * <a name="line.3363"></a>
<FONT color="green">3364</FONT>         * Points are placed into bins based on the (pixel) position of the<a name="line.3364"></a>
<FONT color="green">3365</FONT>         * x (or, with horizontal bands, y) at the center of the rendered<a name="line.3365"></a>
<FONT color="green">3366</FONT>         * symbol. We choose bin size to guarantee that bins are at least as<a name="line.3366"></a>
<FONT color="green">3367</FONT>         * wide (or high, for horizontally banded hit testing) as the<a name="line.3367"></a>
<FONT color="green">3368</FONT>         * rendered symbols on this curve.  This simplifies hit testing,<a name="line.3368"></a>
<FONT color="green">3369</FONT>         * since bins are big enough to assure that a single symbol<a name="line.3369"></a>
<FONT color="green">3370</FONT>         * straddles at most two adjacent bands. Exploits fact that all<a name="line.3370"></a>
<FONT color="green">3371</FONT>         * symbols on the same curve have the same size (in the<a name="line.3371"></a>
<FONT color="green">3372</FONT>         * banding-relevant dimension), and that curves with many points on<a name="line.3372"></a>
<FONT color="green">3373</FONT>         * them tend to have smaller sized symbols.  &lt;p&gt;<a name="line.3373"></a>
<FONT color="green">3374</FONT>         * <a name="line.3374"></a>
<FONT color="green">3375</FONT>         * Note that, for bin placement purposes, pie slices are considered<a name="line.3375"></a>
<FONT color="green">3376</FONT>         * to have a "center" equal to the center of the pie that contains<a name="line.3376"></a>
<FONT color="green">3377</FONT>         * them, and to have a width and height equal to the diameter of the<a name="line.3377"></a>
<FONT color="green">3378</FONT>         * pie containing the slice (the "worst-case slice").  &lt;p&gt;<a name="line.3378"></a>
<FONT color="green">3379</FONT>         * <a name="line.3379"></a>
<FONT color="green">3380</FONT>         * Also note that a symbol whose center is in the right side of a vertical<a name="line.3380"></a>
<FONT color="green">3381</FONT>         * band may overlap into the following band, and one in the left side may<a name="line.3381"></a>
<FONT color="green">3382</FONT>         * overlap the preceding band. Thus during hit testing, we must check not<a name="line.3382"></a>
<FONT color="green">3383</FONT>         * only the lists of points in the bands "touched" by the<a name="line.3383"></a>
<FONT color="green">3384</FONT>         * mouse-cursor-centered brush, but also 1) the band to the immediate left<a name="line.3384"></a>
<FONT color="green">3385</FONT>         * of the leftmost touched band, whenever a left-side sub-band of that band<a name="line.3385"></a>
<FONT color="green">3386</FONT>         * is touched by the brush and 2) the band to the immediate right of the<a name="line.3386"></a>
<FONT color="green">3387</FONT>         * rightmost touched band, whenever a right-side sub-band of that band is<a name="line.3387"></a>
<FONT color="green">3388</FONT>         * touched. The thickness of these left and right side sub-bands equals half<a name="line.3388"></a>
<FONT color="green">3389</FONT>         * the symbol width. Expanding the brush a half-symbol width on either edge<a name="line.3389"></a>
<FONT color="green">3390</FONT>         * is the easiest way to apply these rules. Exactly analogous statements<a name="line.3390"></a>
<FONT color="green">3391</FONT>         * apply to horizontal bands. &lt;p&gt;<a name="line.3391"></a>
<FONT color="green">3392</FONT>         * <a name="line.3392"></a>
<FONT color="green">3393</FONT>         * A minimum band size is enforced to prevent the number of bands from<a name="line.3393"></a>
<FONT color="green">3394</FONT>         * growing too large with small symbols. Each symbol type defines if<a name="line.3394"></a>
<FONT color="green">3395</FONT>         * vertical or horizontal banding is more appropriate, or if brush shape<a name="line.3395"></a>
<FONT color="green">3396</FONT>         * should determine banding strategy (as of this writing, only horizontal<a name="line.3396"></a>
<FONT color="green">3397</FONT>         * bar symbol types require horizontal hit-test bands). Exploits the fact<a name="line.3397"></a>
<FONT color="green">3398</FONT>         * that all symbols have a fixed size for at least one of their dimensions<a name="line.3398"></a>
<FONT color="green">3399</FONT>         * (for example, vertical bars have variable height but fixed width).&lt;p&gt;<a name="line.3399"></a>
<FONT color="green">3400</FONT>         * <a name="line.3400"></a>
<FONT color="green">3401</FONT>         * Note: this method must be called after the curve is rendered during an<a name="line.3401"></a>
<FONT color="green">3402</FONT>         * update(), to assure that hit-test-bins are consistent with rendered<a name="line.3402"></a>
<FONT color="green">3403</FONT>         * curves, and ready for use before the first mouse hit testing is done. &lt;p&gt;<a name="line.3403"></a>
<FONT color="green">3404</FONT>         * <a name="line.3404"></a>
<FONT color="green">3405</FONT>         * After running this method, points on this curve within a given band can<a name="line.3405"></a>
<FONT color="green">3406</FONT>         * be enumerated as in the following code: &lt;p&gt;<a name="line.3406"></a>
<FONT color="green">3407</FONT>         * <a name="line.3407"></a>
<FONT color="green">3408</FONT>         * &lt;pre&gt;<a name="line.3408"></a>
<FONT color="green">3409</FONT>         * Point p = null;<a name="line.3409"></a>
<FONT color="green">3410</FONT>         * for (int iPoint = bandList[iBand];<a name="line.3410"></a>
<FONT color="green">3411</FONT>         *      iPoint != GChart.NAI; iPoint = p.getINextInBand()) {<a name="line.3411"></a>
<FONT color="green">3412</FONT>         *   p = getPoint(iPoint);<a name="line.3412"></a>
<FONT color="green">3413</FONT>         *   // do something requiring points in a given band...<a name="line.3413"></a>
<FONT color="green">3414</FONT>         * }<a name="line.3414"></a>
<FONT color="green">3415</FONT>         * &lt;/pre&gt;<a name="line.3415"></a>
<FONT color="green">3416</FONT>         * <a name="line.3416"></a>
<FONT color="green">3417</FONT>         */<a name="line.3417"></a>
<FONT color="green">3418</FONT>        void bandSeparatePoints() {<a name="line.3418"></a>
<FONT color="green">3419</FONT>          bandThickness = getSymbol().getSymbolType().getBandThickness(<a name="line.3419"></a>
<FONT color="green">3420</FONT>              plotPanel, getSymbol(), onY2());<a name="line.3420"></a>
<FONT color="green">3421</FONT>          int nBands = getNBands(bandThickness);<a name="line.3421"></a>
<FONT color="green">3422</FONT>    <a name="line.3422"></a>
<FONT color="green">3423</FONT>          if (bandList == null || bandList.length != nBands)<a name="line.3423"></a>
<FONT color="green">3424</FONT>            bandList = new int[nBands];<a name="line.3424"></a>
<FONT color="green">3425</FONT>          // else bandList already has required length, reuse it.<a name="line.3425"></a>
<FONT color="green">3426</FONT>    <a name="line.3426"></a>
<FONT color="green">3427</FONT>          // all bands contain NAI terminated, empty lists to start with<a name="line.3427"></a>
<FONT color="green">3428</FONT>          for (int i = 0; i &lt; bandList.length; i++)<a name="line.3428"></a>
<FONT color="green">3429</FONT>            bandList[i] = GChart.NAI;<a name="line.3429"></a>
<FONT color="green">3430</FONT>    <a name="line.3430"></a>
<FONT color="green">3431</FONT>          for (int iPoint = 0; iPoint &lt; getNPoints(); iPoint++) {<a name="line.3431"></a>
<FONT color="green">3432</FONT>            int iBand = getBand(iPoint, bandThickness);<a name="line.3432"></a>
<FONT color="green">3433</FONT>            Point p = getPoint(iPoint);<a name="line.3433"></a>
<FONT color="green">3434</FONT>            if (GChart.NAI == iBand) {<a name="line.3434"></a>
<FONT color="green">3435</FONT>              /*<a name="line.3435"></a>
<FONT color="green">3436</FONT>               * Point isn't rendered at all, so isn't in a band (a next<a name="line.3436"></a>
<FONT color="green">3437</FONT>               * link pointing to self means "I'm not in any band"). To let<a name="line.3437"></a>
<FONT color="green">3438</FONT>               * us skip over these points quickly during rendering.<a name="line.3438"></a>
<FONT color="green">3439</FONT>               *<a name="line.3439"></a>
<FONT color="green">3440</FONT>               */ <a name="line.3440"></a>
<FONT color="green">3441</FONT>              p.setINextInBand(iPoint);<a name="line.3441"></a>
<FONT color="green">3442</FONT>            } else {<a name="line.3442"></a>
<FONT color="green">3443</FONT>              // Add point to front of list for whatever band it's in<a name="line.3443"></a>
<FONT color="green">3444</FONT>              // (note that point order therefore gets reversed).<a name="line.3444"></a>
<FONT color="green">3445</FONT>              p.setINextInBand(bandList[iBand]);<a name="line.3445"></a>
<FONT color="green">3446</FONT>              bandList[iBand] = iPoint;<a name="line.3446"></a>
<FONT color="green">3447</FONT>            }<a name="line.3447"></a>
<FONT color="green">3448</FONT>          }<a name="line.3448"></a>
<FONT color="green">3449</FONT>        }<a name="line.3449"></a>
<FONT color="green">3450</FONT>    <a name="line.3450"></a>
<FONT color="green">3451</FONT>        /*<a name="line.3451"></a>
<FONT color="green">3452</FONT>         * Returns the index of the point on this curve whose rendered symbol<a name="line.3452"></a>
<FONT color="green">3453</FONT>         * intersects a rectangle with the specified width and height centered on<a name="line.3453"></a>
<FONT color="green">3454</FONT>         * the specified point (this rectangle is typically a point selection<a name="line.3454"></a>
<FONT color="green">3455</FONT>         * "brush", centered on the mouse cursor). &lt;p&gt;<a name="line.3455"></a>
<FONT color="green">3456</FONT>         * <a name="line.3456"></a>
<FONT color="green">3457</FONT>         * In the event that more than one point's rendered symbol intersects with<a name="line.3457"></a>
<FONT color="green">3458</FONT>         * the specified rectangle, the point whose center is closest to the<a name="line.3458"></a>
<FONT color="green">3459</FONT>         * specified rectangle's center is returned. In the event of a tie, the<a name="line.3459"></a>
<FONT color="green">3460</FONT>         * point with the largest point index is returned. If no point "touches" the<a name="line.3460"></a>
<FONT color="green">3461</FONT>         * rectangle, &lt;tt&gt;GChart.NAI&lt;/tt&gt; is returned. &lt;p&gt;<a name="line.3461"></a>
<FONT color="green">3462</FONT>         * <a name="line.3462"></a>
<FONT color="green">3463</FONT>         * Assumes/requires up-to-date &lt;tt&gt;bandList&lt;/tt&gt; array and related<a name="line.3463"></a>
<FONT color="green">3464</FONT>         * &lt;tt&gt;iNextInBand&lt;/tt&gt; indexes (these get defined within the<a name="line.3464"></a>
<FONT color="green">3465</FONT>         * &lt;tt&gt;bandSeparatePoints&lt;/tt&gt; method).<a name="line.3465"></a>
<FONT color="green">3466</FONT>         */<a name="line.3466"></a>
<FONT color="green">3467</FONT>    <a name="line.3467"></a>
<FONT color="green">3468</FONT>        int getClosestTouchingPoint(int xBrushIn, int yBrushIn) {<a name="line.3468"></a>
<FONT color="green">3469</FONT>          /*<a name="line.3469"></a>
<FONT color="green">3470</FONT>           * Reverse-shifting brush is an easier way to incorporate<a name="line.3470"></a>
<FONT color="green">3471</FONT>           * hit-testing impact of xShift, yShift than actually shifting<a name="line.3471"></a>
<FONT color="green">3472</FONT>           * object positions.<a name="line.3472"></a>
<FONT color="green">3473</FONT>           * <a name="line.3473"></a>
<FONT color="green">3474</FONT>           */<a name="line.3474"></a>
<FONT color="green">3475</FONT>          int xBrush = xBrushIn - xShift;<a name="line.3475"></a>
<FONT color="green">3476</FONT>          int yBrush = yBrushIn + yShift; // '+': cartesion-to-pixel transform<a name="line.3476"></a>
<FONT color="green">3477</FONT>          int result = GChart.NAI;<a name="line.3477"></a>
<FONT color="green">3478</FONT>          // ANCHOR_MOUSE symbol type curves not band separated/hit tested<a name="line.3478"></a>
<FONT color="green">3479</FONT>          if (null == bandList)<a name="line.3479"></a>
<FONT color="green">3480</FONT>            return result;<a name="line.3480"></a>
<FONT color="green">3481</FONT>          SymbolType symType = getSymbol().getSymbolType();<a name="line.3481"></a>
<FONT color="green">3482</FONT>          double dBest = Double.MAX_VALUE; // closest touching pt's distance^2<a name="line.3482"></a>
<FONT color="green">3483</FONT>    <a name="line.3483"></a>
<FONT color="green">3484</FONT>          int iBandFirst;<a name="line.3484"></a>
<FONT color="green">3485</FONT>          int iBandLast;<a name="line.3485"></a>
<FONT color="green">3486</FONT>    <a name="line.3486"></a>
<FONT color="green">3487</FONT>          int brushWidth = symType.getBrushWidth(getSymbol());<a name="line.3487"></a>
<FONT color="green">3488</FONT>          /*<a name="line.3488"></a>
<FONT color="green">3489</FONT>           * In every tested browser EXCEPT FF3, we don't need the +1 below<a name="line.3489"></a>
<FONT color="green">3490</FONT>           * to select a 1px tall, off-chart, symbol with a 1x1 px brush<a name="line.3490"></a>
<FONT color="green">3491</FONT>           * (specifically, to select the leftmost vertical bar on<a name="line.3491"></a>
<FONT color="green">3492</FONT>           * TestGChart28). The +1 below in effect adds 1 px to the height<a name="line.3492"></a>
<FONT color="green">3493</FONT>           * of the brush to workaround this problem.<a name="line.3493"></a>
<FONT color="green">3494</FONT>           */<a name="line.3494"></a>
<FONT color="green">3495</FONT>          int brushHeight = symType.getBrushHeight(getSymbol()) + 1;<a name="line.3495"></a>
<FONT color="green">3496</FONT>          AnnotationLocation brushLocation =<a name="line.3496"></a>
<FONT color="green">3497</FONT>              symType.getBrushLocation(getSymbol());<a name="line.3497"></a>
<FONT color="green">3498</FONT>          int nBands = bandList.length;<a name="line.3498"></a>
<FONT color="green">3499</FONT>    <a name="line.3499"></a>
<FONT color="green">3500</FONT>          /*<a name="line.3500"></a>
<FONT color="green">3501</FONT>           * Determine range of bands touched by brush, taking into account<a name="line.3501"></a>
<FONT color="green">3502</FONT>           * potential for symbols whose centers are in one band to "stick<a name="line.3502"></a>
<FONT color="green">3503</FONT>           * out" into an adjacent band by half-band thickening of either<a name="line.3503"></a>
<FONT color="green">3504</FONT>           * end of the brush.<a name="line.3504"></a>
<FONT color="green">3505</FONT>           *<a name="line.3505"></a>
<FONT color="green">3506</FONT>           * Note that the 0th and (nBand-1)th bands represent<a name="line.3506"></a>
<FONT color="green">3507</FONT>           * "pseudo-bands" that hold all points that fall to the left or<a name="line.3507"></a>
<FONT color="green">3508</FONT>           * right (or above or below if horizontally banded) the<a name="line.3508"></a>
<FONT color="green">3509</FONT>           * rectangular plot area. The tacit assumption is that such<a name="line.3509"></a>
<FONT color="green">3510</FONT>           * completely off-the-plot-area points are rare, so it's OK to<a name="line.3510"></a>
<FONT color="green">3511</FONT>           * bunch them up into just 2 bands.<a name="line.3511"></a>
<FONT color="green">3512</FONT>           *<a name="line.3512"></a>
<FONT color="green">3513</FONT>           */ <a name="line.3513"></a>
<FONT color="green">3514</FONT>          if (getSymbol().isHorizontallyBanded()) {<a name="line.3514"></a>
<FONT color="green">3515</FONT>            // horizontal bars and curves with "wider than high" brushes<a name="line.3515"></a>
<FONT color="green">3516</FONT>            double top =<a name="line.3516"></a>
<FONT color="green">3517</FONT>              brushLocation.getUpperLeftY(yBrush, brushHeight, 0);<a name="line.3517"></a>
<FONT color="green">3518</FONT>            double bottom = top + brushHeight;<a name="line.3518"></a>
<FONT color="green">3519</FONT>            top -= bandThickness / 2.;<a name="line.3519"></a>
<FONT color="green">3520</FONT>            bottom += bandThickness / 2.;<a name="line.3520"></a>
<FONT color="green">3521</FONT>            iBandFirst = (int) Math.max(0, Math.min(nBands - 1,<a name="line.3521"></a>
<FONT color="green">3522</FONT>              1 + Math.floor(top / bandThickness)));<a name="line.3522"></a>
<FONT color="green">3523</FONT>            iBandLast = (int) Math.max(0, Math.min(nBands - 1,<a name="line.3523"></a>
<FONT color="green">3524</FONT>              1 + Math.floor(bottom / bandThickness)));<a name="line.3524"></a>
<FONT color="green">3525</FONT>          } else { // vertical bars, some curves with "tall or square" brushes<a name="line.3525"></a>
<FONT color="green">3526</FONT>            double left =<a name="line.3526"></a>
<FONT color="green">3527</FONT>              brushLocation.getUpperLeftX(xBrush, brushWidth, 0);<a name="line.3527"></a>
<FONT color="green">3528</FONT>            double right = left + brushWidth;<a name="line.3528"></a>
<FONT color="green">3529</FONT>            left -= bandThickness / 2.0;<a name="line.3529"></a>
<FONT color="green">3530</FONT>            right += bandThickness / 2.0;<a name="line.3530"></a>
<FONT color="green">3531</FONT>            iBandFirst = (int) Math.max(0, Math.min(nBands - 1,<a name="line.3531"></a>
<FONT color="green">3532</FONT>              1 + Math.floor(left / bandThickness)));<a name="line.3532"></a>
<FONT color="green">3533</FONT>            iBandLast = (int) Math.max(0, Math.min(nBands - 1,<a name="line.3533"></a>
<FONT color="green">3534</FONT>              1 + Math.floor(right / bandThickness)));<a name="line.3534"></a>
<FONT color="green">3535</FONT>          }<a name="line.3535"></a>
<FONT color="green">3536</FONT>          /*<a name="line.3536"></a>
<FONT color="green">3537</FONT>           * Every point whose symbol touches the brush must be in one<a name="line.3537"></a>
<FONT color="green">3538</FONT>           * of these bands. Search them to find closest touching point.<a name="line.3538"></a>
<FONT color="green">3539</FONT>           * <a name="line.3539"></a>
<FONT color="green">3540</FONT>           */ <a name="line.3540"></a>
<FONT color="green">3541</FONT>          for (int iBand = iBandFirst; iBand &lt;= iBandLast; iBand++) {<a name="line.3541"></a>
<FONT color="green">3542</FONT>            Point p = null;<a name="line.3542"></a>
<FONT color="green">3543</FONT>            for (int iPoint = bandList[iBand];<a name="line.3543"></a>
<FONT color="green">3544</FONT>                 iPoint != GChart.NAI;<a name="line.3544"></a>
<FONT color="green">3545</FONT>                 iPoint = p.getINextInBand()) {<a name="line.3545"></a>
<FONT color="green">3546</FONT>              if (iPoint &lt; 0 || iPoint &gt;= getNPoints())<a name="line.3546"></a>
<FONT color="green">3547</FONT>                throw new IllegalStateException(<a name="line.3547"></a>
<FONT color="green">3548</FONT>                    "Inappropriately terminated band-point-list, GChart bug likely. "<a name="line.3548"></a>
<FONT color="green">3549</FONT>                        + "iPoint=" + iPoint + " nPoints="<a name="line.3549"></a>
<FONT color="green">3550</FONT>                        + getNPoints() + " iBand=" + iBand<a name="line.3550"></a>
<FONT color="green">3551</FONT>                        + " iBandFirst=" + iBandFirst<a name="line.3551"></a>
<FONT color="green">3552</FONT>                        + " iBandLast=" + iBandLast<a name="line.3552"></a>
<FONT color="green">3553</FONT>                        + " xBrush=" + xBrush + " yBrush="<a name="line.3553"></a>
<FONT color="green">3554</FONT>                        + yBrush + " brushWidth=" + brushWidth<a name="line.3554"></a>
<FONT color="green">3555</FONT>                        + " brushHeight=" + brushHeight<a name="line.3555"></a>
<FONT color="green">3556</FONT>                        + " bandThickness=" + bandThickness);<a name="line.3556"></a>
<FONT color="green">3557</FONT>              p = getPoint(iPoint);<a name="line.3557"></a>
<FONT color="green">3558</FONT>              if (symType.isIntersecting(plotPanel, getSymbol(), iPoint,<a name="line.3558"></a>
<FONT color="green">3559</FONT>                  onY2(), xBrush, yBrush, brushWidth, brushHeight)) {<a name="line.3559"></a>
<FONT color="green">3560</FONT>                // this point touches the brush (keep it if closest)<a name="line.3560"></a>
<FONT color="green">3561</FONT>                double xPoint = symType.getCenterX(plotPanel,<a name="line.3561"></a>
<FONT color="green">3562</FONT>                    getSymbol(), iPoint);<a name="line.3562"></a>
<FONT color="green">3563</FONT>                double yPoint = symType.getCenterY(plotPanel,<a name="line.3563"></a>
<FONT color="green">3564</FONT>                    getSymbol(), iPoint, onY2());<a name="line.3564"></a>
<FONT color="green">3565</FONT>                double dx = getSymbol().xScaleFactor<a name="line.3565"></a>
<FONT color="green">3566</FONT>                    * (xPoint - xBrush);<a name="line.3566"></a>
<FONT color="green">3567</FONT>                double dy = getSymbol().yScaleFactor<a name="line.3567"></a>
<FONT color="green">3568</FONT>                    * (yPoint - yBrush);<a name="line.3568"></a>
<FONT color="green">3569</FONT>                double d = dx * dx + dy * dy;<a name="line.3569"></a>
<FONT color="green">3570</FONT>                if (d &lt; dBest) {<a name="line.3570"></a>
<FONT color="green">3571</FONT>                  result = iPoint;<a name="line.3571"></a>
<FONT color="green">3572</FONT>                  dBest = d;<a name="line.3572"></a>
<FONT color="green">3573</FONT>                } else if (d == dBest &amp;&amp; iPoint &gt; result) {<a name="line.3573"></a>
<FONT color="green">3574</FONT>                  /*<a name="line.3574"></a>
<FONT color="green">3575</FONT>                   * In the case of ties, choose largest point index<a name="line.3575"></a>
<FONT color="green">3576</FONT>                   * (highest "z-order" -- the one "on top")<a name="line.3576"></a>
<FONT color="green">3577</FONT>                   */ <a name="line.3577"></a>
<FONT color="green">3578</FONT>                  result = iPoint;<a name="line.3578"></a>
<FONT color="green">3579</FONT>                }<a name="line.3579"></a>
<FONT color="green">3580</FONT>              }<a name="line.3580"></a>
<FONT color="green">3581</FONT>            }<a name="line.3581"></a>
<FONT color="green">3582</FONT>          }<a name="line.3582"></a>
<FONT color="green">3583</FONT>    <a name="line.3583"></a>
<FONT color="green">3584</FONT>          return result;<a name="line.3584"></a>
<FONT color="green">3585</FONT>    <a name="line.3585"></a>
<FONT color="green">3586</FONT>        }<a name="line.3586"></a>
<FONT color="green">3587</FONT>    <a name="line.3587"></a>
<FONT color="green">3588</FONT>        /**<a name="line.3588"></a>
<FONT color="green">3589</FONT>         * Will the part of this curve's rendering that falls outside of the plot<a name="line.3589"></a>
<FONT color="green">3590</FONT>         * area be hidden?<a name="line.3590"></a>
<FONT color="green">3591</FONT>         * &lt;p&gt;<a name="line.3591"></a>
<FONT color="green">3592</FONT>         * <a name="line.3592"></a>
<FONT color="green">3593</FONT>         * @return &lt;tt&gt;true&lt;/tt&gt; if this curve's rendering is clipped to the &lt;plot<a name="line.3593"></a>
<FONT color="green">3594</FONT>         *         area tt&gt;false&lt;/tt&gt; otherwise.<a name="line.3594"></a>
<FONT color="green">3595</FONT>         * <a name="line.3595"></a>
<FONT color="green">3596</FONT>         * @see Curve#setClipToPlotArea Curve.setClipToPlotArea<a name="line.3596"></a>
<FONT color="green">3597</FONT>         * @see GChart#setClipToPlotArea GChart.setClipToPlotArea<a name="line.3597"></a>
<FONT color="green">3598</FONT>         * <a name="line.3598"></a>
<FONT color="green">3599</FONT>         */<a name="line.3599"></a>
<FONT color="green">3600</FONT>        public boolean getClippedToPlotArea() {<a name="line.3600"></a>
<FONT color="green">3601</FONT>          boolean result = (null == clipToPlotArea) ?<a name="line.3601"></a>
<FONT color="green">3602</FONT>                           GChart.this.getClipToPlotArea() :<a name="line.3602"></a>
<FONT color="green">3603</FONT>                           clipToPlotArea.booleanValue();<a name="line.3603"></a>
<FONT color="green">3604</FONT>          return result;<a name="line.3604"></a>
<FONT color="green">3605</FONT>        }<a name="line.3605"></a>
<FONT color="green">3606</FONT>    <a name="line.3606"></a>
<FONT color="green">3607</FONT>        /**<a name="line.3607"></a>
<FONT color="green">3608</FONT>         * Returns value previously set via &lt;tt&gt;Curve.setClipToPlotArea&lt;/tt&gt;.<a name="line.3608"></a>
<FONT color="green">3609</FONT>         * &lt;p&gt;<a name="line.3609"></a>
<FONT color="green">3610</FONT>         * <a name="line.3610"></a>
<FONT color="green">3611</FONT>         * Note: Use &lt;tt&gt;getClippedToPlotArea&lt;/tt&gt; to determine if this curve will<a name="line.3611"></a>
<FONT color="green">3612</FONT>         * actually be clipped to the plot area.<a name="line.3612"></a>
<FONT color="green">3613</FONT>         * <a name="line.3613"></a>
<FONT color="green">3614</FONT>         * @return value previously set with setClipToPlotArea.<a name="line.3614"></a>
<FONT color="green">3615</FONT>         * <a name="line.3615"></a>
<FONT color="green">3616</FONT>         * @see Curve#setClipToPlotArea setClipToPlotArea<a name="line.3616"></a>
<FONT color="green">3617</FONT>         * @see Curve#getClippedToPlotArea getClippedToPlotArea<a name="line.3617"></a>
<FONT color="green">3618</FONT>         * <a name="line.3618"></a>
<FONT color="green">3619</FONT>         */<a name="line.3619"></a>
<FONT color="green">3620</FONT>        public Boolean getClipToPlotArea() {<a name="line.3620"></a>
<FONT color="green">3621</FONT>          return clipToPlotArea;<a name="line.3621"></a>
<FONT color="green">3622</FONT>        }<a name="line.3622"></a>
<FONT color="green">3623</FONT>    <a name="line.3623"></a>
<FONT color="green">3624</FONT>        /**<a name="line.3624"></a>
<FONT color="green">3625</FONT>         * Returns any developer-defined data associated with this curve.<a name="line.3625"></a>
<FONT color="green">3626</FONT>         * <a name="line.3626"></a>
<FONT color="green">3627</FONT>         * @return the developer-defined curve data, or &lt;tt&gt;null&lt;/tt&gt; if none.<a name="line.3627"></a>
<FONT color="green">3628</FONT>         * <a name="line.3628"></a>
<FONT color="green">3629</FONT>         * @see #setCurveData setCurveData<a name="line.3629"></a>
<FONT color="green">3630</FONT>         * <a name="line.3630"></a>
<FONT color="green">3631</FONT>         */<a name="line.3631"></a>
<FONT color="green">3632</FONT>        public Object getCurveData() {<a name="line.3632"></a>
<FONT color="green">3633</FONT>          return curveData;<a name="line.3633"></a>
<FONT color="green">3634</FONT>        }<a name="line.3634"></a>
<FONT color="green">3635</FONT>    <a name="line.3635"></a>
<FONT color="green">3636</FONT>        /**<a name="line.3636"></a>
<FONT color="green">3637</FONT>         * @deprecated<a name="line.3637"></a>
<FONT color="green">3638</FONT>         * <a name="line.3638"></a>
<FONT color="green">3639</FONT>         *             This method is equivalent to:<a name="line.3639"></a>
<FONT color="green">3640</FONT>         *             &lt;p&gt;<a name="line.3640"></a>
<FONT color="green">3641</FONT>         *             &lt;tt&gt;getSymbol().getHovertextTemplate()&lt;/tt&gt;<a name="line.3641"></a>
<FONT color="green">3642</FONT>         *             &lt;p&gt;<a name="line.3642"></a>
<FONT color="green">3643</FONT>         * <a name="line.3643"></a>
<FONT color="green">3644</FONT>         *             It is retained only for GChart 1.1 compatibility purposes.<a name="line.3644"></a>
<FONT color="green">3645</FONT>         * <a name="line.3645"></a>
<FONT color="green">3646</FONT>         * @see Symbol#getHovertextTemplate() Symbol.getHovertextTemplate<a name="line.3646"></a>
<FONT color="green">3647</FONT>         * <a name="line.3647"></a>
<FONT color="green">3648</FONT>         */<a name="line.3648"></a>
<FONT color="green">3649</FONT>        public String getHovertextTemplate() {<a name="line.3649"></a>
<FONT color="green">3650</FONT>          return symbol.getHovertextTemplate();<a name="line.3650"></a>
<FONT color="green">3651</FONT>        }<a name="line.3651"></a>
<FONT color="green">3652</FONT>    <a name="line.3652"></a>
<FONT color="green">3653</FONT>        /**<a name="line.3653"></a>
<FONT color="green">3654</FONT>         * Returns the HTML defining this curve's legend label.<a name="line.3654"></a>
<FONT color="green">3655</FONT>         * <a name="line.3655"></a>
<FONT color="green">3656</FONT>         * @return the legend label HTML for this curve<a name="line.3656"></a>
<FONT color="green">3657</FONT>         * <a name="line.3657"></a>
<FONT color="green">3658</FONT>         * @see #setLegendLabel setLegendLabel<a name="line.3658"></a>
<FONT color="green">3659</FONT>         * <a name="line.3659"></a>
<FONT color="green">3660</FONT>         */<a name="line.3660"></a>
<FONT color="green">3661</FONT>        public String getLegendLabel() {<a name="line.3661"></a>
<FONT color="green">3662</FONT>          return legendHTML;<a name="line.3662"></a>
<FONT color="green">3663</FONT>        }<a name="line.3663"></a>
<FONT color="green">3664</FONT>    <a name="line.3664"></a>
<FONT color="green">3665</FONT>        /**<a name="line.3665"></a>
<FONT color="green">3666</FONT>         * Returns the number of points this curve contains.<a name="line.3666"></a>
<FONT color="green">3667</FONT>         * <a name="line.3667"></a>
<FONT color="green">3668</FONT>         * @return the number of points this curve contains.<a name="line.3668"></a>
<FONT color="green">3669</FONT>         * <a name="line.3669"></a>
<FONT color="green">3670</FONT>         * @see #getPoint getPoint<a name="line.3670"></a>
<FONT color="green">3671</FONT>         * @see #addPoint(double, double) addPoint(double,double)<a name="line.3671"></a>
<FONT color="green">3672</FONT>         * @see #addPoint(int,double,double) addPoint(int,double,double)<a name="line.3672"></a>
<FONT color="green">3673</FONT>         * @see #removePoint removePoint<a name="line.3673"></a>
<FONT color="green">3674</FONT>         * @see #clearPoints clearPoints<a name="line.3674"></a>
<FONT color="green">3675</FONT>         */<a name="line.3675"></a>
<FONT color="green">3676</FONT>        public int getNPoints() {<a name="line.3676"></a>
<FONT color="green">3677</FONT>          return points.size();<a name="line.3677"></a>
<FONT color="green">3678</FONT>        }<a name="line.3678"></a>
<FONT color="green">3679</FONT>    <a name="line.3679"></a>
<FONT color="green">3680</FONT>        /**<a name="line.3680"></a>
<FONT color="green">3681</FONT>         * Returns a reference to the GChart that contains this curve.<a name="line.3681"></a>
<FONT color="green">3682</FONT>         * <a name="line.3682"></a>
<FONT color="green">3683</FONT>         * @return GChart that contains this curve--its "parent".<a name="line.3683"></a>
<FONT color="green">3684</FONT>         * <a name="line.3684"></a>
<FONT color="green">3685</FONT>         */<a name="line.3685"></a>
<FONT color="green">3686</FONT>        public GChart getParent() {<a name="line.3686"></a>
<FONT color="green">3687</FONT>          return GChart.this;<a name="line.3687"></a>
<FONT color="green">3688</FONT>        }<a name="line.3688"></a>
<FONT color="green">3689</FONT>    <a name="line.3689"></a>
<FONT color="green">3690</FONT>        /**<a name="line.3690"></a>
<FONT color="green">3691</FONT>         * Convenience method equivalent to &lt;tt&gt;getPoint(getNPoints()-1)&lt;/tt&gt;.<a name="line.3691"></a>
<FONT color="green">3692</FONT>         * &lt;p&gt;<a name="line.3692"></a>
<FONT color="green">3693</FONT>         * <a name="line.3693"></a>
<FONT color="green">3694</FONT>         * This method makes code more readable for the common case when you first<a name="line.3694"></a>
<FONT color="green">3695</FONT>         * add a point to the end of a curve, and then modify that point's<a name="line.3695"></a>
<FONT color="green">3696</FONT>         * attributes, as illustrated below:<a name="line.3696"></a>
<FONT color="green">3697</FONT>         * &lt;p&gt;<a name="line.3697"></a>
<FONT color="green">3698</FONT>         * <a name="line.3698"></a>
<FONT color="green">3699</FONT>         * &lt;pre&gt;<a name="line.3699"></a>
<FONT color="green">3700</FONT>         * class MyChart extends GChart {<a name="line.3700"></a>
<FONT color="green">3701</FONT>         *   public MyChart() {<a name="line.3701"></a>
<FONT color="green">3702</FONT>         *     addCurve();<a name="line.3702"></a>
<FONT color="green">3703</FONT>         *     for (int i = 0; i &amp;lt; 10; i++) {<a name="line.3703"></a>
<FONT color="green">3704</FONT>         *       getCurve().addPoint(i, i);<a name="line.3704"></a>
<FONT color="green">3705</FONT>         *       getCurve().getPoint().setAnnotationText(&amp;quot;Point &amp;quot; + i);<a name="line.3705"></a>
<FONT color="green">3706</FONT>         *     }<a name="line.3706"></a>
<FONT color="green">3707</FONT>         *     update();<a name="line.3707"></a>
<FONT color="green">3708</FONT>         *   }<a name="line.3708"></a>
<FONT color="green">3709</FONT>         * }<a name="line.3709"></a>
<FONT color="green">3710</FONT>         * &lt;/pre&gt;<a name="line.3710"></a>
<FONT color="green">3711</FONT>         * <a name="line.3711"></a>
<FONT color="green">3712</FONT>         * @return the point on the curve with the highest integer index<a name="line.3712"></a>
<FONT color="green">3713</FONT>         * <a name="line.3713"></a>
<FONT color="green">3714</FONT>         * @see #getPoint(int) getPoint(int)<a name="line.3714"></a>
<FONT color="green">3715</FONT>         * @see #getNPoints() getNPoints()<a name="line.3715"></a>
<FONT color="green">3716</FONT>         * <a name="line.3716"></a>
<FONT color="green">3717</FONT>         */<a name="line.3717"></a>
<FONT color="green">3718</FONT>        public Point getPoint() {<a name="line.3718"></a>
<FONT color="green">3719</FONT>          Point result = getPoint(getNPoints() - 1);<a name="line.3719"></a>
<FONT color="green">3720</FONT>          return result;<a name="line.3720"></a>
<FONT color="green">3721</FONT>        }<a name="line.3721"></a>
<FONT color="green">3722</FONT>    <a name="line.3722"></a>
<FONT color="green">3723</FONT>        /**<a name="line.3723"></a>
<FONT color="green">3724</FONT>         * Returns a reference to the point at the specified index. The returned<a name="line.3724"></a>
<FONT color="green">3725</FONT>         * reference can be used to modify various properties of the point, such as<a name="line.3725"></a>
<FONT color="green">3726</FONT>         * its optional annotation (text label).<a name="line.3726"></a>
<FONT color="green">3727</FONT>         * <a name="line.3727"></a>
<FONT color="green">3728</FONT>         * &lt;p&gt;<a name="line.3728"></a>
<FONT color="green">3729</FONT>         * <a name="line.3729"></a>
<FONT color="green">3730</FONT>         * @param iPoint<a name="line.3730"></a>
<FONT color="green">3731</FONT>         *          the index of the point to be returned.<a name="line.3731"></a>
<FONT color="green">3732</FONT>         * @return a reference to the Point at the specified index.<a name="line.3732"></a>
<FONT color="green">3733</FONT>         * <a name="line.3733"></a>
<FONT color="green">3734</FONT>         * @see #addPoint(double, double) addPoint(double,double)<a name="line.3734"></a>
<FONT color="green">3735</FONT>         * @see #addPoint(int,double,double) addPoint(int,double,double)<a name="line.3735"></a>
<FONT color="green">3736</FONT>         * @see #removePoint removePoint<a name="line.3736"></a>
<FONT color="green">3737</FONT>         * @see #clearPoints clearPoints<a name="line.3737"></a>
<FONT color="green">3738</FONT>         * @see #getNPoints getNPoints<a name="line.3738"></a>
<FONT color="green">3739</FONT>         */<a name="line.3739"></a>
<FONT color="green">3740</FONT>        public Point getPoint(int iPoint) {<a name="line.3740"></a>
<FONT color="green">3741</FONT>          if (iPoint &lt; 0 || iPoint &gt;= points.size())<a name="line.3741"></a>
<FONT color="green">3742</FONT>            throw new IllegalArgumentException(<a name="line.3742"></a>
<FONT color="green">3743</FONT>                "Point index iPoint=" + iPoint<a name="line.3743"></a>
<FONT color="green">3744</FONT>                + " is either &lt; 0 or &gt;= the number of points on the curve.");<a name="line.3744"></a>
<FONT color="green">3745</FONT>          Point result = points.get(iPoint);<a name="line.3745"></a>
<FONT color="green">3746</FONT>          return result;<a name="line.3746"></a>
<FONT color="green">3747</FONT>        }<a name="line.3747"></a>
<FONT color="green">3748</FONT>    <a name="line.3748"></a>
<FONT color="green">3749</FONT>        /**<a name="line.3749"></a>
<FONT color="green">3750</FONT>         * Returns the positional index (within this curve's list of points) of the<a name="line.3750"></a>
<FONT color="green">3751</FONT>         * specified point.<a name="line.3751"></a>
<FONT color="green">3752</FONT>         * &lt;p&gt;<a name="line.3752"></a>
<FONT color="green">3753</FONT>         * <a name="line.3753"></a>
<FONT color="green">3754</FONT>         * Returns &lt;tt&gt;GChart.NAI&lt;/tt&gt; if the specified point is not found on this<a name="line.3754"></a>
<FONT color="green">3755</FONT>         * curve's point list.<a name="line.3755"></a>
<FONT color="green">3756</FONT>         * <a name="line.3756"></a>
<FONT color="green">3757</FONT>         * &lt;p&gt;<a name="line.3757"></a>
<FONT color="green">3758</FONT>         * <a name="line.3758"></a>
<FONT color="green">3759</FONT>         * @param point<a name="line.3759"></a>
<FONT color="green">3760</FONT>         *          point whose list position is to be retrieved<a name="line.3760"></a>
<FONT color="green">3761</FONT>         * @return position of point on this curve's point list, or<a name="line.3761"></a>
<FONT color="green">3762</FONT>         *         &lt;tt&gt;GChart.NAI&lt;/tt&gt; if not on the list.<a name="line.3762"></a>
<FONT color="green">3763</FONT>         * <a name="line.3763"></a>
<FONT color="green">3764</FONT>         * @see #getPoint() getPoint()<a name="line.3764"></a>
<FONT color="green">3765</FONT>         * @see #getPoint(int) getPoint(int)<a name="line.3765"></a>
<FONT color="green">3766</FONT>         * @see #addPoint addPoint<a name="line.3766"></a>
<FONT color="green">3767</FONT>         * @see #removePoint removePoint<a name="line.3767"></a>
<FONT color="green">3768</FONT>         * @see #clearPoints clearPoints<a name="line.3768"></a>
<FONT color="green">3769</FONT>         * @see #getNPoints getNPoints<a name="line.3769"></a>
<FONT color="green">3770</FONT>         */<a name="line.3770"></a>
<FONT color="green">3771</FONT>        public int getPointIndex(Point point) {<a name="line.3771"></a>
<FONT color="green">3772</FONT>          int result = points.indexOf(point);<a name="line.3772"></a>
<FONT color="green">3773</FONT>          if (-1 == result)<a name="line.3773"></a>
<FONT color="green">3774</FONT>            result = GChart.NAI;<a name="line.3774"></a>
<FONT color="green">3775</FONT>          return result;<a name="line.3775"></a>
<FONT color="green">3776</FONT>        }<a name="line.3776"></a>
<FONT color="green">3777</FONT>    <a name="line.3777"></a>
<FONT color="green">3778</FONT>        /**<a name="line.3778"></a>
<FONT color="green">3779</FONT>         * Returns the symbol associated with this curve.<a name="line.3779"></a>
<FONT color="green">3780</FONT>         * &lt;p&gt;<a name="line.3780"></a>
<FONT color="green">3781</FONT>         * <a name="line.3781"></a>
<FONT color="green">3782</FONT>         * Though you cannot set the symbol itself (there is no &lt;tt&gt;setSymbol&lt;/tt&gt;<a name="line.3782"></a>
<FONT color="green">3783</FONT>         * method) you can have essentially the same effect by setting the<a name="line.3783"></a>
<FONT color="green">3784</FONT>         * &lt;tt&gt;SymbolType&lt;/tt&gt; (to get qualitatively different kinds of symbols,<a name="line.3784"></a>
<FONT color="green">3785</FONT>         * e.g. bar-chart bars vs. boxes) and by changing symbol attributes such as<a name="line.3785"></a>
<FONT color="green">3786</FONT>         * background color, height, and width.<a name="line.3786"></a>
<FONT color="green">3787</FONT>         * <a name="line.3787"></a>
<FONT color="green">3788</FONT>         * @return the symbol used to represent points on this curve<a name="line.3788"></a>
<FONT color="green">3789</FONT>         * <a name="line.3789"></a>
<FONT color="green">3790</FONT>         * @see Symbol#setSymbolType Symbol.setSymbolType<a name="line.3790"></a>
<FONT color="green">3791</FONT>         * @see Symbol#setBackgroundColor Symbol.setBackgroundColor<a name="line.3791"></a>
<FONT color="green">3792</FONT>         * @see Symbol#setBorderWidth Symbol.setBorderWidth<a name="line.3792"></a>
<FONT color="green">3793</FONT>         * @see Symbol#setBorderStyle Symbol.setBorderStyle<a name="line.3793"></a>
<FONT color="green">3794</FONT>         * @see Symbol#setWidth Symbol.setWidth<a name="line.3794"></a>
<FONT color="green">3795</FONT>         * @see Symbol#setHeight Symbol.setHeight<a name="line.3795"></a>
<FONT color="green">3796</FONT>         * @see Symbol#setModelWidth Symbol.setModelWidth<a name="line.3796"></a>
<FONT color="green">3797</FONT>         * @see Symbol#setModelHeight Symbol.setModelHeight<a name="line.3797"></a>
<FONT color="green">3798</FONT>         * <a name="line.3798"></a>
<FONT color="green">3799</FONT>         */<a name="line.3799"></a>
<FONT color="green">3800</FONT>        public Symbol getSymbol() {<a name="line.3800"></a>
<FONT color="green">3801</FONT>          return symbol;<a name="line.3801"></a>
<FONT color="green">3802</FONT>        }<a name="line.3802"></a>
<FONT color="green">3803</FONT>    <a name="line.3803"></a>
<FONT color="green">3804</FONT>        /**<a name="line.3804"></a>
<FONT color="green">3805</FONT>         * The number of pixels the entire rendered curve will be shifted along the<a name="line.3805"></a>
<FONT color="green">3806</FONT>         * x-axis from it's default position.<a name="line.3806"></a>
<FONT color="green">3807</FONT>         * <a name="line.3807"></a>
<FONT color="green">3808</FONT>         * @return pixel shift along x axis<a name="line.3808"></a>
<FONT color="green">3809</FONT>         * <a name="line.3809"></a>
<FONT color="green">3810</FONT>         * @see #setXShift setXShift<a name="line.3810"></a>
<FONT color="green">3811</FONT>         */<a name="line.3811"></a>
<FONT color="green">3812</FONT>        public int getXShift() {<a name="line.3812"></a>
<FONT color="green">3813</FONT>          return xShift;<a name="line.3813"></a>
<FONT color="green">3814</FONT>        }<a name="line.3814"></a>
<FONT color="green">3815</FONT>    <a name="line.3815"></a>
<FONT color="green">3816</FONT>        /**<a name="line.3816"></a>
<FONT color="green">3817</FONT>         * The number of pixels the entire rendered curve will be shifted along the<a name="line.3817"></a>
<FONT color="green">3818</FONT>         * y-axis from it's default position.<a name="line.3818"></a>
<FONT color="green">3819</FONT>         * <a name="line.3819"></a>
<FONT color="green">3820</FONT>         * @return pixel shift along y axis<a name="line.3820"></a>
<FONT color="green">3821</FONT>         * <a name="line.3821"></a>
<FONT color="green">3822</FONT>         * @see #setYShift setYShift<a name="line.3822"></a>
<FONT color="green">3823</FONT>         */<a name="line.3823"></a>
<FONT color="green">3824</FONT>        public int getYShift() {<a name="line.3824"></a>
<FONT color="green">3825</FONT>          return yShift;<a name="line.3825"></a>
<FONT color="green">3826</FONT>        }<a name="line.3826"></a>
<FONT color="green">3827</FONT>    <a name="line.3827"></a>
<FONT color="green">3828</FONT>        /**<a name="line.3828"></a>
<FONT color="green">3829</FONT>         * Returns the y-axis (Y_AXIS or Y2_AXIS) this curve is plotted on.<a name="line.3829"></a>
<FONT color="green">3830</FONT>         * <a name="line.3830"></a>
<FONT color="green">3831</FONT>         * @return an identifier, either Y_AXIS, or Y2_AXIS, indicating if this<a name="line.3831"></a>
<FONT color="green">3832</FONT>         *         curve is plotted on the left (y) or right (y2) y-axis<a name="line.3832"></a>
<FONT color="green">3833</FONT>         * <a name="line.3833"></a>
<FONT color="green">3834</FONT>         * @see #setYAxis setYAxis<a name="line.3834"></a>
<FONT color="green">3835</FONT>         * @see GChart#Y_AXIS Y_AXIS<a name="line.3835"></a>
<FONT color="green">3836</FONT>         * @see GChart#Y2_AXIS Y2_AXIS<a name="line.3836"></a>
<FONT color="green">3837</FONT>         * <a name="line.3837"></a>
<FONT color="green">3838</FONT>         */<a name="line.3838"></a>
<FONT color="green">3839</FONT>        public YAxisId getYAxis() {<a name="line.3839"></a>
<FONT color="green">3840</FONT>          return yAxisId;<a name="line.3840"></a>
<FONT color="green">3841</FONT>        }<a name="line.3841"></a>
<FONT color="green">3842</FONT>    <a name="line.3842"></a>
<FONT color="green">3843</FONT>        /**<a name="line.3843"></a>
<FONT color="green">3844</FONT>         * Explicitly tells GChart to re-render this curve at the next<a name="line.3844"></a>
<FONT color="green">3845</FONT>         * &lt;tt&gt;update&lt;/tt&gt; invocation.<a name="line.3845"></a>
<FONT color="green">3846</FONT>         * &lt;p&gt;<a name="line.3846"></a>
<FONT color="green">3847</FONT>         *<a name="line.3847"></a>
<FONT color="green">3848</FONT>         * &lt;small&gt; &lt;i&gt;Note:&lt;/i&gt; GChart will usually automatically invalidate<a name="line.3848"></a>
<FONT color="green">3849</FONT>         * a curve's rendering when you modify its properties. So you do not<a name="line.3849"></a>
<FONT color="green">3850</FONT>         * ordinarily need to explicitly force a re-rendering via this<a name="line.3850"></a>
<FONT color="green">3851</FONT>         * method. But, you might need to do this, for example, in a specialized<a name="line.3851"></a>
<FONT color="green">3852</FONT>         * application that used an external vector graphics library in a<a name="line.3852"></a>
<FONT color="green">3853</FONT>         * manner such that the rendering depended on properties not<a name="line.3853"></a>
<FONT color="green">3854</FONT>         * directly managed by the GChart.  &lt;/small&gt;<a name="line.3854"></a>
<FONT color="green">3855</FONT>         * <a name="line.3855"></a>
<FONT color="green">3856</FONT>         * @see #update update<a name="line.3856"></a>
<FONT color="green">3857</FONT>         * <a name="line.3857"></a>
<FONT color="green">3858</FONT>         */<a name="line.3858"></a>
<FONT color="green">3859</FONT>        public void invalidateRendering() {<a name="line.3859"></a>
<FONT color="green">3860</FONT>          invalidate();<a name="line.3860"></a>
<FONT color="green">3861</FONT>        }<a name="line.3861"></a>
<FONT color="green">3862</FONT>    <a name="line.3862"></a>
<FONT color="green">3863</FONT>        /**<a name="line.3863"></a>
<FONT color="green">3864</FONT>         * Is this curve visible on the chart and legend key, or is it hidden from<a name="line.3864"></a>
<FONT color="green">3865</FONT>         * view.<a name="line.3865"></a>
<FONT color="green">3866</FONT>         * <a name="line.3866"></a>
<FONT color="green">3867</FONT>         * @return true if the curve is visible, false otherwise.<a name="line.3867"></a>
<FONT color="green">3868</FONT>         * <a name="line.3868"></a>
<FONT color="green">3869</FONT>         * @see #setVisible setVisible<a name="line.3869"></a>
<FONT color="green">3870</FONT>         */<a name="line.3870"></a>
<FONT color="green">3871</FONT>        public boolean isVisible() {<a name="line.3871"></a>
<FONT color="green">3872</FONT>          return isVisible;<a name="line.3872"></a>
<FONT color="green">3873</FONT>        }<a name="line.3873"></a>
<FONT color="green">3874</FONT>    <a name="line.3874"></a>
<FONT color="green">3875</FONT>        /**<a name="line.3875"></a>
<FONT color="green">3876</FONT>         * Convenience method equivalent to &lt;tt&gt;getYAxis()==Y2_AXIS&lt;/tt&gt;.<a name="line.3876"></a>
<FONT color="green">3877</FONT>         * <a name="line.3877"></a>
<FONT color="green">3878</FONT>         * @return true if curve is on second y-axis, else false<a name="line.3878"></a>
<FONT color="green">3879</FONT>         * <a name="line.3879"></a>
<FONT color="green">3880</FONT>         * @see #getYAxis getYAxis<a name="line.3880"></a>
<FONT color="green">3881</FONT>         */<a name="line.3881"></a>
<FONT color="green">3882</FONT>        public boolean onY2() {<a name="line.3882"></a>
<FONT color="green">3883</FONT>          return yAxisId == Y2_AXIS;<a name="line.3883"></a>
<FONT color="green">3884</FONT>        }<a name="line.3884"></a>
<FONT color="green">3885</FONT>    <a name="line.3885"></a>
<FONT color="green">3886</FONT>        /**<a name="line.3886"></a>
<FONT color="green">3887</FONT>         * Removes the point at the specified index.<a name="line.3887"></a>
<FONT color="green">3888</FONT>         * <a name="line.3888"></a>
<FONT color="green">3889</FONT>         * @param iPoint<a name="line.3889"></a>
<FONT color="green">3890</FONT>         *          index of point to be removed.<a name="line.3890"></a>
<FONT color="green">3891</FONT>         * <a name="line.3891"></a>
<FONT color="green">3892</FONT>         * @see #getPoint getPoint<a name="line.3892"></a>
<FONT color="green">3893</FONT>         * @see #addPoint(double, double) addPoint(double,double)<a name="line.3893"></a>
<FONT color="green">3894</FONT>         * @see #addPoint(int,double,double) addPoint(int,double,double)<a name="line.3894"></a>
<FONT color="green">3895</FONT>         * @see #clearPoints clearPoints<a name="line.3895"></a>
<FONT color="green">3896</FONT>         * @see #getNPoints getNPoints<a name="line.3896"></a>
<FONT color="green">3897</FONT>         */<a name="line.3897"></a>
<FONT color="green">3898</FONT>        public void removePoint(int iPoint) {<a name="line.3898"></a>
<FONT color="green">3899</FONT>          if (iPoint &lt; 0 || iPoint &gt;= getNPoints())<a name="line.3899"></a>
<FONT color="green">3900</FONT>            throw new IllegalArgumentException("iPoint=" + iPoint<a name="line.3900"></a>
<FONT color="green">3901</FONT>                + " iPoint arg must be &gt;= 0 and &lt; " + getNPoints()<a name="line.3901"></a>
<FONT color="green">3902</FONT>                + ", the number of points on the curve.");<a name="line.3902"></a>
<FONT color="green">3903</FONT>          invalidate();<a name="line.3903"></a>
<FONT color="green">3904</FONT>    <a name="line.3904"></a>
<FONT color="green">3905</FONT>          /*<a name="line.3905"></a>
<FONT color="green">3906</FONT>           * Simulate user moving away from point before it is deleted (this<a name="line.3906"></a>
<FONT color="green">3907</FONT>           * assures that any required hoverCleanup gets called, and clears<a name="line.3907"></a>
<FONT color="green">3908</FONT>           * the otherwise dangling reference to the point)<a name="line.3908"></a>
<FONT color="green">3909</FONT>           *<a name="line.3909"></a>
<FONT color="green">3910</FONT>           */ <a name="line.3910"></a>
<FONT color="green">3911</FONT>          if (plotPanel.touchedPoint == getPoint(iPoint))<a name="line.3911"></a>
<FONT color="green">3912</FONT>            plotPanel.touch(null);<a name="line.3912"></a>
<FONT color="green">3913</FONT>    <a name="line.3913"></a>
<FONT color="green">3914</FONT>          points.remove(iPoint);<a name="line.3914"></a>
<FONT color="green">3915</FONT>        }<a name="line.3915"></a>
<FONT color="green">3916</FONT>    <a name="line.3916"></a>
<FONT color="green">3917</FONT>        /**<a name="line.3917"></a>
<FONT color="green">3918</FONT>         * Removes the given point from this curve.<a name="line.3918"></a>
<FONT color="green">3919</FONT>         * &lt;p&gt;<a name="line.3919"></a>
<FONT color="green">3920</FONT>         * <a name="line.3920"></a>
<FONT color="green">3921</FONT>         * If the given point is not on this curve, or is &lt;tt&gt;null&lt;/tt&gt;, an<a name="line.3921"></a>
<FONT color="green">3922</FONT>         * exception is thrown.<a name="line.3922"></a>
<FONT color="green">3923</FONT>         * <a name="line.3923"></a>
<FONT color="green">3924</FONT>         * @param p<a name="line.3924"></a>
<FONT color="green">3925</FONT>         *          the point to be removed.<a name="line.3925"></a>
<FONT color="green">3926</FONT>         * <a name="line.3926"></a>
<FONT color="green">3927</FONT>         * <a name="line.3927"></a>
<FONT color="green">3928</FONT>         */<a name="line.3928"></a>
<FONT color="green">3929</FONT>        public void removePoint(Point p) {<a name="line.3929"></a>
<FONT color="green">3930</FONT>          if (null == p)<a name="line.3930"></a>
<FONT color="green">3931</FONT>            throw new IllegalArgumentException("p cannot be null.");<a name="line.3931"></a>
<FONT color="green">3932</FONT>          int index = getPointIndex(p);<a name="line.3932"></a>
<FONT color="green">3933</FONT>          if (GChart.NAI == index)<a name="line.3933"></a>
<FONT color="green">3934</FONT>            throw new IllegalArgumentException(<a name="line.3934"></a>
<FONT color="green">3935</FONT>                "p must be a point on this curve "<a name="line.3935"></a>
<FONT color="green">3936</FONT>                + "(whose curveIndex is "<a name="line.3936"></a>
<FONT color="green">3937</FONT>                + getParent().getCurveIndex(this) + ")");<a name="line.3937"></a>
<FONT color="green">3938</FONT>          removePoint(index);<a name="line.3938"></a>
<FONT color="green">3939</FONT>        }<a name="line.3939"></a>
<FONT color="green">3940</FONT>    <a name="line.3940"></a>
<FONT color="green">3941</FONT>        /**<a name="line.3941"></a>
<FONT color="green">3942</FONT>         * Specifies if the part of this curve's rendering that extends outside of<a name="line.3942"></a>
<FONT color="green">3943</FONT>         * the plot area is hidden (clipped off).<a name="line.3943"></a>
<FONT color="green">3944</FONT>         * &lt;p&gt;<a name="line.3944"></a>
<FONT color="green">3945</FONT>         * <a name="line.3945"></a>
<FONT color="green">3946</FONT>         * If &lt;tt&gt;null&lt;/tt&gt; (the default), the value of the chart's overall<a name="line.3946"></a>
<FONT color="green">3947</FONT>         * &lt;tt&gt;clipToPlotArea&lt;/tt&gt; property (as defined by<a name="line.3947"></a>
<FONT color="green">3948</FONT>         * &lt;tt&gt;GChart.setClipToPlotArea&lt;/tt&gt;) determines if the curve is clipped.<a name="line.3948"></a>
<FONT color="green">3949</FONT>         * <a name="line.3949"></a>
<FONT color="green">3950</FONT>         * @param clipToPlotArea<a name="line.3950"></a>
<FONT color="green">3951</FONT>         *          &lt;tt&gt;Boolean.TRUE&lt;/tt&gt; to clip, &lt;tt&gt;Boolean.FALSE&lt;/tt&gt; to not<a name="line.3951"></a>
<FONT color="green">3952</FONT>         *          clip, or &lt;tt&gt;null&lt;/tt&gt; to clip based on the parent GChart's<a name="line.3952"></a>
<FONT color="green">3953</FONT>         *          &lt;tt&gt;clipToPlotArea&lt;/tt&gt; setting.<a name="line.3953"></a>
<FONT color="green">3954</FONT>         * <a name="line.3954"></a>
<FONT color="green">3955</FONT>         * @see GChart#setClipToPlotArea GChart.setClipToPlotArea<a name="line.3955"></a>
<FONT color="green">3956</FONT>         */<a name="line.3956"></a>
<FONT color="green">3957</FONT>        public void setClipToPlotArea(Boolean clipToPlotArea) {<a name="line.3957"></a>
<FONT color="green">3958</FONT>          invalidate();<a name="line.3958"></a>
<FONT color="green">3959</FONT>          this.clipToPlotArea = clipToPlotArea;<a name="line.3959"></a>
<FONT color="green">3960</FONT>        }<a name="line.3960"></a>
<FONT color="green">3961</FONT>    <a name="line.3961"></a>
<FONT color="green">3962</FONT>        /**<a name="line.3962"></a>
<FONT color="green">3963</FONT>         * Provides a convenient way to associate developer-defined data with a<a name="line.3963"></a>
<FONT color="green">3964</FONT>         * GChart curve.<a name="line.3964"></a>
<FONT color="green">3965</FONT>         * &lt;p&gt;<a name="line.3965"></a>
<FONT color="green">3966</FONT>         * <a name="line.3966"></a>
<FONT color="green">3967</FONT>         * If you use an external vector graphics library to render your charts (see<a name="line.3967"></a>
<FONT color="green">3968</FONT>         * &lt;tt&gt;setCanvasFactory&lt;/tt&gt; for details) all of your vector graphics<a name="line.3968"></a>
<FONT color="green">3969</FONT>         * methods (&lt;tt&gt;lineTo&lt;/tt&gt;, &lt;tt&gt;stroke&lt;/tt&gt; and so forth) can access this<a name="line.3969"></a>
<FONT color="green">3970</FONT>         * data while the curve is being rendered via the<a name="line.3970"></a>
<FONT color="green">3971</FONT>         * &lt;tt&gt;getCurrentCurveData&lt;/tt&gt; method.<a name="line.3971"></a>
<FONT color="green">3972</FONT>         * &lt;p&gt;<a name="line.3972"></a>
<FONT color="green">3973</FONT>         * <a name="line.3973"></a>
<FONT color="green">3974</FONT>         * For example, the oil price simulation chart of the<a name="line.3974"></a>
<FONT color="green">3975</FONT>         * &lt;a<a name="line.3975"></a>
<FONT color="green">3976</FONT>         * href="http://clientsidegchart.googlecode.com/svn/trunk/live-demo/v2_7/com.googlecode.gchart.gchartdemoapp.GChartDemoApp/GChartDemoApp.html"&gt; GChart live demo&lt;/a&gt;<a name="line.3976"></a>
<FONT color="green">3977</FONT>         * uses this method to hold the Catmull-Rom tension<a name="line.3977"></a>
<FONT color="green">3978</FONT>         * parameters it uses to control the "% curvyness" of its lines.<a name="line.3978"></a>
<FONT color="green">3979</FONT>         * &lt;p&gt;<a name="line.3979"></a>
<FONT color="green">3980</FONT>         * <a name="line.3980"></a>
<FONT color="green">3981</FONT>         * &lt;i&gt;Tip&lt;/i&gt;: To associated an application specific list of property value<a name="line.3981"></a>
<FONT color="green">3982</FONT>         * pairs with your curve, either create an appropriate class with the named<a name="line.3982"></a>
<FONT color="green">3983</FONT>         * properties you need, or simply use a &lt;tt&gt;HashMap&lt;/tt&gt; as your data<a name="line.3983"></a>
<FONT color="green">3984</FONT>         * object.<a name="line.3984"></a>
<FONT color="green">3985</FONT>         * <a name="line.3985"></a>
<FONT color="green">3986</FONT>         * @param curveData<a name="line.3986"></a>
<FONT color="green">3987</FONT>         *          a reference to a developer-defined object used to store<a name="line.3987"></a>
<FONT color="green">3988</FONT>         *          auxiliary, application-specific data for this curve.<a name="line.3988"></a>
<FONT color="green">3989</FONT>         * <a name="line.3989"></a>
<FONT color="green">3990</FONT>         * @see Curve#getCurveData getCurveData<a name="line.3990"></a>
<FONT color="green">3991</FONT>         * @see GChart#getCurrentCurveData getCurrentCurveData<a name="line.3991"></a>
<FONT color="green">3992</FONT>         * @see #setCanvasFactory setCanvasFactory<a name="line.3992"></a>
<FONT color="green">3993</FONT>         * <a name="line.3993"></a>
<FONT color="green">3994</FONT>         */<a name="line.3994"></a>
<FONT color="green">3995</FONT>    <a name="line.3995"></a>
<FONT color="green">3996</FONT>        public void setCurveData(Object curveData) {<a name="line.3996"></a>
<FONT color="green">3997</FONT>          invalidate();<a name="line.3997"></a>
<FONT color="green">3998</FONT>          this.curveData = curveData;<a name="line.3998"></a>
<FONT color="green">3999</FONT>        }<a name="line.3999"></a>
<FONT color="green">4000</FONT>    <a name="line.4000"></a>
<FONT color="green">4001</FONT>        /**<a name="line.4001"></a>
<FONT color="green">4002</FONT>         * @deprecated<a name="line.4002"></a>
<FONT color="green">4003</FONT>         * <a name="line.4003"></a>
<FONT color="green">4004</FONT>         *             This method is equivalent to:<a name="line.4004"></a>
<FONT color="green">4005</FONT>         *             &lt;p&gt;<a name="line.4005"></a>
<FONT color="green">4006</FONT>         *             &lt;tt&gt;getSymbol().setHovertextTemplate(hovertextTemplate)&lt;/tt&gt;<a name="line.4006"></a>
<FONT color="green">4007</FONT>         *             &lt;p&gt;<a name="line.4007"></a>
<FONT color="green">4008</FONT>         *             It is retained only for GChart 1.1 compatibility purposes.<a name="line.4008"></a>
<FONT color="green">4009</FONT>         * <a name="line.4009"></a>
<FONT color="green">4010</FONT>         * @see Symbol#setHovertextTemplate Symbol.setHovertextTemplate<a name="line.4010"></a>
<FONT color="green">4011</FONT>         */<a name="line.4011"></a>
<FONT color="green">4012</FONT>        public void setHovertextTemplate(String hovertextTemplate) {<a name="line.4012"></a>
<FONT color="green">4013</FONT>          symbol.setHovertextTemplate(hovertextTemplate);<a name="line.4013"></a>
<FONT color="green">4014</FONT>        }<a name="line.4014"></a>
<FONT color="green">4015</FONT>    <a name="line.4015"></a>
<FONT color="green">4016</FONT>        /**<a name="line.4016"></a>
<FONT color="green">4017</FONT>         * Sets the HTML that defines the label shown to the right of the icon<a name="line.4017"></a>
<FONT color="green">4018</FONT>         * representing the curve's symbol in the chart's legend.<a name="line.4018"></a>
<FONT color="green">4019</FONT>         * &lt;p&gt;<a name="line.4019"></a>
<FONT color="green">4020</FONT>         * <a name="line.4020"></a>
<FONT color="green">4021</FONT>         * Setting the legend label to &lt;tt&gt;null&lt;/tt&gt; removes the entire row (the<a name="line.4021"></a>
<FONT color="green">4022</FONT>         * label and the icon) associated with this curve from the chart key.<a name="line.4022"></a>
<FONT color="green">4023</FONT>         * &lt;p&gt;<a name="line.4023"></a>
<FONT color="green">4024</FONT>         * <a name="line.4024"></a>
<FONT color="green">4025</FONT>         * Note that, since &lt;tt&gt;null&lt;/tt&gt; is the default, unless you set at least<a name="line.4025"></a>
<FONT color="green">4026</FONT>         * one legend label, no chart key will appear at all.<a name="line.4026"></a>
<FONT color="green">4027</FONT>         * <a name="line.4027"></a>
<FONT color="green">4028</FONT>         * @param legendHTML<a name="line.4028"></a>
<FONT color="green">4029</FONT>         *          the HTML defining this curve's legend label, or &lt;tt&gt;null&lt;/tt&gt; to<a name="line.4029"></a>
<FONT color="green">4030</FONT>         *          remove the curve from the legend entirely.<a name="line.4030"></a>
<FONT color="green">4031</FONT>         * <a name="line.4031"></a>
<FONT color="green">4032</FONT>         * @see #getLegendLabel getLegendLabel<a name="line.4032"></a>
<FONT color="green">4033</FONT>         * @see GChart#setLegendThickness setLegendThickness<a name="line.4033"></a>
<FONT color="green">4034</FONT>         * @see GChart#setLegendLocation setLegendLocation<a name="line.4034"></a>
<FONT color="green">4035</FONT>         * <a name="line.4035"></a>
<FONT color="green">4036</FONT>         */<a name="line.4036"></a>
<FONT color="green">4037</FONT>        public void setLegendLabel(String legendHTML) {<a name="line.4037"></a>
<FONT color="green">4038</FONT>          chartDecorationsChanged = true;<a name="line.4038"></a>
<FONT color="green">4039</FONT>          this.legendHTML = legendHTML;<a name="line.4039"></a>
<FONT color="green">4040</FONT>        }<a name="line.4040"></a>
<FONT color="green">4041</FONT>    <a name="line.4041"></a>
<FONT color="green">4042</FONT>        /**<a name="line.4042"></a>
<FONT color="green">4043</FONT>         * Defines if this curve is visible both in the plotting region and on the<a name="line.4043"></a>
<FONT color="green">4044</FONT>         * legend key.<a name="line.4044"></a>
<FONT color="green">4045</FONT>         * &lt;p&gt;<a name="line.4045"></a>
<FONT color="green">4046</FONT>         * <a name="line.4046"></a>
<FONT color="green">4047</FONT>         * &lt;i&gt;Notes:&lt;/i&gt;<a name="line.4047"></a>
<FONT color="green">4048</FONT>         * <a name="line.4048"></a>
<FONT color="green">4049</FONT>         * &lt;ol&gt;<a name="line.4049"></a>
<FONT color="green">4050</FONT>         * &lt;li&gt;A curve must also have a non-&lt;tt&gt;null&lt;/tt&gt; legend label if it is to<a name="line.4050"></a>
<FONT color="green">4051</FONT>         * appear on the legend key.<a name="line.4051"></a>
<FONT color="green">4052</FONT>         * &lt;p&gt;<a name="line.4052"></a>
<FONT color="green">4053</FONT>         * <a name="line.4053"></a>
<FONT color="green">4054</FONT>         * &lt;li&gt;Hidden curves are excluded from the computation of any auto-computed<a name="line.4054"></a>
<FONT color="green">4055</FONT>         * axis limits.<a name="line.4055"></a>
<FONT color="green">4056</FONT>         * <a name="line.4056"></a>
<FONT color="green">4057</FONT>         * &lt;/ol&gt;<a name="line.4057"></a>
<FONT color="green">4058</FONT>         * <a name="line.4058"></a>
<FONT color="green">4059</FONT>         * @param isVisible<a name="line.4059"></a>
<FONT color="green">4060</FONT>         *          false to hide curve, true to reveal it.<a name="line.4060"></a>
<FONT color="green">4061</FONT>         * <a name="line.4061"></a>
<FONT color="green">4062</FONT>         * @see #isVisible() isVisible<a name="line.4062"></a>
<FONT color="green">4063</FONT>         * @see #setLegendLabel setLegendLabel<a name="line.4063"></a>
<FONT color="green">4064</FONT>         * <a name="line.4064"></a>
<FONT color="green">4065</FONT>         */<a name="line.4065"></a>
<FONT color="green">4066</FONT>        public void setVisible(boolean isVisible) {<a name="line.4066"></a>
<FONT color="green">4067</FONT>          /*<a name="line.4067"></a>
<FONT color="green">4068</FONT>           * Axis curve count bookkeeping requires that curve be on the list of<a name="line.4068"></a>
<FONT color="green">4069</FONT>           * curves. &lt;p&gt;<a name="line.4069"></a>
<FONT color="green">4070</FONT>           * <a name="line.4070"></a>
<FONT color="green">4071</FONT>           * Developer refs to removed curves could screw up this bookkeeping. &lt;p&gt;<a name="line.4071"></a>
<FONT color="green">4072</FONT>           * <a name="line.4072"></a>
<FONT color="green">4073</FONT>           * Though often this would be a developer error, best not to throw an<a name="line.4073"></a>
<FONT color="green">4074</FONT>           * exception because some developers could use deleted curves as<a name="line.4074"></a>
<FONT color="green">4075</FONT>           * repositories for curve state data, or an event sequence might produce<a name="line.4075"></a>
<FONT color="green">4076</FONT>           * setVisible calls through a dangling curve reference after a curve had<a name="line.4076"></a>
<FONT color="green">4077</FONT>           * been removed, and best to let developer get away with that kind of<a name="line.4077"></a>
<FONT color="green">4078</FONT>           * thing. &lt;p&gt;<a name="line.4078"></a>
<FONT color="green">4079</FONT>           * <a name="line.4079"></a>
<FONT color="green">4080</FONT>           * No point in invalidating since such removed curves can never become part of<a name="line.4080"></a>
<FONT color="green">4081</FONT>           * a rendered GChart again.<a name="line.4081"></a>
<FONT color="green">4082</FONT>           */<a name="line.4082"></a>
<FONT color="green">4083</FONT>    <a name="line.4083"></a>
<FONT color="green">4084</FONT>          if (getIndexOf() == GChart.NAI) {<a name="line.4084"></a>
<FONT color="green">4085</FONT>            this.isVisible = isVisible;<a name="line.4085"></a>
<FONT color="green">4086</FONT>            return;<a name="line.4086"></a>
<FONT color="green">4087</FONT>          }<a name="line.4087"></a>
<FONT color="green">4088</FONT>    <a name="line.4088"></a>
<FONT color="green">4089</FONT>          invalidate();<a name="line.4089"></a>
<FONT color="green">4090</FONT>    <a name="line.4090"></a>
<FONT color="green">4091</FONT>          /*<a name="line.4091"></a>
<FONT color="green">4092</FONT>           * System curves, such as the hover selection feedback curve,<a name="line.4092"></a>
<FONT color="green">4093</FONT>           * never impact curve counts or appear on the chart legend, so<a name="line.4093"></a>
<FONT color="green">4094</FONT>           * their visibility changes never have additional side effects<a name="line.4094"></a>
<FONT color="green">4095</FONT>           * that require a refresh of the chart's decorations. <a name="line.4095"></a>
<FONT color="green">4096</FONT>           * <a name="line.4096"></a>
<FONT color="green">4097</FONT>           */ <a name="line.4097"></a>
<FONT color="green">4098</FONT>          if (isSystemCurve()) {<a name="line.4098"></a>
<FONT color="green">4099</FONT>            this.isVisible = isVisible;<a name="line.4099"></a>
<FONT color="green">4100</FONT>          } else if (this.isVisible != isVisible) {<a name="line.4100"></a>
<FONT color="green">4101</FONT>            Axis yaxis = (getYAxis() == Y_AXIS) ?<a name="line.4101"></a>
<FONT color="green">4102</FONT>                         GChart.this.getYAxis() :<a name="line.4102"></a>
<FONT color="green">4103</FONT>                         GChart.this.getY2Axis();<a name="line.4103"></a>
<FONT color="green">4104</FONT>            boolean axisCreatedOrDestroyed;<a name="line.4104"></a>
<FONT color="green">4105</FONT>            if (isVisible) {<a name="line.4105"></a>
<FONT color="green">4106</FONT>              axisCreatedOrDestroyed = (yaxis.getNCurvesVisibleOnAxis() == 0);<a name="line.4106"></a>
<FONT color="green">4107</FONT>              getXAxis().incrementCurves();<a name="line.4107"></a>
<FONT color="green">4108</FONT>              yaxis.incrementCurves();<a name="line.4108"></a>
<FONT color="green">4109</FONT>            } else {<a name="line.4109"></a>
<FONT color="green">4110</FONT>              getXAxis().decrementCurves();<a name="line.4110"></a>
<FONT color="green">4111</FONT>              yaxis.decrementCurves();<a name="line.4111"></a>
<FONT color="green">4112</FONT>              axisCreatedOrDestroyed = (yaxis.getNCurvesVisibleOnAxis() == 0);<a name="line.4112"></a>
<FONT color="green">4113</FONT>            }<a name="line.4113"></a>
<FONT color="green">4114</FONT>    <a name="line.4114"></a>
<FONT color="green">4115</FONT>            if ((null != getLegendLabel() &amp;&amp; isLegendVisible())<a name="line.4115"></a>
<FONT color="green">4116</FONT>                || axisCreatedOrDestroyed)<a name="line.4116"></a>
<FONT color="green">4117</FONT>              chartDecorationsChanged = true;<a name="line.4117"></a>
<FONT color="green">4118</FONT>    <a name="line.4118"></a>
<FONT color="green">4119</FONT>            this.isVisible = isVisible;<a name="line.4119"></a>
<FONT color="green">4120</FONT>          }<a name="line.4120"></a>
<FONT color="green">4121</FONT>        }<a name="line.4121"></a>
<FONT color="green">4122</FONT>    <a name="line.4122"></a>
<FONT color="green">4123</FONT>        /**<a name="line.4123"></a>
<FONT color="green">4124</FONT>         * Specifies the number of pixels the entire rendered curve is to be shifted<a name="line.4124"></a>
<FONT color="green">4125</FONT>         * along the x-axis from it's default position.<a name="line.4125"></a>
<FONT color="green">4126</FONT>         * &lt;p&gt;<a name="line.4126"></a>
<FONT color="green">4127</FONT>         * <a name="line.4127"></a>
<FONT color="green">4128</FONT>         * Positive values shift the curve to the right, negative values to the<a name="line.4128"></a>
<FONT color="green">4129</FONT>         * left.<a name="line.4129"></a>
<FONT color="green">4130</FONT>         * &lt;p&gt;<a name="line.4130"></a>
<FONT color="green">4131</FONT>         * <a name="line.4131"></a>
<FONT color="green">4132</FONT>         * &lt;small&gt;&lt;i&gt;Tip:&lt;/i&gt; Because the entire &lt;tt&gt;Panel&lt;/tt&gt; that holds the<a name="line.4132"></a>
<FONT color="green">4133</FONT>         * curve's rendering is shifted, an &lt;tt&gt;update&lt;/tt&gt; that only shifts the<a name="line.4133"></a>
<FONT color="green">4134</FONT>         * curve's position using this method can be performed much more quickly<a name="line.4134"></a>
<FONT color="green">4135</FONT>         * than a re-rendering of the entire curve. This makes such shifts suitable<a name="line.4135"></a>
<FONT color="green">4136</FONT>         * for use in animations and similar applications requiring fast changes in<a name="line.4136"></a>
<FONT color="green">4137</FONT>         * a previously rendered curve's position. For example, the &lt;a<a name="line.4137"></a>
<FONT color="green">4138</FONT>         * href="http://clientsidegchart.googlecode.com/svn/trunk/live-demo/v2_7/com.googlecode.gchart.gchartdemoapp.GChartDemoApp/GChartDemoApp.html"&gt; GChart live demo's&lt;/a&gt; LayZLine&amp;trade; chart editor uses these methods<a name="line.4138"></a>
<FONT color="green">4139</FONT>         * to provide visual feedback for its "drag-to-pan" feature.<a name="line.4139"></a>
<FONT color="green">4140</FONT>         * &lt;/small&gt;<a name="line.4140"></a>
<FONT color="green">4141</FONT>         * <a name="line.4141"></a>
<FONT color="green">4142</FONT>         * @param xShift<a name="line.4142"></a>
<FONT color="green">4143</FONT>         *          number of pixels to shift rendered curve along x-axis.<a name="line.4143"></a>
<FONT color="green">4144</FONT>         * <a name="line.4144"></a>
<FONT color="green">4145</FONT>         * @see #setYShift setYShift<a name="line.4145"></a>
<FONT color="green">4146</FONT>         * <a name="line.4146"></a>
<FONT color="green">4147</FONT>         */<a name="line.4147"></a>
<FONT color="green">4148</FONT>        public void setXShift(int xShift) {<a name="line.4148"></a>
<FONT color="green">4149</FONT>          xOrYShiftChanged = true;<a name="line.4149"></a>
<FONT color="green">4150</FONT>          this.xShift = xShift;<a name="line.4150"></a>
<FONT color="green">4151</FONT>        }<a name="line.4151"></a>
<FONT color="green">4152</FONT>    <a name="line.4152"></a>
<FONT color="green">4153</FONT>        /**<a name="line.4153"></a>
<FONT color="green">4154</FONT>         * Specifies the number of pixels the entire rendered curve is to be shifted<a name="line.4154"></a>
<FONT color="green">4155</FONT>         * along the y-axis from it's default position.<a name="line.4155"></a>
<FONT color="green">4156</FONT>         * &lt;p&gt;<a name="line.4156"></a>
<FONT color="green">4157</FONT>         * <a name="line.4157"></a>
<FONT color="green">4158</FONT>         * Positive values shift the curve towards the top of the page, negative<a name="line.4158"></a>
<FONT color="green">4159</FONT>         * values towards the bottom.<a name="line.4159"></a>
<FONT color="green">4160</FONT>         * &lt;p&gt;<a name="line.4160"></a>
<FONT color="green">4161</FONT>         * <a name="line.4161"></a>
<FONT color="green">4162</FONT>         * &lt;small&gt;&lt;i&gt;Tip:&lt;/i&gt; Because the entire &lt;tt&gt;Panel&lt;/tt&gt; that holds the<a name="line.4162"></a>
<FONT color="green">4163</FONT>         * curve's rendering is shifted, an &lt;tt&gt;update&lt;/tt&gt; that only shifts the<a name="line.4163"></a>
<FONT color="green">4164</FONT>         * curve's position using this method can be performed much more quickly<a name="line.4164"></a>
<FONT color="green">4165</FONT>         * than a re-rendering of the entire curve. This makes such shifts suitable<a name="line.4165"></a>
<FONT color="green">4166</FONT>         * for use in animations and similar applications requiring fast changes in<a name="line.4166"></a>
<FONT color="green">4167</FONT>         * a previously rendered curve's position. &lt;/small&gt;<a name="line.4167"></a>
<FONT color="green">4168</FONT>         * <a name="line.4168"></a>
<FONT color="green">4169</FONT>         * @param yShift<a name="line.4169"></a>
<FONT color="green">4170</FONT>         *          number of pixels to shift rendered curve along y-axis.<a name="line.4170"></a>
<FONT color="green">4171</FONT>         * <a name="line.4171"></a>
<FONT color="green">4172</FONT>         * @see #setXShift setXShift<a name="line.4172"></a>
<FONT color="green">4173</FONT>         * <a name="line.4173"></a>
<FONT color="green">4174</FONT>         */<a name="line.4174"></a>
<FONT color="green">4175</FONT>        public void setYShift(int yShift) {<a name="line.4175"></a>
<FONT color="green">4176</FONT>          xOrYShiftChanged = true;<a name="line.4176"></a>
<FONT color="green">4177</FONT>          this.yShift = yShift;<a name="line.4177"></a>
<FONT color="green">4178</FONT>        }<a name="line.4178"></a>
<FONT color="green">4179</FONT>    <a name="line.4179"></a>
<FONT color="green">4180</FONT>        /**<a name="line.4180"></a>
<FONT color="green">4181</FONT>         * Sets the y-axis that this curve is plotted on.<a name="line.4181"></a>
<FONT color="green">4182</FONT>         * &lt;p&gt;<a name="line.4182"></a>
<FONT color="green">4183</FONT>         * <a name="line.4183"></a>
<FONT color="green">4184</FONT>         * @param axisId<a name="line.4184"></a>
<FONT color="green">4185</FONT>         *          must be either &lt;tt&gt;GChart.Y_AXIS&lt;/tt&gt; or<a name="line.4185"></a>
<FONT color="green">4186</FONT>         *          &lt;tt&gt;GChart.Y2_AXIS&lt;/tt&gt;<a name="line.4186"></a>
<FONT color="green">4187</FONT>         * <a name="line.4187"></a>
<FONT color="green">4188</FONT>         * @see #getYAxis getYAxis<a name="line.4188"></a>
<FONT color="green">4189</FONT>         * @see GChart#Y_AXIS Y_AXIS<a name="line.4189"></a>
<FONT color="green">4190</FONT>         * @see GChart#Y2_AXIS Y2_AXIS<a name="line.4190"></a>
<FONT color="green">4191</FONT>         * <a name="line.4191"></a>
<FONT color="green">4192</FONT>         */<a name="line.4192"></a>
<FONT color="green">4193</FONT>        public void setYAxis(YAxisId axisId) {<a name="line.4193"></a>
<FONT color="green">4194</FONT>          invalidate();<a name="line.4194"></a>
<FONT color="green">4195</FONT>          if (isSystemCurve()) {<a name="line.4195"></a>
<FONT color="green">4196</FONT>            yAxisId = axisId;<a name="line.4196"></a>
<FONT color="green">4197</FONT>          } else if (axisId != yAxisId) {<a name="line.4197"></a>
<FONT color="green">4198</FONT>            if (axisId == Y2_AXIS) { // from Y to Y2<a name="line.4198"></a>
<FONT color="green">4199</FONT>              GChart.this.getYAxis().decrementCurves();<a name="line.4199"></a>
<FONT color="green">4200</FONT>              GChart.this.getY2Axis().incrementCurves();<a name="line.4200"></a>
<FONT color="green">4201</FONT>            } else { // from Y2 to Y<a name="line.4201"></a>
<FONT color="green">4202</FONT>              GChart.this.getY2Axis().decrementCurves();<a name="line.4202"></a>
<FONT color="green">4203</FONT>              GChart.this.getYAxis().incrementCurves();<a name="line.4203"></a>
<FONT color="green">4204</FONT>            }<a name="line.4204"></a>
<FONT color="green">4205</FONT>            yAxisId = axisId;<a name="line.4205"></a>
<FONT color="green">4206</FONT>          }<a name="line.4206"></a>
<FONT color="green">4207</FONT>        }<a name="line.4207"></a>
<FONT color="green">4208</FONT>    <a name="line.4208"></a>
<FONT color="green">4209</FONT>        /*<a name="line.4209"></a>
<FONT color="green">4210</FONT>         * Is this curve one of GChart's special, internally created, system curves?<a name="line.4210"></a>
<FONT color="green">4211</FONT>         * These curves can't be directly accessed by users, and are used by GChart<a name="line.4211"></a>
<FONT color="green">4212</FONT>         * to render special features of the chart, such as the hover selection<a name="line.4212"></a>
<FONT color="green">4213</FONT>         * cursors, titles, footnotes, ticks, gridlines, etc.<a name="line.4213"></a>
<FONT color="green">4214</FONT>         */<a name="line.4214"></a>
<FONT color="green">4215</FONT>        private boolean isSystemCurve() {<a name="line.4215"></a>
<FONT color="green">4216</FONT>          // negative curve indexes are reserved for system curves<a name="line.4216"></a>
<FONT color="green">4217</FONT>          boolean result = (indexOf != GChart.NAI)<a name="line.4217"></a>
<FONT color="green">4218</FONT>              &amp;&amp; externalCurveIndex(indexOf) &lt; 0;<a name="line.4218"></a>
<FONT color="green">4219</FONT>          return result;<a name="line.4219"></a>
<FONT color="green">4220</FONT>        }<a name="line.4220"></a>
<FONT color="green">4221</FONT>    <a name="line.4221"></a>
<FONT color="green">4222</FONT>        // renders the specified point of this curve on the given panels<a name="line.4222"></a>
<FONT color="green">4223</FONT>        void realizePoint(PlotPanel pp, GraphicsRenderingPanel grp,<a name="line.4223"></a>
<FONT color="green">4224</FONT>            AnnotationRenderingPanel arp, int iPoint) {<a name="line.4224"></a>
<FONT color="green">4225</FONT>          Point p = points.get(iPoint);<a name="line.4225"></a>
<FONT color="green">4226</FONT>          double x = p.getX();<a name="line.4226"></a>
<FONT color="green">4227</FONT>          double y = p.getY();<a name="line.4227"></a>
<FONT color="green">4228</FONT>          boolean onY2 = onY2();<a name="line.4228"></a>
<FONT color="green">4229</FONT>          // skip points at undefined locations<a name="line.4229"></a>
<FONT color="green">4230</FONT>          if ((x != x) || (y != y) || // x!=x is a faster isNaN<a name="line.4230"></a>
<FONT color="green">4231</FONT>              plotPanel.isOutOfBounds(x, y, onY2))<a name="line.4231"></a>
<FONT color="green">4232</FONT>            return;<a name="line.4232"></a>
<FONT color="green">4233</FONT>    <a name="line.4233"></a>
<FONT color="green">4234</FONT>          double prevX = Double.NaN;<a name="line.4234"></a>
<FONT color="green">4235</FONT>          double prevY = Double.NaN;<a name="line.4235"></a>
<FONT color="green">4236</FONT>          if (iPoint &gt; 0) {<a name="line.4236"></a>
<FONT color="green">4237</FONT>            Point prevP = points.get(iPoint - 1);<a name="line.4237"></a>
<FONT color="green">4238</FONT>            prevX = prevP.getX();<a name="line.4238"></a>
<FONT color="green">4239</FONT>            prevY = prevP.getY();<a name="line.4239"></a>
<FONT color="green">4240</FONT>            if (plotPanel.isOutOfBounds(prevX, prevY, onY2))<a name="line.4240"></a>
<FONT color="green">4241</FONT>              prevX = prevY = Double.NaN;<a name="line.4241"></a>
<FONT color="green">4242</FONT>          }<a name="line.4242"></a>
<FONT color="green">4243</FONT>          double nextX = Double.NaN;<a name="line.4243"></a>
<FONT color="green">4244</FONT>          double nextY = Double.NaN;<a name="line.4244"></a>
<FONT color="green">4245</FONT>          Point nextP = null;<a name="line.4245"></a>
<FONT color="green">4246</FONT>          if (iPoint &lt; getNPoints() - 1) {<a name="line.4246"></a>
<FONT color="green">4247</FONT>            nextP = points.get(iPoint + 1);<a name="line.4247"></a>
<FONT color="green">4248</FONT>            nextX = nextP.getX();<a name="line.4248"></a>
<FONT color="green">4249</FONT>            nextY = nextP.getY();<a name="line.4249"></a>
<FONT color="green">4250</FONT>            if (plotPanel.isOutOfBounds(nextX, nextY, onY2))<a name="line.4250"></a>
<FONT color="green">4251</FONT>              nextX = nextY = Double.NaN;<a name="line.4251"></a>
<FONT color="green">4252</FONT>          }<a name="line.4252"></a>
<FONT color="green">4253</FONT>    <a name="line.4253"></a>
<FONT color="green">4254</FONT>          /*<a name="line.4254"></a>
<FONT color="green">4255</FONT>           * If point was not assigned to any band, it's not drawn<a name="line.4255"></a>
<FONT color="green">4256</FONT>           * at all (undefined x or y, or off chart entirely).<a name="line.4256"></a>
<FONT color="green">4257</FONT>           * <a name="line.4257"></a>
<FONT color="green">4258</FONT>           */<a name="line.4258"></a>
<FONT color="green">4259</FONT>          boolean drawMainSymbol = (p.getINextInBand() != iPoint);<a name="line.4259"></a>
<FONT color="green">4260</FONT>    <a name="line.4260"></a>
<FONT color="green">4261</FONT>          getSymbol().getSymbolType().realizeSymbol(<a name="line.4261"></a>
<FONT color="green">4262</FONT>              pp, grp, arp, getSymbol(), p.getAnnotation(), onY2,<a name="line.4262"></a>
<FONT color="green">4263</FONT>              getClippedToPlotArea(), getClipToDecoratedChart(),<a name="line.4263"></a>
<FONT color="green">4264</FONT>              getRenderPaddingFactor(), drawMainSymbol, x, y, prevX,<a name="line.4264"></a>
<FONT color="green">4265</FONT>              prevY, nextX, nextY);<a name="line.4265"></a>
<FONT color="green">4266</FONT>        }<a name="line.4266"></a>
<FONT color="green">4267</FONT>    <a name="line.4267"></a>
<FONT color="green">4268</FONT>        /**<a name="line.4268"></a>
<FONT color="green">4269</FONT>         * Represents a single point on one of the chart's curves. This includes the<a name="line.4269"></a>
<FONT color="green">4270</FONT>         * x, y values of the point in "model coordinates" (arbitrary,<a name="line.4270"></a>
<FONT color="green">4271</FONT>         * application-specific, units), as well as an optional annotation (text<a name="line.4271"></a>
<FONT color="green">4272</FONT>         * label) for the point.<a name="line.4272"></a>
<FONT color="green">4273</FONT>         * &lt;p&gt;<a name="line.4273"></a>
<FONT color="green">4274</FONT>         * <a name="line.4274"></a>
<FONT color="green">4275</FONT>         * To create points, you must use a curve's &lt;tt&gt;addPoint&lt;/tt&gt; method.<a name="line.4275"></a>
<FONT color="green">4276</FONT>         * <a name="line.4276"></a>
<FONT color="green">4277</FONT>         * @see Curve#addPoint addPoint<a name="line.4277"></a>
<FONT color="green">4278</FONT>         * <a name="line.4278"></a>
<FONT color="green">4279</FONT>         */<a name="line.4279"></a>
<FONT color="green">4280</FONT>        public class Point {<a name="line.4280"></a>
<FONT color="green">4281</FONT>    <a name="line.4281"></a>
<FONT color="green">4282</FONT>          /*<a name="line.4282"></a>
<FONT color="green">4283</FONT>           * x, y location (user coordinates) of point (points are drawn<a name="line.4283"></a>
<FONT color="green">4284</FONT>           * using the containing curve's symbol).<a name="line.4284"></a>
<FONT color="green">4285</FONT>           * <a name="line.4285"></a>
<FONT color="green">4286</FONT>           */ <a name="line.4286"></a>
<FONT color="green">4287</FONT>          private double x;<a name="line.4287"></a>
<FONT color="green">4288</FONT>          private double y;<a name="line.4288"></a>
<FONT color="green">4289</FONT>          Annotation annotation = null;<a name="line.4289"></a>
<FONT color="green">4290</FONT>          /*<a name="line.4290"></a>
<FONT color="green">4291</FONT>           * Points to index of next point in a vertical or horizontal<a name="line.4291"></a>
<FONT color="green">4292</FONT>           * band (used by the &lt;tt&gt;bandSeparatePoints&lt;/tt&gt; method).<a name="line.4292"></a>
<FONT color="green">4293</FONT>           *<a name="line.4293"></a>
<FONT color="green">4294</FONT>           */ <a name="line.4294"></a>
<FONT color="green">4295</FONT>          private int iNextInBand = GChart.NAI;<a name="line.4295"></a>
<FONT color="green">4296</FONT>    <a name="line.4296"></a>
<FONT color="green">4297</FONT>          int getINextInBand() {<a name="line.4297"></a>
<FONT color="green">4298</FONT>            return iNextInBand;<a name="line.4298"></a>
<FONT color="green">4299</FONT>          }<a name="line.4299"></a>
<FONT color="green">4300</FONT>    <a name="line.4300"></a>
<FONT color="green">4301</FONT>          void setINextInBand(int iNext) {<a name="line.4301"></a>
<FONT color="green">4302</FONT>            iNextInBand = iNext;<a name="line.4302"></a>
<FONT color="green">4303</FONT>          }<a name="line.4303"></a>
<FONT color="green">4304</FONT>    <a name="line.4304"></a>
<FONT color="green">4305</FONT>          Point(double x, double y) {<a name="line.4305"></a>
<FONT color="green">4306</FONT>            this.x = x;<a name="line.4306"></a>
<FONT color="green">4307</FONT>            this.y = y;<a name="line.4307"></a>
<FONT color="green">4308</FONT>          }<a name="line.4308"></a>
<FONT color="green">4309</FONT>    <a name="line.4309"></a>
<FONT color="green">4310</FONT>          /**<a name="line.4310"></a>
<FONT color="green">4311</FONT>           * Returns the weight of the font that will be used to render the text<a name="line.4311"></a>
<FONT color="green">4312</FONT>           * of this point's annotation.<a name="line.4312"></a>
<FONT color="green">4313</FONT>           * &lt;p&gt;<a name="line.4313"></a>
<FONT color="green">4314</FONT>           * <a name="line.4314"></a>
<FONT color="green">4315</FONT>           * @return the font weight of the annotation.<a name="line.4315"></a>
<FONT color="green">4316</FONT>           * <a name="line.4316"></a>
<FONT color="green">4317</FONT>           * @see #setAnnotationFontWeight setAnnotationFontWeight<a name="line.4317"></a>
<FONT color="green">4318</FONT>           */<a name="line.4318"></a>
<FONT color="green">4319</FONT>          public String getAnnotationFontWeight() {<a name="line.4319"></a>
<FONT color="green">4320</FONT>            if (null == annotation)<a name="line.4320"></a>
<FONT color="green">4321</FONT>              annotation = new Annotation();<a name="line.4321"></a>
<FONT color="green">4322</FONT>            return annotation.getFontWeight();<a name="line.4322"></a>
<FONT color="green">4323</FONT>          }<a name="line.4323"></a>
<FONT color="green">4324</FONT>    <a name="line.4324"></a>
<FONT color="green">4325</FONT>          /**<a name="line.4325"></a>
<FONT color="green">4326</FONT>           * Returns the color of the font used to display the point's annotation<a name="line.4326"></a>
<FONT color="green">4327</FONT>           * text.<a name="line.4327"></a>
<FONT color="green">4328</FONT>           * <a name="line.4328"></a>
<FONT color="green">4329</FONT>           * @return CSS color string defining the annotation's color<a name="line.4329"></a>
<FONT color="green">4330</FONT>           * <a name="line.4330"></a>
<FONT color="green">4331</FONT>           * @see #setAnnotationFontColor setAnnotationFontColor<a name="line.4331"></a>
<FONT color="green">4332</FONT>           */<a name="line.4332"></a>
<FONT color="green">4333</FONT>          public String getAnnotationFontColor() {<a name="line.4333"></a>
<FONT color="green">4334</FONT>            if (null == annotation)<a name="line.4334"></a>
<FONT color="green">4335</FONT>              annotation = new Annotation();<a name="line.4335"></a>
<FONT color="green">4336</FONT>            return annotation.getFontColor();<a name="line.4336"></a>
<FONT color="green">4337</FONT>          }<a name="line.4337"></a>
<FONT color="green">4338</FONT>    <a name="line.4338"></a>
<FONT color="green">4339</FONT>          /**<a name="line.4339"></a>
<FONT color="green">4340</FONT>           * Returns the CSS font-family used to render the text of this<a name="line.4340"></a>
<FONT color="green">4341</FONT>           * point's annotation.<a name="line.4341"></a>
<FONT color="green">4342</FONT>           * <a name="line.4342"></a>
<FONT color="green">4343</FONT>           * @return the CSS font-family used by this annotation.<a name="line.4343"></a>
<FONT color="green">4344</FONT>           * <a name="line.4344"></a>
<FONT color="green">4345</FONT>           * @see #setAnnotationFontFamily setAnnotationFontFamily<a name="line.4345"></a>
<FONT color="green">4346</FONT>           */<a name="line.4346"></a>
<FONT color="green">4347</FONT>          public String getAnnotationFontFamily() {<a name="line.4347"></a>
<FONT color="green">4348</FONT>            if (null == annotation)<a name="line.4348"></a>
<FONT color="green">4349</FONT>              annotation = new Annotation();<a name="line.4349"></a>
<FONT color="green">4350</FONT>            return annotation.getFontFamily();<a name="line.4350"></a>
<FONT color="green">4351</FONT>          }<a name="line.4351"></a>
<FONT color="green">4352</FONT>    <a name="line.4352"></a>
<FONT color="green">4353</FONT>          /**<a name="line.4353"></a>
<FONT color="green">4354</FONT>           * Returns the CSS font-style in which the text of this point's<a name="line.4354"></a>
<FONT color="green">4355</FONT>           * annotation will be rendered.<a name="line.4355"></a>
<FONT color="green">4356</FONT>           * <a name="line.4356"></a>
<FONT color="green">4357</FONT>           * @return the font-style used by this point's annotation (italic, normal, etc.)<a name="line.4357"></a>
<FONT color="green">4358</FONT>           * <a name="line.4358"></a>
<FONT color="green">4359</FONT>           * @see #setAnnotationFontStyle setAnnotationFontStyle<a name="line.4359"></a>
<FONT color="green">4360</FONT>           */<a name="line.4360"></a>
<FONT color="green">4361</FONT>          public String getAnnotationFontStyle() {<a name="line.4361"></a>
<FONT color="green">4362</FONT>            if (null == annotation)<a name="line.4362"></a>
<FONT color="green">4363</FONT>              annotation = new Annotation();<a name="line.4363"></a>
<FONT color="green">4364</FONT>            return annotation.getFontStyle();<a name="line.4364"></a>
<FONT color="green">4365</FONT>          }<a name="line.4365"></a>
<FONT color="green">4366</FONT>    <a name="line.4366"></a>
<FONT color="green">4367</FONT>          /**<a name="line.4367"></a>
<FONT color="green">4368</FONT>           * Returns the CSS font size of this point's annotation (text label), in<a name="line.4368"></a>
<FONT color="green">4369</FONT>           * pixels.<a name="line.4369"></a>
<FONT color="green">4370</FONT>           * <a name="line.4370"></a>
<FONT color="green">4371</FONT>           * @return the font size of this point's annotation, in pixels.<a name="line.4371"></a>
<FONT color="green">4372</FONT>           * <a name="line.4372"></a>
<FONT color="green">4373</FONT>           * @see #setAnnotationFontSize setAnnotationFontSize<a name="line.4373"></a>
<FONT color="green">4374</FONT>           */<a name="line.4374"></a>
<FONT color="green">4375</FONT>          public int getAnnotationFontSize() {<a name="line.4375"></a>
<FONT color="green">4376</FONT>            if (null == annotation)<a name="line.4376"></a>
<FONT color="green">4377</FONT>              annotation = new Annotation();<a name="line.4377"></a>
<FONT color="green">4378</FONT>            return annotation.getFontSize();<a name="line.4378"></a>
<FONT color="green">4379</FONT>          }<a name="line.4379"></a>
<FONT color="green">4380</FONT>    <a name="line.4380"></a>
<FONT color="green">4381</FONT>          /**<a name="line.4381"></a>
<FONT color="green">4382</FONT>           * Returns the previously specified location, relative to the symbol<a name="line.4382"></a>
<FONT color="green">4383</FONT>           * representing the point, of the annotation (text label) associated with<a name="line.4383"></a>
<FONT color="green">4384</FONT>           * this point.<a name="line.4384"></a>
<FONT color="green">4385</FONT>           * <a name="line.4385"></a>
<FONT color="green">4386</FONT>           * @return relative location of the point's annotation<a name="line.4386"></a>
<FONT color="green">4387</FONT>           * <a name="line.4387"></a>
<FONT color="green">4388</FONT>           * @see #setAnnotationLocation setAnnotationLocation<a name="line.4388"></a>
<FONT color="green">4389</FONT>           * <a name="line.4389"></a>
<FONT color="green">4390</FONT>           */<a name="line.4390"></a>
<FONT color="green">4391</FONT>          public AnnotationLocation getAnnotationLocation() {<a name="line.4391"></a>
<FONT color="green">4392</FONT>            if (null == annotation)<a name="line.4392"></a>
<FONT color="green">4393</FONT>              annotation = new Annotation();<a name="line.4393"></a>
<FONT color="green">4394</FONT>            AnnotationLocation result = annotation.getLocation();<a name="line.4394"></a>
<FONT color="green">4395</FONT>            if (null == result)<a name="line.4395"></a>
<FONT color="green">4396</FONT>              result =<a name="line.4396"></a>
<FONT color="green">4397</FONT>                getParent().getSymbol().getSymbolType().defaultAnnotationLocation();<a name="line.4397"></a>
<FONT color="green">4398</FONT>            return result;<a name="line.4398"></a>
<FONT color="green">4399</FONT>          }<a name="line.4399"></a>
<FONT color="green">4400</FONT>    <a name="line.4400"></a>
<FONT color="green">4401</FONT>          /**<a name="line.4401"></a>
<FONT color="green">4402</FONT>           * Returns the text of this point's annotation.<a name="line.4402"></a>
<FONT color="green">4403</FONT>           * <a name="line.4403"></a>
<FONT color="green">4404</FONT>           * @return the text of the annotation, or &lt;tt&gt;null&lt;/tt&gt; if this point<a name="line.4404"></a>
<FONT color="green">4405</FONT>           *         either lacks an annotation or uses a widget-based annotation.<a name="line.4405"></a>
<FONT color="green">4406</FONT>           * <a name="line.4406"></a>
<FONT color="green">4407</FONT>           * @see #setAnnotationText setAnnotationText<a name="line.4407"></a>
<FONT color="green">4408</FONT>           * <a name="line.4408"></a>
<FONT color="green">4409</FONT>           */<a name="line.4409"></a>
<FONT color="green">4410</FONT>          public String getAnnotationText() {<a name="line.4410"></a>
<FONT color="green">4411</FONT>            if (null == annotation)<a name="line.4411"></a>
<FONT color="green">4412</FONT>              annotation = new Annotation();<a name="line.4412"></a>
<FONT color="green">4413</FONT>            return annotation.getText();<a name="line.4413"></a>
<FONT color="green">4414</FONT>          }<a name="line.4414"></a>
<FONT color="green">4415</FONT>    <a name="line.4415"></a>
<FONT color="green">4416</FONT>          /**<a name="line.4416"></a>
<FONT color="green">4417</FONT>           * Returns the widget reference that defines this point's annotation as<a name="line.4417"></a>
<FONT color="green">4418</FONT>           * previously specified by &lt;tt&gt;setAnnotationWidget&lt;/tt&gt;. Returns<a name="line.4418"></a>
<FONT color="green">4419</FONT>           * &lt;tt&gt;null&lt;/tt&gt; if the annotation has not yet been specified, or if it<a name="line.4419"></a>
<FONT color="green">4420</FONT>           * was defined via &lt;tt&gt;setAnnotationText&lt;/tt&gt;.<a name="line.4420"></a>
<FONT color="green">4421</FONT>           * <a name="line.4421"></a>
<FONT color="green">4422</FONT>           * @return reference to the widget defining this point's annotation, or<a name="line.4422"></a>
<FONT color="green">4423</FONT>           *         &lt;tt&gt;null&lt;/tt&gt; if none.<a name="line.4423"></a>
<FONT color="green">4424</FONT>           * <a name="line.4424"></a>
<FONT color="green">4425</FONT>           * @see #setAnnotationWidget setAnnotationWidget<a name="line.4425"></a>
<FONT color="green">4426</FONT>           * @see #setAnnotationText setAnnotationText<a name="line.4426"></a>
<FONT color="green">4427</FONT>           * <a name="line.4427"></a>
<FONT color="green">4428</FONT>           */<a name="line.4428"></a>
<FONT color="green">4429</FONT>    <a name="line.4429"></a>
<FONT color="green">4430</FONT>          public Widget getAnnotationWidget() {<a name="line.4430"></a>
<FONT color="green">4431</FONT>            if (null == annotation)<a name="line.4431"></a>
<FONT color="green">4432</FONT>              annotation = new Annotation();<a name="line.4432"></a>
<FONT color="green">4433</FONT>            return annotation.getWidget();<a name="line.4433"></a>
<FONT color="green">4434</FONT>          }<a name="line.4434"></a>
<FONT color="green">4435</FONT>    <a name="line.4435"></a>
<FONT color="green">4436</FONT>          /**<a name="line.4436"></a>
<FONT color="green">4437</FONT>           * Returns true is the point's annotation is visible, false otherwise<a name="line.4437"></a>
<FONT color="green">4438</FONT>           * <a name="line.4438"></a>
<FONT color="green">4439</FONT>           * @return if the a annotation defined for this point will be visible or<a name="line.4439"></a>
<FONT color="green">4440</FONT>           *         not after the next update.<a name="line.4440"></a>
<FONT color="green">4441</FONT>           * <a name="line.4441"></a>
<FONT color="green">4442</FONT>           * @see #setAnnotationVisible setAnnotationVisible<a name="line.4442"></a>
<FONT color="green">4443</FONT>           */<a name="line.4443"></a>
<FONT color="green">4444</FONT>          public boolean getAnnotationVisible() {<a name="line.4444"></a>
<FONT color="green">4445</FONT>            if (null == annotation)<a name="line.4445"></a>
<FONT color="green">4446</FONT>              annotation = new Annotation();<a name="line.4446"></a>
<FONT color="green">4447</FONT>            return annotation.getVisible();<a name="line.4447"></a>
<FONT color="green">4448</FONT>          }<a name="line.4448"></a>
<FONT color="green">4449</FONT>    <a name="line.4449"></a>
<FONT color="green">4450</FONT>          /**<a name="line.4450"></a>
<FONT color="green">4451</FONT>           * Returns the distance, in pixels, that this annotation will be shifted<a name="line.4451"></a>
<FONT color="green">4452</FONT>           * along the x-axis from it's default location.<a name="line.4452"></a>
<FONT color="green">4453</FONT>           * &lt;p&gt;<a name="line.4453"></a>
<FONT color="green">4454</FONT>           * <a name="line.4454"></a>
<FONT color="green">4455</FONT>           * @return amount annotation will be shifted along the x-axis, in pixels.<a name="line.4455"></a>
<FONT color="green">4456</FONT>           * <a name="line.4456"></a>
<FONT color="green">4457</FONT>           * @see #setAnnotationXShift setAnnotationXShift<a name="line.4457"></a>
<FONT color="green">4458</FONT>           */<a name="line.4458"></a>
<FONT color="green">4459</FONT>          public int getAnnotationXShift() {<a name="line.4459"></a>
<FONT color="green">4460</FONT>            if (null == annotation)<a name="line.4460"></a>
<FONT color="green">4461</FONT>              annotation = new Annotation();<a name="line.4461"></a>
<FONT color="green">4462</FONT>            return annotation.getXShift();<a name="line.4462"></a>
<FONT color="green">4463</FONT>          }<a name="line.4463"></a>
<FONT color="green">4464</FONT>    <a name="line.4464"></a>
<FONT color="green">4465</FONT>          /**<a name="line.4465"></a>
<FONT color="green">4466</FONT>           * Returns the distance, in pixels, that this annotation will be shifted<a name="line.4466"></a>
<FONT color="green">4467</FONT>           * along the y-axis from it's default location.<a name="line.4467"></a>
<FONT color="green">4468</FONT>           * &lt;p&gt;<a name="line.4468"></a>
<FONT color="green">4469</FONT>           * <a name="line.4469"></a>
<FONT color="green">4470</FONT>           * @return amount annotation will be shifted along the y-axis, in pixels.<a name="line.4470"></a>
<FONT color="green">4471</FONT>           * <a name="line.4471"></a>
<FONT color="green">4472</FONT>           * @see #setAnnotationYShift setAnnotationYShift<a name="line.4472"></a>
<FONT color="green">4473</FONT>           */<a name="line.4473"></a>
<FONT color="green">4474</FONT>          public int getAnnotationYShift() {<a name="line.4474"></a>
<FONT color="green">4475</FONT>            if (null == annotation)<a name="line.4475"></a>
<FONT color="green">4476</FONT>              annotation = new Annotation();<a name="line.4476"></a>
<FONT color="green">4477</FONT>            return annotation.getYShift();<a name="line.4477"></a>
<FONT color="green">4478</FONT>          }<a name="line.4478"></a>
<FONT color="green">4479</FONT>    <a name="line.4479"></a>
<FONT color="green">4480</FONT>          /**<a name="line.4480"></a>
<FONT color="green">4481</FONT>           * Returns the &lt;tt&gt;Curve&lt;/tt&gt; that this point was added to.<a name="line.4481"></a>
<FONT color="green">4482</FONT>           * <a name="line.4482"></a>
<FONT color="green">4483</FONT>           * @return a reference to the &lt;tt&gt;Curve&lt;/tt&gt; that contains this point (its<a name="line.4483"></a>
<FONT color="green">4484</FONT>           *         "parent").<a name="line.4484"></a>
<FONT color="green">4485</FONT>           * <a name="line.4485"></a>
<FONT color="green">4486</FONT>           */<a name="line.4486"></a>
<FONT color="green">4487</FONT>          public Curve getParent() {<a name="line.4487"></a>
<FONT color="green">4488</FONT>            return Curve.this;<a name="line.4488"></a>
<FONT color="green">4489</FONT>          }<a name="line.4489"></a>
<FONT color="green">4490</FONT>    <a name="line.4490"></a>
<FONT color="green">4491</FONT>          /**<a name="line.4491"></a>
<FONT color="green">4492</FONT>           * Returns the x-coordinate of this point in "model units" (arbitrary,<a name="line.4492"></a>
<FONT color="green">4493</FONT>           * application-specific, units).<a name="line.4493"></a>
<FONT color="green">4494</FONT>           * <a name="line.4494"></a>
<FONT color="green">4495</FONT>           * @return the x-coordinate, in model units<a name="line.4495"></a>
<FONT color="green">4496</FONT>           * <a name="line.4496"></a>
<FONT color="green">4497</FONT>           * @see #setX setX<a name="line.4497"></a>
<FONT color="green">4498</FONT>           * @see #setY setY<a name="line.4498"></a>
<FONT color="green">4499</FONT>           * @see #getY getY<a name="line.4499"></a>
<FONT color="green">4500</FONT>           * <a name="line.4500"></a>
<FONT color="green">4501</FONT>           */<a name="line.4501"></a>
<FONT color="green">4502</FONT>          public double getX() {<a name="line.4502"></a>
<FONT color="green">4503</FONT>            return x;<a name="line.4503"></a>
<FONT color="green">4504</FONT>          }<a name="line.4504"></a>
<FONT color="green">4505</FONT>    <a name="line.4505"></a>
<FONT color="green">4506</FONT>          /**<a name="line.4506"></a>
<FONT color="green">4507</FONT>           * Returns the y-coordinate of this point in "model units" (arbitrary,<a name="line.4507"></a>
<FONT color="green">4508</FONT>           * application-specific, units).<a name="line.4508"></a>
<FONT color="green">4509</FONT>           * <a name="line.4509"></a>
<FONT color="green">4510</FONT>           * @return the y-coordinate, in model units<a name="line.4510"></a>
<FONT color="green">4511</FONT>           * <a name="line.4511"></a>
<FONT color="green">4512</FONT>           * @see #getX getX<a name="line.4512"></a>
<FONT color="green">4513</FONT>           * @see #setX setX<a name="line.4513"></a>
<FONT color="green">4514</FONT>           * @see #setY setY<a name="line.4514"></a>
<FONT color="green">4515</FONT>           * <a name="line.4515"></a>
<FONT color="green">4516</FONT>           */<a name="line.4516"></a>
<FONT color="green">4517</FONT>          public double getY() {<a name="line.4517"></a>
<FONT color="green">4518</FONT>            return y;<a name="line.4518"></a>
<FONT color="green">4519</FONT>          }<a name="line.4519"></a>
<FONT color="green">4520</FONT>    <a name="line.4520"></a>
<FONT color="green">4521</FONT>          /**<a name="line.4521"></a>
<FONT color="green">4522</FONT>           * Specifies the weight of the font that will be used to render the text<a name="line.4522"></a>
<FONT color="green">4523</FONT>           * of this point's annotation.<a name="line.4523"></a>
<FONT color="green">4524</FONT>           * &lt;p&gt;<a name="line.4524"></a>
<FONT color="green">4525</FONT>           * <a name="line.4525"></a>
<FONT color="green">4526</FONT>           * @param cssWeight<a name="line.4526"></a>
<FONT color="green">4527</FONT>           *          A standard CSS font-weight specification such as normal, bold,<a name="line.4527"></a>
<FONT color="green">4528</FONT>           *          bolder, lighter, 100, 200, ... 900, or inherit<a name="line.4528"></a>
<FONT color="green">4529</FONT>           * <a name="line.4529"></a>
<FONT color="green">4530</FONT>           * @see #getAnnotationFontWeight getAnnotationFontWeight<a name="line.4530"></a>
<FONT color="green">4531</FONT>           * @see #setAnnotationFontColor setAnnotationFontColor<a name="line.4531"></a>
<FONT color="green">4532</FONT>           * @see #setAnnotationFontStyle setAnnotationFontStyle<a name="line.4532"></a>
<FONT color="green">4533</FONT>           * @see #setAnnotationFontSize setAnnotationFontSize<a name="line.4533"></a>
<FONT color="green">4534</FONT>           * @see #setAnnotationXShift setAnnotationXShift<a name="line.4534"></a>
<FONT color="green">4535</FONT>           * @see #setAnnotationYShift setAnnotationYShift<a name="line.4535"></a>
<FONT color="green">4536</FONT>           * @see #setAnnotationText setAnnotationText<a name="line.4536"></a>
<FONT color="green">4537</FONT>           * @see #setAnnotationVisible setAnnotationVisible<a name="line.4537"></a>
<FONT color="green">4538</FONT>           */<a name="line.4538"></a>
<FONT color="green">4539</FONT>          public void setAnnotationFontWeight(String cssWeight) {<a name="line.4539"></a>
<FONT color="green">4540</FONT>            getParent().invalidate();<a name="line.4540"></a>
<FONT color="green">4541</FONT>            if (null == annotation)<a name="line.4541"></a>
<FONT color="green">4542</FONT>              annotation = new Annotation();<a name="line.4542"></a>
<FONT color="green">4543</FONT>            annotation.setFontWeight(cssWeight);<a name="line.4543"></a>
<FONT color="green">4544</FONT>          }<a name="line.4544"></a>
<FONT color="green">4545</FONT>    <a name="line.4545"></a>
<FONT color="green">4546</FONT>          /**<a name="line.4546"></a>
<FONT color="green">4547</FONT>           * Specifies the color of the annotation's font.<a name="line.4547"></a>
<FONT color="green">4548</FONT>           * &lt;p&gt;<a name="line.4548"></a>
<FONT color="green">4549</FONT>           * <a name="line.4549"></a>
<FONT color="green">4550</FONT>           * For more information on standard CSS color specifications see the<a name="line.4550"></a>
<FONT color="green">4551</FONT>           * discussion in {@link Symbol#setBackgroundColor<a name="line.4551"></a>
<FONT color="green">4552</FONT>           * Symbol.setBackgroundColor}.<a name="line.4552"></a>
<FONT color="green">4553</FONT>           * &lt;p&gt;<a name="line.4553"></a>
<FONT color="green">4554</FONT>           * <a name="line.4554"></a>
<FONT color="green">4555</FONT>           * @param cssColor<a name="line.4555"></a>
<FONT color="green">4556</FONT>           *          color of the font used to display this point's annotation.<a name="line.4556"></a>
<FONT color="green">4557</FONT>           * <a name="line.4557"></a>
<FONT color="green">4558</FONT>           * @see #getAnnotationFontColor getAnnotationFontColor<a name="line.4558"></a>
<FONT color="green">4559</FONT>           * @see #setAnnotationFontWeight setAnnotationFontWeight<a name="line.4559"></a>
<FONT color="green">4560</FONT>           * @see #setAnnotationFontStyle setAnnotationFontStyle<a name="line.4560"></a>
<FONT color="green">4561</FONT>           * @see #setAnnotationFontSize setAnnotationFontSize<a name="line.4561"></a>
<FONT color="green">4562</FONT>           * @see #setAnnotationXShift setAnnotationXShift<a name="line.4562"></a>
<FONT color="green">4563</FONT>           * @see #setAnnotationYShift setAnnotationYShift<a name="line.4563"></a>
<FONT color="green">4564</FONT>           * @see #setAnnotationText setAnnotationText<a name="line.4564"></a>
<FONT color="green">4565</FONT>           * @see #setAnnotationVisible setAnnotationVisible<a name="line.4565"></a>
<FONT color="green">4566</FONT>           */<a name="line.4566"></a>
<FONT color="green">4567</FONT>          public void setAnnotationFontColor(String cssColor) {<a name="line.4567"></a>
<FONT color="green">4568</FONT>            getParent().invalidate();<a name="line.4568"></a>
<FONT color="green">4569</FONT>            if (null == annotation)<a name="line.4569"></a>
<FONT color="green">4570</FONT>              annotation = new Annotation();<a name="line.4570"></a>
<FONT color="green">4571</FONT>            annotation.setFontColor(cssColor);<a name="line.4571"></a>
<FONT color="green">4572</FONT>          }<a name="line.4572"></a>
<FONT color="green">4573</FONT>    <a name="line.4573"></a>
<FONT color="green">4574</FONT>          /**<a name="line.4574"></a>
<FONT color="green">4575</FONT>           * Specifies the CSS font-family used by this point's annotation.<a name="line.4575"></a>
<FONT color="green">4576</FONT>           * &lt;p&gt;<a name="line.4576"></a>
<FONT color="green">4577</FONT>           * <a name="line.4577"></a>
<FONT color="green">4578</FONT>           * The default font-family is &lt;tt&gt;DEFAULT_FONT_FAMILY&lt;/tt&gt;.<a name="line.4578"></a>
<FONT color="green">4579</FONT>           * &lt;p&gt;<a name="line.4579"></a>
<FONT color="green">4580</FONT>           * <a name="line.4580"></a>
<FONT color="green">4581</FONT>           * @param cssFontFamily<a name="line.4581"></a>
<FONT color="green">4582</FONT>           *          any valid CSS font-family, such as<a name="line.4582"></a>
<FONT color="green">4583</FONT>           *          &lt;tt&gt;"serif", "sans-serif", "monospace", "cursive",<a name="line.4583"></a>
<FONT color="green">4584</FONT>           *          "fantasy"&lt;/tt&gt; or &lt;tt&gt;"Arial, sans-serif"&lt;/tt&gt;.<a name="line.4584"></a>
<FONT color="green">4585</FONT>           * <a name="line.4585"></a>
<FONT color="green">4586</FONT>           * @see #getAnnotationFontFamily getAnnotationFontFamily<a name="line.4586"></a>
<FONT color="green">4587</FONT>           * @see #setAnnotationFontWeight setAnnotationFontWeight<a name="line.4587"></a>
<FONT color="green">4588</FONT>           * @see #setAnnotationFontColor setAnnotationFontColor<a name="line.4588"></a>
<FONT color="green">4589</FONT>           * @see #setAnnotationFontSize setAnnotationFontSize<a name="line.4589"></a>
<FONT color="green">4590</FONT>           * @see #setAnnotationXShift setAnnotationXShift<a name="line.4590"></a>
<FONT color="green">4591</FONT>           * @see #setAnnotationYShift setAnnotationYShift<a name="line.4591"></a>
<FONT color="green">4592</FONT>           * @see #setAnnotationText setAnnotationText<a name="line.4592"></a>
<FONT color="green">4593</FONT>           * @see #setAnnotationVisible setAnnotationVisible<a name="line.4593"></a>
<FONT color="green">4594</FONT>           * @see #setAnnotationFontStyle setAnnotationFontStyle<a name="line.4594"></a>
<FONT color="green">4595</FONT>           * @see #DEFAULT_FONT_FAMILY DEFAULT_FONT_FAMILY<a name="line.4595"></a>
<FONT color="green">4596</FONT>           * <a name="line.4596"></a>
<FONT color="green">4597</FONT>           */<a name="line.4597"></a>
<FONT color="green">4598</FONT>          public void setAnnotationFontFamily(String cssFontFamily) {<a name="line.4598"></a>
<FONT color="green">4599</FONT>            getParent().invalidate();<a name="line.4599"></a>
<FONT color="green">4600</FONT>            if (null == annotation)<a name="line.4600"></a>
<FONT color="green">4601</FONT>              annotation = new Annotation();<a name="line.4601"></a>
<FONT color="green">4602</FONT>            annotation.setFontFamily(cssFontFamily);<a name="line.4602"></a>
<FONT color="green">4603</FONT>          }<a name="line.4603"></a>
<FONT color="green">4604</FONT>    <a name="line.4604"></a>
<FONT color="green">4605</FONT>          /**<a name="line.4605"></a>
<FONT color="green">4606</FONT>           * Specifies the CSS font-style used by this point's annotation.<a name="line.4606"></a>
<FONT color="green">4607</FONT>           * <a name="line.4607"></a>
<FONT color="green">4608</FONT>           * @param cssStyle<a name="line.4608"></a>
<FONT color="green">4609</FONT>           *          any valid CSS font-style, namely, normal, italic, oblique, or<a name="line.4609"></a>
<FONT color="green">4610</FONT>           *          inherit.<a name="line.4610"></a>
<FONT color="green">4611</FONT>           * <a name="line.4611"></a>
<FONT color="green">4612</FONT>           * @see #getAnnotationFontStyle getAnnotationFontStyle<a name="line.4612"></a>
<FONT color="green">4613</FONT>           * @see #setAnnotationFontWeight setAnnotationFontWeight<a name="line.4613"></a>
<FONT color="green">4614</FONT>           * @see #setAnnotationFontColor setAnnotationFontColor<a name="line.4614"></a>
<FONT color="green">4615</FONT>           * @see #setAnnotationFontSize setAnnotationFontSize<a name="line.4615"></a>
<FONT color="green">4616</FONT>           * @see #setAnnotationXShift setAnnotationXShift<a name="line.4616"></a>
<FONT color="green">4617</FONT>           * @see #setAnnotationYShift setAnnotationYShift<a name="line.4617"></a>
<FONT color="green">4618</FONT>           * @see #setAnnotationText setAnnotationText<a name="line.4618"></a>
<FONT color="green">4619</FONT>           * @see #setAnnotationVisible setAnnotationVisible<a name="line.4619"></a>
<FONT color="green">4620</FONT>           * <a name="line.4620"></a>
<FONT color="green">4621</FONT>           */<a name="line.4621"></a>
<FONT color="green">4622</FONT>          public void setAnnotationFontStyle(String cssStyle) {<a name="line.4622"></a>
<FONT color="green">4623</FONT>            getParent().invalidate();<a name="line.4623"></a>
<FONT color="green">4624</FONT>            if (null == annotation)<a name="line.4624"></a>
<FONT color="green">4625</FONT>              annotation = new Annotation();<a name="line.4625"></a>
<FONT color="green">4626</FONT>            annotation.setFontStyle(cssStyle);<a name="line.4626"></a>
<FONT color="green">4627</FONT>          }<a name="line.4627"></a>
<FONT color="green">4628</FONT>    <a name="line.4628"></a>
<FONT color="green">4629</FONT>          /**<a name="line.4629"></a>
<FONT color="green">4630</FONT>           * Specifies the CSS font size of this point's annotation, in pixels.<a name="line.4630"></a>
<FONT color="green">4631</FONT>           * <a name="line.4631"></a>
<FONT color="green">4632</FONT>           * @param fontSize<a name="line.4632"></a>
<FONT color="green">4633</FONT>           *          the font size of this point's annotation, in pixels.<a name="line.4633"></a>
<FONT color="green">4634</FONT>           * <a name="line.4634"></a>
<FONT color="green">4635</FONT>           * @see #getAnnotationFontSize getAnnotationFontSize<a name="line.4635"></a>
<FONT color="green">4636</FONT>           * @see #setAnnotationFontWeight setAnnotationFontWeight<a name="line.4636"></a>
<FONT color="green">4637</FONT>           * @see #setAnnotationFontColor setAnnotationFontColor<a name="line.4637"></a>
<FONT color="green">4638</FONT>           * @see #setAnnotationFontStyle setAnnotationFontStyle<a name="line.4638"></a>
<FONT color="green">4639</FONT>           * @see #setAnnotationXShift setAnnotationXShift<a name="line.4639"></a>
<FONT color="green">4640</FONT>           * @see #setAnnotationYShift setAnnotationYShift<a name="line.4640"></a>
<FONT color="green">4641</FONT>           * @see #setAnnotationText setAnnotationText<a name="line.4641"></a>
<FONT color="green">4642</FONT>           * @see #setAnnotationVisible setAnnotationVisible<a name="line.4642"></a>
<FONT color="green">4643</FONT>           */<a name="line.4643"></a>
<FONT color="green">4644</FONT>          public void setAnnotationFontSize(int fontSize) {<a name="line.4644"></a>
<FONT color="green">4645</FONT>            getParent().invalidate();<a name="line.4645"></a>
<FONT color="green">4646</FONT>            if (null == annotation)<a name="line.4646"></a>
<FONT color="green">4647</FONT>              annotation = new Annotation();<a name="line.4647"></a>
<FONT color="green">4648</FONT>            annotation.setFontSize(fontSize);<a name="line.4648"></a>
<FONT color="green">4649</FONT>          }<a name="line.4649"></a>
<FONT color="green">4650</FONT>    <a name="line.4650"></a>
<FONT color="green">4651</FONT>          /**<a name="line.4651"></a>
<FONT color="green">4652</FONT>           * Specifies the location, relative to this point's symbol, of this<a name="line.4652"></a>
<FONT color="green">4653</FONT>           * point's annotation (text label).<a name="line.4653"></a>
<FONT color="green">4654</FONT>           * &lt;p&gt;<a name="line.4654"></a>
<FONT color="green">4655</FONT>           * <a name="line.4655"></a>
<FONT color="green">4656</FONT>           * You can further adjust the position of a point's annotation by<a name="line.4656"></a>
<FONT color="green">4657</FONT>           * specifying non-zero positional shifts via the<a name="line.4657"></a>
<FONT color="green">4658</FONT>           * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; and &lt;tt&gt;setAnnotationYShift&lt;/tt&gt; methods.<a name="line.4658"></a>
<FONT color="green">4659</FONT>           * <a name="line.4659"></a>
<FONT color="green">4660</FONT>           * <a name="line.4660"></a>
<FONT color="green">4661</FONT>           * @param annotationLocation<a name="line.4661"></a>
<FONT color="green">4662</FONT>           *          the relative location of the annotation<a name="line.4662"></a>
<FONT color="green">4663</FONT>           * <a name="line.4663"></a>
<FONT color="green">4664</FONT>           * @see #getAnnotationLocation getAnnotationLocation<a name="line.4664"></a>
<FONT color="green">4665</FONT>           * @see #setAnnotationFontWeight setAnnotationFontWeight<a name="line.4665"></a>
<FONT color="green">4666</FONT>           * @see #setAnnotationFontColor setAnnotationFontColor<a name="line.4666"></a>
<FONT color="green">4667</FONT>           * @see #setAnnotationFontStyle setAnnotationFontStyle<a name="line.4667"></a>
<FONT color="green">4668</FONT>           * @see #setAnnotationFontSize setAnnotationFontSize<a name="line.4668"></a>
<FONT color="green">4669</FONT>           * @see #setAnnotationText setAnnotationText<a name="line.4669"></a>
<FONT color="green">4670</FONT>           * @see #setAnnotationXShift setAnnotationXShift<a name="line.4670"></a>
<FONT color="green">4671</FONT>           * @see #setAnnotationYShift setAnnotationYShift<a name="line.4671"></a>
<FONT color="green">4672</FONT>           * @see #setAnnotationVisible setAnnotationVisible<a name="line.4672"></a>
<FONT color="green">4673</FONT>           * <a name="line.4673"></a>
<FONT color="green">4674</FONT>           */<a name="line.4674"></a>
<FONT color="green">4675</FONT>          public void setAnnotationLocation(<a name="line.4675"></a>
<FONT color="green">4676</FONT>              AnnotationLocation annotationLocation) {<a name="line.4676"></a>
<FONT color="green">4677</FONT>            getParent().invalidate();<a name="line.4677"></a>
<FONT color="green">4678</FONT>            if (null == annotation)<a name="line.4678"></a>
<FONT color="green">4679</FONT>              annotation = new Annotation();<a name="line.4679"></a>
<FONT color="green">4680</FONT>            annotation.setLocation(annotationLocation);<a name="line.4680"></a>
<FONT color="green">4681</FONT>          }<a name="line.4681"></a>
<FONT color="green">4682</FONT>    <a name="line.4682"></a>
<FONT color="green">4683</FONT>          /**<a name="line.4683"></a>
<FONT color="green">4684</FONT>           * Specifies the text of this point's annotation (label).<a name="line.4684"></a>
<FONT color="green">4685</FONT>           * &lt;p&gt;<a name="line.4685"></a>
<FONT color="green">4686</FONT>           * <a name="line.4686"></a>
<FONT color="green">4687</FONT>           * By default text is plain text, though you can change the size, weight,<a name="line.4687"></a>
<FONT color="green">4688</FONT>           * style, and color of the text via the &lt;tt&gt;setAnnotationFont*&lt;/tt&gt; family<a name="line.4688"></a>
<FONT color="green">4689</FONT>           * of methods.<a name="line.4689"></a>
<FONT color="green">4690</FONT>           * &lt;p&gt;<a name="line.4690"></a>
<FONT color="green">4691</FONT>           * <a name="line.4691"></a>
<FONT color="green">4692</FONT>           * &lt;b&gt;To use HTML, &lt;i&gt;your text must begin with&lt;/i&gt; &lt;tt&gt;&amp;lt;html&amp;gt&lt;/tt&gt;<a name="line.4692"></a>
<FONT color="green">4693</FONT>           * &lt;/b&gt; (otherwise, GChart will treat it as plain text). Note that the<a name="line.4693"></a>
<FONT color="green">4694</FONT>           * leading &lt;tt&gt;&amp;lt;html&amp;gt&lt;/tt&gt; is stripped off by GChart before your HTML<a name="line.4694"></a>
<FONT color="green">4695</FONT>           * gets to the browser. Since it's just a flag for GChart, not a real HTML<a name="line.4695"></a>
<FONT color="green">4696</FONT>           * tag, you should &lt;i&gt;not&lt;/i&gt; use a closing &lt;tt&gt;&amp;lt;/html&amp;gt&lt;/tt&gt; at the<a name="line.4696"></a>
<FONT color="green">4697</FONT>           * end.<a name="line.4697"></a>
<FONT color="green">4698</FONT>           * &lt;p&gt;<a name="line.4698"></a>
<FONT color="green">4699</FONT>           * <a name="line.4699"></a>
<FONT color="green">4700</FONT>           * &lt;small&gt; The idea for adding HTML support (only plain text was supported<a name="line.4700"></a>
<FONT color="green">4701</FONT>           * originally) came from &lt;a href=<a name="line.4701"></a>
<FONT color="green">4702</FONT>           * "http://groups.google.com/group/Google-Web-Toolkit/msg/cb89003dad2416fe"<a name="line.4702"></a>
<FONT color="green">4703</FONT>           * &gt; this GWT forum post by Malcolm Gorman&lt;/a&gt;. The current HTML support<a name="line.4703"></a>
<FONT color="green">4704</FONT>           * (and, it's natural extension, Widget support) in tick labels and<a name="line.4704"></a>
<FONT color="green">4705</FONT>           * annotations, which seems so obvious in hindsight, might never have been<a name="line.4705"></a>
<FONT color="green">4706</FONT>           * added had it not been for this post. Thanks!&lt;/small&gt;<a name="line.4706"></a>
<FONT color="green">4707</FONT>           * &lt;p&gt;<a name="line.4707"></a>
<FONT color="green">4708</FONT>           * <a name="line.4708"></a>
<FONT color="green">4709</FONT>           * &lt;small&gt;&lt;b&gt;How to use the width and height upperbounds:&lt;/b&gt; &lt;/small&gt;<a name="line.4709"></a>
<FONT color="green">4710</FONT>           * &lt;p&gt;<a name="line.4710"></a>
<FONT color="green">4711</FONT>           * <a name="line.4711"></a>
<FONT color="green">4712</FONT>           * &lt;blockquote&gt;&lt;small&gt;<a name="line.4712"></a>
<FONT color="green">4713</FONT>           * In most cases, you can safely ignore these two parameters, simply<a name="line.4713"></a>
<FONT color="green">4714</FONT>           * calling the {@link #setAnnotationText(String) 1-arg convenience method}<a name="line.4714"></a>
<FONT color="green">4715</FONT>           * and getting GChart to estimate them for you.<a name="line.4715"></a>
<FONT color="green">4716</FONT>           * &lt;p&gt;<a name="line.4716"></a>
<FONT color="green">4717</FONT>           * <a name="line.4717"></a>
<FONT color="green">4718</FONT>           * The width and height upper-bounds define an invisible bounding box (a<a name="line.4718"></a>
<FONT color="green">4719</FONT>           * 1x1 GWT Grid, actualy) that is used to properly align and center your<a name="line.4719"></a>
<FONT color="green">4720</FONT>           * annotation.<a name="line.4720"></a>
<FONT color="green">4721</FONT>           * &lt;p&gt;<a name="line.4721"></a>
<FONT color="green">4722</FONT>           * <a name="line.4722"></a>
<FONT color="green">4723</FONT>           * &lt;p&gt;<a name="line.4723"></a>
<FONT color="green">4724</FONT>           * Annotations can become misaligned if, say, due to the user zooming up<a name="line.4724"></a>
<FONT color="green">4725</FONT>           * their font size, an annotation's size exceeds these upperbounds. This<a name="line.4725"></a>
<FONT color="green">4726</FONT>           * misalignment problem can be fixed by specifying a larger width and/or<a name="line.4726"></a>
<FONT color="green">4727</FONT>           * height upperbound. But, larger upperbounds slow chart updates a bit.<a name="line.4727"></a>
<FONT color="green">4728</FONT>           * The defaults try to balance the performance and alignment tradeoff.<a name="line.4728"></a>
<FONT color="green">4729</FONT>           * &lt;p&gt;<a name="line.4729"></a>
<FONT color="green">4730</FONT>           * <a name="line.4730"></a>
<FONT color="green">4731</FONT>           * There is one annoying but generally harmless side effect of using very<a name="line.4731"></a>
<FONT color="green">4732</FONT>           * large upperbounds: most browsers will extend their scroll regions to<a name="line.4732"></a>
<FONT color="green">4733</FONT>           * the right (and presumably below) the real page content so as to include<a name="line.4733"></a>
<FONT color="green">4734</FONT>           * the invisible bounding box. When this happens, it looks to the user as<a name="line.4734"></a>
<FONT color="green">4735</FONT>           * if there is a bunch of blank space on, say, the right edge of the page.<a name="line.4735"></a>
<FONT color="green">4736</FONT>           * In practice, I've always been able to prevent this problem simply by<a name="line.4736"></a>
<FONT color="green">4737</FONT>           * choosing at-least-somewhat-reasonably-tight upper bounds, though a<a name="line.4737"></a>
<FONT color="green">4738</FONT>           * little blank space may be unavoidable in some special cases.<a name="line.4738"></a>
<FONT color="green">4739</FONT>           * &lt;/blockquote&gt;&lt;/small&gt;<a name="line.4739"></a>
<FONT color="green">4740</FONT>           * &lt;p&gt;<a name="line.4740"></a>
<FONT color="green">4741</FONT>           * <a name="line.4741"></a>
<FONT color="green">4742</FONT>           * @param annotationText<a name="line.4742"></a>
<FONT color="green">4743</FONT>           *          the text or (&lt;tt&gt;&amp;lt;html&amp;gt&lt;/tt&gt; prefixed) HTML of this<a name="line.4743"></a>
<FONT color="green">4744</FONT>           *          point's annotation, or &lt;tt&gt;null&lt;/tt&gt; to remove all annotation.<a name="line.4744"></a>
<FONT color="green">4745</FONT>           * <a name="line.4745"></a>
<FONT color="green">4746</FONT>           * @param widthUpperBound<a name="line.4746"></a>
<FONT color="green">4747</FONT>           *          an upper bound on the width of the text or HTML, in pixels.<a name="line.4747"></a>
<FONT color="green">4748</FONT>           *          Use &lt;tt&gt;GChart.NAI&lt;/tt&gt; to get GChart to estimate this width<a name="line.4748"></a>
<FONT color="green">4749</FONT>           *          using an heuristic that works fine most of the time.<a name="line.4749"></a>
<FONT color="green">4750</FONT>           * <a name="line.4750"></a>
<FONT color="green">4751</FONT>           * @param heightUpperBound<a name="line.4751"></a>
<FONT color="green">4752</FONT>           *          an upper bound on the height of the text or HTML, in pixels.<a name="line.4752"></a>
<FONT color="green">4753</FONT>           *          Use &lt;tt&gt;GChart.NAI&lt;/tt&gt; to get GChart to estimate this height<a name="line.4753"></a>
<FONT color="green">4754</FONT>           *          using an heuristic that works fine most of the time.<a name="line.4754"></a>
<FONT color="green">4755</FONT>           * <a name="line.4755"></a>
<FONT color="green">4756</FONT>           * @see #getAnnotationText getAnnotationText<a name="line.4756"></a>
<FONT color="green">4757</FONT>           * @see #setAnnotationText(String) setAnnotationText(String)<a name="line.4757"></a>
<FONT color="green">4758</FONT>           * @see #setAnnotationLocation setAnnotationLocation<a name="line.4758"></a>
<FONT color="green">4759</FONT>           * @see #setAnnotationFontWeight setAnnotationFontWeight<a name="line.4759"></a>
<FONT color="green">4760</FONT>           * @see #setAnnotationFontColor setAnnotationFontColor<a name="line.4760"></a>
<FONT color="green">4761</FONT>           * @see #setAnnotationFontStyle setAnnotationFontStyle<a name="line.4761"></a>
<FONT color="green">4762</FONT>           * @see #setAnnotationFontSize setAnnotationFontSize<a name="line.4762"></a>
<FONT color="green">4763</FONT>           * @see #setAnnotationWidget setAnnotationWidget<a name="line.4763"></a>
<FONT color="green">4764</FONT>           * @see #setAnnotationXShift setAnnotationXShift<a name="line.4764"></a>
<FONT color="green">4765</FONT>           * @see #setAnnotationYShift setAnnotationYShift<a name="line.4765"></a>
<FONT color="green">4766</FONT>           * @see #setAnnotationVisible setAnnotationVisible<a name="line.4766"></a>
<FONT color="green">4767</FONT>           * @see GChart.Axis#addTick(double,String,int,int) addTick<a name="line.4767"></a>
<FONT color="green">4768</FONT>           * <a name="line.4768"></a>
<FONT color="green">4769</FONT>           */<a name="line.4769"></a>
<FONT color="green">4770</FONT>          public void setAnnotationText(String annotationText,<a name="line.4770"></a>
<FONT color="green">4771</FONT>              int widthUpperBound, int heightUpperBound) {<a name="line.4771"></a>
<FONT color="green">4772</FONT>            getParent().invalidate();<a name="line.4772"></a>
<FONT color="green">4773</FONT>            if (null == annotation)<a name="line.4773"></a>
<FONT color="green">4774</FONT>              annotation = new Annotation();<a name="line.4774"></a>
<FONT color="green">4775</FONT>            annotation.setText(annotationText, widthUpperBound,<a name="line.4775"></a>
<FONT color="green">4776</FONT>                heightUpperBound);<a name="line.4776"></a>
<FONT color="green">4777</FONT>          }<a name="line.4777"></a>
<FONT color="green">4778</FONT>    <a name="line.4778"></a>
<FONT color="green">4779</FONT>          /**<a name="line.4779"></a>
<FONT color="green">4780</FONT>           * Sets the text of an annotation.<a name="line.4780"></a>
<FONT color="green">4781</FONT>           * &lt;p&gt;<a name="line.4781"></a>
<FONT color="green">4782</FONT>           * <a name="line.4782"></a>
<FONT color="green">4783</FONT>           * This is a convenience method equivalent to<a name="line.4783"></a>
<FONT color="green">4784</FONT>           * &lt;tt&gt;setAnnotationText(annotationText, GChart.NAI, GChart.NAI)&lt;/tt&gt; .<a name="line.4784"></a>
<FONT color="green">4785</FONT>           * See that method for further details.<a name="line.4785"></a>
<FONT color="green">4786</FONT>           * &lt;p&gt;<a name="line.4786"></a>
<FONT color="green">4787</FONT>           * <a name="line.4787"></a>
<FONT color="green">4788</FONT>           * @param annotationText<a name="line.4788"></a>
<FONT color="green">4789</FONT>           *          the text or (&lt;tt&gt;&amp;lt;html&amp;gt&lt;/tt&gt;-prefixed) HTML of this<a name="line.4789"></a>
<FONT color="green">4790</FONT>           *          point's annotation, or &lt;tt&gt;null&lt;/tt&gt; to remove all annotation.<a name="line.4790"></a>
<FONT color="green">4791</FONT>           * <a name="line.4791"></a>
<FONT color="green">4792</FONT>           * @see #setAnnotationText(String, int, int)<a name="line.4792"></a>
<FONT color="green">4793</FONT>           *      setAnnotationText(String,int,int)<a name="line.4793"></a>
<FONT color="green">4794</FONT>           * <a name="line.4794"></a>
<FONT color="green">4795</FONT>           */<a name="line.4795"></a>
<FONT color="green">4796</FONT>          public void setAnnotationText(String annotationText) {<a name="line.4796"></a>
<FONT color="green">4797</FONT>            setAnnotationText(annotationText, GChart.NAI, GChart.NAI);<a name="line.4797"></a>
<FONT color="green">4798</FONT>          }<a name="line.4798"></a>
<FONT color="green">4799</FONT>    <a name="line.4799"></a>
<FONT color="green">4800</FONT>          /**<a name="line.4800"></a>
<FONT color="green">4801</FONT>           * Specifies a widget defining this point's annotation<a name="line.4801"></a>
<FONT color="green">4802</FONT>           * &lt;p&gt;<a name="line.4802"></a>
<FONT color="green">4803</FONT>           * <a name="line.4803"></a>
<FONT color="green">4804</FONT>           * This method is similar to &lt;tt&gt;setAnnotationText&lt;/tt&gt; except that it<a name="line.4804"></a>
<FONT color="green">4805</FONT>           * uses a widget, rather than a string to define this point's annotation.<a name="line.4805"></a>
<FONT color="green">4806</FONT>           * Although the string based method is faster on first chart rendering,<a name="line.4806"></a>
<FONT color="green">4807</FONT>           * and uses less memory, the widget-based method allows you to change the<a name="line.4807"></a>
<FONT color="green">4808</FONT>           * annotation independently of the chart--potentially bypassing (or at<a name="line.4808"></a>
<FONT color="green">4809</FONT>           * least speeding up) expensive chart updates later on.<a name="line.4809"></a>
<FONT color="green">4810</FONT>           * &lt;p&gt;<a name="line.4810"></a>
<FONT color="green">4811</FONT>           * <a name="line.4811"></a>
<FONT color="green">4812</FONT>           * You might use a widget-based annotation to pop-up a message whenever<a name="line.4812"></a>
<FONT color="green">4813</FONT>           * the user clicks on a button underneath a particular data point on the<a name="line.4813"></a>
<FONT color="green">4814</FONT>           * chart, to include a small GWT &lt;tt&gt;Grid&lt;/tt&gt; as a table embedded in the<a name="line.4814"></a>
<FONT color="green">4815</FONT>           * upper left hand corner of the chart, to trigger mouse-over events when<a name="line.4815"></a>
<FONT color="green">4816</FONT>           * the user hovers over a transparent image-based annotation centered on a<a name="line.4816"></a>
<FONT color="green">4817</FONT>           * particular point, etc.<a name="line.4817"></a>
<FONT color="green">4818</FONT>           * &lt;p&gt;<a name="line.4818"></a>
<FONT color="green">4819</FONT>           * <a name="line.4819"></a>
<FONT color="green">4820</FONT>           * &lt;i&gt;Tip:&lt;/i&gt;If you need to instrument a chart using widgets precisely<a name="line.4820"></a>
<FONT color="green">4821</FONT>           * positioned on the chart, but not associated with any visible curve, add<a name="line.4821"></a>
<FONT color="green">4822</FONT>           * a curve just to hold these annotations, with one point per annotation,<a name="line.4822"></a>
<FONT color="green">4823</FONT>           * and set that curve's symbol type to &lt;tt&gt;SymbolType.NONE&lt;/tt&gt;.<a name="line.4823"></a>
<FONT color="green">4824</FONT>           * &lt;p&gt;<a name="line.4824"></a>
<FONT color="green">4825</FONT>           * <a name="line.4825"></a>
<FONT color="green">4826</FONT>           * &lt;b&gt;&lt;i&gt;Warning:&lt;/i&gt;&lt;/b&gt; If you use the exact same widget reference to<a name="line.4826"></a>
<FONT color="green">4827</FONT>           * define two different annotations, GChart will render only one of them,<a name="line.4827"></a>
<FONT color="green">4828</FONT>           * and &lt;i&gt;there is no easy rule&lt;/i&gt; that lets you reliably determine which<a name="line.4828"></a>
<FONT color="green">4829</FONT>           * one. So, don't do that. Instead, if you want to use the same widget for<a name="line.4829"></a>
<FONT color="green">4830</FONT>           * two different annotations, use two identical but distinct copies of<a name="line.4830"></a>
<FONT color="green">4831</FONT>           * that widget. Similarly, if you want to move a single widget annotation<a name="line.4831"></a>
<FONT color="green">4832</FONT>           * from one point to another, be sure to "&lt;tt&gt;null&lt;/tt&gt; out" the first<a name="line.4832"></a>
<FONT color="green">4833</FONT>           * point's annotation (e.g. via &lt;tt&gt;setAnnotationWidget(null)&lt;/tt&gt;) or the<a name="line.4833"></a>
<FONT color="green">4834</FONT>           * widget may not be rendered where you expect. You should also<a name="line.4834"></a>
<FONT color="green">4835</FONT>           * &lt;tt&gt;null&lt;/tt&gt; out the annotation widget reference before moving the<a name="line.4835"></a>
<FONT color="green">4836</FONT>           * annotation widget to a position in the DOM completely outside of the<a name="line.4836"></a>
<FONT color="green">4837</FONT>           * GChart. This required extra bookkeeping on your part makes it possible to<a name="line.4837"></a>
<FONT color="green">4838</FONT>           * significantly simplify and streamline GChart's rendering algorithms.<a name="line.4838"></a>
<FONT color="green">4839</FONT>           * <a name="line.4839"></a>
<FONT color="green">4840</FONT>           * @param annotationWidget<a name="line.4840"></a>
<FONT color="green">4841</FONT>           *          the GWT Widget that defines this point's annotation.<a name="line.4841"></a>
<FONT color="green">4842</FONT>           * <a name="line.4842"></a>
<FONT color="green">4843</FONT>           * @param widthUpperBound<a name="line.4843"></a>
<FONT color="green">4844</FONT>           *          an upper bound on the width of the Widget, in pixels. If this<a name="line.4844"></a>
<FONT color="green">4845</FONT>           *          and the next parameter are omitted, GChart will use<a name="line.4845"></a>
<FONT color="green">4846</FONT>           *          &lt;tt&gt;DEFAULT_WIDGET_WIDTH_UPPERBOUND&lt;/tt&gt;.<a name="line.4846"></a>
<FONT color="green">4847</FONT>           * <a name="line.4847"></a>
<FONT color="green">4848</FONT>           * @param heightUpperBound<a name="line.4848"></a>
<FONT color="green">4849</FONT>           *          an upper bound on the height of the Widget, in pixels. If this<a name="line.4849"></a>
<FONT color="green">4850</FONT>           *          and the previous parameter are omitted, GChart will use<a name="line.4850"></a>
<FONT color="green">4851</FONT>           *          &lt;tt&gt;DEFAULT_WIDGET_HEIGHT_UPPERBOUND&lt;/tt&gt;<a name="line.4851"></a>
<FONT color="green">4852</FONT>           * <a name="line.4852"></a>
<FONT color="green">4853</FONT>           * @see #getAnnotationWidget getAnnotationWidget<a name="line.4853"></a>
<FONT color="green">4854</FONT>           * @see #setAnnotationText(String, int, int)<a name="line.4854"></a>
<FONT color="green">4855</FONT>           *      setAnnotationText(String,int,int)<a name="line.4855"></a>
<FONT color="green">4856</FONT>           * @see #setAnnotationWidget(Widget) setAnnotationWidget(Widget)<a name="line.4856"></a>
<FONT color="green">4857</FONT>           * @see #DEFAULT_WIDGET_HEIGHT_UPPERBOUND DEFAULT_WIDGET_HEIGHT_UPPERBOUND<a name="line.4857"></a>
<FONT color="green">4858</FONT>           * @see #DEFAULT_WIDGET_WIDTH_UPPERBOUND DEFAULT_WIDGET_WIDTH_UPPERBOUND<a name="line.4858"></a>
<FONT color="green">4859</FONT>           * @see SymbolType#NONE SymbolType.NONE<a name="line.4859"></a>
<FONT color="green">4860</FONT>           * <a name="line.4860"></a>
<FONT color="green">4861</FONT>           */<a name="line.4861"></a>
<FONT color="green">4862</FONT>          public void setAnnotationWidget(Widget annotationWidget,<a name="line.4862"></a>
<FONT color="green">4863</FONT>              int widthUpperBound, int heightUpperBound) {<a name="line.4863"></a>
<FONT color="green">4864</FONT>            getParent().invalidate();<a name="line.4864"></a>
<FONT color="green">4865</FONT>            if (null == annotation)<a name="line.4865"></a>
<FONT color="green">4866</FONT>              annotation = new Annotation();<a name="line.4866"></a>
<FONT color="green">4867</FONT>            // accept "Not an Integer" (because setAnnotationText does)<a name="line.4867"></a>
<FONT color="green">4868</FONT>            if (widthUpperBound == GChart.NAI)<a name="line.4868"></a>
<FONT color="green">4869</FONT>              widthUpperBound = DEFAULT_WIDGET_WIDTH_UPPERBOUND;<a name="line.4869"></a>
<FONT color="green">4870</FONT>            if (heightUpperBound == GChart.NAI)<a name="line.4870"></a>
<FONT color="green">4871</FONT>              heightUpperBound = DEFAULT_WIDGET_HEIGHT_UPPERBOUND;<a name="line.4871"></a>
<FONT color="green">4872</FONT>            annotation.setWidget(annotationWidget, widthUpperBound,<a name="line.4872"></a>
<FONT color="green">4873</FONT>                heightUpperBound);<a name="line.4873"></a>
<FONT color="green">4874</FONT>          }<a name="line.4874"></a>
<FONT color="green">4875</FONT>    <a name="line.4875"></a>
<FONT color="green">4876</FONT>          /**<a name="line.4876"></a>
<FONT color="green">4877</FONT>           * Specifies a widget defining this point's annotation.<a name="line.4877"></a>
<FONT color="green">4878</FONT>           * &lt;p&gt;<a name="line.4878"></a>
<FONT color="green">4879</FONT>           * <a name="line.4879"></a>
<FONT color="green">4880</FONT>           * A convenience method equivalent to<a name="line.4880"></a>
<FONT color="green">4881</FONT>           * &lt;tt&gt;setAnnotationWidget(annotationWidget,<a name="line.4881"></a>
<FONT color="green">4882</FONT>           * DEFAULT_WIDGET_WIDTH_UPPERBOUND,<a name="line.4882"></a>
<FONT color="green">4883</FONT>           * DEFAULT_WIDGET_HEIGHT_UPPERBOUND)&lt;/tt&gt;<a name="line.4883"></a>
<FONT color="green">4884</FONT>           * <a name="line.4884"></a>
<FONT color="green">4885</FONT>           * @param annotationWidget<a name="line.4885"></a>
<FONT color="green">4886</FONT>           *          the GWT Widget that defines this point's annotation.<a name="line.4886"></a>
<FONT color="green">4887</FONT>           * <a name="line.4887"></a>
<FONT color="green">4888</FONT>           * @see #setAnnotationWidget(Widget,int,int)<a name="line.4888"></a>
<FONT color="green">4889</FONT>           *      setAnnotationWidget(Widget,int,int)<a name="line.4889"></a>
<FONT color="green">4890</FONT>           * @see #DEFAULT_WIDGET_HEIGHT_UPPERBOUND DEFAULT_WIDGET_HEIGHT_UPPERBOUND<a name="line.4890"></a>
<FONT color="green">4891</FONT>           * @see #DEFAULT_WIDGET_WIDTH_UPPERBOUND DEFAULT_WIDGET_WIDTH_UPPERBOUND<a name="line.4891"></a>
<FONT color="green">4892</FONT>           * <a name="line.4892"></a>
<FONT color="green">4893</FONT>           */<a name="line.4893"></a>
<FONT color="green">4894</FONT>          public void setAnnotationWidget(Widget annotationWidget) {<a name="line.4894"></a>
<FONT color="green">4895</FONT>            setAnnotationWidget(annotationWidget,<a name="line.4895"></a>
<FONT color="green">4896</FONT>                DEFAULT_WIDGET_WIDTH_UPPERBOUND,<a name="line.4896"></a>
<FONT color="green">4897</FONT>                DEFAULT_WIDGET_HEIGHT_UPPERBOUND);<a name="line.4897"></a>
<FONT color="green">4898</FONT>          }<a name="line.4898"></a>
<FONT color="green">4899</FONT>    <a name="line.4899"></a>
<FONT color="green">4900</FONT>          /**<a name="line.4900"></a>
<FONT color="green">4901</FONT>           * Specifies if this point's annotation (label) is visible or not.<a name="line.4901"></a>
<FONT color="green">4902</FONT>           * &lt;p&gt;<a name="line.4902"></a>
<FONT color="green">4903</FONT>           * <a name="line.4903"></a>
<FONT color="green">4904</FONT>           * @param isVisible<a name="line.4904"></a>
<FONT color="green">4905</FONT>           *          use true to make the annotation visible, or false to hide it.<a name="line.4905"></a>
<FONT color="green">4906</FONT>           * <a name="line.4906"></a>
<FONT color="green">4907</FONT>           * @see #getAnnotationVisible getAnnotationVisible<a name="line.4907"></a>
<FONT color="green">4908</FONT>           * @see #setAnnotationLocation setAnnotationLocation<a name="line.4908"></a>
<FONT color="green">4909</FONT>           * @see #setAnnotationFontWeight setAnnotationFontWeight<a name="line.4909"></a>
<FONT color="green">4910</FONT>           * @see #setAnnotationFontColor setAnnotationFontColor<a name="line.4910"></a>
<FONT color="green">4911</FONT>           * @see #setAnnotationFontStyle setAnnotationFontStyle<a name="line.4911"></a>
<FONT color="green">4912</FONT>           * @see #setAnnotationFontSize setAnnotationFontSize<a name="line.4912"></a>
<FONT color="green">4913</FONT>           * @see #setAnnotationXShift setAnnotationXShift<a name="line.4913"></a>
<FONT color="green">4914</FONT>           * @see #setAnnotationYShift setAnnotationYShift<a name="line.4914"></a>
<FONT color="green">4915</FONT>           * @see #setAnnotationText setAnnotationText<a name="line.4915"></a>
<FONT color="green">4916</FONT>           */<a name="line.4916"></a>
<FONT color="green">4917</FONT>          public void setAnnotationVisible(boolean isVisible) {<a name="line.4917"></a>
<FONT color="green">4918</FONT>            getParent().invalidate();<a name="line.4918"></a>
<FONT color="green">4919</FONT>            if (null == annotation)<a name="line.4919"></a>
<FONT color="green">4920</FONT>              annotation = new Annotation();<a name="line.4920"></a>
<FONT color="green">4921</FONT>            annotation.setVisible(isVisible);<a name="line.4921"></a>
<FONT color="green">4922</FONT>          }<a name="line.4922"></a>
<FONT color="green">4923</FONT>    <a name="line.4923"></a>
<FONT color="green">4924</FONT>          /**<a name="line.4924"></a>
<FONT color="green">4925</FONT>           * Specifies the number of pixels (along the x-axis) to move this point's<a name="line.4925"></a>
<FONT color="green">4926</FONT>           * annotation from its default, &lt;tt&gt;AnnotationLocation&lt;/tt&gt; defined,<a name="line.4926"></a>
<FONT color="green">4927</FONT>           * position. Negative values move the annotation in the negative x<a name="line.4927"></a>
<FONT color="green">4928</FONT>           * direction.<a name="line.4928"></a>
<FONT color="green">4929</FONT>           * &lt;p&gt;<a name="line.4929"></a>
<FONT color="green">4930</FONT>           * <a name="line.4930"></a>
<FONT color="green">4931</FONT>           * For example, with the default &lt;tt&gt;xShift&lt;/tt&gt; of 0, annotations with an<a name="line.4931"></a>
<FONT color="green">4932</FONT>           * &lt;tt&gt;AnnotationLocation&lt;/tt&gt; of &lt;tt&gt;EAST&lt;/tt&gt; will have their left edges<a name="line.4932"></a>
<FONT color="green">4933</FONT>           * flush against the right edge of, say, a box symbol representing the<a name="line.4933"></a>
<FONT color="green">4934</FONT>           * annotated point. You could use an &lt;tt&gt;xShift&lt;/tt&gt; setting of 10 to move<a name="line.4934"></a>
<FONT color="green">4935</FONT>           * the annotation 10 pixels to the right and thus introduce some space<a name="line.4935"></a>
<FONT color="green">4936</FONT>           * between the annotation and the box.<a name="line.4936"></a>
<FONT color="green">4937</FONT>           * &lt;p&gt;<a name="line.4937"></a>
<FONT color="green">4938</FONT>           * <a name="line.4938"></a>
<FONT color="green">4939</FONT>           * &lt;i&gt;Special convention for pie slices:&lt;/i&gt; Points on curves whose<a name="line.4939"></a>
<FONT color="green">4940</FONT>           * symbols represent pie slices always have the positive x-axis associated<a name="line.4940"></a>
<FONT color="green">4941</FONT>           * with the shifts specified by this method aligned with the<a name="line.4941"></a>
<FONT color="green">4942</FONT>           * outward-pointing pie radius that bisects the pie slice. This convention<a name="line.4942"></a>
<FONT color="green">4943</FONT>           * makes it easy to move pie slice annotations radially outward (via<a name="line.4943"></a>
<FONT color="green">4944</FONT>           * &lt;tt&gt;xShift &gt; 0&lt;/tt&gt;) or radially inward (via &lt;tt&gt;xShift &lt; 0&lt;/tt&gt;). For<a name="line.4944"></a>
<FONT color="green">4945</FONT>           * those rare situations where you may need to move a pie annotation<a name="line.4945"></a>
<FONT color="green">4946</FONT>           * perpendicularly to this radius, use &lt;tt&gt;setAnnotationYShift&lt;/tt&gt;.<a name="line.4946"></a>
<FONT color="green">4947</FONT>           * <a name="line.4947"></a>
<FONT color="green">4948</FONT>           * @param xShift<a name="line.4948"></a>
<FONT color="green">4949</FONT>           *          number of pixels to move annotation along the x axis from it's<a name="line.4949"></a>
<FONT color="green">4950</FONT>           *          default, &lt;tt&gt;AnnotationLocation&lt;/tt&gt; defined, location.<a name="line.4950"></a>
<FONT color="green">4951</FONT>           * <a name="line.4951"></a>
<FONT color="green">4952</FONT>           * @see #setAnnotationYShift setAnnotationYShift<a name="line.4952"></a>
<FONT color="green">4953</FONT>           * @see #setAnnotationLocation setAnnotationLocation<a name="line.4953"></a>
<FONT color="green">4954</FONT>           * @see #setAnnotationFontWeight setAnnotationFontWeight<a name="line.4954"></a>
<FONT color="green">4955</FONT>           * @see #setAnnotationFontColor setAnnotationFontColor<a name="line.4955"></a>
<FONT color="green">4956</FONT>           * @see #setAnnotationFontStyle setAnnotationFontStyle<a name="line.4956"></a>
<FONT color="green">4957</FONT>           * @see #setAnnotationFontSize setAnnotationFontSize<a name="line.4957"></a>
<FONT color="green">4958</FONT>           * @see #setAnnotationText setAnnotationText<a name="line.4958"></a>
<FONT color="green">4959</FONT>           * @see #setAnnotationVisible setAnnotationVisible<a name="line.4959"></a>
<FONT color="green">4960</FONT>           * @see #getAnnotationXShift getAnnotationXShift<a name="line.4960"></a>
<FONT color="green">4961</FONT>           */<a name="line.4961"></a>
<FONT color="green">4962</FONT>          public void setAnnotationXShift(int xShift) {<a name="line.4962"></a>
<FONT color="green">4963</FONT>            getParent().invalidate();<a name="line.4963"></a>
<FONT color="green">4964</FONT>            if (null == annotation)<a name="line.4964"></a>
<FONT color="green">4965</FONT>              annotation = new Annotation();<a name="line.4965"></a>
<FONT color="green">4966</FONT>            annotation.setXShift(xShift);<a name="line.4966"></a>
<FONT color="green">4967</FONT>          }<a name="line.4967"></a>
<FONT color="green">4968</FONT>    <a name="line.4968"></a>
<FONT color="green">4969</FONT>          /**<a name="line.4969"></a>
<FONT color="green">4970</FONT>           * Specifies the number of pixels (along the y-axis) to move this point's<a name="line.4970"></a>
<FONT color="green">4971</FONT>           * annotation from its default, &lt;tt&gt;AnnotationLocation&lt;/tt&gt; defined,<a name="line.4971"></a>
<FONT color="green">4972</FONT>           * position. Negative values move the annotation in the negative y<a name="line.4972"></a>
<FONT color="green">4973</FONT>           * direction.<a name="line.4973"></a>
<FONT color="green">4974</FONT>           * <a name="line.4974"></a>
<FONT color="green">4975</FONT>           * &lt;p&gt;<a name="line.4975"></a>
<FONT color="green">4976</FONT>           * For example, with the default &lt;tt&gt;yShift&lt;/tt&gt; of 0, annotations with an<a name="line.4976"></a>
<FONT color="green">4977</FONT>           * &lt;tt&gt;AnnotationLocation&lt;/tt&gt; of &lt;tt&gt;SOUTH&lt;/tt&gt; will have their top edges<a name="line.4977"></a>
<FONT color="green">4978</FONT>           * flush against the bottom edge of, say, a box symbol representing the<a name="line.4978"></a>
<FONT color="green">4979</FONT>           * annotated point. You could use a &lt;tt&gt;yShift&lt;/tt&gt; setting of -10 to move<a name="line.4979"></a>
<FONT color="green">4980</FONT>           * the annotation down 10 pixels and thus introduce some spacing between<a name="line.4980"></a>
<FONT color="green">4981</FONT>           * the annotation and the box.<a name="line.4981"></a>
<FONT color="green">4982</FONT>           * &lt;p&gt;<a name="line.4982"></a>
<FONT color="green">4983</FONT>           * <a name="line.4983"></a>
<FONT color="green">4984</FONT>           * &lt;i&gt;Special convention for pie slices:&lt;/i&gt; The positive y-axis for pie<a name="line.4984"></a>
<FONT color="green">4985</FONT>           * slices always points one 90 degree counter-clockwise rotation from the<a name="line.4985"></a>
<FONT color="green">4986</FONT>           * direction of the outward-pointing pie radius that bisects the pie<a name="line.4986"></a>
<FONT color="green">4987</FONT>           * slice. This convention means that &lt;tt&gt;yShift&lt;/tt&gt; moves pie slice<a name="line.4987"></a>
<FONT color="green">4988</FONT>           * annotations along a line &lt;i&gt;perpendicular to&lt;/i&gt; this bisecting pie<a name="line.4988"></a>
<FONT color="green">4989</FONT>           * radius. Use the companion method &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; for the<a name="line.4989"></a>
<FONT color="green">4990</FONT>           * more common operation of moving the annotation along this bisecting<a name="line.4990"></a>
<FONT color="green">4991</FONT>           * radius.<a name="line.4991"></a>
<FONT color="green">4992</FONT>           * &lt;p&gt;<a name="line.4992"></a>
<FONT color="green">4993</FONT>           * <a name="line.4993"></a>
<FONT color="green">4994</FONT>           * @param yShift<a name="line.4994"></a>
<FONT color="green">4995</FONT>           *          number of pixels to move annotation along the y-axis from it's<a name="line.4995"></a>
<FONT color="green">4996</FONT>           *          default, &lt;tt&gt;AnnotationLocation&lt;/tt&gt; defined, location.<a name="line.4996"></a>
<FONT color="green">4997</FONT>           * <a name="line.4997"></a>
<FONT color="green">4998</FONT>           * @see #setAnnotationXShift setAnnotationXShift<a name="line.4998"></a>
<FONT color="green">4999</FONT>           * @see #setAnnotationLocation setAnnotationLocation<a name="line.4999"></a>
<FONT color="green">5000</FONT>           * @see #setAnnotationFontWeight setAnnotationFontWeight<a name="line.5000"></a>
<FONT color="green">5001</FONT>           * @see #setAnnotationFontColor setAnnotationFontColor<a name="line.5001"></a>
<FONT color="green">5002</FONT>           * @see #setAnnotationFontStyle setAnnotationFontStyle<a name="line.5002"></a>
<FONT color="green">5003</FONT>           * @see #setAnnotationFontSize setAnnotationFontSize<a name="line.5003"></a>
<FONT color="green">5004</FONT>           * @see #setAnnotationText setAnnotationText<a name="line.5004"></a>
<FONT color="green">5005</FONT>           * @see #setAnnotationVisible setAnnotationVisible<a name="line.5005"></a>
<FONT color="green">5006</FONT>           * @see #getAnnotationXShift getAnnotationXShift<a name="line.5006"></a>
<FONT color="green">5007</FONT>           * <a name="line.5007"></a>
<FONT color="green">5008</FONT>           */<a name="line.5008"></a>
<FONT color="green">5009</FONT>          public void setAnnotationYShift(int yShift) {<a name="line.5009"></a>
<FONT color="green">5010</FONT>            getParent().invalidate();<a name="line.5010"></a>
<FONT color="green">5011</FONT>            if (null == annotation)<a name="line.5011"></a>
<FONT color="green">5012</FONT>              annotation = new Annotation();<a name="line.5012"></a>
<FONT color="green">5013</FONT>            annotation.setYShift(yShift);<a name="line.5013"></a>
<FONT color="green">5014</FONT>          }<a name="line.5014"></a>
<FONT color="green">5015</FONT>    <a name="line.5015"></a>
<FONT color="green">5016</FONT>          /**<a name="line.5016"></a>
<FONT color="green">5017</FONT>           * Defines the x-coordinate of this point in "model units" (arbitrary,<a name="line.5017"></a>
<FONT color="green">5018</FONT>           * application-specific, units mapped to the horizontal dimension of the<a name="line.5018"></a>
<FONT color="green">5019</FONT>           * plot area).<a name="line.5019"></a>
<FONT color="green">5020</FONT>           * &lt;p&gt;<a name="line.5020"></a>
<FONT color="green">5021</FONT>           * <a name="line.5021"></a>
<FONT color="green">5022</FONT>           * &lt;tt&gt;Double.NaN&lt;/tt&gt;, &lt;tt&gt;Double.MAX_VALUE&lt;/tt&gt;, and<a name="line.5022"></a>
<FONT color="green">5023</FONT>           * &lt;tt&gt;-Double.MAX_VALUE&lt;/tt&gt; have special meanings. See the<a name="line.5023"></a>
<FONT color="green">5024</FONT>           * &lt;tt&gt;addPoint&lt;/tt&gt; method for details.<a name="line.5024"></a>
<FONT color="green">5025</FONT>           * &lt;p&gt;<a name="line.5025"></a>
<FONT color="green">5026</FONT>           * <a name="line.5026"></a>
<FONT color="green">5027</FONT>           * @param x<a name="line.5027"></a>
<FONT color="green">5028</FONT>           *          the x-coordinate of the point in model units.<a name="line.5028"></a>
<FONT color="green">5029</FONT>           * <a name="line.5029"></a>
<FONT color="green">5030</FONT>           * @see #getX getX<a name="line.5030"></a>
<FONT color="green">5031</FONT>           * @see #setY setY<a name="line.5031"></a>
<FONT color="green">5032</FONT>           * @see #getY getY<a name="line.5032"></a>
<FONT color="green">5033</FONT>           * @see #addPoint(double, double) addPoint<a name="line.5033"></a>
<FONT color="green">5034</FONT>           */<a name="line.5034"></a>
<FONT color="green">5035</FONT>          public void setX(double x) {<a name="line.5035"></a>
<FONT color="green">5036</FONT>            getParent().invalidate();<a name="line.5036"></a>
<FONT color="green">5037</FONT>            this.x = x;<a name="line.5037"></a>
<FONT color="green">5038</FONT>          }<a name="line.5038"></a>
<FONT color="green">5039</FONT>    <a name="line.5039"></a>
<FONT color="green">5040</FONT>          /**<a name="line.5040"></a>
<FONT color="green">5041</FONT>           * Defines the y-coordinate of this point in "model units" (arbitrary,<a name="line.5041"></a>
<FONT color="green">5042</FONT>           * application-specific, units mapped to the vertical dimension of the<a name="line.5042"></a>
<FONT color="green">5043</FONT>           * plot area).<a name="line.5043"></a>
<FONT color="green">5044</FONT>           * &lt;p&gt;<a name="line.5044"></a>
<FONT color="green">5045</FONT>           * <a name="line.5045"></a>
<FONT color="green">5046</FONT>           * &lt;tt&gt;Double.NaN&lt;/tt&gt;, &lt;tt&gt;Double.MAX_VALUE&lt;/tt&gt;, and<a name="line.5046"></a>
<FONT color="green">5047</FONT>           * &lt;tt&gt;-Double.MAX_VALUE&lt;/tt&gt; have special meanings. See the<a name="line.5047"></a>
<FONT color="green">5048</FONT>           * &lt;tt&gt;addPoint&lt;/tt&gt; method for details.<a name="line.5048"></a>
<FONT color="green">5049</FONT>           * &lt;p&gt;<a name="line.5049"></a>
<FONT color="green">5050</FONT>           * <a name="line.5050"></a>
<FONT color="green">5051</FONT>           * @param y<a name="line.5051"></a>
<FONT color="green">5052</FONT>           *          the y-coordinate of the point in model units.<a name="line.5052"></a>
<FONT color="green">5053</FONT>           * <a name="line.5053"></a>
<FONT color="green">5054</FONT>           * @see #getX getX<a name="line.5054"></a>
<FONT color="green">5055</FONT>           * @see #setX setX<a name="line.5055"></a>
<FONT color="green">5056</FONT>           * @see #getY getY<a name="line.5056"></a>
<FONT color="green">5057</FONT>           * @see #addPoint(double, double) addPoint<a name="line.5057"></a>
<FONT color="green">5058</FONT>           * <a name="line.5058"></a>
<FONT color="green">5059</FONT>           */<a name="line.5059"></a>
<FONT color="green">5060</FONT>          public void setY(double y) {<a name="line.5060"></a>
<FONT color="green">5061</FONT>            getParent().invalidate();<a name="line.5061"></a>
<FONT color="green">5062</FONT>            this.y = y;<a name="line.5062"></a>
<FONT color="green">5063</FONT>          }<a name="line.5063"></a>
<FONT color="green">5064</FONT>    <a name="line.5064"></a>
<FONT color="green">5065</FONT>          Annotation getAnnotation() {<a name="line.5065"></a>
<FONT color="green">5066</FONT>            if (annotation == null)<a name="line.5066"></a>
<FONT color="green">5067</FONT>              annotation = new Annotation();<a name="line.5067"></a>
<FONT color="green">5068</FONT>            return annotation;<a name="line.5068"></a>
<FONT color="green">5069</FONT>          }<a name="line.5069"></a>
<FONT color="green">5070</FONT>    <a name="line.5070"></a>
<FONT color="green">5071</FONT>          /**<a name="line.5071"></a>
<FONT color="green">5072</FONT>           * Retrieves the expanded hovertext associated with this point.<a name="line.5072"></a>
<FONT color="green">5073</FONT>           * &lt;p&gt;<a name="line.5073"></a>
<FONT color="green">5074</FONT>           * <a name="line.5074"></a>
<FONT color="green">5075</FONT>           * The expanded hovertext is obtained by replacing any embedded parameters<a name="line.5075"></a>
<FONT color="green">5076</FONT>           * in the hovertext template with their values as evaluated at this point.<a name="line.5076"></a>
<FONT color="green">5077</FONT>           * For example, references to &lt;tt&gt;${x}&lt;/tt&gt; and &lt;tt&gt;${y}&lt;/tt&gt; in the<a name="line.5077"></a>
<FONT color="green">5078</FONT>           * hovertext template are replaced with appropriately formatted<a name="line.5078"></a>
<FONT color="green">5079</FONT>           * representations of this point's x and y properties.<a name="line.5079"></a>
<FONT color="green">5080</FONT>           * &lt;p&gt;<a name="line.5080"></a>
<FONT color="green">5081</FONT>           * <a name="line.5081"></a>
<FONT color="green">5082</FONT>           * By default, GChart will display this expanded hovertext whenever the<a name="line.5082"></a>
<FONT color="green">5083</FONT>           * user "touches" a point with the curve-specific, rectangular,<a name="line.5083"></a>
<FONT color="green">5084</FONT>           * mouse-centered, brush.<a name="line.5084"></a>
<FONT color="green">5085</FONT>           * &lt;p&gt;<a name="line.5085"></a>
<FONT color="green">5086</FONT>           * <a name="line.5086"></a>
<FONT color="green">5087</FONT>           * &lt;i&gt;Tip:&lt;/i&gt; To define your own custom parameter names that can be<a name="line.5087"></a>
<FONT color="green">5088</FONT>           * embedded within hovertext templates and will be interpreted/expanded<a name="line.5088"></a>
<FONT color="green">5089</FONT>           * relative to the touched point, use the<a name="line.5089"></a>
<FONT color="green">5090</FONT>           * &lt;tt&gt;setHoverParameterInterpreter&lt;/tt&gt; method.<a name="line.5090"></a>
<FONT color="green">5091</FONT>           * &lt;p&gt;<a name="line.5091"></a>
<FONT color="green">5092</FONT>           * <a name="line.5092"></a>
<FONT color="green">5093</FONT>           * @return the expanded hover text associated with this point.<a name="line.5093"></a>
<FONT color="green">5094</FONT>           * <a name="line.5094"></a>
<FONT color="green">5095</FONT>           * @see Symbol#setHovertextTemplate setHovertextTemplate<a name="line.5095"></a>
<FONT color="green">5096</FONT>           * @see #setHoverParameterInterpreter setHoverParameterInterpreter<a name="line.5096"></a>
<FONT color="green">5097</FONT>           * <a name="line.5097"></a>
<FONT color="green">5098</FONT>           */<a name="line.5098"></a>
<FONT color="green">5099</FONT>          public String getHovertext() {<a name="line.5099"></a>
<FONT color="green">5100</FONT>            String result = HovertextChunk.getHovertext(getParent()<a name="line.5100"></a>
<FONT color="green">5101</FONT>                .getSymbol().getHovertextChunks(), this);<a name="line.5101"></a>
<FONT color="green">5102</FONT>            return result;<a name="line.5102"></a>
<FONT color="green">5103</FONT>          }<a name="line.5103"></a>
<FONT color="green">5104</FONT>    <a name="line.5104"></a>
<FONT color="green">5105</FONT>        } // end of class GChart.Curve.Point<a name="line.5105"></a>
<FONT color="green">5106</FONT>    <a name="line.5106"></a>
<FONT color="green">5107</FONT>        /*<a name="line.5107"></a>
<FONT color="green">5108</FONT>         * Declares that this curve's rendering panel (its DOM representation) is<a name="line.5108"></a>
<FONT color="green">5109</FONT>         * inconsistent with its current curve specifications.<a name="line.5109"></a>
<FONT color="green">5110</FONT>         * &lt;p&gt;<a name="line.5110"></a>
<FONT color="green">5111</FONT>         * <a name="line.5111"></a>
<FONT color="green">5112</FONT>         * Sets the flag &lt;tt&gt;update&lt;/tt&gt; uses to determine if a curve needs to be<a name="line.5112"></a>
<FONT color="green">5113</FONT>         * re-rendered. &lt;p&gt;<a name="line.5113"></a>
<FONT color="green">5114</FONT>         */<a name="line.5114"></a>
<FONT color="green">5115</FONT>        void invalidate() {<a name="line.5115"></a>
<FONT color="green">5116</FONT>          /*<a name="line.5116"></a>
<FONT color="green">5117</FONT>           * This guard isn't just for speed; it keeps us out of trouble<a name="line.5117"></a>
<FONT color="green">5118</FONT>           * when the system curves are being added/configured initially.<a name="line.5118"></a>
<FONT color="green">5119</FONT>           *<a name="line.5119"></a>
<FONT color="green">5120</FONT>           */ <a name="line.5120"></a>
<FONT color="green">5121</FONT>          if (isValidated) {<a name="line.5121"></a>
<FONT color="green">5122</FONT>            isValidated = false;<a name="line.5122"></a>
<FONT color="green">5123</FONT>            /*<a name="line.5123"></a>
<FONT color="green">5124</FONT>             * For efficiency, all background curves share one rendering<a name="line.5124"></a>
<FONT color="green">5125</FONT>             * panel, so invalidating one such curve invalidates them all.<a name="line.5125"></a>
<FONT color="green">5126</FONT>             *<a name="line.5126"></a>
<FONT color="green">5127</FONT>             */ <a name="line.5127"></a>
<FONT color="green">5128</FONT>            if (indexOf &lt; N_PRE_SYSTEM_CURVES) {<a name="line.5128"></a>
<FONT color="green">5129</FONT>              for (int i = 0; i &lt; N_PRE_SYSTEM_CURVES; i++)<a name="line.5129"></a>
<FONT color="green">5130</FONT>                curves.get(i).isValidated = false;<a name="line.5130"></a>
<FONT color="green">5131</FONT>            }<a name="line.5131"></a>
<FONT color="green">5132</FONT>          }<a name="line.5132"></a>
<FONT color="green">5133</FONT>        }<a name="line.5133"></a>
<FONT color="green">5134</FONT>    <a name="line.5134"></a>
<FONT color="green">5135</FONT>        /*<a name="line.5135"></a>
<FONT color="green">5136</FONT>         * Smallest rectangle containing curve's graphics (ignoring annotations) &lt;p&gt;<a name="line.5136"></a>
<FONT color="green">5137</FONT>         * <a name="line.5137"></a>
<FONT color="green">5138</FONT>         * Each curve has it's own canvas to allow for fast, single curve, updates<a name="line.5138"></a>
<FONT color="green">5139</FONT>         * (and we hope this rendering independence will facilitate additional<a name="line.5139"></a>
<FONT color="green">5140</FONT>         * features in future releases). So, we have to economize on canvas size.<a name="line.5140"></a>
<FONT color="green">5141</FONT>         * Moreover, because we allow rendering outside of the decorated chart<a name="line.5141"></a>
<FONT color="green">5142</FONT>         * region, we can't just set the size of the canvas to the size of the plot<a name="line.5142"></a>
<FONT color="green">5143</FONT>         * area or decorated chart (even if we could afford to do that,<a name="line.5143"></a>
<FONT color="green">5144</FONT>         * memory-wise).<a name="line.5144"></a>
<FONT color="green">5145</FONT>         * &lt;p&gt;<a name="line.5145"></a>
<FONT color="green">5146</FONT>         *<a name="line.5146"></a>
<FONT color="green">5147</FONT>         * Rectangle is in plot-area pixel coordinates.<a name="line.5147"></a>
<FONT color="green">5148</FONT>         * <a name="line.5148"></a>
<FONT color="green">5149</FONT>         */<a name="line.5149"></a>
<FONT color="green">5150</FONT>        Rectangle getContainingRectangle(PlotPanel pp) {<a name="line.5150"></a>
<FONT color="green">5151</FONT>          final Rectangle result = new Rectangle();<a name="line.5151"></a>
<FONT color="green">5152</FONT>          if (getNPoints() == 0) {<a name="line.5152"></a>
<FONT color="green">5153</FONT>            result.x = result.y = result.width = result.height = 0;<a name="line.5153"></a>
<FONT color="green">5154</FONT>            return result;<a name="line.5154"></a>
<FONT color="green">5155</FONT>          }<a name="line.5155"></a>
<FONT color="green">5156</FONT>    <a name="line.5156"></a>
<FONT color="green">5157</FONT>          double minX = Double.MAX_VALUE;<a name="line.5157"></a>
<FONT color="green">5158</FONT>          double maxX = -Double.MAX_VALUE;<a name="line.5158"></a>
<FONT color="green">5159</FONT>          double minY = Double.MAX_VALUE;<a name="line.5159"></a>
<FONT color="green">5160</FONT>          double maxY = -Double.MAX_VALUE;<a name="line.5160"></a>
<FONT color="green">5161</FONT>          // do keyword-positioned points exist on this curve?<a name="line.5161"></a>
<FONT color="green">5162</FONT>          boolean pointAtXAxisMin = false; <a name="line.5162"></a>
<FONT color="green">5163</FONT>          boolean pointAtXAxisMax = false; <a name="line.5163"></a>
<FONT color="green">5164</FONT>          boolean pointAtYAxisMin = false;<a name="line.5164"></a>
<FONT color="green">5165</FONT>          boolean pointAtYAxisMax = false;<a name="line.5165"></a>
<FONT color="green">5166</FONT>          boolean isClippedToDecoratedChart = getClipToDecoratedChart();<a name="line.5166"></a>
<FONT color="green">5167</FONT>          boolean isClippedToPlotArea = getClippedToPlotArea();<a name="line.5167"></a>
<FONT color="green">5168</FONT>          boolean onY2 = onY2();<a name="line.5168"></a>
<FONT color="green">5169</FONT>          // Find min, max for x,y and record each keyword position used<a name="line.5169"></a>
<FONT color="green">5170</FONT>          int nPoints = getNPoints();<a name="line.5170"></a>
<FONT color="green">5171</FONT>          for (int i = 0; i &lt; nPoints; i++) {<a name="line.5171"></a>
<FONT color="green">5172</FONT>            Point p = getPoint(i);<a name="line.5172"></a>
<FONT color="green">5173</FONT>            double x = p.getX();<a name="line.5173"></a>
<FONT color="green">5174</FONT>            double y = p.getY();<a name="line.5174"></a>
<FONT color="green">5175</FONT>            if ((x != x) || (y != y) || // x!=x is a faster isNaN<a name="line.5175"></a>
<FONT color="green">5176</FONT>                plotPanel.isOutOfBounds(x, y, onY2))<a name="line.5176"></a>
<FONT color="green">5177</FONT>              continue;<a name="line.5177"></a>
<FONT color="green">5178</FONT>    <a name="line.5178"></a>
<FONT color="green">5179</FONT>            if (Double.MAX_VALUE == x)<a name="line.5179"></a>
<FONT color="green">5180</FONT>              pointAtXAxisMax = true;<a name="line.5180"></a>
<FONT color="green">5181</FONT>            else if (-Double.MAX_VALUE == x)<a name="line.5181"></a>
<FONT color="green">5182</FONT>              pointAtXAxisMin = true;<a name="line.5182"></a>
<FONT color="green">5183</FONT>            else {<a name="line.5183"></a>
<FONT color="green">5184</FONT>              if (x &lt; minX)<a name="line.5184"></a>
<FONT color="green">5185</FONT>                minX = x;<a name="line.5185"></a>
<FONT color="green">5186</FONT>              if (x &gt; maxX)<a name="line.5186"></a>
<FONT color="green">5187</FONT>                maxX = x;<a name="line.5187"></a>
<FONT color="green">5188</FONT>            }<a name="line.5188"></a>
<FONT color="green">5189</FONT>            if (Double.MAX_VALUE == y)<a name="line.5189"></a>
<FONT color="green">5190</FONT>              pointAtYAxisMax = true;<a name="line.5190"></a>
<FONT color="green">5191</FONT>            else if (-Double.MAX_VALUE == y)<a name="line.5191"></a>
<FONT color="green">5192</FONT>              pointAtYAxisMin = true;<a name="line.5192"></a>
<FONT color="green">5193</FONT>            else {<a name="line.5193"></a>
<FONT color="green">5194</FONT>              if (y &lt; minY)<a name="line.5194"></a>
<FONT color="green">5195</FONT>                minY = y;<a name="line.5195"></a>
<FONT color="green">5196</FONT>              if (y &gt; maxY)<a name="line.5196"></a>
<FONT color="green">5197</FONT>                maxY = y;<a name="line.5197"></a>
<FONT color="green">5198</FONT>            }<a name="line.5198"></a>
<FONT color="green">5199</FONT>          }<a name="line.5199"></a>
<FONT color="green">5200</FONT>    <a name="line.5200"></a>
<FONT color="green">5201</FONT>          // take "at min/max" keywords into account<a name="line.5201"></a>
<FONT color="green">5202</FONT>          if (pointAtXAxisMin) {<a name="line.5202"></a>
<FONT color="green">5203</FONT>            minX = Math.min(minX, pp.getXMin());<a name="line.5203"></a>
<FONT color="green">5204</FONT>            maxX = Math.max(maxX, pp.getXMin());<a name="line.5204"></a>
<FONT color="green">5205</FONT>          }<a name="line.5205"></a>
<FONT color="green">5206</FONT>          if (pointAtXAxisMax) {<a name="line.5206"></a>
<FONT color="green">5207</FONT>            minX = Math.min(minX, pp.getXMax());<a name="line.5207"></a>
<FONT color="green">5208</FONT>            maxX = Math.max(maxX, pp.getXMax());<a name="line.5208"></a>
<FONT color="green">5209</FONT>          }<a name="line.5209"></a>
<FONT color="green">5210</FONT>          if (onY2) {<a name="line.5210"></a>
<FONT color="green">5211</FONT>            if (pointAtYAxisMin) {<a name="line.5211"></a>
<FONT color="green">5212</FONT>              minY = Math.min(minY, pp.getY2Min());<a name="line.5212"></a>
<FONT color="green">5213</FONT>              maxY = Math.max(maxY, pp.getY2Min());<a name="line.5213"></a>
<FONT color="green">5214</FONT>            }<a name="line.5214"></a>
<FONT color="green">5215</FONT>            if (pointAtYAxisMax) {<a name="line.5215"></a>
<FONT color="green">5216</FONT>              minY = Math.min(minY, pp.getY2Max());<a name="line.5216"></a>
<FONT color="green">5217</FONT>              maxY = Math.max(maxY, pp.getY2Max());<a name="line.5217"></a>
<FONT color="green">5218</FONT>            }<a name="line.5218"></a>
<FONT color="green">5219</FONT>          } else {<a name="line.5219"></a>
<FONT color="green">5220</FONT>            if (pointAtYAxisMin) {<a name="line.5220"></a>
<FONT color="green">5221</FONT>              minY = Math.min(minY, pp.getYMin());<a name="line.5221"></a>
<FONT color="green">5222</FONT>              maxY = Math.max(maxY, pp.getYMin());<a name="line.5222"></a>
<FONT color="green">5223</FONT>            }<a name="line.5223"></a>
<FONT color="green">5224</FONT>            if (pointAtYAxisMax) {<a name="line.5224"></a>
<FONT color="green">5225</FONT>              minY = Math.min(minY, pp.getYMax());<a name="line.5225"></a>
<FONT color="green">5226</FONT>              maxY = Math.max(maxY, pp.getYMax());<a name="line.5226"></a>
<FONT color="green">5227</FONT>            }<a name="line.5227"></a>
<FONT color="green">5228</FONT>          }<a name="line.5228"></a>
<FONT color="green">5229</FONT>    <a name="line.5229"></a>
<FONT color="green">5230</FONT>          /*<a name="line.5230"></a>
<FONT color="green">5231</FONT>           * Convert to pixels while taking into account the size of the<a name="line.5231"></a>
<FONT color="green">5232</FONT>           * rendered symbol itself (e.g. pies can stick out from their x,y<a name="line.5232"></a>
<FONT color="green">5233</FONT>           * specified center point, etc.)<a name="line.5233"></a>
<FONT color="green">5234</FONT>           *<a name="line.5234"></a>
<FONT color="green">5235</FONT>           */ <a name="line.5235"></a>
<FONT color="green">5236</FONT>          Symbol sym = getSymbol();<a name="line.5236"></a>
<FONT color="green">5237</FONT>          SymbolType symType = sym.getSymbolType();<a name="line.5237"></a>
<FONT color="green">5238</FONT>          /*<a name="line.5238"></a>
<FONT color="green">5239</FONT>           * Given how baseline bars currently work, they can have negative<a name="line.5239"></a>
<FONT color="green">5240</FONT>           * widths or heights that 'turn the bar inside-out' interchanging<a name="line.5240"></a>
<FONT color="green">5241</FONT>           * the roles of left and right and top and bottom edges. So, we<a name="line.5241"></a>
<FONT color="green">5242</FONT>           * need to check all combinations of min and the max x and y and<a name="line.5242"></a>
<FONT color="green">5243</FONT>           * left and right edge determining methods in order to determine<a name="line.5243"></a>
<FONT color="green">5244</FONT>           * the actual bounding rectangle.<a name="line.5244"></a>
<FONT color="green">5245</FONT>           * <a name="line.5245"></a>
<FONT color="green">5246</FONT>           */ <a name="line.5246"></a>
<FONT color="green">5247</FONT>          double left0 = symType.getEdgeLeft(pp, sym, minX, onY2);<a name="line.5247"></a>
<FONT color="green">5248</FONT>          double left1 = symType.getEdgeLeft(pp, sym, maxX, onY2);<a name="line.5248"></a>
<FONT color="green">5249</FONT>          double right0 = symType.getEdgeRight(pp, sym, minX, onY2);<a name="line.5249"></a>
<FONT color="green">5250</FONT>          double right1 = symType.getEdgeRight(pp, sym, maxX, onY2);<a name="line.5250"></a>
<FONT color="green">5251</FONT>          double bottom0 = symType.getEdgeBottom(pp, sym, minY, onY2);<a name="line.5251"></a>
<FONT color="green">5252</FONT>          double bottom1 = symType.getEdgeBottom(pp, sym, maxY, onY2);<a name="line.5252"></a>
<FONT color="green">5253</FONT>          double top0 = symType.getEdgeTop(pp, sym, minY, onY2);<a name="line.5253"></a>
<FONT color="green">5254</FONT>          double top1 = symType.getEdgeTop(pp, sym, maxY, onY2);<a name="line.5254"></a>
<FONT color="green">5255</FONT>          double xPxMin = Math.min(Math.min(left0, left1),<a name="line.5255"></a>
<FONT color="green">5256</FONT>                                   Math.min(right0,right1));<a name="line.5256"></a>
<FONT color="green">5257</FONT>          double xPxMax = Math.max(Math.max(left0, left1),<a name="line.5257"></a>
<FONT color="green">5258</FONT>                                   Math.max(right0,right1));<a name="line.5258"></a>
<FONT color="green">5259</FONT>          double yPxMin = Math.min(Math.min(bottom0, bottom1),<a name="line.5259"></a>
<FONT color="green">5260</FONT>                                   Math.min(top0,top1));<a name="line.5260"></a>
<FONT color="green">5261</FONT>          double yPxMax = Math.max(Math.max(bottom0, bottom1),<a name="line.5261"></a>
<FONT color="green">5262</FONT>                                   Math.max(top0, top1));<a name="line.5262"></a>
<FONT color="green">5263</FONT>    <a name="line.5263"></a>
<FONT color="green">5264</FONT>          // in obscure cases, canvas could clip without this extra space<a name="line.5264"></a>
<FONT color="green">5265</FONT>          int extraSpace = sym.getFillThickness();<a name="line.5265"></a>
<FONT color="green">5266</FONT>          extraSpace += Math.abs(sym.getBorderWidth());<a name="line.5266"></a>
<FONT color="green">5267</FONT>          double extraXSpace = extraSpace + 0.5 * canvasExpansionFactorX<a name="line.5267"></a>
<FONT color="green">5268</FONT>              * (xPxMax - xPxMin);<a name="line.5268"></a>
<FONT color="green">5269</FONT>          double extraYSpace = extraSpace + 0.5 * canvasExpansionFactorY<a name="line.5269"></a>
<FONT color="green">5270</FONT>              * (yPxMax - yPxMin);<a name="line.5270"></a>
<FONT color="green">5271</FONT>          xPxMin -= extraXSpace;<a name="line.5271"></a>
<FONT color="green">5272</FONT>          xPxMax += extraXSpace;<a name="line.5272"></a>
<FONT color="green">5273</FONT>          yPxMin -= extraYSpace;<a name="line.5273"></a>
<FONT color="green">5274</FONT>          yPxMax += extraYSpace;<a name="line.5274"></a>
<FONT color="green">5275</FONT>          // finally, clip the rectangle, when appropriate<a name="line.5275"></a>
<FONT color="green">5276</FONT>          if (isClippedToPlotArea || isClippedToDecoratedChart) {<a name="line.5276"></a>
<FONT color="green">5277</FONT>            double edge0;<a name="line.5277"></a>
<FONT color="green">5278</FONT>            double edge1;<a name="line.5278"></a>
<FONT color="green">5279</FONT>            double edgeMin;<a name="line.5279"></a>
<FONT color="green">5280</FONT>            double edgeMax;<a name="line.5280"></a>
<FONT color="green">5281</FONT>    <a name="line.5281"></a>
<FONT color="green">5282</FONT>            if (isClippedToPlotArea) {<a name="line.5282"></a>
<FONT color="green">5283</FONT>              edge0 = pp.xToPixel(pp.getXMin());<a name="line.5283"></a>
<FONT color="green">5284</FONT>              edge1 = pp.xToPixel(pp.getXMax());<a name="line.5284"></a>
<FONT color="green">5285</FONT>            } else { // clipped to decorated chart<a name="line.5285"></a>
<FONT color="green">5286</FONT>              edge0 = pp.xToPixel(getXAxis().pixelToModel(0));<a name="line.5286"></a>
<FONT color="green">5287</FONT>              edge1 = pp.xToPixel(getXAxis().pixelToModel(<a name="line.5287"></a>
<FONT color="green">5288</FONT>                  pp.getXChartSizeDecoratedQuickly()));<a name="line.5288"></a>
<FONT color="green">5289</FONT>            }<a name="line.5289"></a>
<FONT color="green">5290</FONT>            // axis min and max are not ness smallest/largest values<a name="line.5290"></a>
<FONT color="green">5291</FONT>            edgeMin = Math.min(edge0, edge1);<a name="line.5291"></a>
<FONT color="green">5292</FONT>            edgeMax = Math.max(edge0, edge1);<a name="line.5292"></a>
<FONT color="green">5293</FONT>            xPxMin = Math.max(xPxMin, edgeMin - renderPaddingFactor<a name="line.5293"></a>
<FONT color="green">5294</FONT>                * (edgeMax - edgeMin));<a name="line.5294"></a>
<FONT color="green">5295</FONT>            xPxMax = Math.min(xPxMax, edgeMax + renderPaddingFactor<a name="line.5295"></a>
<FONT color="green">5296</FONT>                * (edgeMax - edgeMin));<a name="line.5296"></a>
<FONT color="green">5297</FONT>    <a name="line.5297"></a>
<FONT color="green">5298</FONT>            if (onY2) {<a name="line.5298"></a>
<FONT color="green">5299</FONT>              if (isClippedToPlotArea) {<a name="line.5299"></a>
<FONT color="green">5300</FONT>                edge0 = pp.yToPixel(pp.getY2Min(), onY2);<a name="line.5300"></a>
<FONT color="green">5301</FONT>                edge1 = pp.yToPixel(pp.getY2Max(), onY2);<a name="line.5301"></a>
<FONT color="green">5302</FONT>              } else { // clipped to decorated chart<a name="line.5302"></a>
<FONT color="green">5303</FONT>                edge0 = pp.yToPixel(getY2Axis().pixelToModel(0), onY2);<a name="line.5303"></a>
<FONT color="green">5304</FONT>                edge1 = pp.yToPixel(getY2Axis().pixelToModel(<a name="line.5304"></a>
<FONT color="green">5305</FONT>                    pp.getYChartSizeDecoratedQuickly()), onY2);<a name="line.5305"></a>
<FONT color="green">5306</FONT>              }<a name="line.5306"></a>
<FONT color="green">5307</FONT>            } else {<a name="line.5307"></a>
<FONT color="green">5308</FONT>              if (isClippedToPlotArea) {<a name="line.5308"></a>
<FONT color="green">5309</FONT>                edge0 = pp.yToPixel(pp.getYMin(), onY2);<a name="line.5309"></a>
<FONT color="green">5310</FONT>                edge1 = pp.yToPixel(pp.getYMax(), onY2);<a name="line.5310"></a>
<FONT color="green">5311</FONT>              } else { // clipped to decorated chart<a name="line.5311"></a>
<FONT color="green">5312</FONT>                edge0 = pp.yToPixel(GChart.this.getYAxis()<a name="line.5312"></a>
<FONT color="green">5313</FONT>                    .pixelToModel(0), onY2);<a name="line.5313"></a>
<FONT color="green">5314</FONT>                edge1 = pp.yToPixel(GChart.this.getYAxis()<a name="line.5314"></a>
<FONT color="green">5315</FONT>                    .pixelToModel(<a name="line.5315"></a>
<FONT color="green">5316</FONT>                    pp.getYChartSizeDecoratedQuickly()),<a name="line.5316"></a>
<FONT color="green">5317</FONT>                    onY2);<a name="line.5317"></a>
<FONT color="green">5318</FONT>              }<a name="line.5318"></a>
<FONT color="green">5319</FONT>            }<a name="line.5319"></a>
<FONT color="green">5320</FONT>            edgeMin = Math.min(edge0, edge1);<a name="line.5320"></a>
<FONT color="green">5321</FONT>            edgeMax = Math.max(edge0, edge1);<a name="line.5321"></a>
<FONT color="green">5322</FONT>            yPxMin = Math.max(yPxMin, edgeMin - renderPaddingFactor<a name="line.5322"></a>
<FONT color="green">5323</FONT>                * (edgeMax - edgeMin));<a name="line.5323"></a>
<FONT color="green">5324</FONT>            yPxMax = Math.min(yPxMax, edgeMax + renderPaddingFactor<a name="line.5324"></a>
<FONT color="green">5325</FONT>                * (edgeMax - edgeMin));<a name="line.5325"></a>
<FONT color="green">5326</FONT>          }<a name="line.5326"></a>
<FONT color="green">5327</FONT>    <a name="line.5327"></a>
<FONT color="green">5328</FONT>          if (xPxMax &lt; xPxMin || yPxMax &lt; yPxMin) {<a name="line.5328"></a>
<FONT color="green">5329</FONT>            // order flipped ==&gt; canvas rect outside clipping region<a name="line.5329"></a>
<FONT color="green">5330</FONT>            result.x = result.y = result.width = result.height = 0;<a name="line.5330"></a>
<FONT color="green">5331</FONT>          } else {<a name="line.5331"></a>
<FONT color="green">5332</FONT>            result.x = xPxMin;<a name="line.5332"></a>
<FONT color="green">5333</FONT>            result.y = yPxMin;<a name="line.5333"></a>
<FONT color="green">5334</FONT>            result.width = xPxMax - xPxMin + 1;<a name="line.5334"></a>
<FONT color="green">5335</FONT>            result.height = yPxMax - yPxMin + 1;<a name="line.5335"></a>
<FONT color="green">5336</FONT>            if (result.width * result.height &gt; maxCanvasPixels) {<a name="line.5336"></a>
<FONT color="green">5337</FONT>              /*<a name="line.5337"></a>
<FONT color="green">5338</FONT>               * Shrink canvas, then center it on the plot area midpoint<a name="line.5338"></a>
<FONT color="green">5339</FONT>               * (XLarge canvases can use lots of RAM and/or not work).<a name="line.5339"></a>
<FONT color="green">5340</FONT>               *<a name="line.5340"></a>
<FONT color="green">5341</FONT>               * If such an approach would waste pixels (which happens<a name="line.5341"></a>
<FONT color="green">5342</FONT>               * whenever the so-shrunken/centered rectangle isn't entirely<a name="line.5342"></a>
<FONT color="green">5343</FONT>               * contained in the original rectangle) we translate the<a name="line.5343"></a>
<FONT color="green">5344</FONT>               * shrunken rectangle the smallest amount needed to make it<a name="line.5344"></a>
<FONT color="green">5345</FONT>               * fit entirely within the original rectangle.<a name="line.5345"></a>
<FONT color="green">5346</FONT>               *<a name="line.5346"></a>
<FONT color="green">5347</FONT>               * This approach isn't perfect, and will end up shrinking in<a name="line.5347"></a>
<FONT color="green">5348</FONT>               * ways that occlude the more interesting points in special<a name="line.5348"></a>
<FONT color="green">5349</FONT>               * cases, but it's a reasonable strategy that should work OK<a name="line.5349"></a>
<FONT color="green">5350</FONT>               * for typical point sets, where most of the interesting<a name="line.5350"></a>
<FONT color="green">5351</FONT>               * points are near the center of the plot area anyway.<a name="line.5351"></a>
<FONT color="green">5352</FONT>               *<a name="line.5352"></a>
<FONT color="green">5353</FONT>               */<a name="line.5353"></a>
<FONT color="green">5354</FONT>    <a name="line.5354"></a>
<FONT color="green">5355</FONT>              // shrink, center on plot area     <a name="line.5355"></a>
<FONT color="green">5356</FONT>              double xMid = xChartSize / 2;<a name="line.5356"></a>
<FONT color="green">5357</FONT>              double yMid = yChartSize / 2;<a name="line.5357"></a>
<FONT color="green">5358</FONT>              double alpha = Math.sqrt(maxCanvasPixels<a name="line.5358"></a>
<FONT color="green">5359</FONT>                  / (result.width * result.height));<a name="line.5359"></a>
<FONT color="green">5360</FONT>              double newWidth = alpha*result.width;<a name="line.5360"></a>
<FONT color="green">5361</FONT>              double newHeight = alpha*result.height;<a name="line.5361"></a>
<FONT color="green">5362</FONT>              double newX = xMid - newWidth / 2;<a name="line.5362"></a>
<FONT color="green">5363</FONT>              double newY = yMid - newHeight / 2;<a name="line.5363"></a>
<FONT color="green">5364</FONT>    <a name="line.5364"></a>
<FONT color="green">5365</FONT>              // if needed, translate to fit within original rectangle<a name="line.5365"></a>
<FONT color="green">5366</FONT>              if (newX &lt; result.x)<a name="line.5366"></a>
<FONT color="green">5367</FONT>                newX = result.x;<a name="line.5367"></a>
<FONT color="green">5368</FONT>              else if (newX + newWidth &gt; result.x + result.width)<a name="line.5368"></a>
<FONT color="green">5369</FONT>                newX = result.x + result.width - newWidth;<a name="line.5369"></a>
<FONT color="green">5370</FONT>    <a name="line.5370"></a>
<FONT color="green">5371</FONT>              if (newY &lt; result.y)<a name="line.5371"></a>
<FONT color="green">5372</FONT>                newY = result.y;<a name="line.5372"></a>
<FONT color="green">5373</FONT>              else if (newY + newHeight &gt; result.y + result.height)<a name="line.5373"></a>
<FONT color="green">5374</FONT>                newY = result.y + result.height - newHeight;<a name="line.5374"></a>
<FONT color="green">5375</FONT>    <a name="line.5375"></a>
<FONT color="green">5376</FONT>              result.x = newX;<a name="line.5376"></a>
<FONT color="green">5377</FONT>              result.y = newY;<a name="line.5377"></a>
<FONT color="green">5378</FONT>              result.width = newWidth;<a name="line.5378"></a>
<FONT color="green">5379</FONT>              result.height = newHeight;<a name="line.5379"></a>
<FONT color="green">5380</FONT>            }<a name="line.5380"></a>
<FONT color="green">5381</FONT>          }<a name="line.5381"></a>
<FONT color="green">5382</FONT>          // result is (roughly) smallest rectangle that contains every<a name="line.5382"></a>
<FONT color="green">5383</FONT>          // rendered symbol on this curve (ignoring annotations)<a name="line.5383"></a>
<FONT color="green">5384</FONT>    <a name="line.5384"></a>
<FONT color="green">5385</FONT>          return result;<a name="line.5385"></a>
<FONT color="green">5386</FONT>    <a name="line.5386"></a>
<FONT color="green">5387</FONT>        }<a name="line.5387"></a>
<FONT color="green">5388</FONT>    <a name="line.5388"></a>
<FONT color="green">5389</FONT>        // keeps track of if last rendering was canvas-based or not<a name="line.5389"></a>
<FONT color="green">5390</FONT>        private boolean wasCanvasRendered = false;<a name="line.5390"></a>
<FONT color="green">5391</FONT>    <a name="line.5391"></a>
<FONT color="green">5392</FONT>        void setWasCanvasRendered(boolean wasCanvasRendered) {<a name="line.5392"></a>
<FONT color="green">5393</FONT>          this.wasCanvasRendered = wasCanvasRendered;<a name="line.5393"></a>
<FONT color="green">5394</FONT>        }<a name="line.5394"></a>
<FONT color="green">5395</FONT>    <a name="line.5395"></a>
<FONT color="green">5396</FONT>        // is curve currently canvas rendered and up-to-date<a name="line.5396"></a>
<FONT color="green">5397</FONT>        boolean isCanvasRendered() {<a name="line.5397"></a>
<FONT color="green">5398</FONT>          return isValidated &amp;&amp; wasCanvasRendered;<a name="line.5398"></a>
<FONT color="green">5399</FONT>        }<a name="line.5399"></a>
<FONT color="green">5400</FONT>    <a name="line.5400"></a>
<FONT color="green">5401</FONT>      } // end of class GChart.Curve<a name="line.5401"></a>
<FONT color="green">5402</FONT>    <a name="line.5402"></a>
<FONT color="green">5403</FONT>      /*<a name="line.5403"></a>
<FONT color="green">5404</FONT>       * Allows hovertext templates to be parsed into "chunks"<a name="line.5404"></a>
<FONT color="green">5405</FONT>       * so that they can be expanded into hovertext faster.<a name="line.5405"></a>
<FONT color="green">5406</FONT>       *<a name="line.5406"></a>
<FONT color="green">5407</FONT>       */ <a name="line.5407"></a>
<FONT color="green">5408</FONT>      static class HovertextChunk {<a name="line.5408"></a>
<FONT color="green">5409</FONT>        final static int HOVERTEXT_PARAM_NONE = 0; // plain old text<a name="line.5409"></a>
<FONT color="green">5410</FONT>        final static int HOVERTEXT_PARAM_X = 1; // ${x}<a name="line.5410"></a>
<FONT color="green">5411</FONT>        final static int HOVERTEXT_PARAM_Y = 2; // ${y}<a name="line.5411"></a>
<FONT color="green">5412</FONT>        final static int HOVERTEXT_PARAM_PIESLICESIZE = 3; // ${pieSlicePercent}<a name="line.5412"></a>
<FONT color="green">5413</FONT>        final static int HOVERTEXT_PARAM_USERDEFINED = 4; // ${mySpecialParameter}<a name="line.5413"></a>
<FONT color="green">5414</FONT>        // id of substitution parameter<a name="line.5414"></a>
<FONT color="green">5415</FONT>        int paramId; <a name="line.5415"></a>
<FONT color="green">5416</FONT>        // name of substitution parameter <a name="line.5416"></a>
<FONT color="green">5417</FONT>        String paramName; <a name="line.5417"></a>
<FONT color="green">5418</FONT>        // plain text that follows this parameter<a name="line.5418"></a>
<FONT color="green">5419</FONT>        String chunkText;<a name="line.5419"></a>
<FONT color="green">5420</FONT>    <a name="line.5420"></a>
<FONT color="green">5421</FONT>        HovertextChunk(int id, String name, String text) {<a name="line.5421"></a>
<FONT color="green">5422</FONT>          paramId = id;<a name="line.5422"></a>
<FONT color="green">5423</FONT>          paramName = name;<a name="line.5423"></a>
<FONT color="green">5424</FONT>          chunkText = text;<a name="line.5424"></a>
<FONT color="green">5425</FONT>        }<a name="line.5425"></a>
<FONT color="green">5426</FONT>    <a name="line.5426"></a>
<FONT color="green">5427</FONT>        /*<a name="line.5427"></a>
<FONT color="green">5428</FONT>         * Returns array of "chunks" corresponding to the given<a name="line.5428"></a>
<FONT color="green">5429</FONT>         * hovertext template.<a name="line.5429"></a>
<FONT color="green">5430</FONT>         *<a name="line.5430"></a>
<FONT color="green">5431</FONT>         */ <a name="line.5431"></a>
<FONT color="green">5432</FONT>        static HovertextChunk[] parseHovertextTemplate(String htTemplate) {<a name="line.5432"></a>
<FONT color="green">5433</FONT>          if (htTemplate.equals(""))<a name="line.5433"></a>
<FONT color="green">5434</FONT>            return new HovertextChunk[0];<a name="line.5434"></a>
<FONT color="green">5435</FONT>          /*<a name="line.5435"></a>
<FONT color="green">5436</FONT>           * Takes "x=${x}; y=${y}" into {"x=", "x}; y=", "y}"} Thus, except<a name="line.5436"></a>
<FONT color="green">5437</FONT>           * for the first, which contains just a string literal, chunks<a name="line.5437"></a>
<FONT color="green">5438</FONT>           * contain a keyword like part (e.g. "x}"), followed by a string<a name="line.5438"></a>
<FONT color="green">5439</FONT>           * literal (e.g. "; y=")<a name="line.5439"></a>
<FONT color="green">5440</FONT>           *<a name="line.5440"></a>
<FONT color="green">5441</FONT>           */ <a name="line.5441"></a>
<FONT color="green">5442</FONT>          String[] sChunk = htTemplate.split("\\$\\{");<a name="line.5442"></a>
<FONT color="green">5443</FONT>          HovertextChunk[] result = new HovertextChunk[sChunk.length];<a name="line.5443"></a>
<FONT color="green">5444</FONT>    <a name="line.5444"></a>
<FONT color="green">5445</FONT>          for (int i = 0; i &lt; sChunk.length; i++) {<a name="line.5445"></a>
<FONT color="green">5446</FONT>            String sC = sChunk[i];<a name="line.5446"></a>
<FONT color="green">5447</FONT>            if (0 == i)<a name="line.5447"></a>
<FONT color="green">5448</FONT>              // leading (non-parametric) plain text chunk<a name="line.5448"></a>
<FONT color="green">5449</FONT>              result[i] = new HovertextChunk(HOVERTEXT_PARAM_NONE, null,<a name="line.5449"></a>
<FONT color="green">5450</FONT>                  sC);<a name="line.5450"></a>
<FONT color="green">5451</FONT>            else if (sC.startsWith("x}"))<a name="line.5451"></a>
<FONT color="green">5452</FONT>              result[i] = new HovertextChunk(HOVERTEXT_PARAM_X, "x",<a name="line.5452"></a>
<FONT color="green">5453</FONT>                  sC.substring("x}".length()));<a name="line.5453"></a>
<FONT color="green">5454</FONT>            else if (sC.startsWith("y}"))<a name="line.5454"></a>
<FONT color="green">5455</FONT>              result[i] = new HovertextChunk(HOVERTEXT_PARAM_Y, "y",<a name="line.5455"></a>
<FONT color="green">5456</FONT>                  sC.substring("y}".length()));<a name="line.5456"></a>
<FONT color="green">5457</FONT>            else if (sC.startsWith("pieSliceSize}"))<a name="line.5457"></a>
<FONT color="green">5458</FONT>              result[i] = new HovertextChunk(HOVERTEXT_PARAM_PIESLICESIZE,<a name="line.5458"></a>
<FONT color="green">5459</FONT>                  "pieSliceSize",<a name="line.5459"></a>
<FONT color="green">5460</FONT>                  sC.substring("pieSliceSize}".length()));<a name="line.5460"></a>
<FONT color="green">5461</FONT>            else if (sC.matches("[a-zA-Z][a-zA-Z0-9_]*\\}.*")) {<a name="line.5461"></a>
<FONT color="green">5462</FONT>              // fits pattern for a user defined parameter<a name="line.5462"></a>
<FONT color="green">5463</FONT>              int closeCurlyIndex = sC.indexOf("}");<a name="line.5463"></a>
<FONT color="green">5464</FONT>              result[i] = new HovertextChunk(HOVERTEXT_PARAM_USERDEFINED,<a name="line.5464"></a>
<FONT color="green">5465</FONT>                  sC.substring(0, closeCurlyIndex), <a name="line.5465"></a>
<FONT color="green">5466</FONT>                  sC.substring(closeCurlyIndex + 1));<a name="line.5466"></a>
<FONT color="green">5467</FONT>            } else {<a name="line.5467"></a>
<FONT color="green">5468</FONT>              /*<a name="line.5468"></a>
<FONT color="green">5469</FONT>               * Leading "${" without "paramName}". Likely a<a name="line.5469"></a>
<FONT color="green">5470</FONT>               * typo, but output verbatim to give them a clue:<a name="line.5470"></a>
<FONT color="green">5471</FONT>               * <a name="line.5471"></a>
<FONT color="green">5472</FONT>               */ <a name="line.5472"></a>
<FONT color="green">5473</FONT>              result[i] = new HovertextChunk(HOVERTEXT_PARAM_NONE, null,<a name="line.5473"></a>
<FONT color="green">5474</FONT>                  "${" + sC);<a name="line.5474"></a>
<FONT color="green">5475</FONT>            }<a name="line.5475"></a>
<FONT color="green">5476</FONT>    <a name="line.5476"></a>
<FONT color="green">5477</FONT>          }<a name="line.5477"></a>
<FONT color="green">5478</FONT>          return result;<a name="line.5478"></a>
<FONT color="green">5479</FONT>        }<a name="line.5479"></a>
<FONT color="green">5480</FONT>    <a name="line.5480"></a>
<FONT color="green">5481</FONT>        /* hovertext associated with parsed "chunks" for a given point */<a name="line.5481"></a>
<FONT color="green">5482</FONT>        static String getHovertext(HovertextChunk[] htc, Curve.Point p) {<a name="line.5482"></a>
<FONT color="green">5483</FONT>          String result = "";<a name="line.5483"></a>
<FONT color="green">5484</FONT>          String xS = null;<a name="line.5484"></a>
<FONT color="green">5485</FONT>          String yS = null;<a name="line.5485"></a>
<FONT color="green">5486</FONT>          String pieSlicePercentS = null;<a name="line.5486"></a>
<FONT color="green">5487</FONT>          HoverParameterInterpreter hpi = p.getParent().getParent()<a name="line.5487"></a>
<FONT color="green">5488</FONT>              .getHoverParameterInterpreter();<a name="line.5488"></a>
<FONT color="green">5489</FONT>          for (int i = 0; i &lt; htc.length; i++) {<a name="line.5489"></a>
<FONT color="green">5490</FONT>            switch (htc[i].paramId) {<a name="line.5490"></a>
<FONT color="green">5491</FONT>            case HovertextChunk.HOVERTEXT_PARAM_NONE:<a name="line.5491"></a>
<FONT color="green">5492</FONT>              break;<a name="line.5492"></a>
<FONT color="green">5493</FONT>            case HovertextChunk.HOVERTEXT_PARAM_X:<a name="line.5493"></a>
<FONT color="green">5494</FONT>              if (null == xS) {<a name="line.5494"></a>
<FONT color="green">5495</FONT>                String hoverParam = (null == hpi) ? null : <a name="line.5495"></a>
<FONT color="green">5496</FONT>                    hpi.getHoverParameter(htc[i].paramName, p);<a name="line.5496"></a>
<FONT color="green">5497</FONT>                if (null != hoverParam)<a name="line.5497"></a>
<FONT color="green">5498</FONT>                  xS = hoverParam;<a name="line.5498"></a>
<FONT color="green">5499</FONT>                else {<a name="line.5499"></a>
<FONT color="green">5500</FONT>                  Axis axis = p.getParent().getParent().getXAxis();<a name="line.5500"></a>
<FONT color="green">5501</FONT>                  xS = axis.formatAsTickLabel(p.getX());<a name="line.5501"></a>
<FONT color="green">5502</FONT>                }<a name="line.5502"></a>
<FONT color="green">5503</FONT>              }<a name="line.5503"></a>
<FONT color="green">5504</FONT>              result += xS;<a name="line.5504"></a>
<FONT color="green">5505</FONT>              break;<a name="line.5505"></a>
<FONT color="green">5506</FONT>            case HovertextChunk.HOVERTEXT_PARAM_Y:<a name="line.5506"></a>
<FONT color="green">5507</FONT>              if (null == yS) {<a name="line.5507"></a>
<FONT color="green">5508</FONT>                String hoverParam = (null == hpi) ? null : <a name="line.5508"></a>
<FONT color="green">5509</FONT>                    hpi.getHoverParameter(htc[i].paramName, p);<a name="line.5509"></a>
<FONT color="green">5510</FONT>                if (null != hoverParam)<a name="line.5510"></a>
<FONT color="green">5511</FONT>                  yS = hoverParam;<a name="line.5511"></a>
<FONT color="green">5512</FONT>                else {<a name="line.5512"></a>
<FONT color="green">5513</FONT>                  Axis axis = p.getParent().onY2() ? <a name="line.5513"></a>
<FONT color="green">5514</FONT>                      p.getParent().getParent().getY2Axis() : <a name="line.5514"></a>
<FONT color="green">5515</FONT>                      p.getParent().getParent().getYAxis();<a name="line.5515"></a>
<FONT color="green">5516</FONT>                  yS = axis.formatAsTickLabel(p.getY());<a name="line.5516"></a>
<FONT color="green">5517</FONT>                }<a name="line.5517"></a>
<FONT color="green">5518</FONT>              }<a name="line.5518"></a>
<FONT color="green">5519</FONT>              result += yS;<a name="line.5519"></a>
<FONT color="green">5520</FONT>              break;<a name="line.5520"></a>
<FONT color="green">5521</FONT>    <a name="line.5521"></a>
<FONT color="green">5522</FONT>            case HovertextChunk.HOVERTEXT_PARAM_PIESLICESIZE:<a name="line.5522"></a>
<FONT color="green">5523</FONT>              if (null == pieSlicePercentS) {<a name="line.5523"></a>
<FONT color="green">5524</FONT>                String hoverParam = (null == hpi) ? null : <a name="line.5524"></a>
<FONT color="green">5525</FONT>                    hpi.getHoverParameter(htc[i].paramName, p);<a name="line.5525"></a>
<FONT color="green">5526</FONT>                if (null != hoverParam)<a name="line.5526"></a>
<FONT color="green">5527</FONT>                  pieSlicePercentS = hoverParam;<a name="line.5527"></a>
<FONT color="green">5528</FONT>                else {<a name="line.5528"></a>
<FONT color="green">5529</FONT>                  double pieSliceSize = <a name="line.5529"></a>
<FONT color="green">5530</FONT>                    p.getParent().getSymbol().getPieSliceSize();<a name="line.5530"></a>
<FONT color="green">5531</FONT>                  Axis axis = p.getParent().onY2() ? <a name="line.5531"></a>
<FONT color="green">5532</FONT>                    p.getParent().getParent().getY2Axis() : <a name="line.5532"></a>
<FONT color="green">5533</FONT>                    p.getParent().getParent().getYAxis();<a name="line.5533"></a>
<FONT color="green">5534</FONT>                  pieSlicePercentS = <a name="line.5534"></a>
<FONT color="green">5535</FONT>                    axis.formatAsTickLabel(100 * pieSliceSize) + "%";<a name="line.5535"></a>
<FONT color="green">5536</FONT>                }<a name="line.5536"></a>
<FONT color="green">5537</FONT>              }<a name="line.5537"></a>
<FONT color="green">5538</FONT>              result += pieSlicePercentS;<a name="line.5538"></a>
<FONT color="green">5539</FONT>              break;<a name="line.5539"></a>
<FONT color="green">5540</FONT>    <a name="line.5540"></a>
<FONT color="green">5541</FONT>            case HovertextChunk.HOVERTEXT_PARAM_USERDEFINED:<a name="line.5541"></a>
<FONT color="green">5542</FONT>    <a name="line.5542"></a>
<FONT color="green">5543</FONT>              String hoverParam = (null == hpi) ? null : <a name="line.5543"></a>
<FONT color="green">5544</FONT>                  hpi.getHoverParameter(htc[i].paramName, p);<a name="line.5544"></a>
<FONT color="green">5545</FONT>              if (null == hoverParam)<a name="line.5545"></a>
<FONT color="green">5546</FONT>                /*<a name="line.5546"></a>
<FONT color="green">5547</FONT>                 * null means "unrecognized parameter" - so<a name="line.5547"></a>
<FONT color="green">5548</FONT>                 * regenerate the original, unparsed, param spec<a name="line.5548"></a>
<FONT color="green">5549</FONT>                 * to clue them in that it was not processed.<a name="line.5549"></a>
<FONT color="green">5550</FONT>                 * <a name="line.5550"></a>
<FONT color="green">5551</FONT>                 */ <a name="line.5551"></a>
<FONT color="green">5552</FONT>                result += "${" + htc[i].paramName + "}";<a name="line.5552"></a>
<FONT color="green">5553</FONT>              else<a name="line.5553"></a>
<FONT color="green">5554</FONT>                result += hoverParam;<a name="line.5554"></a>
<FONT color="green">5555</FONT>    <a name="line.5555"></a>
<FONT color="green">5556</FONT>              break;<a name="line.5556"></a>
<FONT color="green">5557</FONT>            default:<a name="line.5557"></a>
<FONT color="green">5558</FONT>              throw new IllegalStateException(<a name="line.5558"></a>
<FONT color="green">5559</FONT>                  "An illegal HOVERTEXT_PARAM_* id: "<a name="line.5559"></a>
<FONT color="green">5560</FONT>                  + htc[i].paramId<a name="line.5560"></a>
<FONT color="green">5561</FONT>                  + " was encountered. A GChart bug is likely to blame.");<a name="line.5561"></a>
<FONT color="green">5562</FONT>            }<a name="line.5562"></a>
<FONT color="green">5563</FONT>            result += htc[i].chunkText;<a name="line.5563"></a>
<FONT color="green">5564</FONT>          }<a name="line.5564"></a>
<FONT color="green">5565</FONT>          return result;<a name="line.5565"></a>
<FONT color="green">5566</FONT>        }<a name="line.5566"></a>
<FONT color="green">5567</FONT>      }<a name="line.5567"></a>
<FONT color="green">5568</FONT>    <a name="line.5568"></a>
<FONT color="green">5569</FONT>      /**<a name="line.5569"></a>
<FONT color="green">5570</FONT>       * Defines a chart curve symbol. Each point on a curve is represented<a name="line.5570"></a>
<FONT color="green">5571</FONT>       * on the chart by an appropriate rendering of the curve's symbol.<a name="line.5571"></a>
<FONT color="green">5572</FONT>       * <a name="line.5572"></a>
<FONT color="green">5573</FONT>       * @see Curve#getSymbol Curve.getSymbol<a name="line.5573"></a>
<FONT color="green">5574</FONT>       * @see SymbolType SymbolType<a name="line.5574"></a>
<FONT color="green">5575</FONT>       * <a name="line.5575"></a>
<FONT color="green">5576</FONT>       */<a name="line.5576"></a>
<FONT color="green">5577</FONT>    <a name="line.5577"></a>
<FONT color="green">5578</FONT>      public class Symbol {<a name="line.5578"></a>
<FONT color="green">5579</FONT>    <a name="line.5579"></a>
<FONT color="green">5580</FONT>        private String backgroundColor = DEFAULT_SYMBOL_BACKGROUND_COLOR;<a name="line.5580"></a>
<FONT color="green">5581</FONT>        // same as backgroundColor, except RGBA collapsed to plain RGA<a name="line.5581"></a>
<FONT color="green">5582</FONT>        private String backgroundColorCSS = DEFAULT_SYMBOL_BACKGROUND_COLOR;<a name="line.5582"></a>
<FONT color="green">5583</FONT>        private double baseline = Double.NaN;<a name="line.5583"></a>
<FONT color="green">5584</FONT>        private String borderColor = "black";<a name="line.5584"></a>
<FONT color="green">5585</FONT>        private String borderColorCSS = "black";<a name="line.5585"></a>
<FONT color="green">5586</FONT>        private String borderStyle = DEFAULT_SYMBOL_BORDER_STYLE;<a name="line.5586"></a>
<FONT color="green">5587</FONT>        private int borderWidth = DEFAULT_SYMBOL_BORDER_WIDTH;<a name="line.5587"></a>
<FONT color="green">5588</FONT>        private int brushHeight = DEFAULT_BRUSH_HEIGHT;<a name="line.5588"></a>
<FONT color="green">5589</FONT>        private AnnotationLocation brushLocation = AnnotationLocation.CENTER;<a name="line.5589"></a>
<FONT color="green">5590</FONT>        private int brushWidth = DEFAULT_BRUSH_WIDTH;<a name="line.5590"></a>
<FONT color="green">5591</FONT>        private boolean fillHasHovertext = true;<a name="line.5591"></a>
<FONT color="green">5592</FONT>        private double fillSpacing = Double.NaN;<a name="line.5592"></a>
<FONT color="green">5593</FONT>        private int fillThickness = GChart.NAI;<a name="line.5593"></a>
<FONT color="green">5594</FONT>        private int height = DEFAULT_SYMBOL_HEIGHT;<a name="line.5594"></a>
<FONT color="green">5595</FONT>        private String hovertextTemplate = null;<a name="line.5595"></a>
<FONT color="green">5596</FONT>        /*<a name="line.5596"></a>
<FONT color="green">5597</FONT>         * Holds specification for the hover annotation. Actual<a name="line.5597"></a>
<FONT color="green">5598</FONT>         * hover annotation is generated on the fly when they hover.<a name="line.5598"></a>
<FONT color="green">5599</FONT>         * <a name="line.5599"></a>
<FONT color="green">5600</FONT>         */ <a name="line.5600"></a>
<FONT color="green">5601</FONT>        private Annotation hoverAnnotation = null;<a name="line.5601"></a>
<FONT color="green">5602</FONT>        private boolean hoverAnnotationEnabled = true;<a name="line.5602"></a>
<FONT color="green">5603</FONT>        /*<a name="line.5603"></a>
<FONT color="green">5604</FONT>         * Allows hover annotation to use a different symbol type<a name="line.5604"></a>
<FONT color="green">5605</FONT>         * than the symbol being hovered over. Main use expected to<a name="line.5605"></a>
<FONT color="green">5606</FONT>         * be to place hover feedback at a fixed location on the chart (via<a name="line.5606"></a>
<FONT color="green">5607</FONT>         * ANCHOR_* family of symbol types), for example, a status<a name="line.5607"></a>
<FONT color="green">5608</FONT>         * bar message that changes depending on what the mouse<a name="line.5608"></a>
<FONT color="green">5609</FONT>         * is touching.<a name="line.5609"></a>
<FONT color="green">5610</FONT>         * <a name="line.5610"></a>
<FONT color="green">5611</FONT>         */ <a name="line.5611"></a>
<FONT color="green">5612</FONT>        private SymbolType hoverAnnotationSymbolType = null;<a name="line.5612"></a>
<FONT color="green">5613</FONT>        // encloses each symbol in a 1 px gray selection rectangle:<a name="line.5613"></a>
<FONT color="green">5614</FONT>        private String hoverSelectionBackgroundColor = "transparent";<a name="line.5614"></a>
<FONT color="green">5615</FONT>        private String hoverSelectionBorderColor = "gray";<a name="line.5615"></a>
<FONT color="green">5616</FONT>        private String hoverSelectionBorderStyle = "solid";<a name="line.5616"></a>
<FONT color="green">5617</FONT>        private int hoverSelectionBorderWidth = -1;<a name="line.5617"></a>
<FONT color="green">5618</FONT>        private boolean hoverSelectionEnabled = true;<a name="line.5618"></a>
<FONT color="green">5619</FONT>        private double hoverSelectionFillSpacing = Double.NaN;<a name="line.5619"></a>
<FONT color="green">5620</FONT>        private int hoverSelectionFillThickness = GChart.NAI;<a name="line.5620"></a>
<FONT color="green">5621</FONT>        private int hoverSelectionHeight = GChart.NAI;<a name="line.5621"></a>
<FONT color="green">5622</FONT>        private String hoverSelectionImageURL = null;<a name="line.5622"></a>
<FONT color="green">5623</FONT>        private int hoverSelectionWidth = GChart.NAI;<a name="line.5623"></a>
<FONT color="green">5624</FONT>        private SymbolType hoverSelectionSymbolType = null;<a name="line.5624"></a>
<FONT color="green">5625</FONT>    <a name="line.5625"></a>
<FONT color="green">5626</FONT>        private HovertextChunk[] hovertextChunks = null;<a name="line.5626"></a>
<FONT color="green">5627</FONT>        private String imageURL = null;<a name="line.5627"></a>
<FONT color="green">5628</FONT>        /*<a name="line.5628"></a>
<FONT color="green">5629</FONT>         * XXX: Ticks are now rendered via specialized system curves,<a name="line.5629"></a>
<FONT color="green">5630</FONT>         * instead using a Symbol instantiated independently of curves.<a name="line.5630"></a>
<FONT color="green">5631</FONT>         * So, Symbol could become an inner class of Curve, and this<a name="line.5631"></a>
<FONT color="green">5632</FONT>         * explicit parent pointer would then no longer be required.<a name="line.5632"></a>
<FONT color="green">5633</FONT>         *<a name="line.5633"></a>
<FONT color="green">5634</FONT>         */ <a name="line.5634"></a>
<FONT color="green">5635</FONT>        private Curve parent = null;<a name="line.5635"></a>
<FONT color="green">5636</FONT>        // when specified, model width/height are in user-defined units.<a name="line.5636"></a>
<FONT color="green">5637</FONT>        private double modelHeight = Double.NaN;<a name="line.5637"></a>
<FONT color="green">5638</FONT>        private double modelWidth = Double.NaN;<a name="line.5638"></a>
<FONT color="green">5639</FONT>        /*<a name="line.5639"></a>
<FONT color="green">5640</FONT>         * NaN means "begin this slice where last slice left off, or at<a name="line.5640"></a>
<FONT color="green">5641</FONT>         * initialPieSliceOrientation if it is the first slice to be rendered"<a name="line.5641"></a>
<FONT color="green">5642</FONT>         *<a name="line.5642"></a>
<FONT color="green">5643</FONT>         */ <a name="line.5643"></a>
<FONT color="green">5644</FONT>        private double pieSliceOrientation = Double.NaN;<a name="line.5644"></a>
<FONT color="green">5645</FONT>        private double defaultPieSliceOrientation = 0.0;<a name="line.5645"></a>
<FONT color="green">5646</FONT>        // slices, by default, fill the entire pie (useful for drawing disks)<a name="line.5646"></a>
<FONT color="green">5647</FONT>        private double pieSliceSize = 1;<a name="line.5647"></a>
<FONT color="green">5648</FONT>    <a name="line.5648"></a>
<FONT color="green">5649</FONT>        private SymbolType symbolType = DEFAULT_SYMBOL_TYPE;<a name="line.5649"></a>
<FONT color="green">5650</FONT>    <a name="line.5650"></a>
<FONT color="green">5651</FONT>        private int width = DEFAULT_SYMBOL_WIDTH;<a name="line.5651"></a>
<FONT color="green">5652</FONT>        double xScaleFactor = 1.0;<a name="line.5652"></a>
<FONT color="green">5653</FONT>        double yScaleFactor = 1.0;<a name="line.5653"></a>
<FONT color="green">5654</FONT>    <a name="line.5654"></a>
<FONT color="green">5655</FONT>        Symbol(Curve parent) {<a name="line.5655"></a>
<FONT color="green">5656</FONT>          super();<a name="line.5656"></a>
<FONT color="green">5657</FONT>          this.parent = parent;<a name="line.5657"></a>
<FONT color="green">5658</FONT>        }<a name="line.5658"></a>
<FONT color="green">5659</FONT>    <a name="line.5659"></a>
<FONT color="green">5660</FONT>        /**<a name="line.5660"></a>
<FONT color="green">5661</FONT>         * Returns the background or fill color of this symbol.<a name="line.5661"></a>
<FONT color="green">5662</FONT>         * <a name="line.5662"></a>
<FONT color="green">5663</FONT>         * @return the background or fill color of this symbol.<a name="line.5663"></a>
<FONT color="green">5664</FONT>         * <a name="line.5664"></a>
<FONT color="green">5665</FONT>         * @see #setBackgroundColor(String) setBackgroundColor<a name="line.5665"></a>
<FONT color="green">5666</FONT>         */<a name="line.5666"></a>
<FONT color="green">5667</FONT>        public String getBackgroundColor() {<a name="line.5667"></a>
<FONT color="green">5668</FONT>          return backgroundColor;<a name="line.5668"></a>
<FONT color="green">5669</FONT>        }<a name="line.5669"></a>
<FONT color="green">5670</FONT>    <a name="line.5670"></a>
<FONT color="green">5671</FONT>        String getBackgroundColorCSS() {<a name="line.5671"></a>
<FONT color="green">5672</FONT>          return backgroundColorCSS;<a name="line.5672"></a>
<FONT color="green">5673</FONT>        }<a name="line.5673"></a>
<FONT color="green">5674</FONT>    <a name="line.5674"></a>
<FONT color="green">5675</FONT>        /**<a name="line.5675"></a>
<FONT color="green">5676</FONT>         * Returns the baseline value for this symbol, previously specified via<a name="line.5676"></a>
<FONT color="green">5677</FONT>         * &lt;tt&gt;setBaseline&lt;/tt&gt;<a name="line.5677"></a>
<FONT color="green">5678</FONT>         * <a name="line.5678"></a>
<FONT color="green">5679</FONT>         * @return the previously specified baseline value for this symbol.<a name="line.5679"></a>
<FONT color="green">5680</FONT>         * <a name="line.5680"></a>
<FONT color="green">5681</FONT>         * @see #setBaseline setBaseline<a name="line.5681"></a>
<FONT color="green">5682</FONT>         */<a name="line.5682"></a>
<FONT color="green">5683</FONT>        public double getBaseline() {<a name="line.5683"></a>
<FONT color="green">5684</FONT>          return baseline;<a name="line.5684"></a>
<FONT color="green">5685</FONT>        }<a name="line.5685"></a>
<FONT color="green">5686</FONT>    <a name="line.5686"></a>
<FONT color="green">5687</FONT>        /**<a name="line.5687"></a>
<FONT color="green">5688</FONT>         * Returns the border color. <a name="line.5688"></a>
<FONT color="green">5689</FONT>         * <a name="line.5689"></a>
<FONT color="green">5690</FONT>         * &lt;p&gt;<a name="line.5690"></a>
<FONT color="green">5691</FONT>         * <a name="line.5691"></a>
<FONT color="green">5692</FONT>         * @return the border color <a name="line.5692"></a>
<FONT color="green">5693</FONT>         * <a name="line.5693"></a>
<FONT color="green">5694</FONT>         * @see #setBorderColor setBorderColor<a name="line.5694"></a>
<FONT color="green">5695</FONT>         * <a name="line.5695"></a>
<FONT color="green">5696</FONT>         */<a name="line.5696"></a>
<FONT color="green">5697</FONT>        public String getBorderColor() {<a name="line.5697"></a>
<FONT color="green">5698</FONT>          return borderColor;<a name="line.5698"></a>
<FONT color="green">5699</FONT>        }<a name="line.5699"></a>
<FONT color="green">5700</FONT>    <a name="line.5700"></a>
<FONT color="green">5701</FONT>        String getBorderColorCSS() {<a name="line.5701"></a>
<FONT color="green">5702</FONT>          return borderColorCSS;<a name="line.5702"></a>
<FONT color="green">5703</FONT>        }<a name="line.5703"></a>
<FONT color="green">5704</FONT>    <a name="line.5704"></a>
<FONT color="green">5705</FONT>        /**<a name="line.5705"></a>
<FONT color="green">5706</FONT>         * Returns the border style of all of the rectangular elements from which<a name="line.5706"></a>
<FONT color="green">5707</FONT>         * this symbol is built.<a name="line.5707"></a>
<FONT color="green">5708</FONT>         * &lt;p&gt;<a name="line.5708"></a>
<FONT color="green">5709</FONT>         * <a name="line.5709"></a>
<FONT color="green">5710</FONT>         * @return the CSS borderStyle of this symbol's elements (dotted, dashed,<a name="line.5710"></a>
<FONT color="green">5711</FONT>         *         solid, etc. )<a name="line.5711"></a>
<FONT color="green">5712</FONT>         * <a name="line.5712"></a>
<FONT color="green">5713</FONT>         * @see #setBorderStyle setBorderStyle<a name="line.5713"></a>
<FONT color="green">5714</FONT>         */<a name="line.5714"></a>
<FONT color="green">5715</FONT>        public String getBorderStyle() {<a name="line.5715"></a>
<FONT color="green">5716</FONT>          return borderStyle;<a name="line.5716"></a>
<FONT color="green">5717</FONT>        }<a name="line.5717"></a>
<FONT color="green">5718</FONT>    <a name="line.5718"></a>
<FONT color="green">5719</FONT>        /**<a name="line.5719"></a>
<FONT color="green">5720</FONT>         * Returns the width of the border.<a name="line.5720"></a>
<FONT color="green">5721</FONT>         * &lt;p&gt;<a name="line.5721"></a>
<FONT color="green">5722</FONT>         * <a name="line.5722"></a>
<FONT color="green">5723</FONT>         * @return the previously set border width (in pixels).<a name="line.5723"></a>
<FONT color="green">5724</FONT>         * <a name="line.5724"></a>
<FONT color="green">5725</FONT>         * @see #setBorderWidth setBorderWidth<a name="line.5725"></a>
<FONT color="green">5726</FONT>         */<a name="line.5726"></a>
<FONT color="green">5727</FONT>        public int getBorderWidth() {<a name="line.5727"></a>
<FONT color="green">5728</FONT>          return borderWidth;<a name="line.5728"></a>
<FONT color="green">5729</FONT>        }<a name="line.5729"></a>
<FONT color="green">5730</FONT>    <a name="line.5730"></a>
<FONT color="green">5731</FONT>        /**<a name="line.5731"></a>
<FONT color="green">5732</FONT>         * <a name="line.5732"></a>
<FONT color="green">5733</FONT>         * Returns the height of the rectangular "brush" that defines how close the<a name="line.5733"></a>
<FONT color="green">5734</FONT>         * mouse cursor must be to a rendered symbol for the symbol to be considered<a name="line.5734"></a>
<FONT color="green">5735</FONT>         * to have been "touched" (which causes the point's hover feedback to pop<a name="line.5735"></a>
<FONT color="green">5736</FONT>         * up).<a name="line.5736"></a>
<FONT color="green">5737</FONT>         * &lt;p&gt;<a name="line.5737"></a>
<FONT color="green">5738</FONT>         * <a name="line.5738"></a>
<FONT color="green">5739</FONT>         * @return the height of the "brush", in pixels, associated with this<a name="line.5739"></a>
<FONT color="green">5740</FONT>         *         symbol/curve.<a name="line.5740"></a>
<FONT color="green">5741</FONT>         * <a name="line.5741"></a>
<FONT color="green">5742</FONT>         * @see #setBrushHeight setBrushHeight<a name="line.5742"></a>
<FONT color="green">5743</FONT>         * <a name="line.5743"></a>
<FONT color="green">5744</FONT>         */<a name="line.5744"></a>
<FONT color="green">5745</FONT>        public int getBrushHeight() {<a name="line.5745"></a>
<FONT color="green">5746</FONT>          return brushHeight;<a name="line.5746"></a>
<FONT color="green">5747</FONT>        }<a name="line.5747"></a>
<FONT color="green">5748</FONT>    <a name="line.5748"></a>
<FONT color="green">5749</FONT>        /**<a name="line.5749"></a>
<FONT color="green">5750</FONT>         * <a name="line.5750"></a>
<FONT color="green">5751</FONT>         * Returns the location of the rectangular brush relative to the current x,y<a name="line.5751"></a>
<FONT color="green">5752</FONT>         * coordinates of the mouse cursor.<a name="line.5752"></a>
<FONT color="green">5753</FONT>         * &lt;p&gt;<a name="line.5753"></a>
<FONT color="green">5754</FONT>         * <a name="line.5754"></a>
<FONT color="green">5755</FONT>         * @return the location of the rectangular brush relative to the x,y<a name="line.5755"></a>
<FONT color="green">5756</FONT>         *         coordinates of the mouse cursor.<a name="line.5756"></a>
<FONT color="green">5757</FONT>         * <a name="line.5757"></a>
<FONT color="green">5758</FONT>         * @see #setBrushLocation setBrushLocation<a name="line.5758"></a>
<FONT color="green">5759</FONT>         */<a name="line.5759"></a>
<FONT color="green">5760</FONT>        public AnnotationLocation getBrushLocation() {<a name="line.5760"></a>
<FONT color="green">5761</FONT>          return brushLocation;<a name="line.5761"></a>
<FONT color="green">5762</FONT>        }<a name="line.5762"></a>
<FONT color="green">5763</FONT>    <a name="line.5763"></a>
<FONT color="green">5764</FONT>        /**<a name="line.5764"></a>
<FONT color="green">5765</FONT>         * <a name="line.5765"></a>
<FONT color="green">5766</FONT>         * Returns the width of the rectangular "brush" that defines how close the<a name="line.5766"></a>
<FONT color="green">5767</FONT>         * mouse cursor must be to a rendered symbol for the symbol to be considered<a name="line.5767"></a>
<FONT color="green">5768</FONT>         * to have been "touched" (which causes the point's hover feedback to pop<a name="line.5768"></a>
<FONT color="green">5769</FONT>         * up).<a name="line.5769"></a>
<FONT color="green">5770</FONT>         * &lt;p&gt;<a name="line.5770"></a>
<FONT color="green">5771</FONT>         * <a name="line.5771"></a>
<FONT color="green">5772</FONT>         * @return the width of the "brush", in pixels, associated with this<a name="line.5772"></a>
<FONT color="green">5773</FONT>         *         symbol/curve.<a name="line.5773"></a>
<FONT color="green">5774</FONT>         * <a name="line.5774"></a>
<FONT color="green">5775</FONT>         * @see #setBrushWidth setBrushWidth<a name="line.5775"></a>
<FONT color="green">5776</FONT>         * <a name="line.5776"></a>
<FONT color="green">5777</FONT>         */<a name="line.5777"></a>
<FONT color="green">5778</FONT>        public int getBrushWidth() {<a name="line.5778"></a>
<FONT color="green">5779</FONT>          return brushWidth;<a name="line.5779"></a>
<FONT color="green">5780</FONT>        }<a name="line.5780"></a>
<FONT color="green">5781</FONT>    <a name="line.5781"></a>
<FONT color="green">5782</FONT>        /**<a name="line.5782"></a>
<FONT color="green">5783</FONT>         * @deprecated<a name="line.5783"></a>
<FONT color="green">5784</FONT>         * <a name="line.5784"></a>
<FONT color="green">5785</FONT>         *             Returns the value previously set by setFillHasHovertext.<a name="line.5785"></a>
<FONT color="green">5786</FONT>         * <a name="line.5786"></a>
<FONT color="green">5787</FONT>         * @see #setFillHasHovertext setFillHasHovertext<a name="line.5787"></a>
<FONT color="green">5788</FONT>         * <a name="line.5788"></a>
<FONT color="green">5789</FONT>         */<a name="line.5789"></a>
<FONT color="green">5790</FONT>        public boolean getFillHasHovertext() {<a name="line.5790"></a>
<FONT color="green">5791</FONT>          return fillHasHovertext;<a name="line.5791"></a>
<FONT color="green">5792</FONT>        }<a name="line.5792"></a>
<FONT color="green">5793</FONT>    <a name="line.5793"></a>
<FONT color="green">5794</FONT>        /**<a name="line.5794"></a>
<FONT color="green">5795</FONT>         * Returns the spacing between successive rectangular elements used to<a name="line.5795"></a>
<FONT color="green">5796</FONT>         * emulate any required non-rectangular features of the symbol.<a name="line.5796"></a>
<FONT color="green">5797</FONT>         * &lt;p&gt;<a name="line.5797"></a>
<FONT color="green">5798</FONT>         * <a name="line.5798"></a>
<FONT color="green">5799</FONT>         * @return the previously set (or the default, if the fillSpacing has been<a name="line.5799"></a>
<FONT color="green">5800</FONT>         *         set to &lt;tt&gt;Double.NaN&lt;/tt&gt;) fill spacing (in pixels).<a name="line.5800"></a>
<FONT color="green">5801</FONT>         * <a name="line.5801"></a>
<FONT color="green">5802</FONT>         * @see #setFillSpacing setFillSpacing<a name="line.5802"></a>
<FONT color="green">5803</FONT>         * @see #setFillThickness setFillThickness<a name="line.5803"></a>
<FONT color="green">5804</FONT>         * <a name="line.5804"></a>
<FONT color="green">5805</FONT>         */<a name="line.5805"></a>
<FONT color="green">5806</FONT>        public double getFillSpacing() {<a name="line.5806"></a>
<FONT color="green">5807</FONT>          if ((fillSpacing != fillSpacing)) // x!=x is a faster isNaN<a name="line.5807"></a>
<FONT color="green">5808</FONT>            return symbolType.defaultFillSpacing();<a name="line.5808"></a>
<FONT color="green">5809</FONT>          else<a name="line.5809"></a>
<FONT color="green">5810</FONT>            return fillSpacing;<a name="line.5810"></a>
<FONT color="green">5811</FONT>        }<a name="line.5811"></a>
<FONT color="green">5812</FONT>    <a name="line.5812"></a>
<FONT color="green">5813</FONT>        /**<a name="line.5813"></a>
<FONT color="green">5814</FONT>         * Returns the "thickness" of rectangular elements used to emulate any<a name="line.5814"></a>
<FONT color="green">5815</FONT>         * required non-rectangular features of the symbol.<a name="line.5815"></a>
<FONT color="green">5816</FONT>         * &lt;p&gt;<a name="line.5816"></a>
<FONT color="green">5817</FONT>         * <a name="line.5817"></a>
<FONT color="green">5818</FONT>         * @return the previously set (or the default, if the fillThickness has been<a name="line.5818"></a>
<FONT color="green">5819</FONT>         *         set to &lt;tt&gt;GChart.NAI&lt;/tt&gt;) fill thickness (in pixels).<a name="line.5819"></a>
<FONT color="green">5820</FONT>         * <a name="line.5820"></a>
<FONT color="green">5821</FONT>         * @see #setFillThickness setFillThickness<a name="line.5821"></a>
<FONT color="green">5822</FONT>         * @see #setFillSpacing setFillSpacing<a name="line.5822"></a>
<FONT color="green">5823</FONT>         */<a name="line.5823"></a>
<FONT color="green">5824</FONT>        public int getFillThickness() {<a name="line.5824"></a>
<FONT color="green">5825</FONT>          if (fillThickness == GChart.NAI)<a name="line.5825"></a>
<FONT color="green">5826</FONT>            return symbolType.defaultFillThickness();<a name="line.5826"></a>
<FONT color="green">5827</FONT>          else<a name="line.5827"></a>
<FONT color="green">5828</FONT>            return fillThickness;<a name="line.5828"></a>
<FONT color="green">5829</FONT>        }<a name="line.5829"></a>
<FONT color="green">5830</FONT>    <a name="line.5830"></a>
<FONT color="green">5831</FONT>        /*<a name="line.5831"></a>
<FONT color="green">5832</FONT>         * Retrieves the annotation that defines the properties of the internally<a name="line.5832"></a>
<FONT color="green">5833</FONT>         * generated annotations used to display hover feedback.<a name="line.5833"></a>
<FONT color="green">5834</FONT>         * <a name="line.5834"></a>
<FONT color="green">5835</FONT>         */<a name="line.5835"></a>
<FONT color="green">5836</FONT>        Annotation getHoverAnnotation() {<a name="line.5836"></a>
<FONT color="green">5837</FONT>          if (hoverAnnotation == null)<a name="line.5837"></a>
<FONT color="green">5838</FONT>            hoverAnnotation = new Annotation();<a name="line.5838"></a>
<FONT color="green">5839</FONT>          return hoverAnnotation;<a name="line.5839"></a>
<FONT color="green">5840</FONT>        }<a name="line.5840"></a>
<FONT color="green">5841</FONT>    <a name="line.5841"></a>
<FONT color="green">5842</FONT>        /**<a name="line.5842"></a>
<FONT color="green">5843</FONT>         * Retrieves a boolean that indicates if point-specific annotations popup<a name="line.5843"></a>
<FONT color="green">5844</FONT>         * whenever you hover over a point on the curve associated with this symbol.<a name="line.5844"></a>
<FONT color="green">5845</FONT>         * &lt;p&gt;<a name="line.5845"></a>
<FONT color="green">5846</FONT>         * <a name="line.5846"></a>
<FONT color="green">5847</FONT>         * @return true if hover-induced annotations popup, false otherwise.<a name="line.5847"></a>
<FONT color="green">5848</FONT>         * <a name="line.5848"></a>
<FONT color="green">5849</FONT>         * @see #setHoverAnnotationEnabled setHoverAnnotationEnabled<a name="line.5849"></a>
<FONT color="green">5850</FONT>         * <a name="line.5850"></a>
<FONT color="green">5851</FONT>         */<a name="line.5851"></a>
<FONT color="green">5852</FONT>        public boolean getHoverAnnotationEnabled() {<a name="line.5852"></a>
<FONT color="green">5853</FONT>          return hoverAnnotationEnabled;<a name="line.5853"></a>
<FONT color="green">5854</FONT>        }<a name="line.5854"></a>
<FONT color="green">5855</FONT>    <a name="line.5855"></a>
<FONT color="green">5856</FONT>        /**<a name="line.5856"></a>
<FONT color="green">5857</FONT>         * Retrieves the weight of the font that will be used with this symbol's<a name="line.5857"></a>
<FONT color="green">5858</FONT>         * hover annotations.<a name="line.5858"></a>
<FONT color="green">5859</FONT>         * &lt;p&gt;<a name="line.5859"></a>
<FONT color="green">5860</FONT>         * <a name="line.5860"></a>
<FONT color="green">5861</FONT>         * @return the standard CSS font-weight specification such as normal, bold,<a name="line.5861"></a>
<FONT color="green">5862</FONT>         *         bolder, lighter, 100, 200, ... 900, or inherit used by hover<a name="line.5862"></a>
<FONT color="green">5863</FONT>         *         annotations<a name="line.5863"></a>
<FONT color="green">5864</FONT>         * <a name="line.5864"></a>
<FONT color="green">5865</FONT>         * @see #setHoverFontWeight setHoverFontWeight<a name="line.5865"></a>
<FONT color="green">5866</FONT>         * <a name="line.5866"></a>
<FONT color="green">5867</FONT>         */<a name="line.5867"></a>
<FONT color="green">5868</FONT>        public String getHoverFontWeight() {<a name="line.5868"></a>
<FONT color="green">5869</FONT>          if (hoverAnnotation == null)<a name="line.5869"></a>
<FONT color="green">5870</FONT>            hoverAnnotation = new Annotation();<a name="line.5870"></a>
<FONT color="green">5871</FONT>          String result = hoverAnnotation.getFontWeight();<a name="line.5871"></a>
<FONT color="green">5872</FONT>          return result;<a name="line.5872"></a>
<FONT color="green">5873</FONT>        }<a name="line.5873"></a>
<FONT color="green">5874</FONT>    <a name="line.5874"></a>
<FONT color="green">5875</FONT>        /**<a name="line.5875"></a>
<FONT color="green">5876</FONT>         * Retrieves the font color of this symbol's hover annotations.<a name="line.5876"></a>
<FONT color="green">5877</FONT>         * &lt;p&gt;<a name="line.5877"></a>
<FONT color="green">5878</FONT>         * <a name="line.5878"></a>
<FONT color="green">5879</FONT>         * @return color of the font used to display this symbol's hover annotations<a name="line.5879"></a>
<FONT color="green">5880</FONT>         * <a name="line.5880"></a>
<FONT color="green">5881</FONT>         * @see #setHoverFontColor setHoverFontColor<a name="line.5881"></a>
<FONT color="green">5882</FONT>         */<a name="line.5882"></a>
<FONT color="green">5883</FONT>        public String getHoverFontColor() {<a name="line.5883"></a>
<FONT color="green">5884</FONT>          if (hoverAnnotation == null)<a name="line.5884"></a>
<FONT color="green">5885</FONT>            hoverAnnotation = new Annotation();<a name="line.5885"></a>
<FONT color="green">5886</FONT>          String result = hoverAnnotation.getFontColor();<a name="line.5886"></a>
<FONT color="green">5887</FONT>          return result;<a name="line.5887"></a>
<FONT color="green">5888</FONT>        }<a name="line.5888"></a>
<FONT color="green">5889</FONT>    <a name="line.5889"></a>
<FONT color="green">5890</FONT>        /**<a name="line.5890"></a>
<FONT color="green">5891</FONT>         * Retrieves the CSS font-family used with this symbol's hover annotations.<a name="line.5891"></a>
<FONT color="green">5892</FONT>         * <a name="line.5892"></a>
<FONT color="green">5893</FONT>         * @return the CSS font-family of text displayed in the hover annotations<a name="line.5893"></a>
<FONT color="green">5894</FONT>         *         associated with this symbol.<a name="line.5894"></a>
<FONT color="green">5895</FONT>         * <a name="line.5895"></a>
<FONT color="green">5896</FONT>         * @see #setHoverFontFamily setHoverFontFamily<a name="line.5896"></a>
<FONT color="green">5897</FONT>         */<a name="line.5897"></a>
<FONT color="green">5898</FONT>        public String getHoverFontFamily() {<a name="line.5898"></a>
<FONT color="green">5899</FONT>          if (hoverAnnotation == null)<a name="line.5899"></a>
<FONT color="green">5900</FONT>            hoverAnnotation = new Annotation();<a name="line.5900"></a>
<FONT color="green">5901</FONT>          String result = hoverAnnotation.getFontFamily();<a name="line.5901"></a>
<FONT color="green">5902</FONT>          return result;<a name="line.5902"></a>
<FONT color="green">5903</FONT>        }<a name="line.5903"></a>
<FONT color="green">5904</FONT>    <a name="line.5904"></a>
<FONT color="green">5905</FONT>        /**<a name="line.5905"></a>
<FONT color="green">5906</FONT>         * Retrieves the CSS font-style used with this symbol's hover annotations.<a name="line.5906"></a>
<FONT color="green">5907</FONT>         * <a name="line.5907"></a>
<FONT color="green">5908</FONT>         * @return the CSS font-style, namely, normal, italic, oblique, or inherit<a name="line.5908"></a>
<FONT color="green">5909</FONT>         *         of text displayed in the hover annotations associated with this<a name="line.5909"></a>
<FONT color="green">5910</FONT>         *         symbol<a name="line.5910"></a>
<FONT color="green">5911</FONT>         * <a name="line.5911"></a>
<FONT color="green">5912</FONT>         * @see #setHoverFontStyle setHoverFontStyle<a name="line.5912"></a>
<FONT color="green">5913</FONT>         */<a name="line.5913"></a>
<FONT color="green">5914</FONT>        public String getHoverFontStyle() {<a name="line.5914"></a>
<FONT color="green">5915</FONT>          if (hoverAnnotation == null)<a name="line.5915"></a>
<FONT color="green">5916</FONT>            hoverAnnotation = new Annotation();<a name="line.5916"></a>
<FONT color="green">5917</FONT>          String result = hoverAnnotation.getFontStyle();<a name="line.5917"></a>
<FONT color="green">5918</FONT>          return result;<a name="line.5918"></a>
<FONT color="green">5919</FONT>        }<a name="line.5919"></a>
<FONT color="green">5920</FONT>    <a name="line.5920"></a>
<FONT color="green">5921</FONT>        /**<a name="line.5921"></a>
<FONT color="green">5922</FONT>         * Retrieves the CSS font size used with this symbol's hover annotations, in<a name="line.5922"></a>
<FONT color="green">5923</FONT>         * pixels.<a name="line.5923"></a>
<FONT color="green">5924</FONT>         * <a name="line.5924"></a>
<FONT color="green">5925</FONT>         * @return the font size used in the text displayed in the hover annotations<a name="line.5925"></a>
<FONT color="green">5926</FONT>         *         associated with this symbol.<a name="line.5926"></a>
<FONT color="green">5927</FONT>         * <a name="line.5927"></a>
<FONT color="green">5928</FONT>         * @see #setHoverFontSize setHoverFontSize<a name="line.5928"></a>
<FONT color="green">5929</FONT>         * <a name="line.5929"></a>
<FONT color="green">5930</FONT>         */<a name="line.5930"></a>
<FONT color="green">5931</FONT>        public int getHoverFontSize() {<a name="line.5931"></a>
<FONT color="green">5932</FONT>          if (hoverAnnotation == null)<a name="line.5932"></a>
<FONT color="green">5933</FONT>            hoverAnnotation = new Annotation();<a name="line.5933"></a>
<FONT color="green">5934</FONT>          int result = hoverAnnotation.getFontSize();<a name="line.5934"></a>
<FONT color="green">5935</FONT>          return result;<a name="line.5935"></a>
<FONT color="green">5936</FONT>        }<a name="line.5936"></a>
<FONT color="green">5937</FONT>    <a name="line.5937"></a>
<FONT color="green">5938</FONT>        /**<a name="line.5938"></a>
<FONT color="green">5939</FONT>         * Retrieves point-relative location of this symbol's hover annotations.<a name="line.5939"></a>
<FONT color="green">5940</FONT>         * &lt;p&gt;<a name="line.5940"></a>
<FONT color="green">5941</FONT>         * <a name="line.5941"></a>
<FONT color="green">5942</FONT>         * @return the relative location of the hover annotations for all points on<a name="line.5942"></a>
<FONT color="green">5943</FONT>         *         the curve associated with this symbol.<a name="line.5943"></a>
<FONT color="green">5944</FONT>         * <a name="line.5944"></a>
<FONT color="green">5945</FONT>         * @see #setHoverLocation setHoverLocation<a name="line.5945"></a>
<FONT color="green">5946</FONT>         * @see #DEFAULT_HOVER_LOCATION DEFAULT_HOVER_LOCATION<a name="line.5946"></a>
<FONT color="green">5947</FONT>         * <a name="line.5947"></a>
<FONT color="green">5948</FONT>         */<a name="line.5948"></a>
<FONT color="green">5949</FONT>        public AnnotationLocation getHoverLocation() {<a name="line.5949"></a>
<FONT color="green">5950</FONT>          if (hoverAnnotation == null)<a name="line.5950"></a>
<FONT color="green">5951</FONT>            hoverAnnotation = new Annotation();<a name="line.5951"></a>
<FONT color="green">5952</FONT>          AnnotationLocation result = hoverAnnotation.getLocation();<a name="line.5952"></a>
<FONT color="green">5953</FONT>          if (null == result)<a name="line.5953"></a>
<FONT color="green">5954</FONT>            result = getSymbolType().defaultHoverLocation();<a name="line.5954"></a>
<FONT color="green">5955</FONT>          return result;<a name="line.5955"></a>
<FONT color="green">5956</FONT>        }<a name="line.5956"></a>
<FONT color="green">5957</FONT>    <a name="line.5957"></a>
<FONT color="green">5958</FONT>        /**<a name="line.5958"></a>
<FONT color="green">5959</FONT>         * Retrieves the symbol type that will determine how the hover annotations<a name="line.5959"></a>
<FONT color="green">5960</FONT>         * for this symbol gets positioned.<a name="line.5960"></a>
<FONT color="green">5961</FONT>         * &lt;p&gt;<a name="line.5961"></a>
<FONT color="green">5962</FONT>         * <a name="line.5962"></a>
<FONT color="green">5963</FONT>         * @return &lt;tt&gt;SymbolType&lt;/tt&gt; used to position hover annotations, or<a name="line.5963"></a>
<FONT color="green">5964</FONT>         *         &lt;tt&gt;null&lt;/tt&gt; if the symbol type of the hovered over point is<a name="line.5964"></a>
<FONT color="green">5965</FONT>         *         being used.<a name="line.5965"></a>
<FONT color="green">5966</FONT>         * <a name="line.5966"></a>
<FONT color="green">5967</FONT>         * @see #setHoverAnnotationSymbolType setHoverAnnotationSymbolType<a name="line.5967"></a>
<FONT color="green">5968</FONT>         * <a name="line.5968"></a>
<FONT color="green">5969</FONT>         */<a name="line.5969"></a>
<FONT color="green">5970</FONT>        public SymbolType getHoverAnnotationSymbolType() {<a name="line.5970"></a>
<FONT color="green">5971</FONT>          return hoverAnnotationSymbolType;<a name="line.5971"></a>
<FONT color="green">5972</FONT>        }<a name="line.5972"></a>
<FONT color="green">5973</FONT>    <a name="line.5973"></a>
<FONT color="green">5974</FONT>        /**<a name="line.5974"></a>
<FONT color="green">5975</FONT>         * Retrieves the background color used to indicate that the mouse is<a name="line.5975"></a>
<FONT color="green">5976</FONT>         * "touching" (hovering over) a point.<a name="line.5976"></a>
<FONT color="green">5977</FONT>         * <a name="line.5977"></a>
<FONT color="green">5978</FONT>         * @return a CSS color specification string that represents the background<a name="line.5978"></a>
<FONT color="green">5979</FONT>         *         color used to indicate "hover-selection".<a name="line.5979"></a>
<FONT color="green">5980</FONT>         * <a name="line.5980"></a>
<FONT color="green">5981</FONT>         * @see #setHoverSelectionBackgroundColor setHoverSelectionBackgroundColor<a name="line.5981"></a>
<FONT color="green">5982</FONT>         */<a name="line.5982"></a>
<FONT color="green">5983</FONT>        public String getHoverSelectionBackgroundColor() {<a name="line.5983"></a>
<FONT color="green">5984</FONT>          return hoverSelectionBackgroundColor;<a name="line.5984"></a>
<FONT color="green">5985</FONT>        }<a name="line.5985"></a>
<FONT color="green">5986</FONT>    <a name="line.5986"></a>
<FONT color="green">5987</FONT>        /**<a name="line.5987"></a>
<FONT color="green">5988</FONT>         * Retrieves the border color used to indicate that the mouse is "touching"<a name="line.5988"></a>
<FONT color="green">5989</FONT>         * (hovering over) a point.<a name="line.5989"></a>
<FONT color="green">5990</FONT>         * <a name="line.5990"></a>
<FONT color="green">5991</FONT>         * @return a CSS color specification string that represents the border color<a name="line.5991"></a>
<FONT color="green">5992</FONT>         *         used to indicate "hover-selection".<a name="line.5992"></a>
<FONT color="green">5993</FONT>         * <a name="line.5993"></a>
<FONT color="green">5994</FONT>         * @see #setHoverSelectionBorderColor setHoverSelectionBorderColor<a name="line.5994"></a>
<FONT color="green">5995</FONT>         */<a name="line.5995"></a>
<FONT color="green">5996</FONT>        public String getHoverSelectionBorderColor() {<a name="line.5996"></a>
<FONT color="green">5997</FONT>          return hoverSelectionBorderColor;<a name="line.5997"></a>
<FONT color="green">5998</FONT>        }<a name="line.5998"></a>
<FONT color="green">5999</FONT>    <a name="line.5999"></a>
<FONT color="green">6000</FONT>        /**<a name="line.6000"></a>
<FONT color="green">6001</FONT>         * Retrieves the border style used to indicate that the mouse is "touching"<a name="line.6001"></a>
<FONT color="green">6002</FONT>         * (hovering over) a point.<a name="line.6002"></a>
<FONT color="green">6003</FONT>         * <a name="line.6003"></a>
<FONT color="green">6004</FONT>         * @return a CSS border style specification string that represents the<a name="line.6004"></a>
<FONT color="green">6005</FONT>         *         border style used to indicate "hover-selection".<a name="line.6005"></a>
<FONT color="green">6006</FONT>         * <a name="line.6006"></a>
<FONT color="green">6007</FONT>         * @see #setHoverSelectionBorderStyle setHoverSelectionBorderStyle<a name="line.6007"></a>
<FONT color="green">6008</FONT>         */<a name="line.6008"></a>
<FONT color="green">6009</FONT>        public String getHoverSelectionBorderStyle() {<a name="line.6009"></a>
<FONT color="green">6010</FONT>          return hoverSelectionBorderStyle;<a name="line.6010"></a>
<FONT color="green">6011</FONT>        }<a name="line.6011"></a>
<FONT color="green">6012</FONT>    <a name="line.6012"></a>
<FONT color="green">6013</FONT>        /**<a name="line.6013"></a>
<FONT color="green">6014</FONT>         * Retrieves the width of the border drawn to indicate that the<a name="line.6014"></a>
<FONT color="green">6015</FONT>         * mouse is "touching" (hovering over) a point.<a name="line.6015"></a>
<FONT color="green">6016</FONT>         * <a name="line.6016"></a>
<FONT color="green">6017</FONT>         * @return the width of the border drawn around to indicate that it has been<a name="line.6017"></a>
<FONT color="green">6018</FONT>         *         "touched: by the mouse.<a name="line.6018"></a>
<FONT color="green">6019</FONT>         * <a name="line.6019"></a>
<FONT color="green">6020</FONT>         * @see #setHoverSelectionBorderWidth setHoverSelectionBorderWidth<a name="line.6020"></a>
<FONT color="green">6021</FONT>         */<a name="line.6021"></a>
<FONT color="green">6022</FONT>        public int getHoverSelectionBorderWidth() {<a name="line.6022"></a>
<FONT color="green">6023</FONT>          return hoverSelectionBorderWidth;<a name="line.6023"></a>
<FONT color="green">6024</FONT>        }<a name="line.6024"></a>
<FONT color="green">6025</FONT>    <a name="line.6025"></a>
<FONT color="green">6026</FONT>        /**<a name="line.6026"></a>
<FONT color="green">6027</FONT>         * Retrieves a boolean that indicates if hover selection feedback will be<a name="line.6027"></a>
<FONT color="green">6028</FONT>         * provided for this curve.<a name="line.6028"></a>
<FONT color="green">6029</FONT>         * &lt;p&gt;<a name="line.6029"></a>
<FONT color="green">6030</FONT>         * <a name="line.6030"></a>
<FONT color="green">6031</FONT>         * @return if true, hover selection feedback is enabled, if false, hovering<a name="line.6031"></a>
<FONT color="green">6032</FONT>         *         over a point does not change its color.<a name="line.6032"></a>
<FONT color="green">6033</FONT>         * <a name="line.6033"></a>
<FONT color="green">6034</FONT>         * @see #setHoverSelectionEnabled setHoverSelectionEnabled<a name="line.6034"></a>
<FONT color="green">6035</FONT>         * <a name="line.6035"></a>
<FONT color="green">6036</FONT>         */<a name="line.6036"></a>
<FONT color="green">6037</FONT>        public boolean getHoverSelectionEnabled() {<a name="line.6037"></a>
<FONT color="green">6038</FONT>          return hoverSelectionEnabled;<a name="line.6038"></a>
<FONT color="green">6039</FONT>        }<a name="line.6039"></a>
<FONT color="green">6040</FONT>    <a name="line.6040"></a>
<FONT color="green">6041</FONT>        /**<a name="line.6041"></a>
<FONT color="green">6042</FONT>         * Returns the fill spacing that will be used when rendering this curve's<a name="line.6042"></a>
<FONT color="green">6043</FONT>         * hover selection feedback.<a name="line.6043"></a>
<FONT color="green">6044</FONT>         * &lt;p&gt;<a name="line.6044"></a>
<FONT color="green">6045</FONT>         * <a name="line.6045"></a>
<FONT color="green">6046</FONT>         * @return fill spacing used by hover selection feedback, or<a name="line.6046"></a>
<FONT color="green">6047</FONT>         *         &lt;tt&gt;GChart.NAI&lt;/tt&gt; if the fill spacing setting of the<a name="line.6047"></a>
<FONT color="green">6048</FONT>         *         hovered-over curve is to be used.<a name="line.6048"></a>
<FONT color="green">6049</FONT>         * <a name="line.6049"></a>
<FONT color="green">6050</FONT>         * @see #setHoverSelectionFillSpacing setHoverSelectionFillSpacing<a name="line.6050"></a>
<FONT color="green">6051</FONT>         * <a name="line.6051"></a>
<FONT color="green">6052</FONT>         */<a name="line.6052"></a>
<FONT color="green">6053</FONT>        public double getHoverSelectionFillSpacing() {<a name="line.6053"></a>
<FONT color="green">6054</FONT>          return hoverSelectionFillSpacing;<a name="line.6054"></a>
<FONT color="green">6055</FONT>        }<a name="line.6055"></a>
<FONT color="green">6056</FONT>    <a name="line.6056"></a>
<FONT color="green">6057</FONT>        /**<a name="line.6057"></a>
<FONT color="green">6058</FONT>         * Returns the fill thickness that will be used when rendering this curve's<a name="line.6058"></a>
<FONT color="green">6059</FONT>         * hover selection feedback.<a name="line.6059"></a>
<FONT color="green">6060</FONT>         * &lt;p&gt;<a name="line.6060"></a>
<FONT color="green">6061</FONT>         * <a name="line.6061"></a>
<FONT color="green">6062</FONT>         * @return fill thickness used by hover selection feedback, or<a name="line.6062"></a>
<FONT color="green">6063</FONT>         *         &lt;tt&gt;GChart.NAI&lt;/tt&gt; if the fill thickness setting of the<a name="line.6063"></a>
<FONT color="green">6064</FONT>         *         hovered-over curve is to be used.<a name="line.6064"></a>
<FONT color="green">6065</FONT>         * <a name="line.6065"></a>
<FONT color="green">6066</FONT>         * @see #setHoverSelectionFillThickness setHoverSelectionFillThickness<a name="line.6066"></a>
<FONT color="green">6067</FONT>         * <a name="line.6067"></a>
<FONT color="green">6068</FONT>         */<a name="line.6068"></a>
<FONT color="green">6069</FONT>        public int getHoverSelectionFillThickness() {<a name="line.6069"></a>
<FONT color="green">6070</FONT>          return hoverSelectionFillThickness;<a name="line.6070"></a>
<FONT color="green">6071</FONT>        }<a name="line.6071"></a>
<FONT color="green">6072</FONT>    <a name="line.6072"></a>
<FONT color="green">6073</FONT>        /**<a name="line.6073"></a>
<FONT color="green">6074</FONT>         * Returns the height of the symbol used to indicate when a given point is<a name="line.6074"></a>
<FONT color="green">6075</FONT>         * being "hovered over" with the mouse.<a name="line.6075"></a>
<FONT color="green">6076</FONT>         * &lt;p&gt;<a name="line.6076"></a>
<FONT color="green">6077</FONT>         * <a name="line.6077"></a>
<FONT color="green">6078</FONT>         * @return the height of the symbol used to indicate that that a point has<a name="line.6078"></a>
<FONT color="green">6079</FONT>         *         been selected, or &lt;tt&gt;GChart.NAI&lt;/tt&gt; if the the height of the<a name="line.6079"></a>
<FONT color="green">6080</FONT>         *         symbol representing the selected point is being used.<a name="line.6080"></a>
<FONT color="green">6081</FONT>         * <a name="line.6081"></a>
<FONT color="green">6082</FONT>         * <a name="line.6082"></a>
<FONT color="green">6083</FONT>         * @see #setHoverSelectionHeight setHoverSelectionHeight<a name="line.6083"></a>
<FONT color="green">6084</FONT>         * <a name="line.6084"></a>
<FONT color="green">6085</FONT>         */<a name="line.6085"></a>
<FONT color="green">6086</FONT>        public int getHoverSelectionHeight() {<a name="line.6086"></a>
<FONT color="green">6087</FONT>          return hoverSelectionHeight;<a name="line.6087"></a>
<FONT color="green">6088</FONT>        }<a name="line.6088"></a>
<FONT color="green">6089</FONT>    <a name="line.6089"></a>
<FONT color="green">6090</FONT>        /**<a name="line.6090"></a>
<FONT color="green">6091</FONT>         * Returns the URL that will be used for all of the images used in rendering<a name="line.6091"></a>
<FONT color="green">6092</FONT>         * this symbol's selection feedback.<a name="line.6092"></a>
<FONT color="green">6093</FONT>         * <a name="line.6093"></a>
<FONT color="green">6094</FONT>         * @see #setHoverSelectionImageURL setHoverSelectionImageURL<a name="line.6094"></a>
<FONT color="green">6095</FONT>         * <a name="line.6095"></a>
<FONT color="green">6096</FONT>         * @return the url that defines the &lt;tt&gt;src&lt;/tt&gt; property of all images used<a name="line.6096"></a>
<FONT color="green">6097</FONT>         *         to draw this the selection feedback associated with this symbol.<a name="line.6097"></a>
<FONT color="green">6098</FONT>         * <a name="line.6098"></a>
<FONT color="green">6099</FONT>         */<a name="line.6099"></a>
<FONT color="green">6100</FONT>    <a name="line.6100"></a>
<FONT color="green">6101</FONT>        public String getHoverSelectionImageURL() {<a name="line.6101"></a>
<FONT color="green">6102</FONT>          String result = (null == hoverSelectionImageURL) ? getBlankImageURL()<a name="line.6102"></a>
<FONT color="green">6103</FONT>              : hoverSelectionImageURL;<a name="line.6103"></a>
<FONT color="green">6104</FONT>          return result;<a name="line.6104"></a>
<FONT color="green">6105</FONT>        }<a name="line.6105"></a>
<FONT color="green">6106</FONT>    <a name="line.6106"></a>
<FONT color="green">6107</FONT>        /**<a name="line.6107"></a>
<FONT color="green">6108</FONT>         * <a name="line.6108"></a>
<FONT color="green">6109</FONT>         * Returns the symbol type that GChart will use when generating selection<a name="line.6109"></a>
<FONT color="green">6110</FONT>         * feedback. GChart indicates that a point is selected by re-rendering the<a name="line.6110"></a>
<FONT color="green">6111</FONT>         * point as if it had this symbol type.<a name="line.6111"></a>
<FONT color="green">6112</FONT>         * <a name="line.6112"></a>
<FONT color="green">6113</FONT>         * @return the symbol type that in part determines how selection feedback<a name="line.6113"></a>
<FONT color="green">6114</FONT>         *         for a hovered over point is drawn, or &lt;tt&gt;null&lt;/tt&gt; if defaulting<a name="line.6114"></a>
<FONT color="green">6115</FONT>         *         to the symbol type of the hovered over point.<a name="line.6115"></a>
<FONT color="green">6116</FONT>         * <a name="line.6116"></a>
<FONT color="green">6117</FONT>         * @see #setHoverSelectionSymbolType setHoverSelectionSymbolType<a name="line.6117"></a>
<FONT color="green">6118</FONT>         * <a name="line.6118"></a>
<FONT color="green">6119</FONT>         */<a name="line.6119"></a>
<FONT color="green">6120</FONT>        public SymbolType getHoverSelectionSymbolType() {<a name="line.6120"></a>
<FONT color="green">6121</FONT>          return hoverSelectionSymbolType;<a name="line.6121"></a>
<FONT color="green">6122</FONT>        }<a name="line.6122"></a>
<FONT color="green">6123</FONT>    <a name="line.6123"></a>
<FONT color="green">6124</FONT>        /**<a name="line.6124"></a>
<FONT color="green">6125</FONT>         * Returns the width of the symbol used to indicate when a given point is<a name="line.6125"></a>
<FONT color="green">6126</FONT>         * being "hovered over" with the mouse.<a name="line.6126"></a>
<FONT color="green">6127</FONT>         * <a name="line.6127"></a>
<FONT color="green">6128</FONT>         * @return the width of the symbol used to indicate that that a point has<a name="line.6128"></a>
<FONT color="green">6129</FONT>         *         been selected, or &lt;tt&gt;GChart.NAI&lt;/tt&gt; if using to the width of<a name="line.6129"></a>
<FONT color="green">6130</FONT>         *         the symbol representing the selected point.<a name="line.6130"></a>
<FONT color="green">6131</FONT>         * <a name="line.6131"></a>
<FONT color="green">6132</FONT>         * @see #setHoverSelectionWidth setHoverSelectionWidth<a name="line.6132"></a>
<FONT color="green">6133</FONT>         * <a name="line.6133"></a>
<FONT color="green">6134</FONT>         * <a name="line.6134"></a>
<FONT color="green">6135</FONT>         */<a name="line.6135"></a>
<FONT color="green">6136</FONT>        public int getHoverSelectionWidth() {<a name="line.6136"></a>
<FONT color="green">6137</FONT>          return hoverSelectionWidth;<a name="line.6137"></a>
<FONT color="green">6138</FONT>        }<a name="line.6138"></a>
<FONT color="green">6139</FONT>    <a name="line.6139"></a>
<FONT color="green">6140</FONT>        /**<a name="line.6140"></a>
<FONT color="green">6141</FONT>         * Returns the hovertextTemplate of this symbol.<a name="line.6141"></a>
<FONT color="green">6142</FONT>         * &lt;p&gt;<a name="line.6142"></a>
<FONT color="green">6143</FONT>         * <a name="line.6143"></a>
<FONT color="green">6144</FONT>         * @return hovertextTemplate of the symbol<a name="line.6144"></a>
<FONT color="green">6145</FONT>         * <a name="line.6145"></a>
<FONT color="green">6146</FONT>         * <a name="line.6146"></a>
<FONT color="green">6147</FONT>         * @see #setHovertextTemplate(String) setHovertextTemplate<a name="line.6147"></a>
<FONT color="green">6148</FONT>         * <a name="line.6148"></a>
<FONT color="green">6149</FONT>         */<a name="line.6149"></a>
<FONT color="green">6150</FONT>        public String getHovertextTemplate() {<a name="line.6150"></a>
<FONT color="green">6151</FONT>          if (null == hovertextTemplate)<a name="line.6151"></a>
<FONT color="green">6152</FONT>            return symbolType.defaultHovertextTemplate();<a name="line.6152"></a>
<FONT color="green">6153</FONT>          else<a name="line.6153"></a>
<FONT color="green">6154</FONT>            return hovertextTemplate;<a name="line.6154"></a>
<FONT color="green">6155</FONT>        }<a name="line.6155"></a>
<FONT color="green">6156</FONT>    <a name="line.6156"></a>
<FONT color="green">6157</FONT>        /**<a name="line.6157"></a>
<FONT color="green">6158</FONT>         * When widget-based hover annotations are being used by the curve<a name="line.6158"></a>
<FONT color="green">6159</FONT>         * associated with this symbol, this method returns the<a name="line.6159"></a>
<FONT color="green">6160</FONT>         * &lt;tt&gt;HoverUpdateable&lt;/tt&gt; widget used within those annotations. When<a name="line.6160"></a>
<FONT color="green">6161</FONT>         * simple text or HTML hover annotations are being used, it returns null.<a name="line.6161"></a>
<FONT color="green">6162</FONT>         * <a name="line.6162"></a>
<FONT color="green">6163</FONT>         * @return the widget used to provide widget-based hover annotations or null<a name="line.6163"></a>
<FONT color="green">6164</FONT>         *         if hover annotations are not widget-based.<a name="line.6164"></a>
<FONT color="green">6165</FONT>         * <a name="line.6165"></a>
<FONT color="green">6166</FONT>         * @see #setHoverWidget setHoverWidget<a name="line.6166"></a>
<FONT color="green">6167</FONT>         * <a name="line.6167"></a>
<FONT color="green">6168</FONT>         */<a name="line.6168"></a>
<FONT color="green">6169</FONT>        public HoverUpdateable getHoverWidget() {<a name="line.6169"></a>
<FONT color="green">6170</FONT>          if (hoverAnnotation == null)<a name="line.6170"></a>
<FONT color="green">6171</FONT>            hoverAnnotation = new Annotation();<a name="line.6171"></a>
<FONT color="green">6172</FONT>          return (HoverUpdateable) hoverAnnotation.getWidget();<a name="line.6172"></a>
<FONT color="green">6173</FONT>        }<a name="line.6173"></a>
<FONT color="green">6174</FONT>    <a name="line.6174"></a>
<FONT color="green">6175</FONT>        /**<a name="line.6175"></a>
<FONT color="green">6176</FONT>         * Retrieves the number of pixels (along the x-axis) that this point's<a name="line.6176"></a>
<FONT color="green">6177</FONT>         * hover-annotation will be moved from its default,<a name="line.6177"></a>
<FONT color="green">6178</FONT>         * &lt;tt&gt;setHoverLocation&lt;/tt&gt; defined, point-relative location.<a name="line.6178"></a>
<FONT color="green">6179</FONT>         * &lt;p&gt;<a name="line.6179"></a>
<FONT color="green">6180</FONT>         * <a name="line.6180"></a>
<FONT color="green">6181</FONT>         * @return x-shift, in pixels, of the hover annotation<a name="line.6181"></a>
<FONT color="green">6182</FONT>         * <a name="line.6182"></a>
<FONT color="green">6183</FONT>         * @see #setHoverXShift getHoverXShift<a name="line.6183"></a>
<FONT color="green">6184</FONT>         * <a name="line.6184"></a>
<FONT color="green">6185</FONT>         */<a name="line.6185"></a>
<FONT color="green">6186</FONT>        public int getHoverXShift() {<a name="line.6186"></a>
<FONT color="green">6187</FONT>          if (hoverAnnotation == null)<a name="line.6187"></a>
<FONT color="green">6188</FONT>            hoverAnnotation = new Annotation();<a name="line.6188"></a>
<FONT color="green">6189</FONT>          int result = hoverAnnotation.getXShift();<a name="line.6189"></a>
<FONT color="green">6190</FONT>          return result;<a name="line.6190"></a>
<FONT color="green">6191</FONT>        }<a name="line.6191"></a>
<FONT color="green">6192</FONT>    <a name="line.6192"></a>
<FONT color="green">6193</FONT>        /**<a name="line.6193"></a>
<FONT color="green">6194</FONT>         * Retrieves the number of pixels (along the y-axis) that this point's hover<a name="line.6194"></a>
<FONT color="green">6195</FONT>         * annotation will be moved from its default, &lt;tt&gt;setHoverLocation&lt;/tt&gt;<a name="line.6195"></a>
<FONT color="green">6196</FONT>         * defined, point-relative location.<a name="line.6196"></a>
<FONT color="green">6197</FONT>         * &lt;p&gt;<a name="line.6197"></a>
<FONT color="green">6198</FONT>         * <a name="line.6198"></a>
<FONT color="green">6199</FONT>         * @return y-shift, in pixels, of the hover annotation<a name="line.6199"></a>
<FONT color="green">6200</FONT>         * <a name="line.6200"></a>
<FONT color="green">6201</FONT>         * @see #setHoverYShift setHoverYShift<a name="line.6201"></a>
<FONT color="green">6202</FONT>         * <a name="line.6202"></a>
<FONT color="green">6203</FONT>         */<a name="line.6203"></a>
<FONT color="green">6204</FONT>        public int getHoverYShift() {<a name="line.6204"></a>
<FONT color="green">6205</FONT>          if (hoverAnnotation == null)<a name="line.6205"></a>
<FONT color="green">6206</FONT>            hoverAnnotation = new Annotation();<a name="line.6206"></a>
<FONT color="green">6207</FONT>          int result = hoverAnnotation.getYShift();<a name="line.6207"></a>
<FONT color="green">6208</FONT>          return result;<a name="line.6208"></a>
<FONT color="green">6209</FONT>        }<a name="line.6209"></a>
<FONT color="green">6210</FONT>    <a name="line.6210"></a>
<FONT color="green">6211</FONT>        /**<a name="line.6211"></a>
<FONT color="green">6212</FONT>         * Returns the URL that will be used for all of the images used in rendering<a name="line.6212"></a>
<FONT color="green">6213</FONT>         * this symbol.<a name="line.6213"></a>
<FONT color="green">6214</FONT>         * &lt;p&gt;<a name="line.6214"></a>
<FONT color="green">6215</FONT>         * <a name="line.6215"></a>
<FONT color="green">6216</FONT>         * @see #setImageURL setImageURL<a name="line.6216"></a>
<FONT color="green">6217</FONT>         * @see #setBlankImageURL setBlankImageURL<a name="line.6217"></a>
<FONT color="green">6218</FONT>         * <a name="line.6218"></a>
<FONT color="green">6219</FONT>         * @return the url that defines the &lt;tt&gt;src&lt;/tt&gt; property of all images used<a name="line.6219"></a>
<FONT color="green">6220</FONT>         *         to draw this symbol on the chart.<a name="line.6220"></a>
<FONT color="green">6221</FONT>         */<a name="line.6221"></a>
<FONT color="green">6222</FONT>        public String getImageURL() {<a name="line.6222"></a>
<FONT color="green">6223</FONT>          String result = (null == imageURL) ? getBlankImageURL() : imageURL;<a name="line.6223"></a>
<FONT color="green">6224</FONT>          return result;<a name="line.6224"></a>
<FONT color="green">6225</FONT>        }<a name="line.6225"></a>
<FONT color="green">6226</FONT>    <a name="line.6226"></a>
<FONT color="green">6227</FONT>        // returns an internal, parsed form of the hovertext template<a name="line.6227"></a>
<FONT color="green">6228</FONT>        HovertextChunk[] getHovertextChunks() {<a name="line.6228"></a>
<FONT color="green">6229</FONT>          if (null == hovertextChunks)<a name="line.6229"></a>
<FONT color="green">6230</FONT>            hovertextChunks = <a name="line.6230"></a>
<FONT color="green">6231</FONT>              HovertextChunk.parseHovertextTemplate(getHovertextTemplate());<a name="line.6231"></a>
<FONT color="green">6232</FONT>    <a name="line.6232"></a>
<FONT color="green">6233</FONT>          return hovertextChunks;<a name="line.6233"></a>
<FONT color="green">6234</FONT>        }<a name="line.6234"></a>
<FONT color="green">6235</FONT>    <a name="line.6235"></a>
<FONT color="green">6236</FONT>        /**<a name="line.6236"></a>
<FONT color="green">6237</FONT>         * Returns the &lt;tt&gt;Curve&lt;/tt&gt; that contains this &lt;tt&gt;Symbol&lt;/tt&gt;.<a name="line.6237"></a>
<FONT color="green">6238</FONT>         * <a name="line.6238"></a>
<FONT color="green">6239</FONT>         * @return a reference to the &lt;tt&gt;Curve&lt;/tt&gt; that contains this<a name="line.6239"></a>
<FONT color="green">6240</FONT>         *         &lt;tt&gt;Symbol&lt;/tt&gt; (its "parent")<a name="line.6240"></a>
<FONT color="green">6241</FONT>         * <a name="line.6241"></a>
<FONT color="green">6242</FONT>         */<a name="line.6242"></a>
<FONT color="green">6243</FONT>        public Curve getParent() {<a name="line.6243"></a>
<FONT color="green">6244</FONT>          return parent;<a name="line.6244"></a>
<FONT color="green">6245</FONT>        }<a name="line.6245"></a>
<FONT color="green">6246</FONT>    <a name="line.6246"></a>
<FONT color="green">6247</FONT>        /**<a name="line.6247"></a>
<FONT color="green">6248</FONT>         * Returns the value, previously specified via<a name="line.6248"></a>
<FONT color="green">6249</FONT>         * &lt;tt&gt;setPieSliceOrientation&lt;/tt&gt;, that defines the angular orientation of<a name="line.6249"></a>
<FONT color="green">6250</FONT>         * any pie slices associated with this symbol.<a name="line.6250"></a>
<FONT color="green">6251</FONT>         * &lt;p&gt;<a name="line.6251"></a>
<FONT color="green">6252</FONT>         * <a name="line.6252"></a>
<FONT color="green">6253</FONT>         * <a name="line.6253"></a>
<FONT color="green">6254</FONT>         * @return the value, either &lt;tt&gt;Double.NaN&lt;/tt&gt; or a value between 0 and 1<a name="line.6254"></a>
<FONT color="green">6255</FONT>         *         previously set via &lt;tt&gt;setPieSliceOrientation&lt;/tt&gt;, that<a name="line.6255"></a>
<FONT color="green">6256</FONT>         *         determines the angular orientation of any pie slice associated<a name="line.6256"></a>
<FONT color="green">6257</FONT>         *         with this symbol.<a name="line.6257"></a>
<FONT color="green">6258</FONT>         * <a name="line.6258"></a>
<FONT color="green">6259</FONT>         * @see #setPieSliceOrientation setPieSliceOrientation<a name="line.6259"></a>
<FONT color="green">6260</FONT>         * @see #setPieSliceSize setPieSliceSize<a name="line.6260"></a>
<FONT color="green">6261</FONT>         * <a name="line.6261"></a>
<FONT color="green">6262</FONT>         */<a name="line.6262"></a>
<FONT color="green">6263</FONT>        public double getPieSliceOrientation() {<a name="line.6263"></a>
<FONT color="green">6264</FONT>          return pieSliceOrientation;<a name="line.6264"></a>
<FONT color="green">6265</FONT>        }<a name="line.6265"></a>
<FONT color="green">6266</FONT>    <a name="line.6266"></a>
<FONT color="green">6267</FONT>        /*<a name="line.6267"></a>
<FONT color="green">6268</FONT>         * Used internally to translate &lt;tt&gt;Double.NaN&lt;/tt&gt; into<a name="line.6268"></a>
<FONT color="green">6269</FONT>         * an appropriate default slice orientation that, when pie<a name="line.6269"></a>
<FONT color="green">6270</FONT>         * slice orientation isn't explicitly specified, results<a name="line.6270"></a>
<FONT color="green">6271</FONT>         * in a series of adjacent slices that will form a pie<a name="line.6271"></a>
<FONT color="green">6272</FONT>         * when the sum of the slice sizes equals 1.0<a name="line.6272"></a>
<FONT color="green">6273</FONT>         * <a name="line.6273"></a>
<FONT color="green">6274</FONT>         */ <a name="line.6274"></a>
<FONT color="green">6275</FONT>    <a name="line.6275"></a>
<FONT color="green">6276</FONT>        double getDecodedPieSliceOrientation() {<a name="line.6276"></a>
<FONT color="green">6277</FONT>          double result = pieSliceOrientation;<a name="line.6277"></a>
<FONT color="green">6278</FONT>          if ((result != result)) // x!=x is a faster isNaN<a name="line.6278"></a>
<FONT color="green">6279</FONT>            result = defaultPieSliceOrientation;<a name="line.6279"></a>
<FONT color="green">6280</FONT>          return result;<a name="line.6280"></a>
<FONT color="green">6281</FONT>        }<a name="line.6281"></a>
<FONT color="green">6282</FONT>    <a name="line.6282"></a>
<FONT color="green">6283</FONT>        void setDefaultPieSliceOrientation(double defaultOrientation) {<a name="line.6283"></a>
<FONT color="green">6284</FONT>          defaultPieSliceOrientation = defaultOrientation;<a name="line.6284"></a>
<FONT color="green">6285</FONT>        }<a name="line.6285"></a>
<FONT color="green">6286</FONT>    <a name="line.6286"></a>
<FONT color="green">6287</FONT>        double getDefaultPieSliceOrientation() {<a name="line.6287"></a>
<FONT color="green">6288</FONT>          return defaultPieSliceOrientation;<a name="line.6288"></a>
<FONT color="green">6289</FONT>        }<a name="line.6289"></a>
<FONT color="green">6290</FONT>    <a name="line.6290"></a>
<FONT color="green">6291</FONT>        /**<a name="line.6291"></a>
<FONT color="green">6292</FONT>         * Returns the value, previously specified via &lt;tt&gt;setPieSliceSize&lt;/tt&gt;,<a name="line.6292"></a>
<FONT color="green">6293</FONT>         * that defines the size of the angle subtended by any pie slice associated<a name="line.6293"></a>
<FONT color="green">6294</FONT>         * with this symbol.<a name="line.6294"></a>
<FONT color="green">6295</FONT>         * &lt;p&gt;<a name="line.6295"></a>
<FONT color="green">6296</FONT>         * <a name="line.6296"></a>
<FONT color="green">6297</FONT>         * @return the value, between 0 and 1 and previously set via<a name="line.6297"></a>
<FONT color="green">6298</FONT>         *         &lt;tt&gt;setPieSliceSize&lt;/tt&gt;, that defines the size of the<a name="line.6298"></a>
<FONT color="green">6299</FONT>         *         "wedge of pie" as a fraction of the total pie, for any pie slice<a name="line.6299"></a>
<FONT color="green">6300</FONT>         *         associated with this symbol.<a name="line.6300"></a>
<FONT color="green">6301</FONT>         * <a name="line.6301"></a>
<FONT color="green">6302</FONT>         * @see #setPieSliceOrientation setPieSliceOrientation<a name="line.6302"></a>
<FONT color="green">6303</FONT>         * @see #setPieSliceSize setPieSliceSize<a name="line.6303"></a>
<FONT color="green">6304</FONT>         * <a name="line.6304"></a>
<FONT color="green">6305</FONT>         */<a name="line.6305"></a>
<FONT color="green">6306</FONT>        public double getPieSliceSize() {<a name="line.6306"></a>
<FONT color="green">6307</FONT>          return pieSliceSize;<a name="line.6307"></a>
<FONT color="green">6308</FONT>        }<a name="line.6308"></a>
<FONT color="green">6309</FONT>    <a name="line.6309"></a>
<FONT color="green">6310</FONT>        /*<a name="line.6310"></a>
<FONT color="green">6311</FONT>         * Returns the radius of the pie from which this symbol's pie slice was<a name="line.6311"></a>
<FONT color="green">6312</FONT>         * extracted.<a name="line.6312"></a>
<FONT color="green">6313</FONT>         */<a name="line.6313"></a>
<FONT color="green">6314</FONT>        double getPieSliceRadius(PlotPanel pp, boolean onY2) {<a name="line.6314"></a>
<FONT color="green">6315</FONT>          double w = getWidth(pp); // needed to decode model<a name="line.6315"></a>
<FONT color="green">6316</FONT>          double h = getHeight(pp, onY2);// width,height into pixels<a name="line.6316"></a>
<FONT color="green">6317</FONT>          double result = Math.sqrt(w * w + h * h) / 2.;<a name="line.6317"></a>
<FONT color="green">6318</FONT>          /*<a name="line.6318"></a>
<FONT color="green">6319</FONT>           * Tweak radius to assure it is an even multiple of the fill<a name="line.6319"></a>
<FONT color="green">6320</FONT>           * spacing. Makes it possible to assure regular band spacing<a name="line.6320"></a>
<FONT color="green">6321</FONT>           * across pie at the expense of less precise control of pie<a name="line.6321"></a>
<FONT color="green">6322</FONT>           * size (regular band spacing makes it look much better).<a name="line.6322"></a>
<FONT color="green">6323</FONT>           *<a name="line.6323"></a>
<FONT color="green">6324</FONT>           */ <a name="line.6324"></a>
<FONT color="green">6325</FONT>          double spacing = getFillSpacing();<a name="line.6325"></a>
<FONT color="green">6326</FONT>          if (0 == spacing)<a name="line.6326"></a>
<FONT color="green">6327</FONT>            spacing = 1;<a name="line.6327"></a>
<FONT color="green">6328</FONT>          int nBands = (int) Math.round(result / spacing);<a name="line.6328"></a>
<FONT color="green">6329</FONT>          result = nBands * spacing;<a name="line.6329"></a>
<FONT color="green">6330</FONT>          return result;<a name="line.6330"></a>
<FONT color="green">6331</FONT>        }<a name="line.6331"></a>
<FONT color="green">6332</FONT>    <a name="line.6332"></a>
<FONT color="green">6333</FONT>        // defines first, second edge angle in standard radian units<a name="line.6333"></a>
<FONT color="green">6334</FONT>        double getPieSliceTheta0() {<a name="line.6334"></a>
<FONT color="green">6335</FONT>          double result;<a name="line.6335"></a>
<FONT color="green">6336</FONT>          result = (0.75 - getDecodedPieSliceOrientation()) * 2 * Math.PI;<a name="line.6336"></a>
<FONT color="green">6337</FONT>          return result;<a name="line.6337"></a>
<FONT color="green">6338</FONT>        }<a name="line.6338"></a>
<FONT color="green">6339</FONT>    <a name="line.6339"></a>
<FONT color="green">6340</FONT>        double getPieSliceTheta1() {<a name="line.6340"></a>
<FONT color="green">6341</FONT>          return getPieSliceTheta0() - 2. * Math.PI * getPieSliceSize();<a name="line.6341"></a>
<FONT color="green">6342</FONT>        }<a name="line.6342"></a>
<FONT color="green">6343</FONT>    <a name="line.6343"></a>
<FONT color="green">6344</FONT>        /**<a name="line.6344"></a>
<FONT color="green">6345</FONT>         * Returns this symbol's height, as previously set by &lt;tt&gt;setHeight&lt;/tt&gt; .<a name="line.6345"></a>
<FONT color="green">6346</FONT>         * <a name="line.6346"></a>
<FONT color="green">6347</FONT>         * @return the previously set symbol height, in pixels.<a name="line.6347"></a>
<FONT color="green">6348</FONT>         * <a name="line.6348"></a>
<FONT color="green">6349</FONT>         * @see #setHeight setHeight<a name="line.6349"></a>
<FONT color="green">6350</FONT>         */<a name="line.6350"></a>
<FONT color="green">6351</FONT>        public int getHeight() {<a name="line.6351"></a>
<FONT color="green">6352</FONT>          return height;<a name="line.6352"></a>
<FONT color="green">6353</FONT>        }<a name="line.6353"></a>
<FONT color="green">6354</FONT>    <a name="line.6354"></a>
<FONT color="green">6355</FONT>        /**<a name="line.6355"></a>
<FONT color="green">6356</FONT>         * Returns this symbol's height as previously set by<a name="line.6356"></a>
<FONT color="green">6357</FONT>         * &lt;tt&gt;setModelHeight&lt;/tt&gt;.<a name="line.6357"></a>
<FONT color="green">6358</FONT>         * <a name="line.6358"></a>
<FONT color="green">6359</FONT>         * @return the previously set symbol height, in model units<a name="line.6359"></a>
<FONT color="green">6360</FONT>         * <a name="line.6360"></a>
<FONT color="green">6361</FONT>         * @see #setModelHeight setModelHeight<a name="line.6361"></a>
<FONT color="green">6362</FONT>         * @see #setModelWidth setWidth<a name="line.6362"></a>
<FONT color="green">6363</FONT>         * @see #setHeight setHeight<a name="line.6363"></a>
<FONT color="green">6364</FONT>         * @see #setWidth setWidth<a name="line.6364"></a>
<FONT color="green">6365</FONT>         * <a name="line.6365"></a>
<FONT color="green">6366</FONT>         */<a name="line.6366"></a>
<FONT color="green">6367</FONT>        public double getModelHeight() {<a name="line.6367"></a>
<FONT color="green">6368</FONT>          return modelHeight;<a name="line.6368"></a>
<FONT color="green">6369</FONT>        }<a name="line.6369"></a>
<FONT color="green">6370</FONT>    <a name="line.6370"></a>
<FONT color="green">6371</FONT>        /**<a name="line.6371"></a>
<FONT color="green">6372</FONT>         * Returns this symbol's width as previously set by &lt;tt&gt;setModelWidth&lt;/tt&gt;.<a name="line.6372"></a>
<FONT color="green">6373</FONT>         * <a name="line.6373"></a>
<FONT color="green">6374</FONT>         * @return the previously set symbol width, in model units.<a name="line.6374"></a>
<FONT color="green">6375</FONT>         * <a name="line.6375"></a>
<FONT color="green">6376</FONT>         * @see #setModelWidth setModelWidth<a name="line.6376"></a>
<FONT color="green">6377</FONT>         * @see #setModelHeight setModelHeight<a name="line.6377"></a>
<FONT color="green">6378</FONT>         * @see #setWidth setWidth<a name="line.6378"></a>
<FONT color="green">6379</FONT>         * @see #setHeight setHeight<a name="line.6379"></a>
<FONT color="green">6380</FONT>         * <a name="line.6380"></a>
<FONT color="green">6381</FONT>         */<a name="line.6381"></a>
<FONT color="green">6382</FONT>        public double getModelWidth() {<a name="line.6382"></a>
<FONT color="green">6383</FONT>          return modelWidth;<a name="line.6383"></a>
<FONT color="green">6384</FONT>        }<a name="line.6384"></a>
<FONT color="green">6385</FONT>    <a name="line.6385"></a>
<FONT color="green">6386</FONT>        /**<a name="line.6386"></a>
<FONT color="green">6387</FONT>         * Returns this symbol's type.<a name="line.6387"></a>
<FONT color="green">6388</FONT>         * <a name="line.6388"></a>
<FONT color="green">6389</FONT>         * @return the type of this symbol.<a name="line.6389"></a>
<FONT color="green">6390</FONT>         * <a name="line.6390"></a>
<FONT color="green">6391</FONT>         * @see #setSymbolType setSymbolType<a name="line.6391"></a>
<FONT color="green">6392</FONT>         * <a name="line.6392"></a>
<FONT color="green">6393</FONT>         */<a name="line.6393"></a>
<FONT color="green">6394</FONT>        public SymbolType getSymbolType() {<a name="line.6394"></a>
<FONT color="green">6395</FONT>          return symbolType;<a name="line.6395"></a>
<FONT color="green">6396</FONT>        }<a name="line.6396"></a>
<FONT color="green">6397</FONT>    <a name="line.6397"></a>
<FONT color="green">6398</FONT>        /**<a name="line.6398"></a>
<FONT color="green">6399</FONT>         * Returns this symbol's width as previously set by &lt;tt&gt;setWidth&lt;/tt&gt;.<a name="line.6399"></a>
<FONT color="green">6400</FONT>         * &lt;p&gt;<a name="line.6400"></a>
<FONT color="green">6401</FONT>         * <a name="line.6401"></a>
<FONT color="green">6402</FONT>         * &lt;i&gt;Warning:&lt;/i&gt; This method won't return the correct pixel width<a name="line.6402"></a>
<FONT color="green">6403</FONT>         * associated with a &lt;tt&gt;setModelWidth&lt;/tt&gt; setting, as you might have<a name="line.6403"></a>
<FONT color="green">6404</FONT>         * expected. It only returns the pixel width you last explicitly specified<a name="line.6404"></a>
<FONT color="green">6405</FONT>         * via &lt;tt&gt;setWidth&lt;/tt&gt;.<a name="line.6405"></a>
<FONT color="green">6406</FONT>         * &lt;p&gt;<a name="line.6406"></a>
<FONT color="green">6407</FONT>         * <a name="line.6407"></a>
<FONT color="green">6408</FONT>         * @return the previously set symbol width, in pixels<a name="line.6408"></a>
<FONT color="green">6409</FONT>         * <a name="line.6409"></a>
<FONT color="green">6410</FONT>         * @see #setWidth setWidth<a name="line.6410"></a>
<FONT color="green">6411</FONT>         * @see #setModelWidth setModelWidth<a name="line.6411"></a>
<FONT color="green">6412</FONT>         */<a name="line.6412"></a>
<FONT color="green">6413</FONT>        public int getWidth() {<a name="line.6413"></a>
<FONT color="green">6414</FONT>          return width;<a name="line.6414"></a>
<FONT color="green">6415</FONT>        }<a name="line.6415"></a>
<FONT color="green">6416</FONT>    <a name="line.6416"></a>
<FONT color="green">6417</FONT>        /*<a name="line.6417"></a>
<FONT color="green">6418</FONT>         * Do points on the curve associated with this symbol use a<a name="line.6418"></a>
<FONT color="green">6419</FONT>         * horizontal (or vertical) binning strategy for "what point is the<a name="line.6419"></a>
<FONT color="green">6420</FONT>         * mouse over" hit testing?<a name="line.6420"></a>
<FONT color="green">6421</FONT>         * <a name="line.6421"></a>
<FONT color="green">6422</FONT>         */<a name="line.6422"></a>
<FONT color="green">6423</FONT>        boolean isHorizontallyBanded() {<a name="line.6423"></a>
<FONT color="green">6424</FONT>          boolean result;<a name="line.6424"></a>
<FONT color="green">6425</FONT>          if (null == symbolType.isHorizontallyBanded)<a name="line.6425"></a>
<FONT color="green">6426</FONT>            /*<a name="line.6426"></a>
<FONT color="green">6427</FONT>             * Not fixed by symbol type: use brush shape determined banding<a name="line.6427"></a>
<FONT color="green">6428</FONT>             * (we are guessing point distribution based on brush shape)<a name="line.6428"></a>
<FONT color="green">6429</FONT>             *<a name="line.6429"></a>
<FONT color="green">6430</FONT>             */ <a name="line.6430"></a>
<FONT color="green">6431</FONT>            result = brushHeight &lt; brushWidth;<a name="line.6431"></a>
<FONT color="green">6432</FONT>          else<a name="line.6432"></a>
<FONT color="green">6433</FONT>            result = symbolType.isHorizontallyBanded.booleanValue();<a name="line.6433"></a>
<FONT color="green">6434</FONT>    <a name="line.6434"></a>
<FONT color="green">6435</FONT>          return result;<a name="line.6435"></a>
<FONT color="green">6436</FONT>        }<a name="line.6436"></a>
<FONT color="green">6437</FONT>    <a name="line.6437"></a>
<FONT color="green">6438</FONT>        /*<a name="line.6438"></a>
<FONT color="green">6439</FONT>         * If passed an rgba-like string (rgba(255,255,128,0.5)) returns the<a name="line.6439"></a>
<FONT color="green">6440</FONT>         * collapsed-to-rgb version (rgb(255,255,128)). Else returns the<a name="line.6440"></a>
<FONT color="green">6441</FONT>         * original string. Throws an exception if string begins with rgba(<a name="line.6441"></a>
<FONT color="green">6442</FONT>         * but lacks required format after that.<a name="line.6442"></a>
<FONT color="green">6443</FONT>         * <a name="line.6443"></a>
<FONT color="green">6444</FONT>         */<a name="line.6444"></a>
<FONT color="green">6445</FONT>        private String collapseRGBAToRGB(String rgba) {<a name="line.6445"></a>
<FONT color="green">6446</FONT>          // an int in the range 0..255 for the "R,G,B" parts<a name="line.6446"></a>
<FONT color="green">6447</FONT>          final String RGB = "([0-9]|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5]))";<a name="line.6447"></a>
<FONT color="green">6448</FONT>          // a double in the range 0..1 for the "A" part<a name="line.6448"></a>
<FONT color="green">6449</FONT>          final String A = "(0|1|(1[.]0*)|(0[.][0-9]*)|([.][0-9]+))";<a name="line.6449"></a>
<FONT color="green">6450</FONT>          // full RGBA pattern<a name="line.6450"></a>
<FONT color="green">6451</FONT>          final String RGBA_PATTERN = "rgba[(]" + RGB + "[,]" + RGB + "[,]"<a name="line.6451"></a>
<FONT color="green">6452</FONT>              + RGB + "[,]" + A + "[)]";<a name="line.6452"></a>
<FONT color="green">6453</FONT>          String result = rgba;<a name="line.6453"></a>
<FONT color="green">6454</FONT>          if (null != rgba &amp;&amp; rgba.startsWith("rgba(")) {<a name="line.6454"></a>
<FONT color="green">6455</FONT>            if (rgba.matches(RGBA_PATTERN)) {<a name="line.6455"></a>
<FONT color="green">6456</FONT>              final int FIRST_PAREN = 4;<a name="line.6456"></a>
<FONT color="green">6457</FONT>              int lastComma = rgba.lastIndexOf(",");<a name="line.6457"></a>
<FONT color="green">6458</FONT>              result = "rgb" + rgba.substring(FIRST_PAREN, lastComma)<a name="line.6458"></a>
<FONT color="green">6459</FONT>                  + ")";<a name="line.6459"></a>
<FONT color="green">6460</FONT>            } else<a name="line.6460"></a>
<FONT color="green">6461</FONT>              throw new IllegalArgumentException(<a name="line.6461"></a>
<FONT color="green">6462</FONT>                  "Your RGBA color specification: '"<a name="line.6462"></a>
<FONT color="green">6463</FONT>                      + rgba<a name="line.6463"></a>
<FONT color="green">6464</FONT>                      + "'"<a name="line.6464"></a>
<FONT color="green">6465</FONT>                      + " was not in the GChart-required form: rgba(Red,Green,Blue,Alpha)"<a name="line.6465"></a>
<FONT color="green">6466</FONT>                      + " where Red, Green and Blue are integers in the range 0 to 255 and"<a name="line.6466"></a>
<FONT color="green">6467</FONT>                      + " Alpha is a double in the range 0.0 to 1.0");<a name="line.6467"></a>
<FONT color="green">6468</FONT>          }<a name="line.6468"></a>
<FONT color="green">6469</FONT>          // else special keyword or else some (unchecked) CSS color format<a name="line.6469"></a>
<FONT color="green">6470</FONT>          return result;<a name="line.6470"></a>
<FONT color="green">6471</FONT>        }<a name="line.6471"></a>
<FONT color="green">6472</FONT>    <a name="line.6472"></a>
<FONT color="green">6473</FONT>        /**<a name="line.6473"></a>
<FONT color="green">6474</FONT>         * Specifies the background or fill color of this symbol.<a name="line.6474"></a>
<FONT color="green">6475</FONT>         * &lt;p&gt;<a name="line.6475"></a>
<FONT color="green">6476</FONT>         * <a name="line.6476"></a>
<FONT color="green">6477</FONT>         * For example, this would define the color of the interior, non-border,<a name="line.6477"></a>
<FONT color="green">6478</FONT>         * part of bars in a bar-chart, the color of the interior of each shading<a name="line.6478"></a>
<FONT color="green">6479</FONT>         * bar in a banded-fill pie slice, or the canvas "fill" color of solid fill,<a name="line.6479"></a>
<FONT color="green">6480</FONT>         * canvas-rendered, pie slices.<a name="line.6480"></a>
<FONT color="green">6481</FONT>         * &lt;p&gt;<a name="line.6481"></a>
<FONT color="green">6482</FONT>         * <a name="line.6482"></a>
<FONT color="green">6483</FONT>         * You can use one of the 16 standard HTML/CSS color literals, illustrated<a name="line.6483"></a>
<FONT color="green">6484</FONT>         * below, to quickly specify common colors:<a name="line.6484"></a>
<FONT color="green">6485</FONT>         * <a name="line.6485"></a>
<FONT color="green">6486</FONT>         * &lt;p&gt;<a name="line.6486"></a>
<FONT color="green">6487</FONT>         * &lt;ul&gt;<a name="line.6487"></a>
<FONT color="green">6488</FONT>         * &lt;img src="{@docRoot}/com/googlecode/gchart/client/doc-files/gchartexample10.png"&gt;<a name="line.6488"></a>
<FONT color="green">6489</FONT>         * &lt;/ul&gt;<a name="line.6489"></a>
<FONT color="green">6490</FONT>         * <a name="line.6490"></a>
<FONT color="green">6491</FONT>         * &lt;p&gt;<a name="line.6491"></a>
<FONT color="green">6492</FONT>         * For more variety, use a standard CSS RGB (&lt;b&gt;r&lt;/b&gt;ed, &lt;b&gt;g&lt;/b&gt;reen, and<a name="line.6492"></a>
<FONT color="green">6493</FONT>         * &lt;b&gt;b&lt;/b&gt;lue) color format such as "#FF0000" (same as "red"), "#00FF00"<a name="line.6493"></a>
<FONT color="green">6494</FONT>         * (same as "green"), "#0000FF" (same as "blue"), "#FFFFFF" (same as<a name="line.6494"></a>
<FONT color="green">6495</FONT>         * "white") or "#000000" (same as "black").<a name="line.6495"></a>
<FONT color="green">6496</FONT>         * &lt;p&gt;<a name="line.6496"></a>
<FONT color="green">6497</FONT>         * <a name="line.6497"></a>
<FONT color="green">6498</FONT>         * If you are using an external canvas library that supports them, feel free<a name="line.6498"></a>
<FONT color="green">6499</FONT>         * to use RGBA color specifications (e.g, &lt;tt&gt;rgba(255,255,255,0.5))&lt;/tt&gt;<a name="line.6499"></a>
<FONT color="green">6500</FONT>         * for semi-transparent white). GChart will automatically collapse these<a name="line.6500"></a>
<FONT color="green">6501</FONT>         * specifications down to CSS standard RGB (e.g. &lt;tt&gt;rgb(255,255,255)&lt;/tt&gt;)<a name="line.6501"></a>
<FONT color="green">6502</FONT>         * as needed for any non-canvas-rendered parts of the curve.<a name="line.6502"></a>
<FONT color="green">6503</FONT>         * &lt;p&gt;<a name="line.6503"></a>
<FONT color="green">6504</FONT>         * <a name="line.6504"></a>
<FONT color="green">6505</FONT>         * &lt;small&gt; To maintain &lt;tt&gt;GWTCanvas&lt;/tt&gt; consistency, GChart requires that<a name="line.6505"></a>
<FONT color="green">6506</FONT>         * you use integers in the range &lt;tt&gt;0..255&lt;/tt&gt; in the first three comma<a name="line.6506"></a>
<FONT color="green">6507</FONT>         * delimited RGBA slots, and a double in the range &lt;tt&gt;0..1&lt;/tt&gt; in the<a name="line.6507"></a>
<FONT color="green">6508</FONT>         * fourth. A runtime exception will be raised if you use any other format.<a name="line.6508"></a>
<FONT color="green">6509</FONT>         * &lt;p&gt;<a name="line.6509"></a>
<FONT color="green">6510</FONT>         * &lt;/small&gt;<a name="line.6510"></a>
<FONT color="green">6511</FONT>         * <a name="line.6511"></a>
<FONT color="green">6512</FONT>         * &lt;i&gt;Why GChart sometimes deliberately drops your alpha-transparency specs<a name="line.6512"></a>
<FONT color="green">6513</FONT>         * (and how to workaround this limitation):&lt;/i&gt;<a name="line.6513"></a>
<FONT color="green">6514</FONT>         * <a name="line.6514"></a>
<FONT color="green">6515</FONT>         * &lt;p&gt;<a name="line.6515"></a>
<FONT color="green">6516</FONT>         * &lt;blockquote&gt; &lt;small&gt;<a name="line.6516"></a>
<FONT color="green">6517</FONT>         * &lt;p&gt;<a name="line.6517"></a>
<FONT color="green">6518</FONT>         * <a name="line.6518"></a>
<FONT color="green">6519</FONT>         * The external &lt;tt&gt;GWTCanvas&lt;/tt&gt; vector graphics library lets you use the<a name="line.6519"></a>
<FONT color="green">6520</FONT>         * RGBA format, which adds a fourth, &lt;tt&gt;&lt;b&gt;a&lt;/b&gt;lpha&lt;/tt&gt; parameter in<a name="line.6520"></a>
<FONT color="green">6521</FONT>         * addition to the standard &lt;tt&gt;&lt;b&gt;r&lt;/b&gt;ed&lt;/tt&gt;, &lt;tt&gt;&lt;b&gt;g&lt;/b&gt;reen&lt;/tt&gt; and<a name="line.6521"></a>
<FONT color="green">6522</FONT>         * &lt;tt&gt;&lt;b&gt;b&lt;/b&gt;lue&lt;/tt&gt;. This &lt;tt&gt;alpha&lt;/tt&gt; lets you define the degree of<a name="line.6522"></a>
<FONT color="green">6523</FONT>         * transparency: from 0 (transparent) to 1 (opaque).<a name="line.6523"></a>
<FONT color="green">6524</FONT>         * &lt;p&gt;<a name="line.6524"></a>
<FONT color="green">6525</FONT>         * <a name="line.6525"></a>
<FONT color="green">6526</FONT>         * Problem is, if you use this &lt;tt&gt;rgba(r,g,b,a)&lt;/tt&gt; syntax to specify,<a name="line.6526"></a>
<FONT color="green">6527</FONT>         * say, the color of an HTML element's border, IE won't display anything but<a name="line.6527"></a>
<FONT color="green">6528</FONT>         * an error. So, whenever GChart uses an HTML element to render a symbol's<a name="line.6528"></a>
<FONT color="green">6529</FONT>         * background or border (instead of your external vector graphics library)<a name="line.6529"></a>
<FONT color="green">6530</FONT>         * it collapses the RGBA into the more widely accepted RGB format, by<a name="line.6530"></a>
<FONT color="green">6531</FONT>         * dropping the fourth, &lt;tt&gt;alpha&lt;/tt&gt;, parameter and changing the leading<a name="line.6531"></a>
<FONT color="green">6532</FONT>         * &lt;tt&gt;rgba&lt;/tt&gt; identifier to &lt;tt&gt;rgb&lt;/tt&gt;.<a name="line.6532"></a>
<FONT color="green">6533</FONT>         * &lt;p&gt;<a name="line.6533"></a>
<FONT color="green">6534</FONT>         * <a name="line.6534"></a>
<FONT color="green">6535</FONT>         * GChart will render any "continuously filled" (you can use<a name="line.6535"></a>
<FONT color="green">6536</FONT>         * &lt;tt&gt;setFillSpacing(0)&lt;/tt&gt; to request continuous filling) aspects of your<a name="line.6536"></a>
<FONT color="green">6537</FONT>         * symbols using whatever external vector graphics library you specified via<a name="line.6537"></a>
<FONT color="green">6538</FONT>         * &lt;tt&gt;setCanvasFactory&lt;/tt&gt;. So, you can rely on the full RGBA syntax<a name="line.6538"></a>
<FONT color="green">6539</FONT>         * working for these aspects of your curve, provided that, like<a name="line.6539"></a>
<FONT color="green">6540</FONT>         * &lt;tt&gt;GWTCanvas&lt;/tt&gt;, your external graphics library supports the<a name="line.6540"></a>
<FONT color="green">6541</FONT>         * &lt;tt&gt;rgba(r,g,b,a)&lt;/tt&gt; syntax. Specifically, solid fill pie slices and<a name="line.6541"></a>
<FONT color="green">6542</FONT>         * their borders, solid fill area charts and their borders, and solid<a name="line.6542"></a>
<FONT color="green">6543</FONT>         * point-to-point connecting lines on a line chart all support<a name="line.6543"></a>
<FONT color="green">6544</FONT>         * RGBA-specified alpha-transparency.<a name="line.6544"></a>
<FONT color="green">6545</FONT>         * &lt;p&gt;<a name="line.6545"></a>
<FONT color="green">6546</FONT>         * <a name="line.6546"></a>
<FONT color="green">6547</FONT>         * On the other hand, due to a limitation of GChart's implementation, any<a name="line.6547"></a>
<FONT color="green">6548</FONT>         * rectangular aspects of your symbols, namely bar chart symbols and their<a name="line.6548"></a>
<FONT color="green">6549</FONT>         * borders, rectangular point markers and their borders, and banded-filled<a name="line.6549"></a>
<FONT color="green">6550</FONT>         * pie slices, are rendered via HTML and will collapse your<a name="line.6550"></a>
<FONT color="green">6551</FONT>         * &lt;tt&gt;rgba(r,g,b,a)&lt;/tt&gt; specs into &lt;tt&gt;rgb(r,g,b)&lt;/tt&gt;.<a name="line.6551"></a>
<FONT color="green">6552</FONT>         * &lt;p&gt;<a name="line.6552"></a>
<FONT color="green">6553</FONT>         * <a name="line.6553"></a>
<FONT color="green">6554</FONT>         * But what if you need a semi-transparent bar chart, banded-fill pie slice,<a name="line.6554"></a>
<FONT color="green">6555</FONT>         * or rectangular point marker? Fortunately, there is a simple workaround:<a name="line.6555"></a>
<FONT color="green">6556</FONT>         * just pass the URL of an appropriately-sized semi-transparent image to the<a name="line.6556"></a>
<FONT color="green">6557</FONT>         * &lt;tt&gt;setImageURL&lt;/tt&gt; method of the curve in question.<a name="line.6557"></a>
<FONT color="green">6558</FONT>         * <a name="line.6558"></a>
<FONT color="green">6559</FONT>         * &lt;/small&gt; &lt;/blockquote&gt;<a name="line.6559"></a>
<FONT color="green">6560</FONT>         * &lt;p&gt;<a name="line.6560"></a>
<FONT color="green">6561</FONT>         * <a name="line.6561"></a>
<FONT color="green">6562</FONT>         * The default symbol background color is<a name="line.6562"></a>
<FONT color="green">6563</FONT>         * &lt;tt&gt;DEFAULT_SYMBOL_BACKGROUND_COLOR&lt;/tt&gt;<a name="line.6563"></a>
<FONT color="green">6564</FONT>         * <a name="line.6564"></a>
<FONT color="green">6565</FONT>         * <a name="line.6565"></a>
<FONT color="green">6566</FONT>         * @param backgroundColor<a name="line.6566"></a>
<FONT color="green">6567</FONT>         *          a standard CSS or canvas-library supported RGBA background color<a name="line.6567"></a>
<FONT color="green">6568</FONT>         *          specification string.<a name="line.6568"></a>
<FONT color="green">6569</FONT>         * <a name="line.6569"></a>
<FONT color="green">6570</FONT>         * <a name="line.6570"></a>
<FONT color="green">6571</FONT>         * @see #getBackgroundColor getBackgroundColor<a name="line.6571"></a>
<FONT color="green">6572</FONT>         * @see #setBorderColor setBorderColor<a name="line.6572"></a>
<FONT color="green">6573</FONT>         * @see #DEFAULT_SYMBOL_BACKGROUND_COLOR DEFAULT_SYMBOL_BACKGROUND_COLOR<a name="line.6573"></a>
<FONT color="green">6574</FONT>         * @see #setImageURL setImageURL<a name="line.6574"></a>
<FONT color="green">6575</FONT>         * <a name="line.6575"></a>
<FONT color="green">6576</FONT>         */<a name="line.6576"></a>
<FONT color="green">6577</FONT>        public void setBackgroundColor(String backgroundColor) {<a name="line.6577"></a>
<FONT color="green">6578</FONT>          getParent().invalidate();<a name="line.6578"></a>
<FONT color="green">6579</FONT>          this.backgroundColor = backgroundColor;<a name="line.6579"></a>
<FONT color="green">6580</FONT>          // don't want to keep collapsing whenever we render, so do it once, now.<a name="line.6580"></a>
<FONT color="green">6581</FONT>          backgroundColorCSS = collapseRGBAToRGB(backgroundColor);<a name="line.6581"></a>
<FONT color="green">6582</FONT>        }<a name="line.6582"></a>
<FONT color="green">6583</FONT>    <a name="line.6583"></a>
<FONT color="green">6584</FONT>        /**<a name="line.6584"></a>
<FONT color="green">6585</FONT>         * Specifies the baseline value for this symbol. Use a baseline value when<a name="line.6585"></a>
<FONT color="green">6586</FONT>         * you need to create bar charts whose bars extend up/down to a specified y<a name="line.6586"></a>
<FONT color="green">6587</FONT>         * baseline value (for vertical bar charts) or left/right to a specified x<a name="line.6587"></a>
<FONT color="green">6588</FONT>         * baseline value (for horizontal bar charts).<a name="line.6588"></a>
<FONT color="green">6589</FONT>         * &lt;p&gt;<a name="line.6589"></a>
<FONT color="green">6590</FONT>         * <a name="line.6590"></a>
<FONT color="green">6591</FONT>         * In greater detail:<a name="line.6591"></a>
<FONT color="green">6592</FONT>         * &lt;p&gt;<a name="line.6592"></a>
<FONT color="green">6593</FONT>         * &lt;ul&gt;<a name="line.6593"></a>
<FONT color="green">6594</FONT>         * <a name="line.6594"></a>
<FONT color="green">6595</FONT>         * &lt;li&gt;For curves that employ symbol types with names of the form<a name="line.6595"></a>
<FONT color="green">6596</FONT>         * &lt;tt&gt;VBAR_BASELINE_*&lt;/tt&gt;, a vertical bar is drawn that connects the x,y<a name="line.6596"></a>
<FONT color="green">6597</FONT>         * position of each data point to the horizontal line defined by the<a name="line.6597"></a>
<FONT color="green">6598</FONT>         * equation &lt;tt&gt;y=baseline&lt;/tt&gt;. For the default baseline setting of<a name="line.6598"></a>
<FONT color="green">6599</FONT>         * &lt;tt&gt;Double.NaN&lt;/tt&gt;, the defining equation is &lt;tt&gt;y=(yMin+yMax)/2&lt;/tt&gt;<a name="line.6599"></a>
<FONT color="green">6600</FONT>         * (i.e., a midpoint baseline).<a name="line.6600"></a>
<FONT color="green">6601</FONT>         * &lt;p&gt;<a name="line.6601"></a>
<FONT color="green">6602</FONT>         * <a name="line.6602"></a>
<FONT color="green">6603</FONT>         * &lt;li&gt;For curves that employ symbol types with names of the form<a name="line.6603"></a>
<FONT color="green">6604</FONT>         * &lt;tt&gt;HBAR_BASELINE_*&lt;/tt&gt;, a horizontal bar is drawn from the x,y position<a name="line.6604"></a>
<FONT color="green">6605</FONT>         * associated with each data point to the vertical line defined by the<a name="line.6605"></a>
<FONT color="green">6606</FONT>         * equation &lt;tt&gt;x=baseline&lt;/tt&gt;. For the default baseline setting of<a name="line.6606"></a>
<FONT color="green">6607</FONT>         * &lt;tt&gt;Double.NaN&lt;/tt&gt;, the defining equation is &lt;tt&gt;x=(xMin+xMax)/2&lt;/tt&gt;.<a name="line.6607"></a>
<FONT color="green">6608</FONT>         * &lt;/ul&gt;<a name="line.6608"></a>
<FONT color="green">6609</FONT>         * &lt;p&gt;<a name="line.6609"></a>
<FONT color="green">6610</FONT>         * <a name="line.6610"></a>
<FONT color="green">6611</FONT>         * @param baseline<a name="line.6611"></a>
<FONT color="green">6612</FONT>         *          the y (or x) that defines the horizontal (or vertical) line to<a name="line.6612"></a>
<FONT color="green">6613</FONT>         *          which any baseline-based vertical (or horizontal) bars are<a name="line.6613"></a>
<FONT color="green">6614</FONT>         *          extended.<a name="line.6614"></a>
<FONT color="green">6615</FONT>         * <a name="line.6615"></a>
<FONT color="green">6616</FONT>         * @see #getBaseline getBaseline<a name="line.6616"></a>
<FONT color="green">6617</FONT>         * @see SymbolType#HBAR_BASELINE_CENTER HBAR_BASELINE_CENTER<a name="line.6617"></a>
<FONT color="green">6618</FONT>         * @see SymbolType#HBAR_BASELINE_SOUTH HBAR_BASELINE_SOUTH<a name="line.6618"></a>
<FONT color="green">6619</FONT>         * @see SymbolType#HBAR_BASELINE_NORTH HBAR_BASELINE_NORTH<a name="line.6619"></a>
<FONT color="green">6620</FONT>         * @see SymbolType#VBAR_BASELINE_CENTER VBAR_BASELINE_CENTER<a name="line.6620"></a>
<FONT color="green">6621</FONT>         * @see SymbolType#VBAR_BASELINE_EAST VBAR_BASELINE_EAST<a name="line.6621"></a>
<FONT color="green">6622</FONT>         * @see SymbolType#VBAR_BASELINE_WEST VBAR_BASELINE_WEST<a name="line.6622"></a>
<FONT color="green">6623</FONT>         * <a name="line.6623"></a>
<FONT color="green">6624</FONT>         */<a name="line.6624"></a>
<FONT color="green">6625</FONT>        public void setBaseline(double baseline) {<a name="line.6625"></a>
<FONT color="green">6626</FONT>          getParent().invalidate();<a name="line.6626"></a>
<FONT color="green">6627</FONT>          this.baseline = baseline;<a name="line.6627"></a>
<FONT color="green">6628</FONT>        }<a name="line.6628"></a>
<FONT color="green">6629</FONT>    <a name="line.6629"></a>
<FONT color="green">6630</FONT>        /**<a name="line.6630"></a>
<FONT color="green">6631</FONT>         * Specifies the border color, as a CSS or RGBA color specification string.<a name="line.6631"></a>
<FONT color="green">6632</FONT>         * <a name="line.6632"></a>
<FONT color="green">6633</FONT>         * &lt;p&gt;<a name="line.6633"></a>
<FONT color="green">6634</FONT>         * <a name="line.6634"></a>
<FONT color="green">6635</FONT>         * Both standard CSS and the all-but-IE-supported RGBA extension (with the<a name="line.6635"></a>
<FONT color="green">6636</FONT>         * fourth parameter defining alpha-transparency, for example,<a name="line.6636"></a>
<FONT color="green">6637</FONT>         * &lt;tt&gt;rgba(255,255,255,0.5)&lt;/tt&gt; to define a semi-transparent white) are<a name="line.6637"></a>
<FONT color="green">6638</FONT>         * allowed. However, GChart may collapse these extended specifications into<a name="line.6638"></a>
<FONT color="green">6639</FONT>         * ordinary RGB in some cases. See {@link Symbol#setBackgroundColor<a name="line.6639"></a>
<FONT color="green">6640</FONT>         * setBackgroundColor} for full details.<a name="line.6640"></a>
<FONT color="green">6641</FONT>         * &lt;p&gt;<a name="line.6641"></a>
<FONT color="green">6642</FONT>         * <a name="line.6642"></a>
<FONT color="green">6643</FONT>         * For example, for a square symbol, this would set the color of the line<a name="line.6643"></a>
<FONT color="green">6644</FONT>         * that indicates the outter perimeter of that square. For a banded-fill pie<a name="line.6644"></a>
<FONT color="green">6645</FONT>         * slice, this would set the color of the outter perimeter of every shading<a name="line.6645"></a>
<FONT color="green">6646</FONT>         * bar used to fill in the pie slice. For a solid fill pie slice, with an<a name="line.6646"></a>
<FONT color="green">6647</FONT>         * external canvas library such as &lt;tt&gt;GWTCanvas&lt;/tt&gt; plugged into GChart<a name="line.6647"></a>
<FONT color="green">6648</FONT>         * via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, this method would instead set the color of<a name="line.6648"></a>
<FONT color="green">6649</FONT>         * the canvas-stroked line around the slice's perimeter.<a name="line.6649"></a>
<FONT color="green">6650</FONT>         * &lt;p&gt;<a name="line.6650"></a>
<FONT color="green">6651</FONT>         * <a name="line.6651"></a>
<FONT color="green">6652</FONT>         * This color also defines the color of the point-to-point connecting lines<a name="line.6652"></a>
<FONT color="green">6653</FONT>         * of a continuously connected line chart.<a name="line.6653"></a>
<FONT color="green">6654</FONT>         * &lt;p&gt;<a name="line.6654"></a>
<FONT color="green">6655</FONT>         * <a name="line.6655"></a>
<FONT color="green">6656</FONT>         * &lt;i&gt;Using &lt;tt&gt;TRANSPARENT_BORDER_COLOR&lt;/tt&gt;:&lt;/i&gt;<a name="line.6656"></a>
<FONT color="green">6657</FONT>         * &lt;p&gt;<a name="line.6657"></a>
<FONT color="green">6658</FONT>         * <a name="line.6658"></a>
<FONT color="green">6659</FONT>         * &lt;blockquote&gt; &lt;small&gt;<a name="line.6659"></a>
<FONT color="green">6660</FONT>         * Although you can use the special CSS keyword "transparent", due to a<a name="line.6660"></a>
<FONT color="green">6661</FONT>         * well-known bug, IE6 will usually render that as black. Plus, different<a name="line.6661"></a>
<FONT color="green">6662</FONT>         * browsers define the background color that shines through the transparent<a name="line.6662"></a>
<FONT color="green">6663</FONT>         * border differently, and external canvas libraries such as<a name="line.6663"></a>
<FONT color="green">6664</FONT>         * &lt;tt&gt;GWTCanvas&lt;/tt&gt; may not support the use of "transparent". So, GChart<a name="line.6664"></a>
<FONT color="green">6665</FONT>         * provides a browser-independent keyword &lt;tt&gt;TRANSPARENT_BORDER_COLOR&lt;/tt&gt;<a name="line.6665"></a>
<FONT color="green">6666</FONT>         * that you can use instead, that emulates transparency by removing the<a name="line.6666"></a>
<FONT color="green">6667</FONT>         * border entirely, and then shifting and resizing the transparently<a name="line.6667"></a>
<FONT color="green">6668</FONT>         * bordered element so as to create the illusion that its transparent border<a name="line.6668"></a>
<FONT color="green">6669</FONT>         * is still there. That's not exactly the same thing as having a transparent<a name="line.6669"></a>
<FONT color="green">6670</FONT>         * border (the emulated borders can't "see" mouse moves over them, for<a name="line.6670"></a>
<FONT color="green">6671</FONT>         * example) but it's close enough for most charting purposes. Another simple<a name="line.6671"></a>
<FONT color="green">6672</FONT>         * way to workaround these transparent border inconsistencies is to use an<a name="line.6672"></a>
<FONT color="green">6673</FONT>         * explicitly specified border color equal to the chart's background color.<a name="line.6673"></a>
<FONT color="green">6674</FONT>         * &lt;/small&gt; &lt;/blockquote&gt;<a name="line.6674"></a>
<FONT color="green">6675</FONT>         * <a name="line.6675"></a>
<FONT color="green">6676</FONT>         * @param borderColor<a name="line.6676"></a>
<FONT color="green">6677</FONT>         *          the color of the borders of this curve's rendered symbols, and<a name="line.6677"></a>
<FONT color="green">6678</FONT>         *          of any point-to-point connecting lines. Use any valid CSS color<a name="line.6678"></a>
<FONT color="green">6679</FONT>         *          specification string (including the RGBA extension), or the<a name="line.6679"></a>
<FONT color="green">6680</FONT>         *          special GChart keyword &lt;tt&gt;TRANSPARENT_BORDER_COLOR&lt;/tt&gt;.<a name="line.6680"></a>
<FONT color="green">6681</FONT>         * <a name="line.6681"></a>
<FONT color="green">6682</FONT>         *          For more information on standard CSS color specifications<a name="line.6682"></a>
<FONT color="green">6683</FONT>         *          including how GChart handles the RGBA extended format, see<a name="line.6683"></a>
<FONT color="green">6684</FONT>         *          {@link Symbol#setBackgroundColor setBackgroundColor}.<a name="line.6684"></a>
<FONT color="green">6685</FONT>         * <a name="line.6685"></a>
<FONT color="green">6686</FONT>         * @see #TRANSPARENT_BORDER_COLOR TRANSPARENT_BORDER_COLOR<a name="line.6686"></a>
<FONT color="green">6687</FONT>         * @see #getBorderColor getBorderColor<a name="line.6687"></a>
<FONT color="green">6688</FONT>         * @see #setBackgroundColor setBackgroundColor<a name="line.6688"></a>
<FONT color="green">6689</FONT>         * @see #setCanvasFactory setCanvasFactory<a name="line.6689"></a>
<FONT color="green">6690</FONT>         * <a name="line.6690"></a>
<FONT color="green">6691</FONT>         */<a name="line.6691"></a>
<FONT color="green">6692</FONT>        public void setBorderColor(String borderColor) {<a name="line.6692"></a>
<FONT color="green">6693</FONT>          getParent().invalidate();<a name="line.6693"></a>
<FONT color="green">6694</FONT>          this.borderColor = borderColor;<a name="line.6694"></a>
<FONT color="green">6695</FONT>          borderColorCSS = collapseRGBAToRGB(borderColor);<a name="line.6695"></a>
<FONT color="green">6696</FONT>        }<a name="line.6696"></a>
<FONT color="green">6697</FONT>    <a name="line.6697"></a>
<FONT color="green">6698</FONT>        /**<a name="line.6698"></a>
<FONT color="green">6699</FONT>         * Sets the border style of the rectangular elements used to render this<a name="line.6699"></a>
<FONT color="green">6700</FONT>         * symbol.<a name="line.6700"></a>
<FONT color="green">6701</FONT>         * <a name="line.6701"></a>
<FONT color="green">6702</FONT>         * @param borderStyle<a name="line.6702"></a>
<FONT color="green">6703</FONT>         *          a CSS border style such as "solid", "dotted", "dashed", etc.<a name="line.6703"></a>
<FONT color="green">6704</FONT>         * <a name="line.6704"></a>
<FONT color="green">6705</FONT>         * @see #getBorderStyle getBorderStyle<a name="line.6705"></a>
<FONT color="green">6706</FONT>         * @see #setBackgroundColor setBackgroundColor<a name="line.6706"></a>
<FONT color="green">6707</FONT>         * @see #setBorderColor setBorderColor<a name="line.6707"></a>
<FONT color="green">6708</FONT>         */<a name="line.6708"></a>
<FONT color="green">6709</FONT>        public void setBorderStyle(String borderStyle) {<a name="line.6709"></a>
<FONT color="green">6710</FONT>          getParent().invalidate();<a name="line.6710"></a>
<FONT color="green">6711</FONT>          this.borderStyle = borderStyle;<a name="line.6711"></a>
<FONT color="green">6712</FONT>        }<a name="line.6712"></a>
<FONT color="green">6713</FONT>    <a name="line.6713"></a>
<FONT color="green">6714</FONT>        /**<a name="line.6714"></a>
<FONT color="green">6715</FONT>         * Sets the width of the border around the graphical element(s) used to<a name="line.6715"></a>
<FONT color="green">6716</FONT>         * render this curve, in pixels.<a name="line.6716"></a>
<FONT color="green">6717</FONT>         * &lt;p&gt;<a name="line.6717"></a>
<FONT color="green">6718</FONT>         * <a name="line.6718"></a>
<FONT color="green">6719</FONT>         * If positive, the border is drawn inside each graphical element. If<a name="line.6719"></a>
<FONT color="green">6720</FONT>         * negative, the border is drawn outside of those elements. Note that,<a name="line.6720"></a>
<FONT color="green">6721</FONT>         * negative, external, borders do not increase the mouse hit-testing region<a name="line.6721"></a>
<FONT color="green">6722</FONT>         * associated with the rendered symbols.<a name="line.6722"></a>
<FONT color="green">6723</FONT>         * &lt;p&gt;<a name="line.6723"></a>
<FONT color="green">6724</FONT>         * <a name="line.6724"></a>
<FONT color="green">6725</FONT>         * &lt;blockquote&gt;&lt;small&gt; &lt;i&gt;Tip:&lt;/i&gt; To get the hit test region around a<a name="line.6725"></a>
<FONT color="green">6726</FONT>         * symbol to, &lt;i&gt;in effect&lt;/i&gt;, include the external border associated with<a name="line.6726"></a>
<FONT color="green">6727</FONT>         * a negative border width, simply increase the width and the height of the<a name="line.6727"></a>
<FONT color="green">6728</FONT>         * symbol's point selection brush by &lt;tt&gt;2*Math.abs(getBorderWidth())&lt;/tt&gt;.<a name="line.6728"></a>
<FONT color="green">6729</FONT>         * &lt;/small&gt; &lt;/blockquote&gt;<a name="line.6729"></a>
<FONT color="green">6730</FONT>         * &lt;p&gt;<a name="line.6730"></a>
<FONT color="green">6731</FONT>         * <a name="line.6731"></a>
<FONT color="green">6732</FONT>         * If a rectangular symbol's width or height ever become less than twice the<a name="line.6732"></a>
<FONT color="green">6733</FONT>         * specified positive border width, the border will be shrunk down until it<a name="line.6733"></a>
<FONT color="green">6734</FONT>         * just fills up the entire rectangular area of the symbol.<a name="line.6734"></a>
<FONT color="green">6735</FONT>         * &lt;p&gt;<a name="line.6735"></a>
<FONT color="green">6736</FONT>         * <a name="line.6736"></a>
<FONT color="green">6737</FONT>         * &lt;i&gt;On backgrounds vs borders in bar charts when printing:&lt;/i&gt;<a name="line.6737"></a>
<FONT color="green">6738</FONT>         * &lt;p&gt;<a name="line.6738"></a>
<FONT color="green">6739</FONT>         * <a name="line.6739"></a>
<FONT color="green">6740</FONT>         * &lt;blockquote&gt;&lt;small&gt; Because borders are usually printed more reliably<a name="line.6740"></a>
<FONT color="green">6741</FONT>         * than background colors cross-browser, using such oversized borders is a<a name="line.6741"></a>
<FONT color="green">6742</FONT>         * simple way to assure that on-screen and printed bar chart renderings are<a name="line.6742"></a>
<FONT color="green">6743</FONT>         * consistent. Consistency isn't everything: the removal of background<a name="line.6743"></a>
<FONT color="green">6744</FONT>         * colors can save ink. So, you might prefer to just design bar charts that<a name="line.6744"></a>
<FONT color="green">6745</FONT>         * look good with either solid-filled (on-screen) or outlined (printed w.<a name="line.6745"></a>
<FONT color="green">6746</FONT>         * 'print background colors' unchecked in FF, for example) bars.<a name="line.6746"></a>
<FONT color="green">6747</FONT>         * &lt;/small&gt;&lt;/blockquote&gt;<a name="line.6747"></a>
<FONT color="green">6748</FONT>         * <a name="line.6748"></a>
<FONT color="green">6749</FONT>         * @param borderWidth<a name="line.6749"></a>
<FONT color="green">6750</FONT>         *          the width of the symbol's border, in pixels<a name="line.6750"></a>
<FONT color="green">6751</FONT>         *          <a name="line.6751"></a>
<FONT color="green">6752</FONT>         * @see #getBorderWidth getBorderWidth<a name="line.6752"></a>
<FONT color="green">6753</FONT>         */<a name="line.6753"></a>
<FONT color="green">6754</FONT>        public void setBorderWidth(int borderWidth) {<a name="line.6754"></a>
<FONT color="green">6755</FONT>          getParent().invalidate();<a name="line.6755"></a>
<FONT color="green">6756</FONT>          this.borderWidth = borderWidth;<a name="line.6756"></a>
<FONT color="green">6757</FONT>        }<a name="line.6757"></a>
<FONT color="green">6758</FONT>    <a name="line.6758"></a>
<FONT color="green">6759</FONT>        /**<a name="line.6759"></a>
<FONT color="green">6760</FONT>         * <a name="line.6760"></a>
<FONT color="green">6761</FONT>         * Sets the height of the rectangular point-selection "brush". This brush<a name="line.6761"></a>
<FONT color="green">6762</FONT>         * defines how close the mouse must get to a point on the chart in order to<a name="line.6762"></a>
<FONT color="green">6763</FONT>         * "touch" it.<a name="line.6763"></a>
<FONT color="green">6764</FONT>         * &lt;p&gt;<a name="line.6764"></a>
<FONT color="green">6765</FONT>         * <a name="line.6765"></a>
<FONT color="green">6766</FONT>         * Whenever a point is touched, GChart displays that point's hover feedback.<a name="line.6766"></a>
<FONT color="green">6767</FONT>         * By default, the selected point is highlighted, the associated symbol's<a name="line.6767"></a>
<FONT color="green">6768</FONT>         * hovertext template is expanded relative to the touched point, and the<a name="line.6768"></a>
<FONT color="green">6769</FONT>         * resulting plain text or HTML is placed onto the chart at an appropriate,<a name="line.6769"></a>
<FONT color="green">6770</FONT>         * point-relative, location. You can override this default by passing a<a name="line.6770"></a>
<FONT color="green">6771</FONT>         * &lt;tt&gt;HoverUpdateable&lt;/tt&gt; &lt;tt&gt;Widget&lt;/tt&gt; to the<a name="line.6771"></a>
<FONT color="green">6772</FONT>         * &lt;tt&gt;setHoverWidget&lt;/tt&gt; method. In that case, instead of expanding your<a name="line.6772"></a>
<FONT color="green">6773</FONT>         * hovertext template, the &lt;tt&gt;HoverUpdateable&lt;/tt&gt; &lt;tt&gt;Widget&lt;/tt&gt; is<a name="line.6773"></a>
<FONT color="green">6774</FONT>         * instead positioned properly relative to the touched point, and its<a name="line.6774"></a>
<FONT color="green">6775</FONT>         * &lt;tt&gt;hoverUpdate&lt;/tt&gt; method is invoked with a reference to the touched<a name="line.6775"></a>
<FONT color="green">6776</FONT>         * point passed in as its first argument.<a name="line.6776"></a>
<FONT color="green">6777</FONT>         * &lt;p&gt;<a name="line.6777"></a>
<FONT color="green">6778</FONT>         * <a name="line.6778"></a>
<FONT color="green">6779</FONT>         * The rules for determining if the brush is "touching" a symbol are as<a name="line.6779"></a>
<FONT color="green">6780</FONT>         * follows:<a name="line.6780"></a>
<FONT color="green">6781</FONT>         * <a name="line.6781"></a>
<FONT color="green">6782</FONT>         * &lt;ol&gt;<a name="line.6782"></a>
<FONT color="green">6783</FONT>         * <a name="line.6783"></a>
<FONT color="green">6784</FONT>         * &lt;li&gt;For all symbols &lt;i&gt;except&lt;/i&gt; pie slices, the symbol is considered to<a name="line.6784"></a>
<FONT color="green">6785</FONT>         * have been touched if the rectangle containing the rendered symbol, and a<a name="line.6785"></a>
<FONT color="green">6786</FONT>         * rectangle with the specified brush width and height, and centered on the<a name="line.6786"></a>
<FONT color="green">6787</FONT>         * current mouse position, intersect.<a name="line.6787"></a>
<FONT color="green">6788</FONT>         * &lt;p&gt;<a name="line.6788"></a>
<FONT color="green">6789</FONT>         * <a name="line.6789"></a>
<FONT color="green">6790</FONT>         * <a name="line.6790"></a>
<FONT color="green">6791</FONT>         * &lt;small&gt;&lt;i&gt;Note:&lt;/i&gt; The brush is centered on the mouse by default. You<a name="line.6791"></a>
<FONT color="green">6792</FONT>         * can place the brush above, below, etc. the mouse position via the<a name="line.6792"></a>
<FONT color="green">6793</FONT>         * &lt;tt&gt;setBrushLocation&lt;/tt&gt; method. &lt;/small&gt;<a name="line.6793"></a>
<FONT color="green">6794</FONT>         * &lt;p&gt;<a name="line.6794"></a>
<FONT color="green">6795</FONT>         * <a name="line.6795"></a>
<FONT color="green">6796</FONT>         * For example, with a 10 x 10 pixel brush, a bar chart's bar gets "touched"<a name="line.6796"></a>
<FONT color="green">6797</FONT>         * whenever the mouse is either within, or within a 5 pixel border around,<a name="line.6797"></a>
<FONT color="green">6798</FONT>         * the bar. Note that on line charts, only the individual (rectangular)<a name="line.6798"></a>
<FONT color="green">6799</FONT>         * point markers, not connecting lines between them, are touchable.<a name="line.6799"></a>
<FONT color="green">6800</FONT>         * &lt;p&gt;<a name="line.6800"></a>
<FONT color="green">6801</FONT>         * <a name="line.6801"></a>
<FONT color="green">6802</FONT>         * &lt;li&gt;For pie slices, the slice is considered to have been touched if the<a name="line.6802"></a>
<FONT color="green">6803</FONT>         * mouse cursor is within the angle subtended by the slice, and within<a name="line.6803"></a>
<FONT color="green">6804</FONT>         * &lt;tt&gt;sliceRadius + max(brushWidth,<a name="line.6804"></a>
<FONT color="green">6805</FONT>         *   brushHeight)/2.0&lt;/tt&gt; of the center of the pie containing the slice.<a name="line.6805"></a>
<FONT color="green">6806</FONT>         * Intuitively, the brush in effect aligns its longest dimension,<a name="line.6806"></a>
<FONT color="green">6807</FONT>         * compass-like, so that it points to the center of the pie containing the<a name="line.6807"></a>
<FONT color="green">6808</FONT>         * slice.<a name="line.6808"></a>
<FONT color="green">6809</FONT>         * &lt;p&gt;<a name="line.6809"></a>
<FONT color="green">6810</FONT>         * <a name="line.6810"></a>
<FONT color="green">6811</FONT>         * &lt;small&gt;&lt;i&gt;Note:&lt;/i&gt; Unlike other symbol types, pie slice hit testing<a name="line.6811"></a>
<FONT color="green">6812</FONT>         * works the same regardless of the brush location (c.f.<a name="line.6812"></a>
<FONT color="green">6813</FONT>         * &lt;tt&gt;setBrushLocation&lt;/tt&gt;) setting. &lt;/small&gt;<a name="line.6813"></a>
<FONT color="green">6814</FONT>         * &lt;/ol&gt;<a name="line.6814"></a>
<FONT color="green">6815</FONT>         * &lt;p&gt;<a name="line.6815"></a>
<FONT color="green">6816</FONT>         * <a name="line.6816"></a>
<FONT color="green">6817</FONT>         * Even though each curve's symbol can have an independently sized<a name="line.6817"></a>
<FONT color="green">6818</FONT>         * brush--which gives you a lot of control over which curve's points are<a name="line.6818"></a>
<FONT color="green">6819</FONT>         * easiest to select--using the same sized brush for all curves produces<a name="line.6819"></a>
<FONT color="green">6820</FONT>         * results more consistent with the simple concept of a single physical<a name="line.6820"></a>
<FONT color="green">6821</FONT>         * brush "touching" symbols on the chart.<a name="line.6821"></a>
<FONT color="green">6822</FONT>         * &lt;p&gt;<a name="line.6822"></a>
<FONT color="green">6823</FONT>         * <a name="line.6823"></a>
<FONT color="green">6824</FONT>         * Finally, if the brush touches more than one symbol, the symbol whose<a name="line.6824"></a>
<FONT color="green">6825</FONT>         * center is closest to the mouse cursor (by default, that's also the brush<a name="line.6825"></a>
<FONT color="green">6826</FONT>         * center point) is considered to have been touched. (In these calculations,<a name="line.6826"></a>
<FONT color="green">6827</FONT>         * the ordinary, Euclidean, definition of distance is used by default; the<a name="line.6827"></a>
<FONT color="green">6828</FONT>         * &lt;tt&gt;setDistanceMetric&lt;/tt&gt; method allows for other definitions). For pie<a name="line.6828"></a>
<FONT color="green">6829</FONT>         * slices, the symbol's center point is defined (to simplify the<a name="line.6829"></a>
<FONT color="green">6830</FONT>         * calculations) as the point at the center of the pie that contains the<a name="line.6830"></a>
<FONT color="green">6831</FONT>         * slice. In case of any remaining ties, the point later on the point list<a name="line.6831"></a>
<FONT color="green">6832</FONT>         * (the one "on top") is selected.<a name="line.6832"></a>
<FONT color="green">6833</FONT>         * &lt;p&gt;<a name="line.6833"></a>
<FONT color="green">6834</FONT>         * <a name="line.6834"></a>
<FONT color="green">6835</FONT>         * &lt;small&gt; &lt;i&gt;Fine-print:&lt;/i&gt; Known brush size limitations when selecting<a name="line.6835"></a>
<FONT color="green">6836</FONT>         * off-chart points:<a name="line.6836"></a>
<FONT color="green">6837</FONT>         * &lt;p&gt;<a name="line.6837"></a>
<FONT color="green">6838</FONT>         * <a name="line.6838"></a>
<FONT color="green">6839</FONT>         * &lt;blockquote&gt; GChart allows you to render points that fall outside of the<a name="line.6839"></a>
<FONT color="green">6840</FONT>         * GChart's containing rectangle.<a name="line.6840"></a>
<FONT color="green">6841</FONT>         * &lt;p&gt;<a name="line.6841"></a>
<FONT color="green">6842</FONT>         * <a name="line.6842"></a>
<FONT color="green">6843</FONT>         * But, GChart can't see mouse moves around such off-chart elements--the<a name="line.6843"></a>
<FONT color="green">6844</FONT>         * mouse has to be right on top of these elements before it's motion is<a name="line.6844"></a>
<FONT color="green">6845</FONT>         * detected by GChart (the browser sends mouse moves in these regions to<a name="line.6845"></a>
<FONT color="green">6846</FONT>         * whatever non-GChart related browser elements occupy this space).<a name="line.6846"></a>
<FONT color="green">6847</FONT>         * &lt;p&gt;<a name="line.6847"></a>
<FONT color="green">6848</FONT>         * <a name="line.6848"></a>
<FONT color="green">6849</FONT>         * Consequently, even though GChart still uses your brush settings for hit<a name="line.6849"></a>
<FONT color="green">6850</FONT>         * testing with such points, because it can't see mouse activity until the<a name="line.6850"></a>
<FONT color="green">6851</FONT>         * center of the mouse "touches" such elements, it will often act &lt;i&gt;as<a name="line.6851"></a>
<FONT color="green">6852</FONT>         * if&lt;/i&gt; you were using a &lt;tt&gt;1x1&lt;/tt&gt; pixel brush for such externally<a name="line.6852"></a>
<FONT color="green">6853</FONT>         * rendered points.<a name="line.6853"></a>
<FONT color="green">6854</FONT>         * &lt;p&gt;<a name="line.6854"></a>
<FONT color="green">6855</FONT>         * <a name="line.6855"></a>
<FONT color="green">6856</FONT>         * Unfortunately, this is a basic limitation of how GChart handles mouse<a name="line.6856"></a>
<FONT color="green">6857</FONT>         * events. But there are a number of possible workarounds, such as adding a<a name="line.6857"></a>
<FONT color="green">6858</FONT>         * transparent curve with similar, but larger, dimensions/point locations to<a name="line.6858"></a>
<FONT color="green">6859</FONT>         * the off-chart curve's points (so as to capture external mouse moves<a name="line.6859"></a>
<FONT color="green">6860</FONT>         * around external points) or adding a transparent annotation around<a name="line.6860"></a>
<FONT color="green">6861</FONT>         * external points (again, to create a mouse capture region around these<a name="line.6861"></a>
<FONT color="green">6862</FONT>         * points). Perhaps the easiest approach is to simply make the outter<a name="line.6862"></a>
<FONT color="green">6863</FONT>         * decoration regions around the chart big enough (via methods such as<a name="line.6863"></a>
<FONT color="green">6864</FONT>         * &lt;tt&gt;setAxisLabelThickness&lt;/tt&gt; and similarly named &lt;tt&gt;set*Thickness&lt;/tt&gt;<a name="line.6864"></a>
<FONT color="green">6865</FONT>         * methods) so that there is enough empty space around the plot area's<a name="line.6865"></a>
<FONT color="green">6866</FONT>         * perimeter so that points never fall outside the chart's bounding<a name="line.6866"></a>
<FONT color="green">6867</FONT>         * rectangle.<a name="line.6867"></a>
<FONT color="green">6868</FONT>         * &lt;p&gt;<a name="line.6868"></a>
<FONT color="green">6869</FONT>         * <a name="line.6869"></a>
<FONT color="green">6870</FONT>         * Because most applications place their points on the chart, this is only<a name="line.6870"></a>
<FONT color="green">6871</FONT>         * an issue for advanced applications that deliberately draw outside of the<a name="line.6871"></a>
<FONT color="green">6872</FONT>         * chart's rectangle so as to overlay the chart onto the host page.<a name="line.6872"></a>
<FONT color="green">6873</FONT>         * &lt;/blockquote&gt;&lt;/small&gt;<a name="line.6873"></a>
<FONT color="green">6874</FONT>         * <a name="line.6874"></a>
<FONT color="green">6875</FONT>         * @param height<a name="line.6875"></a>
<FONT color="green">6876</FONT>         *          the height of the rectangular point selection brush used by<a name="line.6876"></a>
<FONT color="green">6877</FONT>         *          points on the curve associated with this symbol (in pixels).<a name="line.6877"></a>
<FONT color="green">6878</FONT>         * <a name="line.6878"></a>
<FONT color="green">6879</FONT>         * @see #getBrushHeight getBrushHeight<a name="line.6879"></a>
<FONT color="green">6880</FONT>         * @see #setBrushWidth setBrushWidth<a name="line.6880"></a>
<FONT color="green">6881</FONT>         * @see #setBrushSize setBrushSize<a name="line.6881"></a>
<FONT color="green">6882</FONT>         * @see #setBrushLocation setBrushLocation<a name="line.6882"></a>
<FONT color="green">6883</FONT>         * @see #setDistanceMetric setDistanceMetric<a name="line.6883"></a>
<FONT color="green">6884</FONT>         * @see Symbol#setHoverWidget setHoverWidget<a name="line.6884"></a>
<FONT color="green">6885</FONT>         * @see HoverUpdateable HoverUpdateable<a name="line.6885"></a>
<FONT color="green">6886</FONT>         * @see #DEFAULT_BRUSH_WIDTH DEFAULT_BRUSH_WIDTH<a name="line.6886"></a>
<FONT color="green">6887</FONT>         * @see #DEFAULT_BRUSH_HEIGHT DEFAULT_BRUSH_HEIGHT<a name="line.6887"></a>
<FONT color="green">6888</FONT>         * @see #getTouchedPoint getTouchedPoint<a name="line.6888"></a>
<FONT color="green">6889</FONT>         * @see #touch touch<a name="line.6889"></a>
<FONT color="green">6890</FONT>         * @see GChart#setHoverTouchingEnabled setHoverTouchingEnabled<a name="line.6890"></a>
<FONT color="green">6891</FONT>         * <a name="line.6891"></a>
<FONT color="green">6892</FONT>         */<a name="line.6892"></a>
<FONT color="green">6893</FONT>        public void setBrushHeight(int height) {<a name="line.6893"></a>
<FONT color="green">6894</FONT>          brushHeight = height;<a name="line.6894"></a>
<FONT color="green">6895</FONT>        }<a name="line.6895"></a>
<FONT color="green">6896</FONT>    <a name="line.6896"></a>
<FONT color="green">6897</FONT>        /**<a name="line.6897"></a>
<FONT color="green">6898</FONT>         * Sets the location of the brush relative to the mouse x,y coordinates.<a name="line.6898"></a>
<FONT color="green">6899</FONT>         * &lt;p&gt;<a name="line.6899"></a>
<FONT color="green">6900</FONT>         * <a name="line.6900"></a>
<FONT color="green">6901</FONT>         * With the default setting of &lt;tt&gt;AnnotationLocation.CENTER&lt;/tt&gt;, the brush<a name="line.6901"></a>
<FONT color="green">6902</FONT>         * is centered on the mouse cursor, which is usually acceptable.<a name="line.6902"></a>
<FONT color="green">6903</FONT>         * &lt;p&gt;<a name="line.6903"></a>
<FONT color="green">6904</FONT>         * <a name="line.6904"></a>
<FONT color="green">6905</FONT>         * The most useful non-default settings, which facilitate "single sided"<a name="line.6905"></a>
<FONT color="green">6906</FONT>         * point selection, are tabulated below:<a name="line.6906"></a>
<FONT color="green">6907</FONT>         * <a name="line.6907"></a>
<FONT color="green">6908</FONT>         * &lt;table border&gt;<a name="line.6908"></a>
<FONT color="green">6909</FONT>         * &lt;tr&gt;<a name="line.6909"></a>
<FONT color="green">6910</FONT>         * &lt;th&gt;Location&lt;/th&gt;<a name="line.6910"></a>
<FONT color="green">6911</FONT>         * &lt;th&gt;Impact on point selection&lt;/th&gt;<a name="line.6911"></a>
<FONT color="green">6912</FONT>         * &lt;/tr&gt;<a name="line.6912"></a>
<FONT color="green">6913</FONT>         * &lt;tr&gt;<a name="line.6913"></a>
<FONT color="green">6914</FONT>         * &lt;td&gt;&lt;tt&gt;AnnotationLocation.NORTH&lt;/tt&gt;&lt;/td&gt;<a name="line.6914"></a>
<FONT color="green">6915</FONT>         * &lt;td&gt;The mouse only selects points when it is on or below them.&lt;/td&gt;<a name="line.6915"></a>
<FONT color="green">6916</FONT>         * &lt;/tr&gt;<a name="line.6916"></a>
<FONT color="green">6917</FONT>         * &lt;tr&gt;<a name="line.6917"></a>
<FONT color="green">6918</FONT>         * &lt;td&gt;&lt;tt&gt;AnnotationLocation.SOUTH&lt;/tt&gt;&lt;/td&gt;<a name="line.6918"></a>
<FONT color="green">6919</FONT>         * &lt;td&gt;The mouse only selects points when it is on or above them.&lt;/td&gt;<a name="line.6919"></a>
<FONT color="green">6920</FONT>         * &lt;/tr&gt;<a name="line.6920"></a>
<FONT color="green">6921</FONT>         * &lt;tr&gt;<a name="line.6921"></a>
<FONT color="green">6922</FONT>         * &lt;td&gt;&lt;tt&gt;AnnotationLocation.WEST&lt;/tt&gt;&lt;/td&gt;<a name="line.6922"></a>
<FONT color="green">6923</FONT>         * &lt;td&gt;The mouse only selects points when it is on them or to their right.&lt;/td&gt;<a name="line.6923"></a>
<FONT color="green">6924</FONT>         * &lt;/tr&gt;<a name="line.6924"></a>
<FONT color="green">6925</FONT>         * &lt;tr&gt;<a name="line.6925"></a>
<FONT color="green">6926</FONT>         * &lt;td&gt;&lt;tt&gt;AnnotationLocation.EAST&lt;/tt&gt;&lt;/td&gt;<a name="line.6926"></a>
<FONT color="green">6927</FONT>         * &lt;td&gt;The mouse only selects points when it is on them or to their left.&lt;/td&gt;<a name="line.6927"></a>
<FONT color="green">6928</FONT>         * &lt;/tr&gt;<a name="line.6928"></a>
<FONT color="green">6929</FONT>         * <a name="line.6929"></a>
<FONT color="green">6930</FONT>         * &lt;/table&gt;<a name="line.6930"></a>
<FONT color="green">6931</FONT>         * &lt;p&gt;<a name="line.6931"></a>
<FONT color="green">6932</FONT>         * <a name="line.6932"></a>
<FONT color="green">6933</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; When a chart has two curves, setting one curve to use<a name="line.6933"></a>
<FONT color="green">6934</FONT>         * &lt;tt&gt;NORTH&lt;/tt&gt; as its brush location, and the other to use &lt;tt&gt;SOUTH&lt;/tt&gt;<a name="line.6934"></a>
<FONT color="green">6935</FONT>         * , and using a brush height equal to the height of the decorated chart<a name="line.6935"></a>
<FONT color="green">6936</FONT>         * (returned via &lt;tt&gt;getYChartSizeDecorated()&lt;/tt&gt;) allows points on one<a name="line.6936"></a>
<FONT color="green">6937</FONT>         * curve to be selected when the user is near the top of the chart, and<a name="line.6937"></a>
<FONT color="green">6938</FONT>         * points on the other curve to be selected when the user is near the bottom<a name="line.6938"></a>
<FONT color="green">6939</FONT>         * of the chart.<a name="line.6939"></a>
<FONT color="green">6940</FONT>         * &lt;p&gt;<a name="line.6940"></a>
<FONT color="green">6941</FONT>         * <a name="line.6941"></a>
<FONT color="green">6942</FONT>         * @see #setBrushHeight setBrushHeight<a name="line.6942"></a>
<FONT color="green">6943</FONT>         * @see #setBrushWidth setBrushWidth<a name="line.6943"></a>
<FONT color="green">6944</FONT>         * @see GChart#getYChartSizeDecorated getYChartSizeDecorated<a name="line.6944"></a>
<FONT color="green">6945</FONT>         * <a name="line.6945"></a>
<FONT color="green">6946</FONT>         * @param location<a name="line.6946"></a>
<FONT color="green">6947</FONT>         *          the location of the rectangular brush, relative to the x,y<a name="line.6947"></a>
<FONT color="green">6948</FONT>         *          position of the mouse.<a name="line.6948"></a>
<FONT color="green">6949</FONT>         * <a name="line.6949"></a>
<FONT color="green">6950</FONT>         */<a name="line.6950"></a>
<FONT color="green">6951</FONT>        public void setBrushLocation(AnnotationLocation location) {<a name="line.6951"></a>
<FONT color="green">6952</FONT>          brushLocation = location;<a name="line.6952"></a>
<FONT color="green">6953</FONT>        }<a name="line.6953"></a>
<FONT color="green">6954</FONT>    <a name="line.6954"></a>
<FONT color="green">6955</FONT>        /**<a name="line.6955"></a>
<FONT color="green">6956</FONT>         * <a name="line.6956"></a>
<FONT color="green">6957</FONT>         * Convenience method equivalent to:<a name="line.6957"></a>
<FONT color="green">6958</FONT>         * &lt;p&gt;<a name="line.6958"></a>
<FONT color="green">6959</FONT>         * <a name="line.6959"></a>
<FONT color="green">6960</FONT>         * &lt;pre&gt;<a name="line.6960"></a>
<FONT color="green">6961</FONT>         * setBrushWidth(width);<a name="line.6961"></a>
<FONT color="green">6962</FONT>         * setBrushHeight(height);<a name="line.6962"></a>
<FONT color="green">6963</FONT>         * &lt;/pre&gt;<a name="line.6963"></a>
<FONT color="green">6964</FONT>         * &lt;p&gt;<a name="line.6964"></a>
<FONT color="green">6965</FONT>         * <a name="line.6965"></a>
<FONT color="green">6966</FONT>         * For a full discussion of how GChart uses it's "brush" to determine when<a name="line.6966"></a>
<FONT color="green">6967</FONT>         * hover feedback for a point gets displayed, see &lt;tt&gt;setBrushHeight&lt;/tt&gt;.<a name="line.6967"></a>
<FONT color="green">6968</FONT>         * &lt;p&gt;<a name="line.6968"></a>
<FONT color="green">6969</FONT>         * <a name="line.6969"></a>
<FONT color="green">6970</FONT>         * @param width<a name="line.6970"></a>
<FONT color="green">6971</FONT>         *          the width of this chart's brush, in pixels<a name="line.6971"></a>
<FONT color="green">6972</FONT>         * @param height<a name="line.6972"></a>
<FONT color="green">6973</FONT>         *          the height of this chart's brush, in pixels<a name="line.6973"></a>
<FONT color="green">6974</FONT>         * <a name="line.6974"></a>
<FONT color="green">6975</FONT>         * @see #setBrushHeight setBrushHeight<a name="line.6975"></a>
<FONT color="green">6976</FONT>         * @see #setBrushWidth setBrushWidth<a name="line.6976"></a>
<FONT color="green">6977</FONT>         * @see #DEFAULT_BRUSH_WIDTH DEFAULT_BRUSH_WIDTH<a name="line.6977"></a>
<FONT color="green">6978</FONT>         * @see #DEFAULT_BRUSH_HEIGHT DEFAULT_BRUSH_HEIGHT<a name="line.6978"></a>
<FONT color="green">6979</FONT>         * <a name="line.6979"></a>
<FONT color="green">6980</FONT>         */<a name="line.6980"></a>
<FONT color="green">6981</FONT>        public void setBrushSize(int width, int height) {<a name="line.6981"></a>
<FONT color="green">6982</FONT>          setBrushWidth(width);<a name="line.6982"></a>
<FONT color="green">6983</FONT>          setBrushHeight(height);<a name="line.6983"></a>
<FONT color="green">6984</FONT>        }<a name="line.6984"></a>
<FONT color="green">6985</FONT>    <a name="line.6985"></a>
<FONT color="green">6986</FONT>        /**<a name="line.6986"></a>
<FONT color="green">6987</FONT>         * Sets the width of the rectangular "brush" that defines how close the<a name="line.6987"></a>
<FONT color="green">6988</FONT>         * mouse position must be to a rendered symbol for that symbol to have been<a name="line.6988"></a>
<FONT color="green">6989</FONT>         * "touched".<a name="line.6989"></a>
<FONT color="green">6990</FONT>         * &lt;p&gt;<a name="line.6990"></a>
<FONT color="green">6991</FONT>         * <a name="line.6991"></a>
<FONT color="green">6992</FONT>         * For a full discussion of how GChart uses it's "brush" to determine when<a name="line.6992"></a>
<FONT color="green">6993</FONT>         * hover feedback for a point gets displayed, see &lt;tt&gt;setBrushHeight&lt;/tt&gt;.<a name="line.6993"></a>
<FONT color="green">6994</FONT>         * <a name="line.6994"></a>
<FONT color="green">6995</FONT>         * @param width<a name="line.6995"></a>
<FONT color="green">6996</FONT>         *          width of the point selection brush, in pixels.<a name="line.6996"></a>
<FONT color="green">6997</FONT>         * <a name="line.6997"></a>
<FONT color="green">6998</FONT>         * @see #setBrushHeight setBrushHeight<a name="line.6998"></a>
<FONT color="green">6999</FONT>         * @see #setBrushSize setBrushSize<a name="line.6999"></a>
<FONT color="green">7000</FONT>         * @see #DEFAULT_BRUSH_WIDTH DEFAULT_BRUSH_WIDTH<a name="line.7000"></a>
<FONT color="green">7001</FONT>         * @see #DEFAULT_BRUSH_HEIGHT DEFAULT_BRUSH_HEIGHT<a name="line.7001"></a>
<FONT color="green">7002</FONT>         * <a name="line.7002"></a>
<FONT color="green">7003</FONT>         */<a name="line.7003"></a>
<FONT color="green">7004</FONT>        public void setBrushWidth(int width) {<a name="line.7004"></a>
<FONT color="green">7005</FONT>          brushWidth = width;<a name="line.7005"></a>
<FONT color="green">7006</FONT>        }<a name="line.7006"></a>
<FONT color="green">7007</FONT>    <a name="line.7007"></a>
<FONT color="green">7008</FONT>        /**<a name="line.7008"></a>
<FONT color="green">7009</FONT>         * Allows you to change the x,y scale factors that define the distance<a name="line.7009"></a>
<FONT color="green">7010</FONT>         * between the mouse cursor and each rendered point; these distances<a name="line.7010"></a>
<FONT color="green">7011</FONT>         * determine which point is "closest" to the mouse during hit testing.<a name="line.7011"></a>
<FONT color="green">7012</FONT>         * &lt;p&gt;<a name="line.7012"></a>
<FONT color="green">7013</FONT>         * <a name="line.7013"></a>
<FONT color="green">7014</FONT>         * Whenever the mouse selection brush "touches" more than one point, the<a name="line.7014"></a>
<FONT color="green">7015</FONT>         * point whose center is closest to the mouse cursor is the one selected.<a name="line.7015"></a>
<FONT color="green">7016</FONT>         * For a point centered at (all coordinates are in pixels)<a name="line.7016"></a>
<FONT color="green">7017</FONT>         * &lt;tt&gt;(xCenter, yCenter)&lt;/tt&gt; the distance to the mouse cursor at<a name="line.7017"></a>
<FONT color="green">7018</FONT>         * &lt;tt&gt;(xMouse, yMouse)&lt;/tt&gt; is given by:<a name="line.7018"></a>
<FONT color="green">7019</FONT>         * &lt;p&gt;<a name="line.7019"></a>
<FONT color="green">7020</FONT>         * <a name="line.7020"></a>
<FONT color="green">7021</FONT>         * &lt;pre&gt;<a name="line.7021"></a>
<FONT color="green">7022</FONT>         * dx = xScaleFactor * (xCenter - xMouse);<a name="line.7022"></a>
<FONT color="green">7023</FONT>         * dy = yScaleFactor * (yCenter - yMouse);<a name="line.7023"></a>
<FONT color="green">7024</FONT>         * distance = Math.sqrt(dx * dx + dy * dy);<a name="line.7024"></a>
<FONT color="green">7025</FONT>         * &lt;/pre&gt;<a name="line.7025"></a>
<FONT color="green">7026</FONT>         * &lt;p&gt;<a name="line.7026"></a>
<FONT color="green">7027</FONT>         * <a name="line.7027"></a>
<FONT color="green">7028</FONT>         * In the above, &lt;tt&gt;(xCenter, yCenter)&lt;/tt&gt; is the position at the center<a name="line.7028"></a>
<FONT color="green">7029</FONT>         * of the rectangle associated with the rendered point. For pie slices, it<a name="line.7029"></a>
<FONT color="green">7030</FONT>         * is the position at the center of the pie containing the slice.<a name="line.7030"></a>
<FONT color="green">7031</FONT>         * &lt;p&gt;<a name="line.7031"></a>
<FONT color="green">7032</FONT>         * <a name="line.7032"></a>
<FONT color="green">7033</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; Here are the most commonly used x-y scale factors, and how<a name="line.7033"></a>
<FONT color="green">7034</FONT>         * they are typically used:<a name="line.7034"></a>
<FONT color="green">7035</FONT>         * &lt;p&gt;<a name="line.7035"></a>
<FONT color="green">7036</FONT>         * <a name="line.7036"></a>
<FONT color="green">7037</FONT>         * &lt;ol&gt;<a name="line.7037"></a>
<FONT color="green">7038</FONT>         * &lt;li&gt;To select points based on the ordinary (Euclidean) distance use<a name="line.7038"></a>
<FONT color="green">7039</FONT>         * &lt;tt&gt;xScaleFactor = 1, yScaleFactor = 1&lt;/tt&gt; (this is the default).<a name="line.7039"></a>
<FONT color="green">7040</FONT>         * &lt;p&gt;<a name="line.7040"></a>
<FONT color="green">7041</FONT>         * <a name="line.7041"></a>
<FONT color="green">7042</FONT>         * &lt;li&gt;To select points based only on how close the mouse x-coordinate is to<a name="line.7042"></a>
<FONT color="green">7043</FONT>         * the x-coordinate at the point's center (often a good choice for a time<a name="line.7043"></a>
<FONT color="green">7044</FONT>         * series chart) use &lt;tt&gt;xScaleFactor=1, yScaleFactor=0&lt;/tt&gt;<a name="line.7044"></a>
<FONT color="green">7045</FONT>         * &lt;p&gt;<a name="line.7045"></a>
<FONT color="green">7046</FONT>         * <a name="line.7046"></a>
<FONT color="green">7047</FONT>         * &lt;li&gt;To select points based only on how close the mouse y-coordinate is to<a name="line.7047"></a>
<FONT color="green">7048</FONT>         * the y-coordinate at the point's center (a good choice for a horizontally<a name="line.7048"></a>
<FONT color="green">7049</FONT>         * oriented bar chart) use &lt;tt&gt;xScaleFactor=0, yScaleFactor=1&lt;/tt&gt;<a name="line.7049"></a>
<FONT color="green">7050</FONT>         * &lt;p&gt;<a name="line.7050"></a>
<FONT color="green">7051</FONT>         * <a name="line.7051"></a>
<FONT color="green">7052</FONT>         * &lt;li&gt;To ignore the distance to the point, and instead always<a name="line.7052"></a>
<FONT color="green">7053</FONT>         * select, from among those points touching the brush, the point<a name="line.7053"></a>
<FONT color="green">7054</FONT>         * rendered last, use &lt;tt&gt;xScaleFactor=0, yScaleFactor=0&lt;/tt&gt;. This<a name="line.7054"></a>
<FONT color="green">7055</FONT>         * choice guarantees that points that are completely occluded by<a name="line.7055"></a>
<FONT color="green">7056</FONT>         * other points can never get selected. But, because distances are<a name="line.7056"></a>
<FONT color="green">7057</FONT>         * ignored, this choice can lead to points further from the mouse<a name="line.7057"></a>
<FONT color="green">7058</FONT>         * being selected in preference to points closer to the mouse. You<a name="line.7058"></a>
<FONT color="green">7059</FONT>         * can minimize this effect by using a very small brush size.<a name="line.7059"></a>
<FONT color="green">7060</FONT>         * &lt;/ol&gt;<a name="line.7060"></a>
<FONT color="green">7061</FONT>         * &lt;p&gt;<a name="line.7061"></a>
<FONT color="green">7062</FONT>         * <a name="line.7062"></a>
<FONT color="green">7063</FONT>         * &lt;i&gt;Warning:&lt;/i&gt; Mixed metrics, like mixed metaphors, can be confusing:<a name="line.7063"></a>
<FONT color="green">7064</FONT>         * &lt;p&gt;<a name="line.7064"></a>
<FONT color="green">7065</FONT>         * <a name="line.7065"></a>
<FONT color="green">7066</FONT>         * &lt;blockquote&gt;<a name="line.7066"></a>
<FONT color="green">7067</FONT>         * Since each curve gets it's own distance metric, it's possible to<a name="line.7067"></a>
<FONT color="green">7068</FONT>         * preferentially select one curve over another by giving it relatively<a name="line.7068"></a>
<FONT color="green">7069</FONT>         * smaller scale factors. This can produce very counter-intuitive selection<a name="line.7069"></a>
<FONT color="green">7070</FONT>         * behaviors (selecting a point that is farther away from the mouse than<a name="line.7070"></a>
<FONT color="green">7071</FONT>         * another point, for example). Generally, &lt;b&gt;&lt;i&gt;it's best to use the same<a name="line.7071"></a>
<FONT color="green">7072</FONT>         * distance metric for all curves&lt;/i&gt;&lt;/b&gt; except in special cases.<a name="line.7072"></a>
<FONT color="green">7073</FONT>         * &lt;p&gt;<a name="line.7073"></a>
<FONT color="green">7074</FONT>         * <a name="line.7074"></a>
<FONT color="green">7075</FONT>         * For example, suppose you had a vertical bar chart on curve 0 that was<a name="line.7075"></a>
<FONT color="green">7076</FONT>         * restricted to the top half of your chart, and a horizontal bar chart on<a name="line.7076"></a>
<FONT color="green">7077</FONT>         * curve 1 restricted to the bottom half. Then you might use<a name="line.7077"></a>
<FONT color="green">7078</FONT>         * &lt;tt&gt;xScaleFactor=1, yScaleFactor=0&lt;/tt&gt; for curve 0 and<a name="line.7078"></a>
<FONT color="green">7079</FONT>         * &lt;tt&gt;xScaleFactor=0, yScaleFactor=1&lt;/tt&gt; for curve 1. This "mixed metric"<a name="line.7079"></a>
<FONT color="green">7080</FONT>         * would not create confusion, because the user would view the<a name="line.7080"></a>
<FONT color="green">7081</FONT>         * region-specific selection behaviour as sensibly coordinated with the<a name="line.7081"></a>
<FONT color="green">7082</FONT>         * orientation of the bars in each region.<a name="line.7082"></a>
<FONT color="green">7083</FONT>         * &lt;/blockquote&gt;<a name="line.7083"></a>
<FONT color="green">7084</FONT>         * &lt;p&gt;<a name="line.7084"></a>
<FONT color="green">7085</FONT>         * <a name="line.7085"></a>
<FONT color="green">7086</FONT>         * Though using a relatively larger &lt;tt&gt;xScaleFactor&lt;/tt&gt;,<a name="line.7086"></a>
<FONT color="green">7087</FONT>         * &lt;tt&gt;yScaleFactor&lt;/tt&gt; makes a curve's points relatively harder to select<a name="line.7087"></a>
<FONT color="green">7088</FONT>         * during hit testing, to completely ignore a curve's points during hit<a name="line.7088"></a>
<FONT color="green">7089</FONT>         * testing, you need to use &lt;tt&gt;setHoverSelectionEnabled(false)&lt;/tt&gt; and<a name="line.7089"></a>
<FONT color="green">7090</FONT>         * &lt;tt&gt;setHoverAnnotationEnabled(false)&lt;/tt&gt;.<a name="line.7090"></a>
<FONT color="green">7091</FONT>         * <a name="line.7091"></a>
<FONT color="green">7092</FONT>         * @param xScaleFactor<a name="line.7092"></a>
<FONT color="green">7093</FONT>         *          multiplies the x-pixel distance between the mouse cursor and the<a name="line.7093"></a>
<FONT color="green">7094</FONT>         *          point center (see distance formula above).<a name="line.7094"></a>
<FONT color="green">7095</FONT>         * @param yScaleFactor<a name="line.7095"></a>
<FONT color="green">7096</FONT>         *          multiplies the y-pixel distance between the mouse cursor and the<a name="line.7096"></a>
<FONT color="green">7097</FONT>         *          point center (see distance formula above).<a name="line.7097"></a>
<FONT color="green">7098</FONT>         * <a name="line.7098"></a>
<FONT color="green">7099</FONT>         * @see #setBrushSize setBrushSize<a name="line.7099"></a>
<FONT color="green">7100</FONT>         * @see #setBrushLocation setBrushLocation<a name="line.7100"></a>
<FONT color="green">7101</FONT>         * @see #setHoverSelectionEnabled setHoverSelectionEnabled<a name="line.7101"></a>
<FONT color="green">7102</FONT>         * @see #setHoverAnnotationEnabled setHoverAnnotationEnabled<a name="line.7102"></a>
<FONT color="green">7103</FONT>         * <a name="line.7103"></a>
<FONT color="green">7104</FONT>         */<a name="line.7104"></a>
<FONT color="green">7105</FONT>        public void setDistanceMetric(double xScaleFactor, double yScaleFactor) {<a name="line.7105"></a>
<FONT color="green">7106</FONT>          this.xScaleFactor = xScaleFactor;<a name="line.7106"></a>
<FONT color="green">7107</FONT>          this.yScaleFactor = yScaleFactor;<a name="line.7107"></a>
<FONT color="green">7108</FONT>        }<a name="line.7108"></a>
<FONT color="green">7109</FONT>    <a name="line.7109"></a>
<FONT color="green">7110</FONT>        /**<a name="line.7110"></a>
<FONT color="green">7111</FONT>         * @deprecated<a name="line.7111"></a>
<FONT color="green">7112</FONT>         *             This method has no impact on the rendered chart; it<a name="line.7112"></a>
<FONT color="green">7113</FONT>         *             is retained for compatibility purposes only.<a name="line.7113"></a>
<FONT color="green">7114</FONT>         *             &lt;p&gt;<a name="line.7114"></a>
<FONT color="green">7115</FONT>         *             <a name="line.7115"></a>
<FONT color="green">7116</FONT>         *             As of GChart 2.4, hover feedback has been completely<a name="line.7116"></a>
<FONT color="green">7117</FONT>         *             redesigned. Though these changes are mostly positive, one<a name="line.7117"></a>
<FONT color="green">7118</FONT>         *             downside is that, to simplify its hit-testing algorithms,<a name="line.7118"></a>
<FONT color="green">7119</FONT>         *             GChart only provides hover feedback for the explicitly<a name="line.7119"></a>
<FONT color="green">7120</FONT>         *             specified data points on a line chart; it can no longer<a name="line.7120"></a>
<FONT color="green">7121</FONT>         *             provide feedback for the "filled in" points connecting<a name="line.7121"></a>
<FONT color="green">7122</FONT>         *             successive data points. If you need hover feedback on such<a name="line.7122"></a>
<FONT color="green">7123</FONT>         *             interpolated points you will have to explicitly add<a name="line.7123"></a>
<FONT color="green">7124</FONT>         *             individual data points to the curve representing the<a name="line.7124"></a>
<FONT color="green">7125</FONT>         *             interpolated values.<a name="line.7125"></a>
<FONT color="green">7126</FONT>         *             &lt;p&gt;<a name="line.7126"></a>
<FONT color="green">7127</FONT>         * <a name="line.7127"></a>
<FONT color="green">7128</FONT>         *             Another difference is that you can no longer turn off hover<a name="line.7128"></a>
<FONT color="green">7129</FONT>         *             feedback for a pie slice via this method. If you need to turn<a name="line.7129"></a>
<FONT color="green">7130</FONT>         *             hover feedback off for a pie slice (or for any other symbol,<a name="line.7130"></a>
<FONT color="green">7131</FONT>         *             for that matter) you can use the (new with 2.4)<a name="line.7131"></a>
<FONT color="green">7132</FONT>         *             &lt;tt&gt;setHoverAnnotationEnabled&lt;/tt&gt; and<a name="line.7132"></a>
<FONT color="green">7133</FONT>         *             &lt;tt&gt;setHoverSelectionEnabled&lt;/tt&gt; methods.<a name="line.7133"></a>
<FONT color="green">7134</FONT>         * <a name="line.7134"></a>
<FONT color="green">7135</FONT>         * <a name="line.7135"></a>
<FONT color="green">7136</FONT>         * @see #getFillHasHovertext getFillHasHovertext<a name="line.7136"></a>
<FONT color="green">7137</FONT>         * @see #setHovertextTemplate setHovertextTemplate<a name="line.7137"></a>
<FONT color="green">7138</FONT>         * @see #setHoverAnnotationEnabled setHoverAnnotationEnabled<a name="line.7138"></a>
<FONT color="green">7139</FONT>         * @see #setHoverSelectionEnabled setHoverSelectionEnabled<a name="line.7139"></a>
<FONT color="green">7140</FONT>         * <a name="line.7140"></a>
<FONT color="green">7141</FONT>         */<a name="line.7141"></a>
<FONT color="green">7142</FONT>        public void setFillHasHovertext(boolean fillHasHovertext) {<a name="line.7142"></a>
<FONT color="green">7143</FONT>          this.fillHasHovertext = fillHasHovertext;<a name="line.7143"></a>
<FONT color="green">7144</FONT>        }<a name="line.7144"></a>
<FONT color="green">7145</FONT>    <a name="line.7145"></a>
<FONT color="green">7146</FONT>        /**<a name="line.7146"></a>
<FONT color="green">7147</FONT>         * Specifies the spacing between successive rectangular elements used to<a name="line.7147"></a>
<FONT color="green">7148</FONT>         * render any required non-rectangular features of the symbol.<a name="line.7148"></a>
<FONT color="green">7149</FONT>         * &lt;p&gt;<a name="line.7149"></a>
<FONT color="green">7150</FONT>         * <a name="line.7150"></a>
<FONT color="green">7151</FONT>         * The exact meaning of this spacing setting depends on the symbol type, and<a name="line.7151"></a>
<FONT color="green">7152</FONT>         * on if an external canvas factory has been specified via<a name="line.7152"></a>
<FONT color="green">7153</FONT>         * &lt;tt&gt;setCanvasFactory&lt;/tt&gt;:<a name="line.7153"></a>
<FONT color="green">7154</FONT>         * &lt;p&gt;<a name="line.7154"></a>
<FONT color="green">7155</FONT>         * <a name="line.7155"></a>
<FONT color="green">7156</FONT>         * &lt;table border&gt;<a name="line.7156"></a>
<FONT color="green">7157</FONT>         * &lt;tr&gt;<a name="line.7157"></a>
<FONT color="green">7158</FONT>         * &lt;th&gt;SymbolType&lt;/th&gt;<a name="line.7158"></a>
<FONT color="green">7159</FONT>         * &lt;th&gt;How spacing is interpreted&lt;/th&gt;<a name="line.7159"></a>
<FONT color="green">7160</FONT>         * &lt;th&gt;Default value&lt;/th&gt;<a name="line.7160"></a>
<FONT color="green">7161</FONT>         * &lt;/tr&gt;<a name="line.7161"></a>
<FONT color="green">7162</FONT>         * &lt;tr&gt;<a name="line.7162"></a>
<FONT color="green">7163</FONT>         * &lt;td&gt;BOX_*&lt;/td&gt;<a name="line.7163"></a>
<FONT color="green">7164</FONT>         * <a name="line.7164"></a>
<FONT color="green">7165</FONT>         * &lt;td&gt;The distance between the centers of the "dots" used to draw the<a name="line.7165"></a>
<FONT color="green">7166</FONT>         * dotted connecting lines between successive x,y data points on a curve.<a name="line.7166"></a>
<FONT color="green">7167</FONT>         * &lt;p&gt;<a name="line.7167"></a>
<FONT color="green">7168</FONT>         * <a name="line.7168"></a>
<FONT color="green">7169</FONT>         * If &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; ("continuously filled"),<a name="line.7169"></a>
<FONT color="green">7170</FONT>         * &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;, and a canvas factory has been specified via<a name="line.7170"></a>
<FONT color="green">7171</FONT>         * &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, a continuous line connecting the centers of<a name="line.7171"></a>
<FONT color="green">7172</FONT>         * successive boxes is produced in exactly the same way as is done for the<a name="line.7172"></a>
<FONT color="green">7173</FONT>         * &lt;tt&gt;LINE&lt;/tt&gt; symbol type. Without a canvas factory (the default)<a name="line.7173"></a>
<FONT color="green">7174</FONT>         * &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; works the same as &lt;tt&gt;fillSpacing == 1&lt;/tt&gt;.<a name="line.7174"></a>
<FONT color="green">7175</FONT>         * &lt;/td&gt;<a name="line.7175"></a>
<FONT color="green">7176</FONT>         * <a name="line.7176"></a>
<FONT color="green">7177</FONT>         * &lt;td&gt;4&lt;/td&gt;<a name="line.7177"></a>
<FONT color="green">7178</FONT>         * &lt;/tr&gt;<a name="line.7178"></a>
<FONT color="green">7179</FONT>         * <a name="line.7179"></a>
<FONT color="green">7180</FONT>         * &lt;tr&gt;<a name="line.7180"></a>
<FONT color="green">7181</FONT>         * &lt;td&gt;LINE&lt;/td&gt;<a name="line.7181"></a>
<FONT color="green">7182</FONT>         * <a name="line.7182"></a>
<FONT color="green">7183</FONT>         * &lt;td&gt;The horizontal distance between the centers of the successive<a name="line.7183"></a>
<FONT color="green">7184</FONT>         * vertical bars, or the vertical distance between the centers of the<a name="line.7184"></a>
<FONT color="green">7185</FONT>         * successive horizontal bars, that GChart uses to render the point-to-point<a name="line.7185"></a>
<FONT color="green">7186</FONT>         * connecting lines of the LINE symbol type.<a name="line.7186"></a>
<FONT color="green">7187</FONT>         * &lt;p&gt;<a name="line.7187"></a>
<FONT color="green">7188</FONT>         * <a name="line.7188"></a>
<FONT color="green">7189</FONT>         * The defaults (no canvas factory specified, 0px spacing) provide the<a name="line.7189"></a>
<FONT color="green">7190</FONT>         * smoothest lines possible without using canvas, but also the longest chart<a name="line.7190"></a>
<FONT color="green">7191</FONT>         * update times. Spacing values larger than 1px will provide proportionally<a name="line.7191"></a>
<FONT color="green">7192</FONT>         * faster rendering of connecting lines (provided the connecting line<a name="line.7192"></a>
<FONT color="green">7193</FONT>         * segments are significantly longer than the specified spacing), but they<a name="line.7193"></a>
<FONT color="green">7194</FONT>         * give the lines a grainy, "stair-step" look.<a name="line.7194"></a>
<FONT color="green">7195</FONT>         * &lt;p&gt;<a name="line.7195"></a>
<FONT color="green">7196</FONT>         * <a name="line.7196"></a>
<FONT color="green">7197</FONT>         * If &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; ("continuously filled"),<a name="line.7197"></a>
<FONT color="green">7198</FONT>         * &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;, and a canvas factory has been specified via<a name="line.7198"></a>
<FONT color="green">7199</FONT>         * &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, a continuous, crisp (sans stair-steps) line<a name="line.7199"></a>
<FONT color="green">7200</FONT>         * connecting the centers of successive boxes is produced--quickly. Without<a name="line.7200"></a>
<FONT color="green">7201</FONT>         * any canvas factory specified, &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; will work the<a name="line.7201"></a>
<FONT color="green">7202</FONT>         * same as &lt;tt&gt;fillSpacing == 1&lt;/tt&gt;.<a name="line.7202"></a>
<FONT color="green">7203</FONT>         * &lt;p&gt;<a name="line.7203"></a>
<FONT color="green">7204</FONT>         * <a name="line.7204"></a>
<FONT color="green">7205</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; To assure an unbroken connecting line, use a non-zero fill<a name="line.7205"></a>
<FONT color="green">7206</FONT>         * thickness setting greater than or equal to your fill spacing setting.<a name="line.7206"></a>
<FONT color="green">7207</FONT>         * &lt;/td&gt;<a name="line.7207"></a>
<FONT color="green">7208</FONT>         * <a name="line.7208"></a>
<FONT color="green">7209</FONT>         * &lt;td&gt;0&lt;/td&gt;<a name="line.7209"></a>
<FONT color="green">7210</FONT>         * &lt;/tr&gt;<a name="line.7210"></a>
<FONT color="green">7211</FONT>         * <a name="line.7211"></a>
<FONT color="green">7212</FONT>         * &lt;tr&gt;<a name="line.7212"></a>
<FONT color="green">7213</FONT>         * &lt;td&gt;PIE_SLICE_*&lt;/td&gt;<a name="line.7213"></a>
<FONT color="green">7214</FONT>         * <a name="line.7214"></a>
<FONT color="green">7215</FONT>         * &lt;td&gt;The vertical or horizontal distance between the centers of the<a name="line.7215"></a>
<FONT color="green">7216</FONT>         * vertical, and/or horizontal, shading bars used to fill in the pie slice.<a name="line.7216"></a>
<FONT color="green">7217</FONT>         * With the default setting, this produces a banded-fill look.<a name="line.7217"></a>
<FONT color="green">7218</FONT>         * &lt;p&gt;<a name="line.7218"></a>
<FONT color="green">7219</FONT>         * <a name="line.7219"></a>
<FONT color="green">7220</FONT>         * If &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; ("continuously filled"),<a name="line.7220"></a>
<FONT color="green">7221</FONT>         * &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;, and a canvas factory has been<a name="line.7221"></a>
<FONT color="green">7222</FONT>         * specified via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, the pie slices are<a name="line.7222"></a>
<FONT color="green">7223</FONT>         * crisp, quickly-rendered, and solid-filled. Without a canvas<a name="line.7223"></a>
<FONT color="green">7224</FONT>         * factory specified (the default) &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; works<a name="line.7224"></a>
<FONT color="green">7225</FONT>         * the same as &lt;tt&gt;fillSpacing == 1&lt;/tt&gt;.<a name="line.7225"></a>
<FONT color="green">7226</FONT>         * &lt;/td&gt;<a name="line.7226"></a>
<FONT color="green">7227</FONT>         * <a name="line.7227"></a>
<FONT color="green">7228</FONT>         * &lt;td&gt;4&lt;/td&gt;<a name="line.7228"></a>
<FONT color="green">7229</FONT>         * &lt;/tr&gt;<a name="line.7229"></a>
<FONT color="green">7230</FONT>         * <a name="line.7230"></a>
<FONT color="green">7231</FONT>         * &lt;tr&gt;<a name="line.7231"></a>
<FONT color="green">7232</FONT>         * &lt;td&gt;VBAR_*&lt;/td&gt;<a name="line.7232"></a>
<FONT color="green">7233</FONT>         * <a name="line.7233"></a>
<FONT color="green">7234</FONT>         * &lt;td&gt;The horizontal distance between corresponding edges of the vertical<a name="line.7234"></a>
<FONT color="green">7235</FONT>         * bars used to fill in the trapezoidal areas linearly interpolated between<a name="line.7235"></a>
<FONT color="green">7236</FONT>         * successive vertical bars on a curve.<a name="line.7236"></a>
<FONT color="green">7237</FONT>         * &lt;p&gt;<a name="line.7237"></a>
<FONT color="green">7238</FONT>         * <a name="line.7238"></a>
<FONT color="green">7239</FONT>         * If &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; ("continuously filled"),<a name="line.7239"></a>
<FONT color="green">7240</FONT>         * &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;, and a canvas factory has been specified via<a name="line.7240"></a>
<FONT color="green">7241</FONT>         * &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, a filled polygon whose perimeter connects the<a name="line.7241"></a>
<FONT color="green">7242</FONT>         * x,y points of the curve with a corresponding interval on the x-axis,<a name="line.7242"></a>
<FONT color="green">7243</FONT>         * x2-axis, or horizontal baseline is rendered, so as to create a vertical,<a name="line.7243"></a>
<FONT color="green">7244</FONT>         * solid-filled, area chart.<a name="line.7244"></a>
<FONT color="green">7245</FONT>         * &lt;p&gt;<a name="line.7245"></a>
<FONT color="green">7246</FONT>         * <a name="line.7246"></a>
<FONT color="green">7247</FONT>         * Without a canvas factory, &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; works the same as<a name="line.7247"></a>
<FONT color="green">7248</FONT>         * &lt;tt&gt;fillSpacing == 1&lt;/tt&gt;.<a name="line.7248"></a>
<FONT color="green">7249</FONT>         * &lt;/td&gt;<a name="line.7249"></a>
<FONT color="green">7250</FONT>         * <a name="line.7250"></a>
<FONT color="green">7251</FONT>         * &lt;td&gt;0&lt;/td&gt;<a name="line.7251"></a>
<FONT color="green">7252</FONT>         * <a name="line.7252"></a>
<FONT color="green">7253</FONT>         * &lt;tr&gt;<a name="line.7253"></a>
<FONT color="green">7254</FONT>         * &lt;td&gt;HBAR_*&lt;/td&gt;<a name="line.7254"></a>
<FONT color="green">7255</FONT>         * <a name="line.7255"></a>
<FONT color="green">7256</FONT>         * &lt;td&gt;The vertical distance between corresponding edges of the horizontal<a name="line.7256"></a>
<FONT color="green">7257</FONT>         * bars used to fill in the trapezoidal areas linearly interpolated between<a name="line.7257"></a>
<FONT color="green">7258</FONT>         * successive horizontal bars on a curve.<a name="line.7258"></a>
<FONT color="green">7259</FONT>         * &lt;p&gt;<a name="line.7259"></a>
<FONT color="green">7260</FONT>         * <a name="line.7260"></a>
<FONT color="green">7261</FONT>         * If &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; ("continuously filled"),<a name="line.7261"></a>
<FONT color="green">7262</FONT>         * &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;, and a canvas factory has been<a name="line.7262"></a>
<FONT color="green">7263</FONT>         * specified via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, a filled polygon whose<a name="line.7263"></a>
<FONT color="green">7264</FONT>         * perimeter connects the x,y points of the curve with a<a name="line.7264"></a>
<FONT color="green">7265</FONT>         * corresponding interval on the y-axis, y2-axis, or vertical<a name="line.7265"></a>
<FONT color="green">7266</FONT>         * baseline will be rendered, so as to create a horizontal,<a name="line.7266"></a>
<FONT color="green">7267</FONT>         * solid-filled, area chart.<a name="line.7267"></a>
<FONT color="green">7268</FONT>         * &lt;p&gt;<a name="line.7268"></a>
<FONT color="green">7269</FONT>         * <a name="line.7269"></a>
<FONT color="green">7270</FONT>         * Without a canvas factory, &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; works the same as<a name="line.7270"></a>
<FONT color="green">7271</FONT>         * &lt;tt&gt;fillSpacing == 1&lt;/tt&gt;.<a name="line.7271"></a>
<FONT color="green">7272</FONT>         * &lt;/td&gt;<a name="line.7272"></a>
<FONT color="green">7273</FONT>         * <a name="line.7273"></a>
<FONT color="green">7274</FONT>         * &lt;td&gt;0&lt;/td&gt;<a name="line.7274"></a>
<FONT color="green">7275</FONT>         * &lt;/tr&gt;<a name="line.7275"></a>
<FONT color="green">7276</FONT>         * <a name="line.7276"></a>
<FONT color="green">7277</FONT>         * &lt;tr&gt;<a name="line.7277"></a>
<FONT color="green">7278</FONT>         * &lt;td&gt;XGRIDLINE&lt;/td&gt;<a name="line.7278"></a>
<FONT color="green">7279</FONT>         * <a name="line.7279"></a>
<FONT color="green">7280</FONT>         * &lt;td&gt;The horizontal distance between corresponding edges of the vertical<a name="line.7280"></a>
<FONT color="green">7281</FONT>         * bars used to fill in the trapezoidal areas linearly interpolated between<a name="line.7281"></a>
<FONT color="green">7282</FONT>         * successive x-gridlines on a curve.<a name="line.7282"></a>
<FONT color="green">7283</FONT>         * &lt;p&gt;<a name="line.7283"></a>
<FONT color="green">7284</FONT>         * <a name="line.7284"></a>
<FONT color="green">7285</FONT>         * If &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; ("continuously filled"),<a name="line.7285"></a>
<FONT color="green">7286</FONT>         * &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;, and a canvas factory has been<a name="line.7286"></a>
<FONT color="green">7287</FONT>         * specified via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, a filled polygon is<a name="line.7287"></a>
<FONT color="green">7288</FONT>         * drawn whose perimeter connects the x,y points of the curve with a<a name="line.7288"></a>
<FONT color="green">7289</FONT>         * corresponding interval on either the x-axis or x2-axis, depending<a name="line.7289"></a>
<FONT color="green">7290</FONT>         * on whichever axis is furthest from each point on the curve.<a name="line.7290"></a>
<FONT color="green">7291</FONT>         * &lt;p&gt;<a name="line.7291"></a>
<FONT color="green">7292</FONT>         * <a name="line.7292"></a>
<FONT color="green">7293</FONT>         * Without a canvas factory, &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; works the same as<a name="line.7293"></a>
<FONT color="green">7294</FONT>         * &lt;tt&gt;fillSpacing == 1&lt;/tt&gt;.<a name="line.7294"></a>
<FONT color="green">7295</FONT>         * &lt;p&gt;<a name="line.7295"></a>
<FONT color="green">7296</FONT>         * <a name="line.7296"></a>
<FONT color="green">7297</FONT>         * &lt;i&gt;Tip:&lt;i&gt; To make a canvas-filled x-gridline curve fill in a rectangular<a name="line.7297"></a>
<FONT color="green">7298</FONT>         * region, set the y of each point to &lt;tt&gt;Double.MAX_VALUE&lt;/tt&gt;.<a name="line.7298"></a>
<FONT color="green">7299</FONT>         * &lt;/td&gt;<a name="line.7299"></a>
<FONT color="green">7300</FONT>         * <a name="line.7300"></a>
<FONT color="green">7301</FONT>         * &lt;td&gt;4&lt;/td&gt;<a name="line.7301"></a>
<FONT color="green">7302</FONT>         * &lt;/tr&gt;<a name="line.7302"></a>
<FONT color="green">7303</FONT>         * &lt;tr&gt;<a name="line.7303"></a>
<FONT color="green">7304</FONT>         * &lt;td&gt;YGRIDLINE&lt;/td&gt;<a name="line.7304"></a>
<FONT color="green">7305</FONT>         * <a name="line.7305"></a>
<FONT color="green">7306</FONT>         * &lt;td&gt;The vertical distance between corresponding edges of the horizontal<a name="line.7306"></a>
<FONT color="green">7307</FONT>         * bars used to fill in the trapezoidal areas linearly interpolated between<a name="line.7307"></a>
<FONT color="green">7308</FONT>         * successive y-gridlines on a curve.<a name="line.7308"></a>
<FONT color="green">7309</FONT>         * &lt;p&gt;<a name="line.7309"></a>
<FONT color="green">7310</FONT>         * <a name="line.7310"></a>
<FONT color="green">7311</FONT>         * If &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; ("continuously filled"),<a name="line.7311"></a>
<FONT color="green">7312</FONT>         * &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;, and a canvas factory has been<a name="line.7312"></a>
<FONT color="green">7313</FONT>         * specified via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, a filled polygon is<a name="line.7313"></a>
<FONT color="green">7314</FONT>         * drawn whose perimeter connects the x,y points of the curve with a<a name="line.7314"></a>
<FONT color="green">7315</FONT>         * corresponding interval on either the y-axis or y2-axis, depending<a name="line.7315"></a>
<FONT color="green">7316</FONT>         * on whichever axis is furthest from each point on the curve.<a name="line.7316"></a>
<FONT color="green">7317</FONT>         * <a name="line.7317"></a>
<FONT color="green">7318</FONT>         * &lt;p&gt;<a name="line.7318"></a>
<FONT color="green">7319</FONT>         * <a name="line.7319"></a>
<FONT color="green">7320</FONT>         * Without a canvas factory, &lt;tt&gt;fillSpacing == 0&lt;/tt&gt; works the same as<a name="line.7320"></a>
<FONT color="green">7321</FONT>         * &lt;tt&gt;fillSpacing == 1&lt;/tt&gt;.<a name="line.7321"></a>
<FONT color="green">7322</FONT>         * &lt;p&gt;<a name="line.7322"></a>
<FONT color="green">7323</FONT>         * <a name="line.7323"></a>
<FONT color="green">7324</FONT>         * &lt;i&gt;Tip:&lt;i&gt; To make a canvas-filled y-gridline curve fill in a rectangular<a name="line.7324"></a>
<FONT color="green">7325</FONT>         * region, set the x of each point to &lt;tt&gt;Double.MAX_VALUE&lt;/tt&gt;.<a name="line.7325"></a>
<FONT color="green">7326</FONT>         * &lt;/td&gt;<a name="line.7326"></a>
<FONT color="green">7327</FONT>         * <a name="line.7327"></a>
<FONT color="green">7328</FONT>         * &lt;td&gt;4&lt;/td&gt;<a name="line.7328"></a>
<FONT color="green">7329</FONT>         * &lt;/tr&gt;<a name="line.7329"></a>
<FONT color="green">7330</FONT>         * &lt;/table&gt;<a name="line.7330"></a>
<FONT color="green">7331</FONT>         * &lt;p&gt;<a name="line.7331"></a>
<FONT color="green">7332</FONT>         * <a name="line.7332"></a>
<FONT color="green">7333</FONT>         * As of version 2.5 GChart provides support for canvas-based, crisp,<a name="line.7333"></a>
<FONT color="green">7334</FONT>         * quickly drawn, lines, 2-D pie slices, and area charts if a<a name="line.7334"></a>
<FONT color="green">7335</FONT>         * &lt;tt&gt;fillSpacing&lt;/tt&gt; of &lt;tt&gt;0&lt;/tt&gt; is specified ("continuously filled")<a name="line.7335"></a>
<FONT color="green">7336</FONT>         * along with a &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;. However, you must bolt-on an<a name="line.7336"></a>
<FONT color="green">7337</FONT>         * external canvas library (plain vanilla GWT does not currently come<a name="line.7337"></a>
<FONT color="green">7338</FONT>         * pre-loaded with a browser independent canvas Widget. However, the fact<a name="line.7338"></a>
<FONT color="green">7339</FONT>         * that the GWT incubator project contains one implies that the GWT team is<a name="line.7339"></a>
<FONT color="green">7340</FONT>         * considering adding one). See the &lt;tt&gt;setCanvasFactory&lt;/tt&gt; method for<a name="line.7340"></a>
<FONT color="green">7341</FONT>         * details.<a name="line.7341"></a>
<FONT color="green">7342</FONT>         * &lt;p&gt;<a name="line.7342"></a>
<FONT color="green">7343</FONT>         * <a name="line.7343"></a>
<FONT color="green">7344</FONT>         * By default, GChart does not use an external canvas library, and thus<a name="line.7344"></a>
<FONT color="green">7345</FONT>         * depends only on the standard GWT distribution and its own 3,000-odd<a name="line.7345"></a>
<FONT color="green">7346</FONT>         * semi-colon terminated lines of GWT Java. If you decide to stick with this<a name="line.7346"></a>
<FONT color="green">7347</FONT>         * default, the following tips may help you workaround GChart's<a name="line.7347"></a>
<FONT color="green">7348</FONT>         * rectangle-element-based limitations when used in this mode.<a name="line.7348"></a>
<FONT color="green">7349</FONT>         * &lt;p&gt;<a name="line.7349"></a>
<FONT color="green">7350</FONT>         * <a name="line.7350"></a>
<FONT color="green">7351</FONT>         * First, if your goal is to produce a solid connecting line between points<a name="line.7351"></a>
<FONT color="green">7352</FONT>         * always use the &lt;tt&gt;LINE&lt;/tt&gt; symbol type rather than the<a name="line.7352"></a>
<FONT color="green">7353</FONT>         * &lt;tt&gt;BOX_CENTER&lt;/tt&gt; symbol type with a fill spacing of 1px. The<a name="line.7353"></a>
<FONT color="green">7354</FONT>         * &lt;tt&gt;LINE&lt;/tt&gt; symbol type knows how to merge adjacent pixels into larger<a name="line.7354"></a>
<FONT color="green">7355</FONT>         * rectangular elements, and is therefore usually much more efficient,<a name="line.7355"></a>
<FONT color="green">7356</FONT>         * especially with curves that involve many near-vertical or near-horizontal<a name="line.7356"></a>
<FONT color="green">7357</FONT>         * connecting lines. For best performance, use the &lt;tt&gt;BOX_CENTER&lt;/tt&gt;<a name="line.7357"></a>
<FONT color="green">7358</FONT>         * symbol only to produce dotted connecting lines that have widely spaced<a name="line.7358"></a>
<FONT color="green">7359</FONT>         * dots.<a name="line.7359"></a>
<FONT color="green">7360</FONT>         * &lt;p&gt;<a name="line.7360"></a>
<FONT color="green">7361</FONT>         * <a name="line.7361"></a>
<FONT color="green">7362</FONT>         * In general, since the number of elements required is often inversely<a name="line.7362"></a>
<FONT color="green">7363</FONT>         * proportional to fill spacing, using a very small fill spacing like 1px,<a name="line.7363"></a>
<FONT color="green">7364</FONT>         * while allowed, could degrade performance unacceptably, especially for<a name="line.7364"></a>
<FONT color="green">7365</FONT>         * very large-sized charts. On the other hand, too large a fill<a name="line.7365"></a>
<FONT color="green">7366</FONT>         * spacing/thickness can degrade graphical quality unacceptably (e.g. due to<a name="line.7366"></a>
<FONT color="green">7367</FONT>         * too few "dots" on dotted connecting lines, "stair-step" solid connecting<a name="line.7367"></a>
<FONT color="green">7368</FONT>         * lines, or "grainy filled" pie slices).<a name="line.7368"></a>
<FONT color="green">7369</FONT>         * &lt;p&gt;<a name="line.7369"></a>
<FONT color="green">7370</FONT>         * <a name="line.7370"></a>
<FONT color="green">7371</FONT>         * &lt;blockquote&gt;&lt;small&gt;<a name="line.7371"></a>
<FONT color="green">7372</FONT>         * <a name="line.7372"></a>
<FONT color="green">7373</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; For pie slices as well as for dotted or solid connecting<a name="line.7373"></a>
<FONT color="green">7374</FONT>         * lines, scaling down the size of the chart via &lt;tt&gt;setXPixelSize&lt;/tt&gt; and<a name="line.7374"></a>
<FONT color="green">7375</FONT>         * &lt;tt&gt;setYPixelSize&lt;/tt&gt; can also speed up chart display, and thus will<a name="line.7375"></a>
<FONT color="green">7376</FONT>         * often provide a better-looking alternative to increasing the fill<a name="line.7376"></a>
<FONT color="green">7377</FONT>         * spacing.<a name="line.7377"></a>
<FONT color="green">7378</FONT>         * &lt;p&gt;<a name="line.7378"></a>
<FONT color="green">7379</FONT>         * <a name="line.7379"></a>
<FONT color="green">7380</FONT>         * In particular, for a typical curve whose x-values always increase with<a name="line.7380"></a>
<FONT color="green">7381</FONT>         * point index (i.e. no "doubling back") &lt;tt&gt;LINE&lt;/tt&gt; symbol type curves<a name="line.7381"></a>
<FONT color="green">7382</FONT>         * often have a number of elements, and thus an update time, that is<a name="line.7382"></a>
<FONT color="green">7383</FONT>         * approximately equal to:<a name="line.7383"></a>
<FONT color="green">7384</FONT>         * &lt;p&gt;<a name="line.7384"></a>
<FONT color="green">7385</FONT>         * <a name="line.7385"></a>
<FONT color="green">7386</FONT>         * &lt;pre&gt;<a name="line.7386"></a>
<FONT color="green">7387</FONT>         * <a name="line.7387"></a>
<FONT color="green">7388</FONT>         * &amp;quot;Some Constant&amp;quot; * (xMaxInPixels - xMinInPixels) / fillSpacing<a name="line.7388"></a>
<FONT color="green">7389</FONT>         * <a name="line.7389"></a>
<FONT color="green">7390</FONT>         * &lt;/pre&gt;<a name="line.7390"></a>
<FONT color="green">7391</FONT>         * &lt;p&gt;<a name="line.7391"></a>
<FONT color="green">7392</FONT>         * <a name="line.7392"></a>
<FONT color="green">7393</FONT>         * So, for &lt;tt&gt;LINE&lt;/tt&gt; curves, halving the x-axis range via<a name="line.7393"></a>
<FONT color="green">7394</FONT>         * &lt;tt&gt;setXPixelSize&lt;/tt&gt; will provide approximately the same speedup as<a name="line.7394"></a>
<FONT color="green">7395</FONT>         * doubling the fill spacing setting, and, because the lines will be less<a name="line.7395"></a>
<FONT color="green">7396</FONT>         * "stair-steppy", will often provide a more acceptable visual result.<a name="line.7396"></a>
<FONT color="green">7397</FONT>         * &lt;/small&gt; &lt;/blockquote&gt;<a name="line.7397"></a>
<FONT color="green">7398</FONT>         * &lt;p&gt;<a name="line.7398"></a>
<FONT color="green">7399</FONT>         * <a name="line.7399"></a>
<FONT color="green">7400</FONT>         * Experience suggests that many applications will be able to find a<a name="line.7400"></a>
<FONT color="green">7401</FONT>         * combination of chart size and spacing/thickness settings that provide an<a name="line.7401"></a>
<FONT color="green">7402</FONT>         * acceptable level of both graphical quality and performance--particularly<a name="line.7402"></a>
<FONT color="green">7403</FONT>         * if your charting needs are more utilitarian than aesthetic. When that's<a name="line.7403"></a>
<FONT color="green">7404</FONT>         * not good enough, it's time to use &lt;tt&gt;setCanvasFactory&lt;/tt&gt; to<a name="line.7404"></a>
<FONT color="green">7405</FONT>         * super-charge GChart's rendering with the power of a cross-browser vector<a name="line.7405"></a>
<FONT color="green">7406</FONT>         * graphics facility, such as &lt;tt&gt;GWTCanvas&lt;/tt&gt;.<a name="line.7406"></a>
<FONT color="green">7407</FONT>         * &lt;p&gt;<a name="line.7407"></a>
<FONT color="green">7408</FONT>         * <a name="line.7408"></a>
<FONT color="green">7409</FONT>         * @param fillSpacing<a name="line.7409"></a>
<FONT color="green">7410</FONT>         *          spacing between successive rectangular elements used to fill in<a name="line.7410"></a>
<FONT color="green">7411</FONT>         *          non-rectangular symbols, in pixels. If a canvas factory has been<a name="line.7411"></a>
<FONT color="green">7412</FONT>         *          specified, you can use a setting of &lt;tt&gt;0&lt;/tt&gt; to produce<a name="line.7412"></a>
<FONT color="green">7413</FONT>         *          "continuously filled" elements.<a name="line.7413"></a>
<FONT color="green">7414</FONT>         * <a name="line.7414"></a>
<FONT color="green">7415</FONT>         * @see #getFillSpacing getFillSpacing<a name="line.7415"></a>
<FONT color="green">7416</FONT>         * @see #setFillThickness setFillThickness<a name="line.7416"></a>
<FONT color="green">7417</FONT>         * @see #setCanvasFactory setCanvasFactory<a name="line.7417"></a>
<FONT color="green">7418</FONT>         * <a name="line.7418"></a>
<FONT color="green">7419</FONT>         */<a name="line.7419"></a>
<FONT color="green">7420</FONT>        public void setFillSpacing(double fillSpacing) {<a name="line.7420"></a>
<FONT color="green">7421</FONT>          getParent().invalidate();<a name="line.7421"></a>
<FONT color="green">7422</FONT>          // x!=x is a faster isNaN<a name="line.7422"></a>
<FONT color="green">7423</FONT>          if (!(fillSpacing != fillSpacing) &amp;&amp; fillSpacing != 0<a name="line.7423"></a>
<FONT color="green">7424</FONT>              &amp;&amp; fillSpacing &lt; 1)<a name="line.7424"></a>
<FONT color="green">7425</FONT>            throw new IllegalArgumentException("fillSpacing=" + fillSpacing<a name="line.7425"></a>
<FONT color="green">7426</FONT>                + "; " + "fillSpacing must either be &gt;= 1, or else "<a name="line.7426"></a>
<FONT color="green">7427</FONT>                + "equal to either 0 or Double.NaN.");<a name="line.7427"></a>
<FONT color="green">7428</FONT>          this.fillSpacing = fillSpacing;<a name="line.7428"></a>
<FONT color="green">7429</FONT>        }<a name="line.7429"></a>
<FONT color="green">7430</FONT>    <a name="line.7430"></a>
<FONT color="green">7431</FONT>        /**<a name="line.7431"></a>
<FONT color="green">7432</FONT>         * Sets the "thickness" of the rectangular elements used to render any<a name="line.7432"></a>
<FONT color="green">7433</FONT>         * required non-rectangular features of this symbol.<a name="line.7433"></a>
<FONT color="green">7434</FONT>         * &lt;p&gt;<a name="line.7434"></a>
<FONT color="green">7435</FONT>         * <a name="line.7435"></a>
<FONT color="green">7436</FONT>         * The exact meaning of this thickness setting, as well as the default used<a name="line.7436"></a>
<FONT color="green">7437</FONT>         * whenever the thickness is set to the special undefined integer value<a name="line.7437"></a>
<FONT color="green">7438</FONT>         * recognized by GChart (&lt;tt&gt;GChart.NAI&lt;/tt&gt;), depends on the symbol type,<a name="line.7438"></a>
<FONT color="green">7439</FONT>         * and if an external canvas factory has been specified via<a name="line.7439"></a>
<FONT color="green">7440</FONT>         * &lt;tt&gt;setCanvasFactory&lt;/tt&gt;:<a name="line.7440"></a>
<FONT color="green">7441</FONT>         * &lt;p&gt;<a name="line.7441"></a>
<FONT color="green">7442</FONT>         * <a name="line.7442"></a>
<FONT color="green">7443</FONT>         * &lt;table border&gt;<a name="line.7443"></a>
<FONT color="green">7444</FONT>         * &lt;tr&gt;<a name="line.7444"></a>
<FONT color="green">7445</FONT>         * &lt;th&gt;SymbolType&lt;/th&gt;<a name="line.7445"></a>
<FONT color="green">7446</FONT>         * &lt;th&gt;How thickness is interpreted&lt;/th&gt;<a name="line.7446"></a>
<FONT color="green">7447</FONT>         * &lt;th&gt;Default value&lt;/th&gt;<a name="line.7447"></a>
<FONT color="green">7448</FONT>         * &lt;/tr&gt;<a name="line.7448"></a>
<FONT color="green">7449</FONT>         * <a name="line.7449"></a>
<FONT color="green">7450</FONT>         * &lt;tr&gt;<a name="line.7450"></a>
<FONT color="green">7451</FONT>         * &lt;td&gt;BOX_*&lt;/td&gt;<a name="line.7451"></a>
<FONT color="green">7452</FONT>         * <a name="line.7452"></a>
<FONT color="green">7453</FONT>         * &lt;td&gt;The height and width of rectangular "dots" used to draw the dotted<a name="line.7453"></a>
<FONT color="green">7454</FONT>         * connecting lines between successive x,y data points on a curve.<a name="line.7454"></a>
<FONT color="green">7455</FONT>         * &lt;p&gt;<a name="line.7455"></a>
<FONT color="green">7456</FONT>         * <a name="line.7456"></a>
<FONT color="green">7457</FONT>         * If the fill spacing (&lt;tt&gt;setFillSpacing&lt;/tt&gt;) is &lt;tt&gt;0&lt;/tt&gt; and a canvas<a name="line.7457"></a>
<FONT color="green">7458</FONT>         * factory has been specified via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;,<a name="line.7458"></a>
<FONT color="green">7459</FONT>         * &lt;tt&gt;fillThickness&lt;/tt&gt; is the width of the continuous connecting lines<a name="line.7459"></a>
<FONT color="green">7460</FONT>         * between successive points.<a name="line.7460"></a>
<FONT color="green">7461</FONT>         * &lt;/td&gt;<a name="line.7461"></a>
<FONT color="green">7462</FONT>         * &lt;p&gt;<a name="line.7462"></a>
<FONT color="green">7463</FONT>         * <a name="line.7463"></a>
<FONT color="green">7464</FONT>         * &lt;td&gt;0 (implies no interpolated dots or connecting lines)&lt;/td&gt;<a name="line.7464"></a>
<FONT color="green">7465</FONT>         * &lt;/tr&gt;<a name="line.7465"></a>
<FONT color="green">7466</FONT>         * <a name="line.7466"></a>
<FONT color="green">7467</FONT>         * &lt;tr&gt;<a name="line.7467"></a>
<FONT color="green">7468</FONT>         * &lt;td&gt;LINE&lt;/td&gt;<a name="line.7468"></a>
<FONT color="green">7469</FONT>         * <a name="line.7469"></a>
<FONT color="green">7470</FONT>         * &lt;td&gt;The width of the vertical line segments placed end-to-end to render<a name="line.7470"></a>
<FONT color="green">7471</FONT>         * any "more-nearly-vertical" connecting lines of the curve, and the height<a name="line.7471"></a>
<FONT color="green">7472</FONT>         * of the horizontal line segments placed end-to-end to render any<a name="line.7472"></a>
<FONT color="green">7473</FONT>         * "more-nearly-horizontal" connecting lines on this curve. Note that if you<a name="line.7473"></a>
<FONT color="green">7474</FONT>         * use a fill thickness less than the fill spacing, your line will not be<a name="line.7474"></a>
<FONT color="green">7475</FONT>         * continuously connected.<a name="line.7475"></a>
<FONT color="green">7476</FONT>         * &lt;p&gt;<a name="line.7476"></a>
<FONT color="green">7477</FONT>         * <a name="line.7477"></a>
<FONT color="green">7478</FONT>         * If the fill spacing (&lt;tt&gt;setFillSpacing&lt;/tt&gt;) is &lt;tt&gt;0&lt;/tt&gt; and a canvas<a name="line.7478"></a>
<FONT color="green">7479</FONT>         * factory has been specified via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;,<a name="line.7479"></a>
<FONT color="green">7480</FONT>         * &lt;tt&gt;fillThickness&lt;/tt&gt; is the width of the continuous connecting lines<a name="line.7480"></a>
<FONT color="green">7481</FONT>         * drawn between successive points.<a name="line.7481"></a>
<FONT color="green">7482</FONT>         * <a name="line.7482"></a>
<FONT color="green">7483</FONT>         * &lt;/td&gt;<a name="line.7483"></a>
<FONT color="green">7484</FONT>         * <a name="line.7484"></a>
<FONT color="green">7485</FONT>         * &lt;td&gt;1&lt;/td&gt;<a name="line.7485"></a>
<FONT color="green">7486</FONT>         * &lt;/tr&gt;<a name="line.7486"></a>
<FONT color="green">7487</FONT>         * <a name="line.7487"></a>
<FONT color="green">7488</FONT>         * &lt;tr&gt;<a name="line.7488"></a>
<FONT color="green">7489</FONT>         * &lt;td&gt;PIE_SLICE_*&lt;/td&gt;<a name="line.7489"></a>
<FONT color="green">7490</FONT>         * <a name="line.7490"></a>
<FONT color="green">7491</FONT>         * &lt;td&gt;The width of vertical, and/or the height of horizontal, shading bars<a name="line.7491"></a>
<FONT color="green">7492</FONT>         * used to fill in the pie slice<a name="line.7492"></a>
<FONT color="green">7493</FONT>         * &lt;p&gt;<a name="line.7493"></a>
<FONT color="green">7494</FONT>         * <a name="line.7494"></a>
<FONT color="green">7495</FONT>         * If the fill spacing (&lt;tt&gt;setFillSpacing&lt;/tt&gt;) is &lt;tt&gt;0&lt;/tt&gt; and a canvas<a name="line.7495"></a>
<FONT color="green">7496</FONT>         * factory has been specified via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, pie slices are<a name="line.7496"></a>
<FONT color="green">7497</FONT>         * solidly and continously filled for any &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;.<a name="line.7497"></a>
<FONT color="green">7498</FONT>         * &lt;/td&gt;<a name="line.7498"></a>
<FONT color="green">7499</FONT>         * <a name="line.7499"></a>
<FONT color="green">7500</FONT>         * &lt;td&gt;2&lt;/td&gt;<a name="line.7500"></a>
<FONT color="green">7501</FONT>         * <a name="line.7501"></a>
<FONT color="green">7502</FONT>         * &lt;/tr&gt;<a name="line.7502"></a>
<FONT color="green">7503</FONT>         * <a name="line.7503"></a>
<FONT color="green">7504</FONT>         * &lt;tr&gt;<a name="line.7504"></a>
<FONT color="green">7505</FONT>         * &lt;td&gt;VBAR_*&lt;/td&gt;<a name="line.7505"></a>
<FONT color="green">7506</FONT>         * <a name="line.7506"></a>
<FONT color="green">7507</FONT>         * &lt;td&gt;The width of vertical bars used to fill in the trapezoidal areas<a name="line.7507"></a>
<FONT color="green">7508</FONT>         * linearly interpolated between successive vertical bars on a curve.<a name="line.7508"></a>
<FONT color="green">7509</FONT>         * &lt;p&gt;<a name="line.7509"></a>
<FONT color="green">7510</FONT>         * <a name="line.7510"></a>
<FONT color="green">7511</FONT>         * If the fill spacing (&lt;tt&gt;setFillSpacing&lt;/tt&gt;) is &lt;tt&gt;0&lt;/tt&gt; and a canvas<a name="line.7511"></a>
<FONT color="green">7512</FONT>         * factory has been specified via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, these<a name="line.7512"></a>
<FONT color="green">7513</FONT>         * trapezoidal areas are merged together and solidly and continously filled<a name="line.7513"></a>
<FONT color="green">7514</FONT>         * for any &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;.<a name="line.7514"></a>
<FONT color="green">7515</FONT>         * <a name="line.7515"></a>
<FONT color="green">7516</FONT>         * &lt;/td&gt;<a name="line.7516"></a>
<FONT color="green">7517</FONT>         * <a name="line.7517"></a>
<FONT color="green">7518</FONT>         * &lt;td&gt;0 (implies no "area filling" between bars)<a name="line.7518"></a>
<FONT color="green">7519</FONT>         * <a name="line.7519"></a>
<FONT color="green">7520</FONT>         * &lt;tr&gt;<a name="line.7520"></a>
<FONT color="green">7521</FONT>         * &lt;td&gt;HBAR_*&lt;/td&gt;<a name="line.7521"></a>
<FONT color="green">7522</FONT>         * <a name="line.7522"></a>
<FONT color="green">7523</FONT>         * &lt;td&gt;The height of horizontal bars used to fill in the trapezoidal areas<a name="line.7523"></a>
<FONT color="green">7524</FONT>         * linearly interpolated between successive horizontal bars on a curve.<a name="line.7524"></a>
<FONT color="green">7525</FONT>         * &lt;p&gt;<a name="line.7525"></a>
<FONT color="green">7526</FONT>         * <a name="line.7526"></a>
<FONT color="green">7527</FONT>         * If the fill spacing (&lt;tt&gt;setFillSpacing&lt;/tt&gt;) is &lt;tt&gt;0&lt;/tt&gt; and a canvas<a name="line.7527"></a>
<FONT color="green">7528</FONT>         * factory has been specified via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, these<a name="line.7528"></a>
<FONT color="green">7529</FONT>         * trapezoidal areas are merged together and solidly and continously filled<a name="line.7529"></a>
<FONT color="green">7530</FONT>         * for any &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;.<a name="line.7530"></a>
<FONT color="green">7531</FONT>         * <a name="line.7531"></a>
<FONT color="green">7532</FONT>         * &lt;/td&gt;<a name="line.7532"></a>
<FONT color="green">7533</FONT>         * <a name="line.7533"></a>
<FONT color="green">7534</FONT>         * &lt;td&gt;0 (implies no "area filling" between bars)&lt;/td&gt;<a name="line.7534"></a>
<FONT color="green">7535</FONT>         * &lt;/tr&gt;<a name="line.7535"></a>
<FONT color="green">7536</FONT>         * <a name="line.7536"></a>
<FONT color="green">7537</FONT>         * &lt;tr&gt;<a name="line.7537"></a>
<FONT color="green">7538</FONT>         * &lt;td&gt;XGRIDLINE&lt;/td&gt;<a name="line.7538"></a>
<FONT color="green">7539</FONT>         * <a name="line.7539"></a>
<FONT color="green">7540</FONT>         * &lt;td&gt;The width of vertical bars used to fill in the trapezoidal areas<a name="line.7540"></a>
<FONT color="green">7541</FONT>         * linearly interpolated between successive x-gridlilnes on a curve.<a name="line.7541"></a>
<FONT color="green">7542</FONT>         * &lt;p&gt;<a name="line.7542"></a>
<FONT color="green">7543</FONT>         * <a name="line.7543"></a>
<FONT color="green">7544</FONT>         * If the fill spacing (&lt;tt&gt;setFillSpacing&lt;/tt&gt;) is &lt;tt&gt;0&lt;/tt&gt;,<a name="line.7544"></a>
<FONT color="green">7545</FONT>         * &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;, and a canvas factory has been specified<a name="line.7545"></a>
<FONT color="green">7546</FONT>         * via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, a continuously filled area chart, as<a name="line.7546"></a>
<FONT color="green">7547</FONT>         * described in &lt;tt&gt;setFillSpacing&lt;/tt&gt;, will be produced.<a name="line.7547"></a>
<FONT color="green">7548</FONT>         * &lt;/td&gt;<a name="line.7548"></a>
<FONT color="green">7549</FONT>         * <a name="line.7549"></a>
<FONT color="green">7550</FONT>         * &lt;td&gt;0 (implies no "area filling" between gridlines)<a name="line.7550"></a>
<FONT color="green">7551</FONT>         * &lt;/tr&gt;<a name="line.7551"></a>
<FONT color="green">7552</FONT>         * <a name="line.7552"></a>
<FONT color="green">7553</FONT>         * &lt;tr&gt;<a name="line.7553"></a>
<FONT color="green">7554</FONT>         * &lt;td&gt;YGRIDLINE&lt;/td&gt;<a name="line.7554"></a>
<FONT color="green">7555</FONT>         * <a name="line.7555"></a>
<FONT color="green">7556</FONT>         * &lt;td&gt;The height of horizontal bars used to fill in the trapezoidal areas<a name="line.7556"></a>
<FONT color="green">7557</FONT>         * linearly interpolated between successive y-gridlilnes on a curve.<a name="line.7557"></a>
<FONT color="green">7558</FONT>         * &lt;p&gt;<a name="line.7558"></a>
<FONT color="green">7559</FONT>         * <a name="line.7559"></a>
<FONT color="green">7560</FONT>         * If the fill spacing (&lt;tt&gt;setFillSpacing&lt;/tt&gt;) is &lt;tt&gt;0&lt;/tt&gt;,<a name="line.7560"></a>
<FONT color="green">7561</FONT>         * &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt;, and a canvas factory has been specified<a name="line.7561"></a>
<FONT color="green">7562</FONT>         * via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, a continuously filled area-chart, as<a name="line.7562"></a>
<FONT color="green">7563</FONT>         * described in &lt;tt&gt;setFillSpacing&lt;/tt&gt;, will be produced.<a name="line.7563"></a>
<FONT color="green">7564</FONT>         * <a name="line.7564"></a>
<FONT color="green">7565</FONT>         * &lt;/td&gt;<a name="line.7565"></a>
<FONT color="green">7566</FONT>         * <a name="line.7566"></a>
<FONT color="green">7567</FONT>         * &lt;td&gt;0 (implies no "area filling" between gridlines)<a name="line.7567"></a>
<FONT color="green">7568</FONT>         * &lt;/tr&gt;<a name="line.7568"></a>
<FONT color="green">7569</FONT>         * &lt;/table&gt;<a name="line.7569"></a>
<FONT color="green">7570</FONT>         * <a name="line.7570"></a>
<FONT color="green">7571</FONT>         * &lt;p&gt;<a name="line.7571"></a>
<FONT color="green">7572</FONT>         * This fill thickness setting and the associated fill spacing setting (c.f.<a name="line.7572"></a>
<FONT color="green">7573</FONT>         * &lt;tt&gt;setFillSpacing&lt;/tt&gt;) work together to define the look and efficiency<a name="line.7573"></a>
<FONT color="green">7574</FONT>         * of pie slice shading, connecting lines, etc.<a name="line.7574"></a>
<FONT color="green">7575</FONT>         * <a name="line.7575"></a>
<FONT color="green">7576</FONT>         * @param fillThickness<a name="line.7576"></a>
<FONT color="green">7577</FONT>         *          the fill thickness, in pixels<a name="line.7577"></a>
<FONT color="green">7578</FONT>         * <a name="line.7578"></a>
<FONT color="green">7579</FONT>         * @see #setCanvasFactory setCanvasFactory<a name="line.7579"></a>
<FONT color="green">7580</FONT>         * @see #getFillThickness getFillThickness<a name="line.7580"></a>
<FONT color="green">7581</FONT>         * @see #setFillSpacing setFillSpacing<a name="line.7581"></a>
<FONT color="green">7582</FONT>         */<a name="line.7582"></a>
<FONT color="green">7583</FONT>        public void setFillThickness(int fillThickness) {<a name="line.7583"></a>
<FONT color="green">7584</FONT>          getParent().invalidate();<a name="line.7584"></a>
<FONT color="green">7585</FONT>          if (fillThickness != GChart.NAI &amp;&amp; fillThickness &lt; 0)<a name="line.7585"></a>
<FONT color="green">7586</FONT>            throw new IllegalArgumentException("fillThickness="<a name="line.7586"></a>
<FONT color="green">7587</FONT>                + fillThickness + "; "<a name="line.7587"></a>
<FONT color="green">7588</FONT>                + "fillThickness must either be &gt;= 0, or else "<a name="line.7588"></a>
<FONT color="green">7589</FONT>                + "equal to GChart.NAI.");<a name="line.7589"></a>
<FONT color="green">7590</FONT>          this.fillThickness = fillThickness;<a name="line.7590"></a>
<FONT color="green">7591</FONT>        }<a name="line.7591"></a>
<FONT color="green">7592</FONT>    <a name="line.7592"></a>
<FONT color="green">7593</FONT>        /**<a name="line.7593"></a>
<FONT color="green">7594</FONT>         * Sets a boolean that determines if point-specific annotations will popup<a name="line.7594"></a>
<FONT color="green">7595</FONT>         * whenever you hover over a point on the curve associated with this symbol.<a name="line.7595"></a>
<FONT color="green">7596</FONT>         * &lt;p&gt;<a name="line.7596"></a>
<FONT color="green">7597</FONT>         * <a name="line.7597"></a>
<FONT color="green">7598</FONT>         * By default, these hover-induced popups are enabled.<a name="line.7598"></a>
<FONT color="green">7599</FONT>         * &lt;p&gt;<a name="line.7599"></a>
<FONT color="green">7600</FONT>         * <a name="line.7600"></a>
<FONT color="green">7601</FONT>         * Note that the point selection feedback on the hovered-over point is<a name="line.7601"></a>
<FONT color="green">7602</FONT>         * controlled separately, via the &lt;tt&gt;setHoverSelectionEnabled&lt;/tt&gt; method.<a name="line.7602"></a>
<FONT color="green">7603</FONT>         * <a name="line.7603"></a>
<FONT color="green">7604</FONT>         * @param hoverAnnotationEnabled<a name="line.7604"></a>
<FONT color="green">7605</FONT>         *          true if hover-induced annotations popup on this curve, false<a name="line.7605"></a>
<FONT color="green">7606</FONT>         *          otherwise.<a name="line.7606"></a>
<FONT color="green">7607</FONT>         * <a name="line.7607"></a>
<FONT color="green">7608</FONT>         * @see #getHoverAnnotationEnabled getHoverAnnotationEnabled<a name="line.7608"></a>
<FONT color="green">7609</FONT>         * @see #setHoverSelectionEnabled setHoverSelectionEnabled<a name="line.7609"></a>
<FONT color="green">7610</FONT>         * @see #setHovertextTemplate setHovertextTemplate<a name="line.7610"></a>
<FONT color="green">7611</FONT>         * @see #setHoverWidget setHoverWidget<a name="line.7611"></a>
<FONT color="green">7612</FONT>         * @see #setHoverLocation setHoverLocation<a name="line.7612"></a>
<FONT color="green">7613</FONT>         * @see #setHoverAnnotationSymbolType setHoverAnnotationSymbolType<a name="line.7613"></a>
<FONT color="green">7614</FONT>         * @see #setHoverXShift setHoverXShift<a name="line.7614"></a>
<FONT color="green">7615</FONT>         * @see #setHoverYShift setHoverYShift<a name="line.7615"></a>
<FONT color="green">7616</FONT>         * <a name="line.7616"></a>
<FONT color="green">7617</FONT>         */<a name="line.7617"></a>
<FONT color="green">7618</FONT>        public void setHoverAnnotationEnabled(boolean hoverAnnotationEnabled) {<a name="line.7618"></a>
<FONT color="green">7619</FONT>          this.hoverAnnotationEnabled = hoverAnnotationEnabled;<a name="line.7619"></a>
<FONT color="green">7620</FONT>        }<a name="line.7620"></a>
<FONT color="green">7621</FONT>    <a name="line.7621"></a>
<FONT color="green">7622</FONT>        /**<a name="line.7622"></a>
<FONT color="green">7623</FONT>         * Specifies the weight of the font that will be used to render the text of<a name="line.7623"></a>
<FONT color="green">7624</FONT>         * this point's hover annotations.<a name="line.7624"></a>
<FONT color="green">7625</FONT>         * &lt;p&gt;<a name="line.7625"></a>
<FONT color="green">7626</FONT>         * <a name="line.7626"></a>
<FONT color="green">7627</FONT>         * @param cssWeight<a name="line.7627"></a>
<FONT color="green">7628</FONT>         *          A standard CSS font-weight specification such as normal, bold,<a name="line.7628"></a>
<FONT color="green">7629</FONT>         *          bolder, lighter, 100, 200, ... 900, or inherit<a name="line.7629"></a>
<FONT color="green">7630</FONT>         * <a name="line.7630"></a>
<FONT color="green">7631</FONT>         * @see #getHoverFontWeight getHoverFontWeight<a name="line.7631"></a>
<FONT color="green">7632</FONT>         * @see #setHoverFontColor setHoverFontColor<a name="line.7632"></a>
<FONT color="green">7633</FONT>         * @see #setHoverFontStyle setHoverFontStyle<a name="line.7633"></a>
<FONT color="green">7634</FONT>         * @see #setHoverFontSize setHoverFontSize<a name="line.7634"></a>
<FONT color="green">7635</FONT>         * @see #setHoverLocation setHoverLocation<a name="line.7635"></a>
<FONT color="green">7636</FONT>         * @see #setHoverWidget setHoverWidget<a name="line.7636"></a>
<FONT color="green">7637</FONT>         * @see #setHoverXShift setHoverXShift<a name="line.7637"></a>
<FONT color="green">7638</FONT>         * @see #setHoverYShift setHoverYShift<a name="line.7638"></a>
<FONT color="green">7639</FONT>         * <a name="line.7639"></a>
<FONT color="green">7640</FONT>         */<a name="line.7640"></a>
<FONT color="green">7641</FONT>        public void setHoverFontWeight(String cssWeight) {<a name="line.7641"></a>
<FONT color="green">7642</FONT>          if (hoverAnnotation == null)<a name="line.7642"></a>
<FONT color="green">7643</FONT>            hoverAnnotation = new Annotation();<a name="line.7643"></a>
<FONT color="green">7644</FONT>          hoverAnnotation.setFontWeight(cssWeight);<a name="line.7644"></a>
<FONT color="green">7645</FONT>        }<a name="line.7645"></a>
<FONT color="green">7646</FONT>    <a name="line.7646"></a>
<FONT color="green">7647</FONT>        /**<a name="line.7647"></a>
<FONT color="green">7648</FONT>         * Specifies the color of the hover annotations' font.<a name="line.7648"></a>
<FONT color="green">7649</FONT>         * &lt;p&gt;<a name="line.7649"></a>
<FONT color="green">7650</FONT>         * <a name="line.7650"></a>
<FONT color="green">7651</FONT>         * For more information on standard CSS color specifications see the<a name="line.7651"></a>
<FONT color="green">7652</FONT>         * discussion in {@link Symbol#setBackgroundColor Symbol.setBackgroundColor}.<a name="line.7652"></a>
<FONT color="green">7653</FONT>         * &lt;p&gt;<a name="line.7653"></a>
<FONT color="green">7654</FONT>         * <a name="line.7654"></a>
<FONT color="green">7655</FONT>         * @param cssColor<a name="line.7655"></a>
<FONT color="green">7656</FONT>         *          color of the font used to display this symbol's hover<a name="line.7656"></a>
<FONT color="green">7657</FONT>         *          annotations.<a name="line.7657"></a>
<FONT color="green">7658</FONT>         * <a name="line.7658"></a>
<FONT color="green">7659</FONT>         * @see #getHoverFontColor getHoverFontColor<a name="line.7659"></a>
<FONT color="green">7660</FONT>         * @see #setHoverFontWeight setHoverFontWeight<a name="line.7660"></a>
<FONT color="green">7661</FONT>         * @see #setHoverFontStyle setHoverFontStyle<a name="line.7661"></a>
<FONT color="green">7662</FONT>         * @see #setHoverFontSize setHoverFontSize<a name="line.7662"></a>
<FONT color="green">7663</FONT>         * @see #setHoverLocation setHoverLocation<a name="line.7663"></a>
<FONT color="green">7664</FONT>         * @see #setHoverWidget setHoverWidget<a name="line.7664"></a>
<FONT color="green">7665</FONT>         * @see #setHoverXShift setHoverXShift<a name="line.7665"></a>
<FONT color="green">7666</FONT>         * @see #setHoverYShift setHoverYShift<a name="line.7666"></a>
<FONT color="green">7667</FONT>         * <a name="line.7667"></a>
<FONT color="green">7668</FONT>         */<a name="line.7668"></a>
<FONT color="green">7669</FONT>        public void setHoverFontColor(String cssColor) {<a name="line.7669"></a>
<FONT color="green">7670</FONT>          if (hoverAnnotation == null)<a name="line.7670"></a>
<FONT color="green">7671</FONT>            hoverAnnotation = new Annotation();<a name="line.7671"></a>
<FONT color="green">7672</FONT>          hoverAnnotation.setFontColor(cssColor);<a name="line.7672"></a>
<FONT color="green">7673</FONT>        }<a name="line.7673"></a>
<FONT color="green">7674</FONT>    <a name="line.7674"></a>
<FONT color="green">7675</FONT>        /**<a name="line.7675"></a>
<FONT color="green">7676</FONT>         * Specifies the CSS font-family used by this symbol's hover annotations.<a name="line.7676"></a>
<FONT color="green">7677</FONT>         * <a name="line.7677"></a>
<FONT color="green">7678</FONT>         * @param cssFontFamily<a name="line.7678"></a>
<FONT color="green">7679</FONT>         *          any valid CSS font-family, such as<a name="line.7679"></a>
<FONT color="green">7680</FONT>         *          &lt;tt&gt;"serif", "sans-serif", "monospace", "cursive",<a name="line.7680"></a>
<FONT color="green">7681</FONT>         *          "fantasy"&lt;/tt&gt; or &lt;tt&gt;"Arial, sans-serif"&lt;/tt&gt;.<a name="line.7681"></a>
<FONT color="green">7682</FONT>         * <a name="line.7682"></a>
<FONT color="green">7683</FONT>         * @see #getHoverFontFamily getHoverFontFamily<a name="line.7683"></a>
<FONT color="green">7684</FONT>         * @see #setHoverFontWeight setHoverFontWeight<a name="line.7684"></a>
<FONT color="green">7685</FONT>         * @see #setHoverFontColor setHoverFontColor<a name="line.7685"></a>
<FONT color="green">7686</FONT>         * @see #setHoverFontSize setHoverFontSize<a name="line.7686"></a>
<FONT color="green">7687</FONT>         * @see #setHoverLocation setHoverLocation<a name="line.7687"></a>
<FONT color="green">7688</FONT>         * @see #setHoverWidget setHoverWidget<a name="line.7688"></a>
<FONT color="green">7689</FONT>         * @see #setHoverXShift setHoverXShift<a name="line.7689"></a>
<FONT color="green">7690</FONT>         * @see #setHoverYShift setHoverYShift<a name="line.7690"></a>
<FONT color="green">7691</FONT>         * @see #setHoverFontStyle setHoverFontStyle<a name="line.7691"></a>
<FONT color="green">7692</FONT>         */<a name="line.7692"></a>
<FONT color="green">7693</FONT>        public void setHoverFontFamily(String cssFontFamily) {<a name="line.7693"></a>
<FONT color="green">7694</FONT>          if (hoverAnnotation == null)<a name="line.7694"></a>
<FONT color="green">7695</FONT>            hoverAnnotation = new Annotation();<a name="line.7695"></a>
<FONT color="green">7696</FONT>          hoverAnnotation.setFontFamily(cssFontFamily);<a name="line.7696"></a>
<FONT color="green">7697</FONT>        }<a name="line.7697"></a>
<FONT color="green">7698</FONT>    <a name="line.7698"></a>
<FONT color="green">7699</FONT>        /**<a name="line.7699"></a>
<FONT color="green">7700</FONT>         * Specifies the CSS font-style used by this symbol's hover annotations.<a name="line.7700"></a>
<FONT color="green">7701</FONT>         * <a name="line.7701"></a>
<FONT color="green">7702</FONT>         * @param cssStyle<a name="line.7702"></a>
<FONT color="green">7703</FONT>         *          any valid CSS font-style, namely, normal, italic, oblique, or<a name="line.7703"></a>
<FONT color="green">7704</FONT>         *          inherit.<a name="line.7704"></a>
<FONT color="green">7705</FONT>         * <a name="line.7705"></a>
<FONT color="green">7706</FONT>         * @see #getHoverFontStyle getHoverFontStyle<a name="line.7706"></a>
<FONT color="green">7707</FONT>         * @see #setHoverFontWeight setHoverFontWeight<a name="line.7707"></a>
<FONT color="green">7708</FONT>         * @see #setHoverFontColor setHoverFontColor<a name="line.7708"></a>
<FONT color="green">7709</FONT>         * @see #setHoverFontSize setHoverFontSize<a name="line.7709"></a>
<FONT color="green">7710</FONT>         * @see #setHoverLocation setHoverLocation<a name="line.7710"></a>
<FONT color="green">7711</FONT>         * @see #setHoverWidget setHoverWidget<a name="line.7711"></a>
<FONT color="green">7712</FONT>         * @see #setHoverXShift setHoverXShift<a name="line.7712"></a>
<FONT color="green">7713</FONT>         * @see #setHoverYShift setHoverYShift<a name="line.7713"></a>
<FONT color="green">7714</FONT>         */<a name="line.7714"></a>
<FONT color="green">7715</FONT>        public void setHoverFontStyle(String cssStyle) {<a name="line.7715"></a>
<FONT color="green">7716</FONT>          if (hoverAnnotation == null)<a name="line.7716"></a>
<FONT color="green">7717</FONT>            hoverAnnotation = new Annotation();<a name="line.7717"></a>
<FONT color="green">7718</FONT>          hoverAnnotation.setFontStyle(cssStyle);<a name="line.7718"></a>
<FONT color="green">7719</FONT>        }<a name="line.7719"></a>
<FONT color="green">7720</FONT>    <a name="line.7720"></a>
<FONT color="green">7721</FONT>        /**<a name="line.7721"></a>
<FONT color="green">7722</FONT>         * Specifies the CSS font size used in this symbol's hover annotations, in<a name="line.7722"></a>
<FONT color="green">7723</FONT>         * pixels.<a name="line.7723"></a>
<FONT color="green">7724</FONT>         * <a name="line.7724"></a>
<FONT color="green">7725</FONT>         * @param fontSize<a name="line.7725"></a>
<FONT color="green">7726</FONT>         *          the CSS font size used in the hover annotations associated with<a name="line.7726"></a>
<FONT color="green">7727</FONT>         *          this symbol, in pixels.<a name="line.7727"></a>
<FONT color="green">7728</FONT>         * <a name="line.7728"></a>
<FONT color="green">7729</FONT>         * @see #getHoverFontSize getHoverFontSize<a name="line.7729"></a>
<FONT color="green">7730</FONT>         * @see #setHoverFontWeight setHoverFontWeight<a name="line.7730"></a>
<FONT color="green">7731</FONT>         * @see #setHoverFontColor setHoverFontColor<a name="line.7731"></a>
<FONT color="green">7732</FONT>         * @see #setHoverFontStyle setHoverFontStyle<a name="line.7732"></a>
<FONT color="green">7733</FONT>         * @see #setHoverLocation setHoverLocation<a name="line.7733"></a>
<FONT color="green">7734</FONT>         * @see #setHoverWidget setHoverWidget<a name="line.7734"></a>
<FONT color="green">7735</FONT>         * @see #setHoverXShift setHoverXShift<a name="line.7735"></a>
<FONT color="green">7736</FONT>         * @see #setHoverYShift setHoverYShift<a name="line.7736"></a>
<FONT color="green">7737</FONT>         */<a name="line.7737"></a>
<FONT color="green">7738</FONT>        public void setHoverFontSize(int fontSize) {<a name="line.7738"></a>
<FONT color="green">7739</FONT>          if (hoverAnnotation == null)<a name="line.7739"></a>
<FONT color="green">7740</FONT>            hoverAnnotation = new Annotation();<a name="line.7740"></a>
<FONT color="green">7741</FONT>          hoverAnnotation.setFontSize(fontSize);<a name="line.7741"></a>
<FONT color="green">7742</FONT>        }<a name="line.7742"></a>
<FONT color="green">7743</FONT>    <a name="line.7743"></a>
<FONT color="green">7744</FONT>        /**<a name="line.7744"></a>
<FONT color="green">7745</FONT>         * Specifies the location of this point's hover annotations. Set this<a name="line.7745"></a>
<FONT color="green">7746</FONT>         * property to &lt;tt&gt;null&lt;/tt&gt; (the default) to use GChart's default hover<a name="line.7746"></a>
<FONT color="green">7747</FONT>         * location, which varies with the hover annotation's symbol type, as<a name="line.7747"></a>
<FONT color="green">7748</FONT>         * tabulated below. (The hover annotation symbol type defaults to the symbol<a name="line.7748"></a>
<FONT color="green">7749</FONT>         * type of the hovered over curve, and can be specified explicitly via the<a name="line.7749"></a>
<FONT color="green">7750</FONT>         * &lt;tt&gt;setHoverAnnotationSymbolType&lt;/tt&gt; method).<a name="line.7750"></a>
<FONT color="green">7751</FONT>         * &lt;p&gt;<a name="line.7751"></a>
<FONT color="green">7752</FONT>         * <a name="line.7752"></a>
<FONT color="green">7753</FONT>         * &lt;table border&gt;<a name="line.7753"></a>
<FONT color="green">7754</FONT>         * &lt;tr&gt;<a name="line.7754"></a>
<FONT color="green">7755</FONT>         * &lt;th&gt;SymbolType used to&lt;br&gt;<a name="line.7755"></a>
<FONT color="green">7756</FONT>         * position hover annotation&lt;/th&gt;<a name="line.7756"></a>
<FONT color="green">7757</FONT>         * &lt;th&gt;Default Hover&lt;br&gt;<a name="line.7757"></a>
<FONT color="green">7758</FONT>         * AnnotationLocation&lt;/th&gt;<a name="line.7758"></a>
<FONT color="green">7759</FONT>         * &lt;/tr&gt;<a name="line.7759"></a>
<FONT color="green">7760</FONT>         * &lt;tr&gt;<a name="line.7760"></a>
<FONT color="green">7761</FONT>         * &lt;td&gt;HBAR_BASELINE_*&lt;/td&gt;<a name="line.7761"></a>
<FONT color="green">7762</FONT>         * &lt;td&gt;FARTHEST_FROM_VERTICAL_BASELINE&lt;/td&gt;<a name="line.7762"></a>
<FONT color="green">7763</FONT>         * &lt;/tr&gt;<a name="line.7763"></a>
<FONT color="green">7764</FONT>         * &lt;tr&gt;<a name="line.7764"></a>
<FONT color="green">7765</FONT>         * &lt;td&gt;HBAR_*WEST&lt;/td&gt;<a name="line.7765"></a>
<FONT color="green">7766</FONT>         * &lt;td&gt;EAST&lt;/td&gt;<a name="line.7766"></a>
<FONT color="green">7767</FONT>         * &lt;/tr&gt;<a name="line.7767"></a>
<FONT color="green">7768</FONT>         * &lt;tr&gt;<a name="line.7768"></a>
<FONT color="green">7769</FONT>         * &lt;td&gt;HBAR_*EAST&lt;/td&gt;<a name="line.7769"></a>
<FONT color="green">7770</FONT>         * &lt;td&gt;WEST&lt;/td&gt;<a name="line.7770"></a>
<FONT color="green">7771</FONT>         * &lt;/tr&gt;<a name="line.7771"></a>
<FONT color="green">7772</FONT>         * &lt;tr&gt;<a name="line.7772"></a>
<FONT color="green">7773</FONT>         * &lt;td&gt;PIE_SLICE_*&lt;/td&gt;<a name="line.7773"></a>
<FONT color="green">7774</FONT>         * &lt;td&gt;OUTSIDE_PIE_ARC&lt;/td&gt;<a name="line.7774"></a>
<FONT color="green">7775</FONT>         * &lt;/tr&gt;<a name="line.7775"></a>
<FONT color="green">7776</FONT>         * &lt;tr&gt;<a name="line.7776"></a>
<FONT color="green">7777</FONT>         * &lt;td&gt;VBAR_SOUTH*&lt;/td&gt;<a name="line.7777"></a>
<FONT color="green">7778</FONT>         * &lt;td&gt;NORTH&lt;/td&gt;<a name="line.7778"></a>
<FONT color="green">7779</FONT>         * &lt;/tr&gt;<a name="line.7779"></a>
<FONT color="green">7780</FONT>         * &lt;tr&gt;<a name="line.7780"></a>
<FONT color="green">7781</FONT>         * &lt;td&gt;VBAR_BASELINE_*&lt;/td&gt;<a name="line.7781"></a>
<FONT color="green">7782</FONT>         * &lt;td&gt;FARTHEST_FROM_HORIZONTAL_BASELINE&lt;/td&gt;<a name="line.7782"></a>
<FONT color="green">7783</FONT>         * &lt;/tr&gt;<a name="line.7783"></a>
<FONT color="green">7784</FONT>         * &lt;tr&gt;<a name="line.7784"></a>
<FONT color="green">7785</FONT>         * &lt;td&gt;VBAR_NORTH*&lt;/td&gt;<a name="line.7785"></a>
<FONT color="green">7786</FONT>         * &lt;td&gt;SOUTH&lt;/td&gt;<a name="line.7786"></a>
<FONT color="green">7787</FONT>         * &lt;/tr&gt;<a name="line.7787"></a>
<FONT color="green">7788</FONT>         * &lt;tr&gt;<a name="line.7788"></a>
<FONT color="green">7789</FONT>         * &lt;td&gt;All others&lt;/td&gt;<a name="line.7789"></a>
<FONT color="green">7790</FONT>         * &lt;td&gt;NORTHWEST&lt;/td&gt;<a name="line.7790"></a>
<FONT color="green">7791</FONT>         * &lt;/tr&gt;<a name="line.7791"></a>
<FONT color="green">7792</FONT>         * &lt;/table&gt;<a name="line.7792"></a>
<FONT color="green">7793</FONT>         * <a name="line.7793"></a>
<FONT color="green">7794</FONT>         * &lt;p&gt;<a name="line.7794"></a>
<FONT color="green">7795</FONT>         * <a name="line.7795"></a>
<FONT color="green">7796</FONT>         * You can further adjust the position of a point's hover annotations by<a name="line.7796"></a>
<FONT color="green">7797</FONT>         * specifying non-zero positional shifts via the &lt;tt&gt;setHoverXShift&lt;/tt&gt; and<a name="line.7797"></a>
<FONT color="green">7798</FONT>         * &lt;tt&gt;setHoverYShift&lt;/tt&gt; methods, and via the<a name="line.7798"></a>
<FONT color="green">7799</FONT>         * &lt;tt&gt;setHoverAnnotationSymbolType&lt;/tt&gt; method.<a name="line.7799"></a>
<FONT color="green">7800</FONT>         * &lt;p&gt;<a name="line.7800"></a>
<FONT color="green">7801</FONT>         * <a name="line.7801"></a>
<FONT color="green">7802</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; To position hover annotations at a fixed location on the<a name="line.7802"></a>
<FONT color="green">7803</FONT>         * chart, (such as a status bar that displays information about the hovered<a name="line.7803"></a>
<FONT color="green">7804</FONT>         * over point, an inset chart that shows a detailed view, etc.) pass one of<a name="line.7804"></a>
<FONT color="green">7805</FONT>         * the &lt;tt&gt;ANCHOR_*&lt;/tt&gt; symbol types to the<a name="line.7805"></a>
<FONT color="green">7806</FONT>         * &lt;tt&gt;setHoverAnnotationSymbolType&lt;/tt&gt; method.<a name="line.7806"></a>
<FONT color="green">7807</FONT>         * &lt;p&gt;<a name="line.7807"></a>
<FONT color="green">7808</FONT>         * <a name="line.7808"></a>
<FONT color="green">7809</FONT>         * @param hoverLocation<a name="line.7809"></a>
<FONT color="green">7810</FONT>         *          the relative location of the hover annotations, or &lt;tt&gt;null&lt;/tt&gt;<a name="line.7810"></a>
<FONT color="green">7811</FONT>         *          to use a symbol-type-specific default.<a name="line.7811"></a>
<FONT color="green">7812</FONT>         * <a name="line.7812"></a>
<FONT color="green">7813</FONT>         * @see #getHoverLocation getHoverLocation<a name="line.7813"></a>
<FONT color="green">7814</FONT>         * @see #setHoverFontWeight setHoverFontWeight<a name="line.7814"></a>
<FONT color="green">7815</FONT>         * @see #setHoverFontColor setHoverFontColor<a name="line.7815"></a>
<FONT color="green">7816</FONT>         * @see #setHoverFontStyle setHoverFontStyle<a name="line.7816"></a>
<FONT color="green">7817</FONT>         * @see #setHoverFontSize setHoverFontSize<a name="line.7817"></a>
<FONT color="green">7818</FONT>         * @see #setHoverAnnotationSymbolType setHoverAnnotationSymbolType<a name="line.7818"></a>
<FONT color="green">7819</FONT>         * @see #setHoverWidget setHoverWidget<a name="line.7819"></a>
<FONT color="green">7820</FONT>         * @see #setHoverXShift setHoverXShift<a name="line.7820"></a>
<FONT color="green">7821</FONT>         * @see #setHoverYShift setHoverYShift<a name="line.7821"></a>
<FONT color="green">7822</FONT>         * @see #DEFAULT_HOVER_LOCATION DEFAULT_HOVER_LOCATION<a name="line.7822"></a>
<FONT color="green">7823</FONT>         * <a name="line.7823"></a>
<FONT color="green">7824</FONT>         */<a name="line.7824"></a>
<FONT color="green">7825</FONT>        public void setHoverLocation(AnnotationLocation hoverLocation) {<a name="line.7825"></a>
<FONT color="green">7826</FONT>          if (hoverAnnotation == null)<a name="line.7826"></a>
<FONT color="green">7827</FONT>            hoverAnnotation = new Annotation();<a name="line.7827"></a>
<FONT color="green">7828</FONT>          hoverAnnotation.setLocation(hoverLocation);<a name="line.7828"></a>
<FONT color="green">7829</FONT>        }<a name="line.7829"></a>
<FONT color="green">7830</FONT>    <a name="line.7830"></a>
<FONT color="green">7831</FONT>        /**<a name="line.7831"></a>
<FONT color="green">7832</FONT>         * Sets the symbol type that GChart will use when positioning hover<a name="line.7832"></a>
<FONT color="green">7833</FONT>         * annotations. GChart positions each hover annotation as if it were<a name="line.7833"></a>
<FONT color="green">7834</FONT>         * associated with a point with the same x,y as the hovered over point, and<a name="line.7834"></a>
<FONT color="green">7835</FONT>         * mapped to the same y-axis, but that appears on a curve with the symbol<a name="line.7835"></a>
<FONT color="green">7836</FONT>         * type specified by this method.<a name="line.7836"></a>
<FONT color="green">7837</FONT>         * <a name="line.7837"></a>
<FONT color="green">7838</FONT>         * &lt;p&gt;<a name="line.7838"></a>
<FONT color="green">7839</FONT>         * If &lt;tt&gt;null&lt;/tt&gt; is used (this is the default) GChart will use the symbol<a name="line.7839"></a>
<FONT color="green">7840</FONT>         * type associated with the curve containing the hovered over point. Since<a name="line.7840"></a>
<FONT color="green">7841</FONT>         * normally you will want hover annotations to be positioned as if they were<a name="line.7841"></a>
<FONT color="green">7842</FONT>         * annotations of the hovered over points, this default is usually<a name="line.7842"></a>
<FONT color="green">7843</FONT>         * appropriate.<a name="line.7843"></a>
<FONT color="green">7844</FONT>         * &lt;p&gt;<a name="line.7844"></a>
<FONT color="green">7845</FONT>         * <a name="line.7845"></a>
<FONT color="green">7846</FONT>         * However, sometimes you would like the hover annotations to be positioned<a name="line.7846"></a>
<FONT color="green">7847</FONT>         * differently. For example, you might prefer the hover annotations to<a name="line.7847"></a>
<FONT color="green">7848</FONT>         * always appear within a status bar at the bottom of the chart. To achieve<a name="line.7848"></a>
<FONT color="green">7849</FONT>         * this, you could set this property to &lt;tt&gt;ANCHOR_SOUTHWEST&lt;/tt&gt;. Or<a name="line.7849"></a>
<FONT color="green">7850</FONT>         * suppose you always wanted a pie chart's hover annotations to appear in<a name="line.7850"></a>
<FONT color="green">7851</FONT>         * the center of the pie instead of along the outer perimeter. Then you<a name="line.7851"></a>
<FONT color="green">7852</FONT>         * could use &lt;tt&gt;BOX_CENTER&lt;/tt&gt;. Or, if you wanted the hover annotations to<a name="line.7852"></a>
<FONT color="green">7853</FONT>         * be positioned relative to the position that the mouse was at when the<a name="line.7853"></a>
<FONT color="green">7854</FONT>         * symbol was first "touched", you could use &lt;tt&gt;ANCHOR_MOUSE&lt;/tt&gt;.<a name="line.7854"></a>
<FONT color="green">7855</FONT>         * &lt;p&gt;<a name="line.7855"></a>
<FONT color="green">7856</FONT>         * <a name="line.7856"></a>
<FONT color="green">7857</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; Pre v2.4 versions of GChart supported a much simpler,<a name="line.7857"></a>
<FONT color="green">7858</FONT>         * "at-the-mouse", &lt;tt&gt;setTitle&lt;/tt&gt;-based, hover feedback that you can<a name="line.7858"></a>
<FONT color="green">7859</FONT>         * emulate using code such as:<a name="line.7859"></a>
<FONT color="green">7860</FONT>         * &lt;p&gt;<a name="line.7860"></a>
<FONT color="green">7861</FONT>         * <a name="line.7861"></a>
<FONT color="green">7862</FONT>         * &lt;pre&gt;<a name="line.7862"></a>
<FONT color="green">7863</FONT>         * Symbol sym = getCurve().getSymbol();<a name="line.7863"></a>
<FONT color="green">7864</FONT>         * sym.setHoverAnnotationSymbolType(SymbolType.ANCHOR_MOUSE);<a name="line.7864"></a>
<FONT color="green">7865</FONT>         * sym.setHoverLocation(AnnotationLocation.SOUTHEAST);<a name="line.7865"></a>
<FONT color="green">7866</FONT>         * // push 20px below mouse (kind of like setTitle does it).<a name="line.7866"></a>
<FONT color="green">7867</FONT>         * sym.setHoverYShift(-20);<a name="line.7867"></a>
<FONT color="green">7868</FONT>         * <a name="line.7868"></a>
<FONT color="green">7869</FONT>         * // Convenience/transition-helper method<a name="line.7869"></a>
<FONT color="green">7870</FONT>         * // formatAsHovertext wraps plain text in appropriate<a name="line.7870"></a>
<FONT color="green">7871</FONT>         * // HTML so it looks kind of like setTitle-based hovertext.<a name="line.7871"></a>
<FONT color="green">7872</FONT>         * <a name="line.7872"></a>
<FONT color="green">7873</FONT>         * sym.setHovertextTemplate(GChart.formatAsHovertext(&amp;quot;x=${x}, y=${y}&amp;quot;));<a name="line.7873"></a>
<FONT color="green">7874</FONT>         * &lt;/pre&gt;<a name="line.7874"></a>
<FONT color="green">7875</FONT>         * &lt;p&gt;<a name="line.7875"></a>
<FONT color="green">7876</FONT>         * <a name="line.7876"></a>
<FONT color="green">7877</FONT>         * @param hoverAnnotationSymbolType<a name="line.7877"></a>
<FONT color="green">7878</FONT>         *          the symbol type that in part determines how the hover<a name="line.7878"></a>
<FONT color="green">7879</FONT>         *          annotations get positioned, or &lt;tt&gt;null&lt;/tt&gt; (the default) to<a name="line.7879"></a>
<FONT color="green">7880</FONT>         *          use the symbol type of the hovered over point.<a name="line.7880"></a>
<FONT color="green">7881</FONT>         * <a name="line.7881"></a>
<FONT color="green">7882</FONT>         * @see #getHoverAnnotationSymbolType getHoverAnnotationSymbolType<a name="line.7882"></a>
<FONT color="green">7883</FONT>         * @see #setHoverLocation setHoverLocation<a name="line.7883"></a>
<FONT color="green">7884</FONT>         * @see #setHovertextTemplate setHovertextTemplate<a name="line.7884"></a>
<FONT color="green">7885</FONT>         * @see #setHoverXShift setHoverXShift<a name="line.7885"></a>
<FONT color="green">7886</FONT>         * @see #setHoverYShift setHoverYShift<a name="line.7886"></a>
<FONT color="green">7887</FONT>         * @see GChart#formatAsHovertext GChart.formatAsHovertext<a name="line.7887"></a>
<FONT color="green">7888</FONT>         */<a name="line.7888"></a>
<FONT color="green">7889</FONT>        public void setHoverAnnotationSymbolType(<a name="line.7889"></a>
<FONT color="green">7890</FONT>            SymbolType hoverAnnotationSymbolType) {<a name="line.7890"></a>
<FONT color="green">7891</FONT>          this.hoverAnnotationSymbolType = hoverAnnotationSymbolType;<a name="line.7891"></a>
<FONT color="green">7892</FONT>        }<a name="line.7892"></a>
<FONT color="green">7893</FONT>    <a name="line.7893"></a>
<FONT color="green">7894</FONT>        /**<a name="line.7894"></a>
<FONT color="green">7895</FONT>         * Specifies the background color used to indicate that the mouse is<a name="line.7895"></a>
<FONT color="green">7896</FONT>         * "touching" (hovering over) a point.<a name="line.7896"></a>
<FONT color="green">7897</FONT>         * &lt;p&gt;<a name="line.7897"></a>
<FONT color="green">7898</FONT>         * <a name="line.7898"></a>
<FONT color="green">7899</FONT>         * Whenever the user "touches" a point on this curve with the curve's<a name="line.7899"></a>
<FONT color="green">7900</FONT>         * mouse-centered "brush", GChart displays the hover feedback for that<a name="line.7900"></a>
<FONT color="green">7901</FONT>         * point, and indicates that the point is the one the hover feedback refers<a name="line.7901"></a>
<FONT color="green">7902</FONT>         * to by changing its background color to this color.<a name="line.7902"></a>
<FONT color="green">7903</FONT>         * &lt;p&gt;<a name="line.7903"></a>
<FONT color="green">7904</FONT>         * <a name="line.7904"></a>
<FONT color="green">7905</FONT>         * The default hover selection background color is "transparent". This<a name="line.7905"></a>
<FONT color="green">7906</FONT>         * allows the original symbol to appear within selection rectangles that can<a name="line.7906"></a>
<FONT color="green">7907</FONT>         * be defined via the &lt;tt&gt;setHoverSelectionBorderWidth&lt;/tt&gt; and<a name="line.7907"></a>
<FONT color="green">7908</FONT>         * &lt;tt&gt;setHoverSelectionBorderColor&lt;/tt&gt; methods (1px thick external gray<a name="line.7908"></a>
<FONT color="green">7909</FONT>         * selection rectangles are used by default).<a name="line.7909"></a>
<FONT color="green">7910</FONT>         * &lt;p&gt;<a name="line.7910"></a>
<FONT color="green">7911</FONT>         * <a name="line.7911"></a>
<FONT color="green">7912</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; Because the background selection color will often cover the<a name="line.7912"></a>
<FONT color="green">7913</FONT>         * original symbol, it's usually best to choose a selection background color<a name="line.7913"></a>
<FONT color="green">7914</FONT>         * closely related to the original symbol's background color. For example,<a name="line.7914"></a>
<FONT color="green">7915</FONT>         * if the original symbol were blue, you might use a lighter shade of blue.<a name="line.7915"></a>
<FONT color="green">7916</FONT>         * <a name="line.7916"></a>
<FONT color="green">7917</FONT>         * @param hoverSelectionBackgroundColor<a name="line.7917"></a>
<FONT color="green">7918</FONT>         *          a CSS color specification string that specifies the background<a name="line.7918"></a>
<FONT color="green">7919</FONT>         *          color used to indicate "hover-selection".<a name="line.7919"></a>
<FONT color="green">7920</FONT>         * <a name="line.7920"></a>
<FONT color="green">7921</FONT>         * @see #getHoverSelectionBackgroundColor getHoverSelectionBackgroundColor<a name="line.7921"></a>
<FONT color="green">7922</FONT>         * @see #setHoverSelectionBorderColor setHoverSelectionBorderColor<a name="line.7922"></a>
<FONT color="green">7923</FONT>         * @see #setHoverSelectionBorderStyle setHoverSelectionBorderStyle<a name="line.7923"></a>
<FONT color="green">7924</FONT>         * @see #setHoverSelectionBorderWidth setHoverSelectionBorderWidth<a name="line.7924"></a>
<FONT color="green">7925</FONT>         * @see #setBrushHeight setBrushHeight<a name="line.7925"></a>
<FONT color="green">7926</FONT>         * <a name="line.7926"></a>
<FONT color="green">7927</FONT>         */<a name="line.7927"></a>
<FONT color="green">7928</FONT>        public void setHoverSelectionBackgroundColor(<a name="line.7928"></a>
<FONT color="green">7929</FONT>            String hoverSelectionBackgroundColor) {<a name="line.7929"></a>
<FONT color="green">7930</FONT>          this.hoverSelectionBackgroundColor = hoverSelectionBackgroundColor;<a name="line.7930"></a>
<FONT color="green">7931</FONT>        }<a name="line.7931"></a>
<FONT color="green">7932</FONT>    <a name="line.7932"></a>
<FONT color="green">7933</FONT>        /**<a name="line.7933"></a>
<FONT color="green">7934</FONT>         * Specifies the border color used to indicate that the mouse is "touching"<a name="line.7934"></a>
<FONT color="green">7935</FONT>         * (hovering over) a point.<a name="line.7935"></a>
<FONT color="green">7936</FONT>         * &lt;p&gt;<a name="line.7936"></a>
<FONT color="green">7937</FONT>         * <a name="line.7937"></a>
<FONT color="green">7938</FONT>         * Whenever the user "touches" a point on this curve with the mouse-centered<a name="line.7938"></a>
<FONT color="green">7939</FONT>         * "brush", GChart displays the hover feedback for that point, and indicates<a name="line.7939"></a>
<FONT color="green">7940</FONT>         * that the point is the one the hover feedback refers to by drawing a<a name="line.7940"></a>
<FONT color="green">7941</FONT>         * border around it with the given color.<a name="line.7941"></a>
<FONT color="green">7942</FONT>         * &lt;p&gt;<a name="line.7942"></a>
<FONT color="green">7943</FONT>         * <a name="line.7943"></a>
<FONT color="green">7944</FONT>         * The width of this border, and if the is drawn outside or just inside the<a name="line.7944"></a>
<FONT color="green">7945</FONT>         * rectangles associated with the symbol, can be specified via<a name="line.7945"></a>
<FONT color="green">7946</FONT>         * &lt;tt&gt;setHoverSelectionBorderWidth&lt;/tt&gt;.<a name="line.7946"></a>
<FONT color="green">7947</FONT>         * &lt;p&gt;<a name="line.7947"></a>
<FONT color="green">7948</FONT>         * <a name="line.7948"></a>
<FONT color="green">7949</FONT>         * The default hover selection border color is &lt;tt&gt;gray&lt;/tt&gt;.<a name="line.7949"></a>
<FONT color="green">7950</FONT>         * <a name="line.7950"></a>
<FONT color="green">7951</FONT>         * @param hoverSelectionBorderColor<a name="line.7951"></a>
<FONT color="green">7952</FONT>         *          a CSS color specification string that specifies the color used<a name="line.7952"></a>
<FONT color="green">7953</FONT>         *          to indicate "hover-selection", or the special keyword<a name="line.7953"></a>
<FONT color="green">7954</FONT>         *          TRANSPARENT_BORDER_COLOR for a cross-browser consistent<a name="line.7954"></a>
<FONT color="green">7955</FONT>         *          transparent border.<a name="line.7955"></a>
<FONT color="green">7956</FONT>         * <a name="line.7956"></a>
<FONT color="green">7957</FONT>         * @see #getHoverSelectionBorderColor getHoverSelectionBorderColor<a name="line.7957"></a>
<FONT color="green">7958</FONT>         * @see #setHoverSelectionBorderStyle setHoverSelectionBorderStyle<a name="line.7958"></a>
<FONT color="green">7959</FONT>         * @see #setHoverSelectionBorderWidth setHoverSelectionBorderWidth<a name="line.7959"></a>
<FONT color="green">7960</FONT>         * @see #setBrushHeight setBrushHeight<a name="line.7960"></a>
<FONT color="green">7961</FONT>         * <a name="line.7961"></a>
<FONT color="green">7962</FONT>         */<a name="line.7962"></a>
<FONT color="green">7963</FONT>        public void setHoverSelectionBorderColor(<a name="line.7963"></a>
<FONT color="green">7964</FONT>            String hoverSelectionBorderColor) {<a name="line.7964"></a>
<FONT color="green">7965</FONT>          this.hoverSelectionBorderColor = hoverSelectionBorderColor;<a name="line.7965"></a>
<FONT color="green">7966</FONT>        }<a name="line.7966"></a>
<FONT color="green">7967</FONT>    <a name="line.7967"></a>
<FONT color="green">7968</FONT>        /**<a name="line.7968"></a>
<FONT color="green">7969</FONT>         * Specifies the border style used to indicate that the mouse is "touching"<a name="line.7969"></a>
<FONT color="green">7970</FONT>         * (hovering over) a point.<a name="line.7970"></a>
<FONT color="green">7971</FONT>         * &lt;p&gt;<a name="line.7971"></a>
<FONT color="green">7972</FONT>         * <a name="line.7972"></a>
<FONT color="green">7973</FONT>         * Whenever the user "touches" a point on this curve with the mouse-centered<a name="line.7973"></a>
<FONT color="green">7974</FONT>         * "brush", GChart displays the hover feedback for that point, and indicates<a name="line.7974"></a>
<FONT color="green">7975</FONT>         * that the point is the one the hover feedback refers to by drawing a<a name="line.7975"></a>
<FONT color="green">7976</FONT>         * border around it with the given style.<a name="line.7976"></a>
<FONT color="green">7977</FONT>         * &lt;p&gt;<a name="line.7977"></a>
<FONT color="green">7978</FONT>         * <a name="line.7978"></a>
<FONT color="green">7979</FONT>         * The width of this border, and if it is drawn outside or just inside the<a name="line.7979"></a>
<FONT color="green">7980</FONT>         * rectangles associated with the symbol, can be specified via<a name="line.7980"></a>
<FONT color="green">7981</FONT>         * &lt;tt&gt;setHoverSelectionBorderWidth&lt;/tt&gt;.<a name="line.7981"></a>
<FONT color="green">7982</FONT>         * <a name="line.7982"></a>
<FONT color="green">7983</FONT>         * The default hover selection border style is &lt;tt&gt;solid&lt;/tt&gt;.<a name="line.7983"></a>
<FONT color="green">7984</FONT>         * <a name="line.7984"></a>
<FONT color="green">7985</FONT>         * @param hoverSelectionBorderStyle<a name="line.7985"></a>
<FONT color="green">7986</FONT>         *          a CSS border style specification string that indicates the style<a name="line.7986"></a>
<FONT color="green">7987</FONT>         *          of border used to indicate "hover-selection".<a name="line.7987"></a>
<FONT color="green">7988</FONT>         * <a name="line.7988"></a>
<FONT color="green">7989</FONT>         * @see #getHoverSelectionBorderStyle getHoverSelectionBorderStyle<a name="line.7989"></a>
<FONT color="green">7990</FONT>         * @see #setHoverSelectionBorderWidth setHoverSelectionBorderWidth<a name="line.7990"></a>
<FONT color="green">7991</FONT>         * @see #setHoverSelectionBorderColor setHoverSelectionBorderColor<a name="line.7991"></a>
<FONT color="green">7992</FONT>         * @see #setBrushHeight setBrushHeight<a name="line.7992"></a>
<FONT color="green">7993</FONT>         * <a name="line.7993"></a>
<FONT color="green">7994</FONT>         */<a name="line.7994"></a>
<FONT color="green">7995</FONT>        public void setHoverSelectionBorderStyle(<a name="line.7995"></a>
<FONT color="green">7996</FONT>            String hoverSelectionBorderStyle) {<a name="line.7996"></a>
<FONT color="green">7997</FONT>          this.hoverSelectionBorderStyle = hoverSelectionBorderStyle;<a name="line.7997"></a>
<FONT color="green">7998</FONT>        }<a name="line.7998"></a>
<FONT color="green">7999</FONT>    <a name="line.7999"></a>
<FONT color="green">8000</FONT>        /**<a name="line.8000"></a>
<FONT color="green">8001</FONT>         * Sets the width of the border around the perimeter of the symbol used to<a name="line.8001"></a>
<FONT color="green">8002</FONT>         * indicate that the mouse is "touching" (hovering over) a point.<a name="line.8002"></a>
<FONT color="green">8003</FONT>         * &lt;p&gt;<a name="line.8003"></a>
<FONT color="green">8004</FONT>         * <a name="line.8004"></a>
<FONT color="green">8005</FONT>         * If positive, the border is drawn just inside the selected<a name="line.8005"></a>
<FONT color="green">8006</FONT>         * symbol's perimeter; if negative, the border is drawn just outside<a name="line.8006"></a>
<FONT color="green">8007</FONT>         * of it.  &lt;p&gt;<a name="line.8007"></a>
<FONT color="green">8008</FONT>         * <a name="line.8008"></a>
<FONT color="green">8009</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; To create the illusion that symbols increase in size when<a name="line.8009"></a>
<FONT color="green">8010</FONT>         * they are "touched", use a hover selection border color that matches the<a name="line.8010"></a>
<FONT color="green">8011</FONT>         * symbol's color along with a negative hover selection border width.<a name="line.8011"></a>
<FONT color="green">8012</FONT>         * &lt;p&gt;<a name="line.8012"></a>
<FONT color="green">8013</FONT>         * <a name="line.8013"></a>
<FONT color="green">8014</FONT>         * @param borderWidth<a name="line.8014"></a>
<FONT color="green">8015</FONT>         *          the width of the border drawn around the perimeter of the<a name="line.8015"></a>
<FONT color="green">8016</FONT>         *          selected symbolto indicate that the symbol is<a name="line.8016"></a>
<FONT color="green">8017</FONT>         *          being "touched: by the mouse. A negative value adds that border<a name="line.8017"></a>
<FONT color="green">8018</FONT>         *          around the outside of the symbol, in effect<a name="line.8018"></a>
<FONT color="green">8019</FONT>         *          increasing the selected symbol's size (in pixels).<a name="line.8019"></a>
<FONT color="green">8020</FONT>         * <a name="line.8020"></a>
<FONT color="green">8021</FONT>         * @see #getHoverSelectionBorderWidth getHoverSelectionBorderWidth<a name="line.8021"></a>
<FONT color="green">8022</FONT>         * @see #setHoverSelectionBorderColor setHoverSelectionBorderColor<a name="line.8022"></a>
<FONT color="green">8023</FONT>         * @see #setHoverSelectionBackgroundColor setHoverSelectionBackgroundColor<a name="line.8023"></a>
<FONT color="green">8024</FONT>         * @see #setHoverSelectionBorderStyle setHoverSelectionBorderStyle<a name="line.8024"></a>
<FONT color="green">8025</FONT>         * <a name="line.8025"></a>
<FONT color="green">8026</FONT>         */<a name="line.8026"></a>
<FONT color="green">8027</FONT>        public void setHoverSelectionBorderWidth(int borderWidth) {<a name="line.8027"></a>
<FONT color="green">8028</FONT>          hoverSelectionBorderWidth = borderWidth;<a name="line.8028"></a>
<FONT color="green">8029</FONT>        }<a name="line.8029"></a>
<FONT color="green">8030</FONT>    <a name="line.8030"></a>
<FONT color="green">8031</FONT>        /**<a name="line.8031"></a>
<FONT color="green">8032</FONT>         * Specifies if hover selection feedback will be provided for this curve.<a name="line.8032"></a>
<FONT color="green">8033</FONT>         * &lt;p&gt;<a name="line.8033"></a>
<FONT color="green">8034</FONT>         * <a name="line.8034"></a>
<FONT color="green">8035</FONT>         * When enabled, whenever the user "touches" a point on this curve with the<a name="line.8035"></a>
<FONT color="green">8036</FONT>         * mouse-centered "brush", GChart indicates the hover-selected point by<a name="line.8036"></a>
<FONT color="green">8037</FONT>         * adding a selection border around the point, etc.<a name="line.8037"></a>
<FONT color="green">8038</FONT>         * &lt;p&gt;<a name="line.8038"></a>
<FONT color="green">8039</FONT>         * <a name="line.8039"></a>
<FONT color="green">8040</FONT>         * By default, hover selection feedback is enabled.<a name="line.8040"></a>
<FONT color="green">8041</FONT>         * &lt;p&gt;<a name="line.8041"></a>
<FONT color="green">8042</FONT>         * <a name="line.8042"></a>
<FONT color="green">8043</FONT>         * Note that the pop-up hover annotation itself is controlled separately,<a name="line.8043"></a>
<FONT color="green">8044</FONT>         * via the &lt;tt&gt;setHoverAnnotationEnabled&lt;/tt&gt; method.<a name="line.8044"></a>
<FONT color="green">8045</FONT>         * &lt;p&gt;<a name="line.8045"></a>
<FONT color="green">8046</FONT>         * <a name="line.8046"></a>
<FONT color="green">8047</FONT>         * @param hoverSelectionEnabled<a name="line.8047"></a>
<FONT color="green">8048</FONT>         *          a if true, hover selection feedback is enabled, if false,<a name="line.8048"></a>
<FONT color="green">8049</FONT>         *          hovering over a point does not change its color, etc.<a name="line.8049"></a>
<FONT color="green">8050</FONT>         * <a name="line.8050"></a>
<FONT color="green">8051</FONT>         * @see #getHoverSelectionEnabled getHoverSelectionEnabled<a name="line.8051"></a>
<FONT color="green">8052</FONT>         * @see #setHoverAnnotationEnabled setHoverAnnotationEnabled<a name="line.8052"></a>
<FONT color="green">8053</FONT>         * @see #setHoverSelectionBackgroundColor setHoverSelectionBackgroundColor<a name="line.8053"></a>
<FONT color="green">8054</FONT>         * @see #setHoverSelectionBorderColor setHoverSelectionBorderColor<a name="line.8054"></a>
<FONT color="green">8055</FONT>         * @see #setHoverSelectionBorderStyle setHoverSelectionBorderStyle<a name="line.8055"></a>
<FONT color="green">8056</FONT>         * @see #setHoverSelectionBorderWidth setHoverSelectionBorderWidth<a name="line.8056"></a>
<FONT color="green">8057</FONT>         * @see #setHoverSelectionSymbolType setHoverSelectionSymbolType<a name="line.8057"></a>
<FONT color="green">8058</FONT>         * <a name="line.8058"></a>
<FONT color="green">8059</FONT>         */<a name="line.8059"></a>
<FONT color="green">8060</FONT>        public void setHoverSelectionEnabled(boolean hoverSelectionEnabled) {<a name="line.8060"></a>
<FONT color="green">8061</FONT>          this.hoverSelectionEnabled = hoverSelectionEnabled;<a name="line.8061"></a>
<FONT color="green">8062</FONT>        }<a name="line.8062"></a>
<FONT color="green">8063</FONT>    <a name="line.8063"></a>
<FONT color="green">8064</FONT>        /**<a name="line.8064"></a>
<FONT color="green">8065</FONT>         * Specifies the fill spacing that will be used when rendering this curve's<a name="line.8065"></a>
<FONT color="green">8066</FONT>         * hover selection feedback.<a name="line.8066"></a>
<FONT color="green">8067</FONT>         * &lt;p&gt;<a name="line.8067"></a>
<FONT color="green">8068</FONT>         * <a name="line.8068"></a>
<FONT color="green">8069</FONT>         * For more on fill spacing, see &lt;tt&gt;setFillSpacing&lt;/tt&gt;.<a name="line.8069"></a>
<FONT color="green">8070</FONT>         * &lt;p&gt;<a name="line.8070"></a>
<FONT color="green">8071</FONT>         * <a name="line.8071"></a>
<FONT color="green">8072</FONT>         * @param selectionFillSpacing<a name="line.8072"></a>
<FONT color="green">8073</FONT>         *          fill spacing, in pixels, used when rendering this curve's hover<a name="line.8073"></a>
<FONT color="green">8074</FONT>         *          selection feedback or &lt;tt&gt;Double.NaN&lt;/tt&gt; (the default) to adopt<a name="line.8074"></a>
<FONT color="green">8075</FONT>         *          the curve's fill spacing.<a name="line.8075"></a>
<FONT color="green">8076</FONT>         * <a name="line.8076"></a>
<FONT color="green">8077</FONT>         * @see #getHoverSelectionFillSpacing getHoverSelectionFillSpacing<a name="line.8077"></a>
<FONT color="green">8078</FONT>         * @see #setFillSpacing setFillSpacing<a name="line.8078"></a>
<FONT color="green">8079</FONT>         * <a name="line.8079"></a>
<FONT color="green">8080</FONT>         */<a name="line.8080"></a>
<FONT color="green">8081</FONT>    <a name="line.8081"></a>
<FONT color="green">8082</FONT>        public void setHoverSelectionFillSpacing(double selectionFillSpacing) {<a name="line.8082"></a>
<FONT color="green">8083</FONT>          hoverSelectionFillSpacing = selectionFillSpacing;<a name="line.8083"></a>
<FONT color="green">8084</FONT>        }<a name="line.8084"></a>
<FONT color="green">8085</FONT>    <a name="line.8085"></a>
<FONT color="green">8086</FONT>        /**<a name="line.8086"></a>
<FONT color="green">8087</FONT>         * Specifies the fill thickness that will be used when rendering this<a name="line.8087"></a>
<FONT color="green">8088</FONT>         * curve's hover selection feedback.<a name="line.8088"></a>
<FONT color="green">8089</FONT>         * &lt;p&gt;<a name="line.8089"></a>
<FONT color="green">8090</FONT>         * <a name="line.8090"></a>
<FONT color="green">8091</FONT>         * For more on fill thickness, see &lt;tt&gt;setFillThickness&lt;/tt&gt;.<a name="line.8091"></a>
<FONT color="green">8092</FONT>         * &lt;p&gt;<a name="line.8092"></a>
<FONT color="green">8093</FONT>         * <a name="line.8093"></a>
<FONT color="green">8094</FONT>         * @param selectionFillThickness<a name="line.8094"></a>
<FONT color="green">8095</FONT>         *          fill thickness, in pixels, used when rendering this curve's<a name="line.8095"></a>
<FONT color="green">8096</FONT>         *          hover selection feedback or &lt;tt&gt;GChart.NAI&lt;/tt&gt; (the default) to<a name="line.8096"></a>
<FONT color="green">8097</FONT>         *          adopt the curve's fill thickness.<a name="line.8097"></a>
<FONT color="green">8098</FONT>         * <a name="line.8098"></a>
<FONT color="green">8099</FONT>         * @see #getHoverSelectionFillThickness getHoverSelectionFillThickness<a name="line.8099"></a>
<FONT color="green">8100</FONT>         * @see #setFillThickness setFillThickness<a name="line.8100"></a>
<FONT color="green">8101</FONT>         * <a name="line.8101"></a>
<FONT color="green">8102</FONT>         */<a name="line.8102"></a>
<FONT color="green">8103</FONT>        public void setHoverSelectionFillThickness(int selectionFillThickness) {<a name="line.8103"></a>
<FONT color="green">8104</FONT>          hoverSelectionFillThickness = selectionFillThickness;<a name="line.8104"></a>
<FONT color="green">8105</FONT>        }<a name="line.8105"></a>
<FONT color="green">8106</FONT>    <a name="line.8106"></a>
<FONT color="green">8107</FONT>        /**<a name="line.8107"></a>
<FONT color="green">8108</FONT>         * Sets the height of the symbol used to indicate when a given point is<a name="line.8108"></a>
<FONT color="green">8109</FONT>         * being "hovered over" with the mouse.<a name="line.8109"></a>
<FONT color="green">8110</FONT>         * &lt;p&gt;<a name="line.8110"></a>
<FONT color="green">8111</FONT>         * <a name="line.8111"></a>
<FONT color="green">8112</FONT>         * With the default setting of &lt;tt&gt;GChart.NAI&lt;/tt&gt;, GChart simply gives the<a name="line.8112"></a>
<FONT color="green">8113</FONT>         * hover selection symbol the same height as the symbol representing the<a name="line.8113"></a>
<FONT color="green">8114</FONT>         * point itself. Though this default is usually appropriate, you might want<a name="line.8114"></a>
<FONT color="green">8115</FONT>         * the selection symbol to have a larger size so as to increase the<a name="line.8115"></a>
<FONT color="green">8116</FONT>         * visibility of the selected point, etc.<a name="line.8116"></a>
<FONT color="green">8117</FONT>         * &lt;p&gt;<a name="line.8117"></a>
<FONT color="green">8118</FONT>         * <a name="line.8118"></a>
<FONT color="green">8119</FONT>         * @param selectionHeight<a name="line.8119"></a>
<FONT color="green">8120</FONT>         *          the height of the symbol used to indicate that that a point has<a name="line.8120"></a>
<FONT color="green">8121</FONT>         *          been selected, in pixels, or &lt;tt&gt;GChart.NAI&lt;/tt&gt; (the default)<a name="line.8121"></a>
<FONT color="green">8122</FONT>         *          to use the height of the symbol representing the selected point.<a name="line.8122"></a>
<FONT color="green">8123</FONT>         * <a name="line.8123"></a>
<FONT color="green">8124</FONT>         * <a name="line.8124"></a>
<FONT color="green">8125</FONT>         * @see #getHoverSelectionHeight getHoverSelectionHeight<a name="line.8125"></a>
<FONT color="green">8126</FONT>         * @see #setHoverSelectionWidth setHoverSelectionWidth<a name="line.8126"></a>
<FONT color="green">8127</FONT>         * @see #setHoverSelectionBorderColor setHoverSelectionBorderColor<a name="line.8127"></a>
<FONT color="green">8128</FONT>         * @see #setHoverSelectionBackgroundColor setHoverSelectionBackgroundColor<a name="line.8128"></a>
<FONT color="green">8129</FONT>         * <a name="line.8129"></a>
<FONT color="green">8130</FONT>         */<a name="line.8130"></a>
<FONT color="green">8131</FONT>        public void setHoverSelectionHeight(int selectionHeight) {<a name="line.8131"></a>
<FONT color="green">8132</FONT>          hoverSelectionHeight = selectionHeight;<a name="line.8132"></a>
<FONT color="green">8133</FONT>        }<a name="line.8133"></a>
<FONT color="green">8134</FONT>    <a name="line.8134"></a>
<FONT color="green">8135</FONT>        /**<a name="line.8135"></a>
<FONT color="green">8136</FONT>         * Specifies the URL that will define the image used to render selection<a name="line.8136"></a>
<FONT color="green">8137</FONT>         * feedback for points on the curve associated with this symbol.<a name="line.8137"></a>
<FONT color="green">8138</FONT>         * &lt;p&gt;<a name="line.8138"></a>
<FONT color="green">8139</FONT>         * <a name="line.8139"></a>
<FONT color="green">8140</FONT>         * Specify &lt;tt&gt;null&lt;/tt&gt; to use the URL returned by<a name="line.8140"></a>
<FONT color="green">8141</FONT>         * &lt;tt&gt;getBlankImageURL&lt;/tt&gt; (this is the default, and gives you a blank 1x1<a name="line.8141"></a>
<FONT color="green">8142</FONT>         * pixel GIF). Since the image is transparent, the<a name="line.8142"></a>
<FONT color="green">8143</FONT>         * &lt;tt&gt;setHoverSelectionBackgroundColor&lt;/tt&gt; method can be used to define<a name="line.8143"></a>
<FONT color="green">8144</FONT>         * the background color of the selection feedback.<a name="line.8144"></a>
<FONT color="green">8145</FONT>         * &lt;p&gt;<a name="line.8145"></a>
<FONT color="green">8146</FONT>         * <a name="line.8146"></a>
<FONT color="green">8147</FONT>         * Though most applications will do just fine with this default, you can use<a name="line.8147"></a>
<FONT color="green">8148</FONT>         * this method for special selection effects, such creating a<a name="line.8148"></a>
<FONT color="green">8149</FONT>         * semi-transparent "screen" (say, by using an image with alternating<a name="line.8149"></a>
<FONT color="green">8150</FONT>         * transparent and gray pixels) that overlays the selected points.<a name="line.8150"></a>
<FONT color="green">8151</FONT>         * &lt;p&gt;<a name="line.8151"></a>
<FONT color="green">8152</FONT>         * <a name="line.8152"></a>
<FONT color="green">8153</FONT>         * The image is applied in the same way as the symbol's own image URL, but<a name="line.8153"></a>
<FONT color="green">8154</FONT>         * to the internal, system, curve GChart uses to render the selection<a name="line.8154"></a>
<FONT color="green">8155</FONT>         * feedback. See &lt;tt&gt;setImageURL&lt;/tt&gt; for additional information.<a name="line.8155"></a>
<FONT color="green">8156</FONT>         * <a name="line.8156"></a>
<FONT color="green">8157</FONT>         * @see #getHoverSelectionImageURL getHoverSelectionImageURL<a name="line.8157"></a>
<FONT color="green">8158</FONT>         * @see #setImageURL setImageURL<a name="line.8158"></a>
<FONT color="green">8159</FONT>         * @see #setBlankImageURL setBlankImageURL<a name="line.8159"></a>
<FONT color="green">8160</FONT>         * <a name="line.8160"></a>
<FONT color="green">8161</FONT>         * @param imageURL<a name="line.8161"></a>
<FONT color="green">8162</FONT>         *          the url that defines the image used to generate selection<a name="line.8162"></a>
<FONT color="green">8163</FONT>         *          feedback for points rendered with this symbol, or &lt;tt&gt;null&lt;/tt&gt;<a name="line.8163"></a>
<FONT color="green">8164</FONT>         *          to to use GChart's default selection image URL (a 1x1<a name="line.8164"></a>
<FONT color="green">8165</FONT>         *          transparent blank GIF).<a name="line.8165"></a>
<FONT color="green">8166</FONT>         * <a name="line.8166"></a>
<FONT color="green">8167</FONT>         */<a name="line.8167"></a>
<FONT color="green">8168</FONT>        public void setHoverSelectionImageURL(String imageURL) {<a name="line.8168"></a>
<FONT color="green">8169</FONT>          hoverSelectionImageURL = imageURL;<a name="line.8169"></a>
<FONT color="green">8170</FONT>        }<a name="line.8170"></a>
<FONT color="green">8171</FONT>    <a name="line.8171"></a>
<FONT color="green">8172</FONT>        /**<a name="line.8172"></a>
<FONT color="green">8173</FONT>         * Sets the symbol type that GChart will use when generating selection<a name="line.8173"></a>
<FONT color="green">8174</FONT>         * feedback. GChart indicates that a point is selected by re-rendering the<a name="line.8174"></a>
<FONT color="green">8175</FONT>         * point &lt;i&gt;as if&lt;/i&gt; it had this symbol type (this re-rendering overlays,<a name="line.8175"></a>
<FONT color="green">8176</FONT>         * but need not completely cover, the original rendering).<a name="line.8176"></a>
<FONT color="green">8177</FONT>         * &lt;p&gt;<a name="line.8177"></a>
<FONT color="green">8178</FONT>         * <a name="line.8178"></a>
<FONT color="green">8179</FONT>         * If &lt;tt&gt;null&lt;/tt&gt; is used (this is the default) GChart will use the symbol<a name="line.8179"></a>
<FONT color="green">8180</FONT>         * type associated with the original point. This default, which overlays the<a name="line.8180"></a>
<FONT color="green">8181</FONT>         * selection feedback on top of the rendered symbol, is usually appropriate.<a name="line.8181"></a>
<FONT color="green">8182</FONT>         * &lt;p&gt;<a name="line.8182"></a>
<FONT color="green">8183</FONT>         * <a name="line.8183"></a>
<FONT color="green">8184</FONT>         * However, sometimes you would like the selection feedback to use a<a name="line.8184"></a>
<FONT color="green">8185</FONT>         * different symbol type. For example, you might prefer to indicate that a<a name="line.8185"></a>
<FONT color="green">8186</FONT>         * point is selected by drawing a vertical gridline through the point. To<a name="line.8186"></a>
<FONT color="green">8187</FONT>         * achieve this, you could use the &lt;tt&gt;XGRIDLINE&lt;/tt&gt; symbol type. Or, you<a name="line.8187"></a>
<FONT color="green">8188</FONT>         * might wish to indicate selection by dropping a vertical line from the<a name="line.8188"></a>
<FONT color="green">8189</FONT>         * center of the selected point to the x-axis. In this case, you could use<a name="line.8189"></a>
<FONT color="green">8190</FONT>         * &lt;tt&gt;VBAR_SOUTH&lt;/tt&gt; as the hover selection symbol type.<a name="line.8190"></a>
<FONT color="green">8191</FONT>         * &lt;p&gt;<a name="line.8191"></a>
<FONT color="green">8192</FONT>         * <a name="line.8192"></a>
<FONT color="green">8193</FONT>         * &lt;i&gt;Note:&lt;/i&gt; The special mouse related symbol types (those with names<a name="line.8193"></a>
<FONT color="green">8194</FONT>         * matching &lt;tt&gt;ANCHOR_MOUSE*&lt;/tt&gt;) are intended for use in positioning<a name="line.8194"></a>
<FONT color="green">8195</FONT>         * hover popup annotations (via &lt;tt&gt;setHoverAnnotationSymbolType&lt;/tt&gt;). They<a name="line.8195"></a>
<FONT color="green">8196</FONT>         * are not expected to be useful, and could potentially cause confusion, if<a name="line.8196"></a>
<FONT color="green">8197</FONT>         * used as the symbol type passed to this method.<a name="line.8197"></a>
<FONT color="green">8198</FONT>         * &lt;p&gt;<a name="line.8198"></a>
<FONT color="green">8199</FONT>         * <a name="line.8199"></a>
<FONT color="green">8200</FONT>         * @param hoverSelectionSymbolType<a name="line.8200"></a>
<FONT color="green">8201</FONT>         *          the symbol type that in part determines how selection feedback<a name="line.8201"></a>
<FONT color="green">8202</FONT>         *          for a hovered over point is drawn, or &lt;tt&gt;null&lt;/tt&gt; (the<a name="line.8202"></a>
<FONT color="green">8203</FONT>         *          default) to use the symbol type of the hovered over point.<a name="line.8203"></a>
<FONT color="green">8204</FONT>         * <a name="line.8204"></a>
<FONT color="green">8205</FONT>         * @see #getHoverSelectionSymbolType getHoverSelectionSymbolType<a name="line.8205"></a>
<FONT color="green">8206</FONT>         * @see Symbol#setHoverSelectionBackgroundColor<a name="line.8206"></a>
<FONT color="green">8207</FONT>         *      setHoverSelectionBackgroundColor<a name="line.8207"></a>
<FONT color="green">8208</FONT>         * @see Symbol#setHoverSelectionBorderColor setHoverSelectionBorderColor<a name="line.8208"></a>
<FONT color="green">8209</FONT>         * @see Symbol#setHoverSelectionBorderWidth setHoverSelectionBorderWidth<a name="line.8209"></a>
<FONT color="green">8210</FONT>         * @see Symbol#setHoverSelectionHeight setHoverSelectionHeight<a name="line.8210"></a>
<FONT color="green">8211</FONT>         * @see Symbol#setHoverSelectionWidth setHoverSelectionWidth<a name="line.8211"></a>
<FONT color="green">8212</FONT>         * @see Symbol#setHoverAnnotationSymbolType setHoverAnnotationSymbolType<a name="line.8212"></a>
<FONT color="green">8213</FONT>         * <a name="line.8213"></a>
<FONT color="green">8214</FONT>         */<a name="line.8214"></a>
<FONT color="green">8215</FONT>        public void setHoverSelectionSymbolType(<a name="line.8215"></a>
<FONT color="green">8216</FONT>            SymbolType hoverSelectionSymbolType) {<a name="line.8216"></a>
<FONT color="green">8217</FONT>          this.hoverSelectionSymbolType = hoverSelectionSymbolType;<a name="line.8217"></a>
<FONT color="green">8218</FONT>        }<a name="line.8218"></a>
<FONT color="green">8219</FONT>    <a name="line.8219"></a>
<FONT color="green">8220</FONT>        /**<a name="line.8220"></a>
<FONT color="green">8221</FONT>         * Sets the width of the symbol used to indicate when a given point is being<a name="line.8221"></a>
<FONT color="green">8222</FONT>         * "hovered over" with the mouse.<a name="line.8222"></a>
<FONT color="green">8223</FONT>         * &lt;p&gt;<a name="line.8223"></a>
<FONT color="green">8224</FONT>         * <a name="line.8224"></a>
<FONT color="green">8225</FONT>         * With the default setting of &lt;tt&gt;GChart.NAI&lt;/tt&gt;, GChart simply gives the<a name="line.8225"></a>
<FONT color="green">8226</FONT>         * hover selection symbol the same width as the symbol representing the<a name="line.8226"></a>
<FONT color="green">8227</FONT>         * point itself. Though this default is usually appropriate, you might want<a name="line.8227"></a>
<FONT color="green">8228</FONT>         * the selection symbol to have a larger size so as to increase the<a name="line.8228"></a>
<FONT color="green">8229</FONT>         * visibility of the selected point, etc.<a name="line.8229"></a>
<FONT color="green">8230</FONT>         * &lt;p&gt;<a name="line.8230"></a>
<FONT color="green">8231</FONT>         * <a name="line.8231"></a>
<FONT color="green">8232</FONT>         * @param selectionWidth<a name="line.8232"></a>
<FONT color="green">8233</FONT>         *          the width of the symbol used to indicate that a point has<a name="line.8233"></a>
<FONT color="green">8234</FONT>         *          been selected, in pixels, or &lt;tt&gt;GChart.NAI&lt;/tt&gt; (the default)<a name="line.8234"></a>
<FONT color="green">8235</FONT>         *          to use the width of the symbol representing the selected point.<a name="line.8235"></a>
<FONT color="green">8236</FONT>         * <a name="line.8236"></a>
<FONT color="green">8237</FONT>         * @see #getHoverSelectionWidth getHoverSelectionWidth<a name="line.8237"></a>
<FONT color="green">8238</FONT>         * @see #setHoverSelectionHeight setHoverSelectionHeight<a name="line.8238"></a>
<FONT color="green">8239</FONT>         * @see #setHoverSelectionBorderColor setHoverSelectionBorderColor<a name="line.8239"></a>
<FONT color="green">8240</FONT>         * @see #setHoverSelectionBackgroundColor setHoverSelectionBackgroundColor<a name="line.8240"></a>
<FONT color="green">8241</FONT>         * <a name="line.8241"></a>
<FONT color="green">8242</FONT>         */<a name="line.8242"></a>
<FONT color="green">8243</FONT>        public void setHoverSelectionWidth(int selectionWidth) {<a name="line.8243"></a>
<FONT color="green">8244</FONT>          hoverSelectionWidth = selectionWidth;<a name="line.8244"></a>
<FONT color="green">8245</FONT>        }<a name="line.8245"></a>
<FONT color="green">8246</FONT>    <a name="line.8246"></a>
<FONT color="green">8247</FONT>        /**<a name="line.8247"></a>
<FONT color="green">8248</FONT>         * Defines the "hover-text" that appears whenever the user points their<a name="line.8248"></a>
<FONT color="green">8249</FONT>         * mouse at a point on the curve.<a name="line.8249"></a>
<FONT color="green">8250</FONT>         * &lt;p&gt;<a name="line.8250"></a>
<FONT color="green">8251</FONT>         * <a name="line.8251"></a>
<FONT color="green">8252</FONT>         * HTML is supported within hover-text. As with &lt;tt&gt;setAnnotationText&lt;/tt&gt;,<a name="line.8252"></a>
<FONT color="green">8253</FONT>         * you must prefix HTML template strings with &lt;tt&gt;&amp;lt;html&amp;gt;&lt;/tt&gt; or they<a name="line.8253"></a>
<FONT color="green">8254</FONT>         * will be treated as plain text.<a name="line.8254"></a>
<FONT color="green">8255</FONT>         * &lt;p&gt;<a name="line.8255"></a>
<FONT color="green">8256</FONT>         * <a name="line.8256"></a>
<FONT color="green">8257</FONT>         * Three built-in parameters, &lt;tt&gt;${x}&lt;/tt&gt;, &lt;tt&gt;${y}&lt;/tt&gt;, and<a name="line.8257"></a>
<FONT color="green">8258</FONT>         * &lt;tt&gt;${pieSliceSize}&lt;/tt&gt; are recognized within these hover text<a name="line.8258"></a>
<FONT color="green">8259</FONT>         * templates. Any occurrences of &lt;tt&gt;${x}&lt;/tt&gt; in the string will be<a name="line.8259"></a>
<FONT color="green">8260</FONT>         * replaced with the x-coordinate of the point, formatted as per the<a name="line.8260"></a>
<FONT color="green">8261</FONT>         * specified tick label format of the x-axis. Any occurrences of<a name="line.8261"></a>
<FONT color="green">8262</FONT>         * &lt;tt&gt;${y}&lt;/tt&gt; within the string will be replaced with the y-coordinate of<a name="line.8262"></a>
<FONT color="green">8263</FONT>         * the point, formatted using either the y-axis or y2-axis tick label<a name="line.8263"></a>
<FONT color="green">8264</FONT>         * format, depending on the axis on which the curve is displayed. Any<a name="line.8264"></a>
<FONT color="green">8265</FONT>         * occurrences of &lt;tt&gt;${pieSliceSize}&lt;/tt&gt; within the string will be<a name="line.8265"></a>
<FONT color="green">8266</FONT>         * replaced with 100 times the specified &lt;tt&gt;pieSliceSize&lt;/tt&gt; of the point,<a name="line.8266"></a>
<FONT color="green">8267</FONT>         * formatted the same way as &lt;tt&gt;${y}&lt;/tt&gt;, except that a "%" is tacked onto<a name="line.8267"></a>
<FONT color="green">8268</FONT>         * the end.<a name="line.8268"></a>
<FONT color="green">8269</FONT>         * &lt;p&gt;<a name="line.8269"></a>
<FONT color="green">8270</FONT>         * <a name="line.8270"></a>
<FONT color="green">8271</FONT>         * In addition to these built-in parameters, user-defined parameters are<a name="line.8271"></a>
<FONT color="green">8272</FONT>         * also supported. All parameter names must begin with a letter (<a name="line.8272"></a>
<FONT color="green">8273</FONT>         * &lt;tt&gt;a,b,...,z&lt;/tt&gt; or &lt;tt&gt;A,B,...,Z&lt;/tt&gt;) and be followed by a series of<a name="line.8273"></a>
<FONT color="green">8274</FONT>         * letters, digits (&lt;tt&gt;0,1,...,9&lt;/tt&gt;), and underscores (&lt;tt&gt;_&lt;/tt&gt; ). For<a name="line.8274"></a>
<FONT color="green">8275</FONT>         * example, &lt;tt&gt;${myParam3}&lt;/tt&gt; or &lt;tt&gt;${xyz_123}&lt;/tt&gt;. Note that parameter<a name="line.8275"></a>
<FONT color="green">8276</FONT>         * names are case-sensitive.<a name="line.8276"></a>
<FONT color="green">8277</FONT>         * &lt;p&gt;<a name="line.8277"></a>
<FONT color="green">8278</FONT>         * <a name="line.8278"></a>
<FONT color="green">8279</FONT>         * You define the rules for expanding these user-defined parameters relative<a name="line.8279"></a>
<FONT color="green">8280</FONT>         * to the hovered-over point, by instantiating a<a name="line.8280"></a>
<FONT color="green">8281</FONT>         * &lt;tt&gt;HoverParameterInterpreter&lt;/tt&gt; and passing it to GChart's<a name="line.8281"></a>
<FONT color="green">8282</FONT>         * &lt;tt&gt;setHoverParameterInterpreter&lt;/tt&gt; method. See the<a name="line.8282"></a>
<FONT color="green">8283</FONT>         * &lt;tt&gt;HoverParameterInterpreter&lt;/tt&gt; interface's javadocs for full details.<a name="line.8283"></a>
<FONT color="green">8284</FONT>         * &lt;p&gt;<a name="line.8284"></a>
<FONT color="green">8285</FONT>         * <a name="line.8285"></a>
<FONT color="green">8286</FONT>         * &lt;blockquote&gt;<a name="line.8286"></a>
<FONT color="green">8287</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; If the &lt;tt&gt;${&lt;/tt&gt; is not followed by a valid parameter name<a name="line.8287"></a>
<FONT color="green">8288</FONT>         * and then by &lt;tt&gt;}&lt;/tt&gt;, the "invalid name", along with the original<a name="line.8288"></a>
<FONT color="green">8289</FONT>         * delimiters, passes through literally into the final hovertext (no<a name="line.8289"></a>
<FONT color="green">8290</FONT>         * exception is thrown). So, if you see keywords in your hovertext, it<a name="line.8290"></a>
<FONT color="green">8291</FONT>         * probably means you misspelled a keyword (e.g. you entered<a name="line.8291"></a>
<FONT color="green">8292</FONT>         * &lt;tt&gt;${piesliceSize}&lt;/tt&gt; instead of &lt;tt&gt;${pieSliceSize}&lt;/tt&gt; ), forgot<a name="line.8292"></a>
<FONT color="green">8293</FONT>         * the closing &lt;tt&gt;}&lt;/tt&gt;, began a user-defined parameter name with a digit,<a name="line.8293"></a>
<FONT color="green">8294</FONT>         * and so on.<a name="line.8294"></a>
<FONT color="green">8295</FONT>         * &lt;/blockquote&gt;<a name="line.8295"></a>
<FONT color="green">8296</FONT>         * &lt;p&gt;<a name="line.8296"></a>
<FONT color="green">8297</FONT>         * <a name="line.8297"></a>
<FONT color="green">8298</FONT>         * The default hovertext template, used automatically if hovertext template<a name="line.8298"></a>
<FONT color="green">8299</FONT>         * is &lt;tt&gt;null&lt;/tt&gt;, is &lt;tt&gt;DEFAULT_PIE_SLICE_HOVERTEXT_TEMPLATE&lt;/tt&gt; for<a name="line.8299"></a>
<FONT color="green">8300</FONT>         * pie slice type symbols and &lt;tt&gt;DEFAULT_HOVERTEXT_TEMPLATE&lt;/tt&gt; for all<a name="line.8300"></a>
<FONT color="green">8301</FONT>         * other symbol types.<a name="line.8301"></a>
<FONT color="green">8302</FONT>         * <a name="line.8302"></a>
<FONT color="green">8303</FONT>         * &lt;blockquote&gt; &lt;i&gt;Tip:&lt;/i&gt;If you notice unexplained whitespace to the right<a name="line.8303"></a>
<FONT color="green">8304</FONT>         * or below your pages, that comes and goes as you hover over the chart, it<a name="line.8304"></a>
<FONT color="green">8305</FONT>         * could be due to an overly large default estimate for the hidden<a name="line.8305"></a>
<FONT color="green">8306</FONT>         * "bounding box" GChart uses to properly center hover annotations. You can<a name="line.8306"></a>
<FONT color="green">8307</FONT>         * use the {@link #setHoverWidget setHoverWidget} method, with a<a name="line.8307"></a>
<FONT color="green">8308</FONT>         * &lt;tt&gt;null&lt;/tt&gt; first widget parameter, to override these defaults and<a name="line.8308"></a>
<FONT color="green">8309</FONT>         * correct this problem. &lt;/blockquote&gt;<a name="line.8309"></a>
<FONT color="green">8310</FONT>         * &lt;p&gt;<a name="line.8310"></a>
<FONT color="green">8311</FONT>         * <a name="line.8311"></a>
<FONT color="green">8312</FONT>         * @param hovertextTemplate<a name="line.8312"></a>
<FONT color="green">8313</FONT>         *          defines the hoverText to display when the mouse moves over a<a name="line.8313"></a>
<FONT color="green">8314</FONT>         *          point on this curve, with &lt;tt&gt;${x}&lt;/tt&gt;, &lt;tt&gt;${y}&lt;/tt&gt; and<a name="line.8314"></a>
<FONT color="green">8315</FONT>         *          &lt;tt&gt;${pieSliceSize}&lt;/tt&gt; parameters replaced as described above,<a name="line.8315"></a>
<FONT color="green">8316</FONT>         *          and custom parameters replaced as defined by the parent GChart's<a name="line.8316"></a>
<FONT color="green">8317</FONT>         *          &lt;tt&gt;HoverParameterInterpreter&lt;/tt&gt;.<a name="line.8317"></a>
<FONT color="green">8318</FONT>         * <a name="line.8318"></a>
<FONT color="green">8319</FONT>         * @see #getHovertextTemplate getHovertextTemplate<a name="line.8319"></a>
<FONT color="green">8320</FONT>         * @see Curve.Point#getHovertext getHovertext<a name="line.8320"></a>
<FONT color="green">8321</FONT>         * @see HoverParameterInterpreter HoverParameterInterpreter<a name="line.8321"></a>
<FONT color="green">8322</FONT>         * @see GChart#setHoverParameterInterpreter setHoverParameterInterpreter<a name="line.8322"></a>
<FONT color="green">8323</FONT>         * @see HoverUpdateable HoverUpdateable<a name="line.8323"></a>
<FONT color="green">8324</FONT>         * @see GChart.Curve.Point#setAnnotationText setAnnotationText<a name="line.8324"></a>
<FONT color="green">8325</FONT>         * @see #DEFAULT_HOVERTEXT_TEMPLATE DEFAULT_HOVERTEXT_TEMPLATE<a name="line.8325"></a>
<FONT color="green">8326</FONT>         * @see #DEFAULT_PIE_SLICE_HOVERTEXT_TEMPLATE<a name="line.8326"></a>
<FONT color="green">8327</FONT>         *      DEFAULT_PIE_SLICE_HOVERTEXT_TEMPLATE<a name="line.8327"></a>
<FONT color="green">8328</FONT>         */<a name="line.8328"></a>
<FONT color="green">8329</FONT>        public void setHovertextTemplate(String hovertextTemplate) {<a name="line.8329"></a>
<FONT color="green">8330</FONT>          if (this.hovertextTemplate != hovertextTemplate)<a name="line.8330"></a>
<FONT color="green">8331</FONT>            hovertextChunks = null; // invalidates prev chunk-parse<a name="line.8331"></a>
<FONT color="green">8332</FONT>          this.hovertextTemplate = hovertextTemplate;<a name="line.8332"></a>
<FONT color="green">8333</FONT>        }<a name="line.8333"></a>
<FONT color="green">8334</FONT>    <a name="line.8334"></a>
<FONT color="green">8335</FONT>        /**<a name="line.8335"></a>
<FONT color="green">8336</FONT>         * Specifies a &lt;tt&gt;HoverUpdateable&lt;/tt&gt; widget that will be used to display<a name="line.8336"></a>
<FONT color="green">8337</FONT>         * the hover annotations associated with this symbol. If &lt;tt&gt;null&lt;/tt&gt;,<a name="line.8337"></a>
<FONT color="green">8338</FONT>         * GChart's built-in, &lt;tt&gt;setHovertextTemplate&lt;/tt&gt; based, text or HTML<a name="line.8338"></a>
<FONT color="green">8339</FONT>         * based hover annotations will instead be used.<a name="line.8339"></a>
<FONT color="green">8340</FONT>         * &lt;p&gt;<a name="line.8340"></a>
<FONT color="green">8341</FONT>         * <a name="line.8341"></a>
<FONT color="green">8342</FONT>         * Whenever the rectangular "brush" centered on the current mouse position<a name="line.8342"></a>
<FONT color="green">8343</FONT>         * "touches" a point on this symbol's parent curve, GChart will first call<a name="line.8343"></a>
<FONT color="green">8344</FONT>         * the &lt;tt&gt;hoverUpdate&lt;/tt&gt; method of this "hover-widget", and then position<a name="line.8344"></a>
<FONT color="green">8345</FONT>         * it appropriately relative to the touched point. Most applications will<a name="line.8345"></a>
<FONT color="green">8346</FONT>         * want to implement &lt;tt&gt;hoverUpdate&lt;/tt&gt; so as to populate the hover widget<a name="line.8346"></a>
<FONT color="green">8347</FONT>         * with detailed information about the touched point. For example, to<a name="line.8347"></a>
<FONT color="green">8348</FONT>         * emulate GChart's default hover feedback, you could extend an<a name="line.8348"></a>
<FONT color="green">8349</FONT>         * &lt;tt&gt;HTML&lt;/tt&gt; widget and, within the &lt;tt&gt;hoverUpdate&lt;/tt&gt; method, use the<a name="line.8349"></a>
<FONT color="green">8350</FONT>         * &lt;tt&gt;setHTML&lt;/tt&gt; method to set the widget's HTML to the expanded hover<a name="line.8350"></a>
<FONT color="green">8351</FONT>         * text returned by &lt;tt&gt;hoveredOverPoint.getHovertext()&lt;/tt&gt;.<a name="line.8351"></a>
<FONT color="green">8352</FONT>         * &lt;p&gt;<a name="line.8352"></a>
<FONT color="green">8353</FONT>         * <a name="line.8353"></a>
<FONT color="green">8354</FONT>         * The exact position of the hover widget relative to the touched point is<a name="line.8354"></a>
<FONT color="green">8355</FONT>         * defined by the companion methods, &lt;tt&gt;setHoverLocation&lt;/tt&gt;,<a name="line.8355"></a>
<FONT color="green">8356</FONT>         * &lt;tt&gt;setHoverAnnotationSymbolType&lt;/tt&gt;, &lt;tt&gt;setHoverXShift&lt;/tt&gt;, and<a name="line.8356"></a>
<FONT color="green">8357</FONT>         * &lt;tt&gt;setHoverYShift&lt;/tt&gt;.<a name="line.8357"></a>
<FONT color="green">8358</FONT>         * <a name="line.8358"></a>
<FONT color="green">8359</FONT>         * @param hoverWidget<a name="line.8359"></a>
<FONT color="green">8360</FONT>         *          a &lt;tt&gt;Widget&lt;/tt&gt; that implements the &lt;tt&gt;HoverUpdateable&lt;/tt&gt;<a name="line.8360"></a>
<FONT color="green">8361</FONT>         *          interface that GChart will use when generating this symbol's<a name="line.8361"></a>
<FONT color="green">8362</FONT>         *          widget-based hover annotations, or &lt;tt&gt;null&lt;/tt&gt; to use GChart's<a name="line.8362"></a>
<FONT color="green">8363</FONT>         *          text or HTML based hover annotations (the other two parameters<a name="line.8363"></a>
<FONT color="green">8364</FONT>         *          can still be used to specify upper-bounds on the width and<a name="line.8364"></a>
<FONT color="green">8365</FONT>         *          height of this default hover text).<a name="line.8365"></a>
<FONT color="green">8366</FONT>         * <a name="line.8366"></a>
<FONT color="green">8367</FONT>         * @param widthUpperBound<a name="line.8367"></a>
<FONT color="green">8368</FONT>         *          an upper bound on the width of the widget (or default hover<a name="line.8368"></a>
<FONT color="green">8369</FONT>         *          annotation) in pixels. Use GChart.NAI to get the<a name="line.8369"></a>
<FONT color="green">8370</FONT>         *          GChart-determined default.<a name="line.8370"></a>
<FONT color="green">8371</FONT>         * <a name="line.8371"></a>
<FONT color="green">8372</FONT>         * @param heightUpperBound<a name="line.8372"></a>
<FONT color="green">8373</FONT>         *          an upper bound on the height of the widget (or default hover<a name="line.8373"></a>
<FONT color="green">8374</FONT>         *          annotation) in pixels. Use GChart.NAI to get the<a name="line.8374"></a>
<FONT color="green">8375</FONT>         *          GChart-determined default.<a name="line.8375"></a>
<FONT color="green">8376</FONT>         * <a name="line.8376"></a>
<FONT color="green">8377</FONT>         * @see #getHoverWidget getHoverWidget<a name="line.8377"></a>
<FONT color="green">8378</FONT>         * @see Curve.Point#getHovertext getHovertext<a name="line.8378"></a>
<FONT color="green">8379</FONT>         * @see HoverUpdateable HoverUpdateable<a name="line.8379"></a>
<FONT color="green">8380</FONT>         * @see #setHoverFontWeight setHoverFontWeight<a name="line.8380"></a>
<FONT color="green">8381</FONT>         * @see #setHoverFontColor setHoverFontColor<a name="line.8381"></a>
<FONT color="green">8382</FONT>         * @see #setHoverFontStyle setHoverFontStyle<a name="line.8382"></a>
<FONT color="green">8383</FONT>         * @see #setHoverFontSize setHoverFontSize<a name="line.8383"></a>
<FONT color="green">8384</FONT>         * @see #setHoverLocation setHoverLocation<a name="line.8384"></a>
<FONT color="green">8385</FONT>         * @see #setHoverAnnotationSymbolType setHoverAnnotationSymbolType<a name="line.8385"></a>
<FONT color="green">8386</FONT>         * @see #setHovertextTemplate setHovertextTemplate<a name="line.8386"></a>
<FONT color="green">8387</FONT>         * @see #setHoverXShift setHoverXShift<a name="line.8387"></a>
<FONT color="green">8388</FONT>         * @see #setHoverYShift setHoverYShift<a name="line.8388"></a>
<FONT color="green">8389</FONT>         * <a name="line.8389"></a>
<FONT color="green">8390</FONT>         */<a name="line.8390"></a>
<FONT color="green">8391</FONT>        public void setHoverWidget(HoverUpdateable hoverWidget,<a name="line.8391"></a>
<FONT color="green">8392</FONT>            int widthUpperBound, int heightUpperBound) {<a name="line.8392"></a>
<FONT color="green">8393</FONT>          if (null != hoverWidget &amp;&amp; !(hoverWidget instanceof Widget))<a name="line.8393"></a>
<FONT color="green">8394</FONT>            throw new IllegalArgumentException(<a name="line.8394"></a>
<FONT color="green">8395</FONT>                "hoverWidget must either be null or a Widget.");<a name="line.8395"></a>
<FONT color="green">8396</FONT>    <a name="line.8396"></a>
<FONT color="green">8397</FONT>          if (hoverAnnotation == null)<a name="line.8397"></a>
<FONT color="green">8398</FONT>            hoverAnnotation = new Annotation();<a name="line.8398"></a>
<FONT color="green">8399</FONT>          hoverAnnotation.setWidget((Widget) hoverWidget, widthUpperBound,<a name="line.8399"></a>
<FONT color="green">8400</FONT>              heightUpperBound);<a name="line.8400"></a>
<FONT color="green">8401</FONT>        }<a name="line.8401"></a>
<FONT color="green">8402</FONT>    <a name="line.8402"></a>
<FONT color="green">8403</FONT>        /**<a name="line.8403"></a>
<FONT color="green">8404</FONT>         * Specifies a &lt;tt&gt;HoverUpdateable&lt;/tt&gt; widget that will be used to display<a name="line.8404"></a>
<FONT color="green">8405</FONT>         * all hover annotations associated with this symbol. If &lt;tt&gt;null&lt;/tt&gt;,<a name="line.8405"></a>
<FONT color="green">8406</FONT>         * GChart's built-in, &lt;tt&gt;setHovertextTemplate&lt;/tt&gt; based, text or HTML<a name="line.8406"></a>
<FONT color="green">8407</FONT>         * based hover annotations will instead be used.<a name="line.8407"></a>
<FONT color="green">8408</FONT>         * &lt;p&gt;<a name="line.8408"></a>
<FONT color="green">8409</FONT>         * <a name="line.8409"></a>
<FONT color="green">8410</FONT>         * A convenience method equivalent to<a name="line.8410"></a>
<FONT color="green">8411</FONT>         * &lt;tt&gt;setHoverWidget(hoverWidget, GChart.NAI, GChart.NAI)&lt;/tt&gt;<a name="line.8411"></a>
<FONT color="green">8412</FONT>         * <a name="line.8412"></a>
<FONT color="green">8413</FONT>         * @param annotationWidget<a name="line.8413"></a>
<FONT color="green">8414</FONT>         *          the GWT Widget that defines this point's hover-induced<a name="line.8414"></a>
<FONT color="green">8415</FONT>         *          annotation, or &lt;tt&gt;null&lt;/tt&gt; to use the default hover<a name="line.8415"></a>
<FONT color="green">8416</FONT>         *          annotation, which is based on expanding the hover text template<a name="line.8416"></a>
<FONT color="green">8417</FONT>         *          relative to the hovered over point.<a name="line.8417"></a>
<FONT color="green">8418</FONT>         * <a name="line.8418"></a>
<FONT color="green">8419</FONT>         * @see #setHoverWidget(HoverUpdateable,int,int)<a name="line.8419"></a>
<FONT color="green">8420</FONT>         *      setHoverWidget(HoverUpdateable,int,int)<a name="line.8420"></a>
<FONT color="green">8421</FONT>         * @see #setHovertextTemplate setHovertextTemplate<a name="line.8421"></a>
<FONT color="green">8422</FONT>         * @see Curve.Point#getHovertext getHovertext<a name="line.8422"></a>
<FONT color="green">8423</FONT>         * @see #DEFAULT_WIDGET_HEIGHT_UPPERBOUND DEFAULT_WIDGET_HEIGHT_UPPERBOUND<a name="line.8423"></a>
<FONT color="green">8424</FONT>         * @see #DEFAULT_WIDGET_WIDTH_UPPERBOUND DEFAULT_WIDGET_WIDTH_UPPERBOUND<a name="line.8424"></a>
<FONT color="green">8425</FONT>         * <a name="line.8425"></a>
<FONT color="green">8426</FONT>         */<a name="line.8426"></a>
<FONT color="green">8427</FONT>        public void setHoverWidget(HoverUpdateable annotationWidget) {<a name="line.8427"></a>
<FONT color="green">8428</FONT>          setHoverWidget(annotationWidget, DEFAULT_WIDGET_WIDTH_UPPERBOUND,<a name="line.8428"></a>
<FONT color="green">8429</FONT>              DEFAULT_WIDGET_HEIGHT_UPPERBOUND);<a name="line.8429"></a>
<FONT color="green">8430</FONT>        }<a name="line.8430"></a>
<FONT color="green">8431</FONT>    <a name="line.8431"></a>
<FONT color="green">8432</FONT>        /**<a name="line.8432"></a>
<FONT color="green">8433</FONT>         * Specifies the number of pixels (along the x-axis) to move this symbol's<a name="line.8433"></a>
<FONT color="green">8434</FONT>         * hover annotations from their default, &lt;tt&gt;AnnotationLocation&lt;/tt&gt;<a name="line.8434"></a>
<FONT color="green">8435</FONT>         * defined, point-relative locations.<a name="line.8435"></a>
<FONT color="green">8436</FONT>         * &lt;p&gt;<a name="line.8436"></a>
<FONT color="green">8437</FONT>         * <a name="line.8437"></a>
<FONT color="green">8438</FONT>         * Actual positional shifts are defined via the same conventions as are used<a name="line.8438"></a>
<FONT color="green">8439</FONT>         * by &lt;tt&gt;setAnnotationXShift&lt;/tt&gt;. See that method for further details.<a name="line.8439"></a>
<FONT color="green">8440</FONT>         * <a name="line.8440"></a>
<FONT color="green">8441</FONT>         * @see #getHoverXShift getHoverXShift<a name="line.8441"></a>
<FONT color="green">8442</FONT>         * @see GChart.Curve.Point#setAnnotationXShift setAnnotationXShift<a name="line.8442"></a>
<FONT color="green">8443</FONT>         * @see #setHoverFontWeight setHoverFontWeight<a name="line.8443"></a>
<FONT color="green">8444</FONT>         * @see #setHoverFontColor setHoverFontColor<a name="line.8444"></a>
<FONT color="green">8445</FONT>         * @see #setHoverFontStyle setHoverFontStyle<a name="line.8445"></a>
<FONT color="green">8446</FONT>         * @see #setHoverFontSize setHoverFontSize<a name="line.8446"></a>
<FONT color="green">8447</FONT>         * @see #setHoverLocation setHoverLocation<a name="line.8447"></a>
<FONT color="green">8448</FONT>         * @see #setHoverAnnotationSymbolType setHoverAnnotationSymbolType<a name="line.8448"></a>
<FONT color="green">8449</FONT>         * @see #setHovertextTemplate setHovertextTemplate<a name="line.8449"></a>
<FONT color="green">8450</FONT>         * @see #setHoverWidget setHoverWidget<a name="line.8450"></a>
<FONT color="green">8451</FONT>         * @see #setHoverYShift setHoverYShift<a name="line.8451"></a>
<FONT color="green">8452</FONT>         * <a name="line.8452"></a>
<FONT color="green">8453</FONT>         */<a name="line.8453"></a>
<FONT color="green">8454</FONT>        public void setHoverXShift(int xShift) {<a name="line.8454"></a>
<FONT color="green">8455</FONT>          if (hoverAnnotation == null)<a name="line.8455"></a>
<FONT color="green">8456</FONT>            hoverAnnotation = new Annotation();<a name="line.8456"></a>
<FONT color="green">8457</FONT>          hoverAnnotation.setXShift(xShift);<a name="line.8457"></a>
<FONT color="green">8458</FONT>        }<a name="line.8458"></a>
<FONT color="green">8459</FONT>    <a name="line.8459"></a>
<FONT color="green">8460</FONT>        /**<a name="line.8460"></a>
<FONT color="green">8461</FONT>         * Specifies the number of pixels (along the y-axis) to move this symbol's<a name="line.8461"></a>
<FONT color="green">8462</FONT>         * hover annotations from their default, &lt;tt&gt;AnnotationLocation&lt;/tt&gt;<a name="line.8462"></a>
<FONT color="green">8463</FONT>         * defined, point-relative locations.<a name="line.8463"></a>
<FONT color="green">8464</FONT>         * &lt;p&gt;<a name="line.8464"></a>
<FONT color="green">8465</FONT>         * <a name="line.8465"></a>
<FONT color="green">8466</FONT>         * Actual positional shifts are defined via the same conventions as are used<a name="line.8466"></a>
<FONT color="green">8467</FONT>         * by &lt;tt&gt;setAnnotationYShift&lt;/tt&gt;. See that method for further details.<a name="line.8467"></a>
<FONT color="green">8468</FONT>         * <a name="line.8468"></a>
<FONT color="green">8469</FONT>         * @see #getHoverYShift getHoverYShift<a name="line.8469"></a>
<FONT color="green">8470</FONT>         * @see GChart.Curve.Point#setAnnotationYShift setAnnotationYShift<a name="line.8470"></a>
<FONT color="green">8471</FONT>         * @see #setHoverFontWeight setHoverFontWeight<a name="line.8471"></a>
<FONT color="green">8472</FONT>         * @see #setHoverFontColor setHoverFontColor<a name="line.8472"></a>
<FONT color="green">8473</FONT>         * @see #setHoverFontStyle setHoverFontStyle<a name="line.8473"></a>
<FONT color="green">8474</FONT>         * @see #setHoverFontSize setHoverFontSize<a name="line.8474"></a>
<FONT color="green">8475</FONT>         * @see #setHoverLocation setHoverLocation<a name="line.8475"></a>
<FONT color="green">8476</FONT>         * @see #setHoverAnnotationSymbolType setHoverAnnotationSymbolType<a name="line.8476"></a>
<FONT color="green">8477</FONT>         * @see #setHovertextTemplate setHovertextTemplate<a name="line.8477"></a>
<FONT color="green">8478</FONT>         * @see #setHoverWidget setHoverWidget<a name="line.8478"></a>
<FONT color="green">8479</FONT>         * @see #setHoverXShift setHoverXShift<a name="line.8479"></a>
<FONT color="green">8480</FONT>         * <a name="line.8480"></a>
<FONT color="green">8481</FONT>         */<a name="line.8481"></a>
<FONT color="green">8482</FONT>        public void setHoverYShift(int yShift) {<a name="line.8482"></a>
<FONT color="green">8483</FONT>          if (hoverAnnotation == null)<a name="line.8483"></a>
<FONT color="green">8484</FONT>            hoverAnnotation = new Annotation();<a name="line.8484"></a>
<FONT color="green">8485</FONT>          hoverAnnotation.setYShift(yShift);<a name="line.8485"></a>
<FONT color="green">8486</FONT>        }<a name="line.8486"></a>
<FONT color="green">8487</FONT>    <a name="line.8487"></a>
<FONT color="green">8488</FONT>        /**<a name="line.8488"></a>
<FONT color="green">8489</FONT>         * Specifies the URL that will define the image used to represent the points<a name="line.8489"></a>
<FONT color="green">8490</FONT>         * on this curve.<a name="line.8490"></a>
<FONT color="green">8491</FONT>         * &lt;p&gt;<a name="line.8491"></a>
<FONT color="green">8492</FONT>         * <a name="line.8492"></a>
<FONT color="green">8493</FONT>         * Specify &lt;tt&gt;null&lt;/tt&gt; to use the URL returned by<a name="line.8493"></a>
<FONT color="green">8494</FONT>         * &lt;tt&gt;getBlankImageURL&lt;/tt&gt; (this is the default, and gives you a blank 1x1<a name="line.8494"></a>
<FONT color="green">8495</FONT>         * pixel GIF).<a name="line.8495"></a>
<FONT color="green">8496</FONT>         * &lt;p&gt;<a name="line.8496"></a>
<FONT color="green">8497</FONT>         * <a name="line.8497"></a>
<FONT color="green">8498</FONT>         * Most applications will do just fine with the default. However, this<a name="line.8498"></a>
<FONT color="green">8499</FONT>         * method lets you replace the default, rectangular, chart symbols with<a name="line.8499"></a>
<FONT color="green">8500</FONT>         * custom images (e.g. a five pointed star) or even a Google Chart API url<a name="line.8500"></a>
<FONT color="green">8501</FONT>         * to use tiny 3-D pie charts for each point symbol (it looks a bit strange,<a name="line.8501"></a>
<FONT color="green">8502</FONT>         * and your chart will no longer be strictly client-side any more, but it<a name="line.8502"></a>
<FONT color="green">8503</FONT>         * does work).<a name="line.8503"></a>
<FONT color="green">8504</FONT>         * &lt;p&gt;<a name="line.8504"></a>
<FONT color="green">8505</FONT>         * <a name="line.8505"></a>
<FONT color="green">8506</FONT>         * Note that if the symbol's width and height are bigger or smaller than the<a name="line.8506"></a>
<FONT color="green">8507</FONT>         * specified image, the image will be stretched to fit the symbol's size.<a name="line.8507"></a>
<FONT color="green">8508</FONT>         * Except for single pixel images and such, this does not usually look that<a name="line.8508"></a>
<FONT color="green">8509</FONT>         * great, so exactly matching up the symbol and image size is often best.<a name="line.8509"></a>
<FONT color="green">8510</FONT>         * &lt;p&gt;<a name="line.8510"></a>
<FONT color="green">8511</FONT>         * <a name="line.8511"></a>
<FONT color="green">8512</FONT>         * &lt;small&gt; &lt;i&gt;Tip:&lt;/i&gt; By using a single pixel high or wide image whose<a name="line.8512"></a>
<FONT color="green">8513</FONT>         * other dimension exactly matches the width or height of the symbol, the<a name="line.8513"></a>
<FONT color="green">8514</FONT>         * image will stretch to produce a regular pattern of horizontal or vertical<a name="line.8514"></a>
<FONT color="green">8515</FONT>         * lines. For example, this technique can be used to produce a vertical or<a name="line.8515"></a>
<FONT color="green">8516</FONT>         * horizontal gradient effect in a horizontal or vertical bar chart.<a name="line.8516"></a>
<FONT color="green">8517</FONT>         * &lt;/small&gt;<a name="line.8517"></a>
<FONT color="green">8518</FONT>         * &lt;p&gt;<a name="line.8518"></a>
<FONT color="green">8519</FONT>         * <a name="line.8519"></a>
<FONT color="green">8520</FONT>         * Be aware that GChart was originally designed with only blank image URL's<a name="line.8520"></a>
<FONT color="green">8521</FONT>         * in mind, so it may take some effort to adjust other settings (such as<a name="line.8521"></a>
<FONT color="green">8522</FONT>         * symbol type, width, height, background color, border color, various<a name="line.8522"></a>
<FONT color="green">8523</FONT>         * legend related settings, and curve order) so that the overall chart looks<a name="line.8523"></a>
<FONT color="green">8524</FONT>         * right with your custom images for the curve symbols. In particular, the<a name="line.8524"></a>
<FONT color="green">8525</FONT>         * legend icons are just scaled-down versions of the image, which often<a name="line.8525"></a>
<FONT color="green">8526</FONT>         * doesn't look that great.<a name="line.8526"></a>
<FONT color="green">8527</FONT>         * &lt;p&gt;<a name="line.8527"></a>
<FONT color="green">8528</FONT>         * <a name="line.8528"></a>
<FONT color="green">8529</FONT>         * A alternative that gives you more control (but is less efficient) is to<a name="line.8529"></a>
<FONT color="green">8530</FONT>         * use &lt;tt&gt;SymbolType.NONE&lt;/tt&gt; with &lt;tt&gt;setAnnotationWidget&lt;/tt&gt; (or<a name="line.8530"></a>
<FONT color="green">8531</FONT>         * &lt;tt&gt;setAnnotationText&lt;/tt&gt;) and<a name="line.8531"></a>
<FONT color="green">8532</FONT>         * &lt;tt&gt;setAnnotationLocation(AnnotationLocation.CENTER)&lt;/tt&gt; to use<a name="line.8532"></a>
<FONT color="green">8533</FONT>         * separate, centered, widget-based (or HTML based) annotations in lieu of<a name="line.8533"></a>
<FONT color="green">8534</FONT>         * each point's image-based symbol.<a name="line.8534"></a>
<FONT color="green">8535</FONT>         * <a name="line.8535"></a>
<FONT color="green">8536</FONT>         * @see #getImageURL getImageURL<a name="line.8536"></a>
<FONT color="green">8537</FONT>         * @see #setBlankImageURL setBlankImageURL<a name="line.8537"></a>
<FONT color="green">8538</FONT>         * @see GChart#setPlotAreaImageURL setPlotAreaImageURL<a name="line.8538"></a>
<FONT color="green">8539</FONT>         * @see Curve.Point#setAnnotationWidget setAnnotationWidget<a name="line.8539"></a>
<FONT color="green">8540</FONT>         * @see Curve.Point#setAnnotationText setAnnotationText<a name="line.8540"></a>
<FONT color="green">8541</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.8541"></a>
<FONT color="green">8542</FONT>         * @see Symbol#setSymbolType setSymbolType<a name="line.8542"></a>
<FONT color="green">8543</FONT>         * @see SymbolType#NONE SymbolType.NONE<a name="line.8543"></a>
<FONT color="green">8544</FONT>         * <a name="line.8544"></a>
<FONT color="green">8545</FONT>         * @param imageURL<a name="line.8545"></a>
<FONT color="green">8546</FONT>         *          the url that defines the image within all the rectangular<a name="line.8546"></a>
<FONT color="green">8547</FONT>         *          elements used to draw this symbol on the chart, or &lt;tt&gt;null&lt;/tt&gt;<a name="line.8547"></a>
<FONT color="green">8548</FONT>         *          to revert to GChart's default (a 1x1 transparent blank GIF).<a name="line.8548"></a>
<FONT color="green">8549</FONT>         * <a name="line.8549"></a>
<FONT color="green">8550</FONT>         */<a name="line.8550"></a>
<FONT color="green">8551</FONT>        public void setImageURL(String imageURL) {<a name="line.8551"></a>
<FONT color="green">8552</FONT>          getParent().invalidate();<a name="line.8552"></a>
<FONT color="green">8553</FONT>          this.imageURL = imageURL;<a name="line.8553"></a>
<FONT color="green">8554</FONT>        }<a name="line.8554"></a>
<FONT color="green">8555</FONT>    <a name="line.8555"></a>
<FONT color="green">8556</FONT>        /**<a name="line.8556"></a>
<FONT color="green">8557</FONT>         * Sets the height of this symbol (including any specified border) in<a name="line.8557"></a>
<FONT color="green">8558</FONT>         * pixels.<a name="line.8558"></a>
<FONT color="green">8559</FONT>         * &lt;p&gt;<a name="line.8559"></a>
<FONT color="green">8560</FONT>         * <a name="line.8560"></a>
<FONT color="green">8561</FONT>         * Symbols that draw vertical bars often compute their heights<a name="line.8561"></a>
<FONT color="green">8562</FONT>         * automatically based on curve data, axes limits, specified baselines, etc.<a name="line.8562"></a>
<FONT color="green">8563</FONT>         * These symbols, namely &lt;tt&gt;XGRIDLINE&lt;/tt&gt; and all those whose names begin<a name="line.8563"></a>
<FONT color="green">8564</FONT>         * with &lt;tt&gt;VBAR_&lt;/tt&gt; will ignore this height setting.<a name="line.8564"></a>
<FONT color="green">8565</FONT>         * &lt;p&gt;<a name="line.8565"></a>
<FONT color="green">8566</FONT>         * <a name="line.8566"></a>
<FONT color="green">8567</FONT>         * @param height<a name="line.8567"></a>
<FONT color="green">8568</FONT>         *          height of this symbol, in pixels.<a name="line.8568"></a>
<FONT color="green">8569</FONT>         * <a name="line.8569"></a>
<FONT color="green">8570</FONT>         * @see #getHeight getHeight<a name="line.8570"></a>
<FONT color="green">8571</FONT>         * @see #setWidth setWidth<a name="line.8571"></a>
<FONT color="green">8572</FONT>         * @see #setModelHeight setModelHeight<a name="line.8572"></a>
<FONT color="green">8573</FONT>         * @see #setModelWidth setModelWidth<a name="line.8573"></a>
<FONT color="green">8574</FONT>         */<a name="line.8574"></a>
<FONT color="green">8575</FONT>        public void setHeight(int height) {<a name="line.8575"></a>
<FONT color="green">8576</FONT>          getParent().invalidate();<a name="line.8576"></a>
<FONT color="green">8577</FONT>          this.height = height;<a name="line.8577"></a>
<FONT color="green">8578</FONT>          this.modelHeight = Double.NaN;<a name="line.8578"></a>
<FONT color="green">8579</FONT>        }<a name="line.8579"></a>
<FONT color="green">8580</FONT>    <a name="line.8580"></a>
<FONT color="green">8581</FONT>        /**<a name="line.8581"></a>
<FONT color="green">8582</FONT>         * Sets the height of this symbol (including any specified border) in model<a name="line.8582"></a>
<FONT color="green">8583</FONT>         * units (arbitrary, user-defined, units). Model units are the same units in<a name="line.8583"></a>
<FONT color="green">8584</FONT>         * which the points on the chart are specified and charted.<a name="line.8584"></a>
<FONT color="green">8585</FONT>         * &lt;p&gt;<a name="line.8585"></a>
<FONT color="green">8586</FONT>         * <a name="line.8586"></a>
<FONT color="green">8587</FONT>         * Specification of the modelHeight undefines (that is, sets to<a name="line.8587"></a>
<FONT color="green">8588</FONT>         * &lt;tt&gt;GChart.NAI&lt;/tt&gt;) any previous pixel-based specification made via<a name="line.8588"></a>
<FONT color="green">8589</FONT>         * &lt;tt&gt;setHeight&lt;/tt&gt;.<a name="line.8589"></a>
<FONT color="green">8590</FONT>         * &lt;p&gt;<a name="line.8590"></a>
<FONT color="green">8591</FONT>         * <a name="line.8591"></a>
<FONT color="green">8592</FONT>         * Symbols for drawing vertical bars often compute their heights<a name="line.8592"></a>
<FONT color="green">8593</FONT>         * automatically based on curve data, axes limits, specified baselines, etc.<a name="line.8593"></a>
<FONT color="green">8594</FONT>         * These symbols, namely &lt;tt&gt;XGRIDLINE&lt;/tt&gt; and all those whose names begin<a name="line.8594"></a>
<FONT color="green">8595</FONT>         * with &lt;tt&gt;VBAR_&lt;/tt&gt; will ignore this height setting.<a name="line.8595"></a>
<FONT color="green">8596</FONT>         * &lt;p&gt;<a name="line.8596"></a>
<FONT color="green">8597</FONT>         * <a name="line.8597"></a>
<FONT color="green">8598</FONT>         * @param modelHeight<a name="line.8598"></a>
<FONT color="green">8599</FONT>         *          height of this symbol, in model units<a name="line.8599"></a>
<FONT color="green">8600</FONT>         * <a name="line.8600"></a>
<FONT color="green">8601</FONT>         * @see #getModelHeight getModelHeight<a name="line.8601"></a>
<FONT color="green">8602</FONT>         * @see #setHeight setHeight<a name="line.8602"></a>
<FONT color="green">8603</FONT>         * @see #setModelWidth setModelWidth<a name="line.8603"></a>
<FONT color="green">8604</FONT>         * @see #setWidth setWidth<a name="line.8604"></a>
<FONT color="green">8605</FONT>         */<a name="line.8605"></a>
<FONT color="green">8606</FONT>        public void setModelHeight(double modelHeight) {<a name="line.8606"></a>
<FONT color="green">8607</FONT>          getParent().invalidate();<a name="line.8607"></a>
<FONT color="green">8608</FONT>          this.modelHeight = modelHeight;<a name="line.8608"></a>
<FONT color="green">8609</FONT>        }<a name="line.8609"></a>
<FONT color="green">8610</FONT>    <a name="line.8610"></a>
<FONT color="green">8611</FONT>        /**<a name="line.8611"></a>
<FONT color="green">8612</FONT>         * Sets the width of this symbol (including any specified border) in model<a name="line.8612"></a>
<FONT color="green">8613</FONT>         * units. Model units are an arbitrary, user-defined units system associated<a name="line.8613"></a>
<FONT color="green">8614</FONT>         * with the x,y coordinates of points displayed on the chart.<a name="line.8614"></a>
<FONT color="green">8615</FONT>         * &lt;p&gt;<a name="line.8615"></a>
<FONT color="green">8616</FONT>         * <a name="line.8616"></a>
<FONT color="green">8617</FONT>         * Specification of a symbol's model width undefines (that is, sets to<a name="line.8617"></a>
<FONT color="green">8618</FONT>         * &lt;tt&gt;GChart.NAI&lt;/tt&gt;) any previous, pixel-based, width specification made<a name="line.8618"></a>
<FONT color="green">8619</FONT>         * via &lt;tt&gt;setWidth&lt;/tt&gt;.<a name="line.8619"></a>
<FONT color="green">8620</FONT>         * &lt;p&gt;<a name="line.8620"></a>
<FONT color="green">8621</FONT>         * <a name="line.8621"></a>
<FONT color="green">8622</FONT>         * Symbols for drawing horizontal bars often compute their widths<a name="line.8622"></a>
<FONT color="green">8623</FONT>         * automatically based on curve data, axes limits, specified baseline, etc.<a name="line.8623"></a>
<FONT color="green">8624</FONT>         * These symbols, namely &lt;tt&gt;YGRIDLINE&lt;/tt&gt; and all those whose names begin<a name="line.8624"></a>
<FONT color="green">8625</FONT>         * with &lt;tt&gt;HBAR_&lt;/tt&gt; will ignore this width setting.<a name="line.8625"></a>
<FONT color="green">8626</FONT>         * <a name="line.8626"></a>
<FONT color="green">8627</FONT>         * &lt;p&gt;<a name="line.8627"></a>
<FONT color="green">8628</FONT>         * <a name="line.8628"></a>
<FONT color="green">8629</FONT>         * @param modelWidth<a name="line.8629"></a>
<FONT color="green">8630</FONT>         *          width of this symbol, in model units.<a name="line.8630"></a>
<FONT color="green">8631</FONT>         * <a name="line.8631"></a>
<FONT color="green">8632</FONT>         * @see #setModelHeight setModelHeight<a name="line.8632"></a>
<FONT color="green">8633</FONT>         * @see #setWidth setWidth<a name="line.8633"></a>
<FONT color="green">8634</FONT>         * @see #setHeight setHeight<a name="line.8634"></a>
<FONT color="green">8635</FONT>         * <a name="line.8635"></a>
<FONT color="green">8636</FONT>         */<a name="line.8636"></a>
<FONT color="green">8637</FONT>        public void setModelWidth(double modelWidth) {<a name="line.8637"></a>
<FONT color="green">8638</FONT>          getParent().invalidate();<a name="line.8638"></a>
<FONT color="green">8639</FONT>          this.modelWidth = modelWidth;<a name="line.8639"></a>
<FONT color="green">8640</FONT>        }<a name="line.8640"></a>
<FONT color="green">8641</FONT>    <a name="line.8641"></a>
<FONT color="green">8642</FONT>        /**<a name="line.8642"></a>
<FONT color="green">8643</FONT>         * Specifies a value that defines the angular orientation of the first edge<a name="line.8643"></a>
<FONT color="green">8644</FONT>         * of the pie slice associated with this symbol. (An additional clockwise<a name="line.8644"></a>
<FONT color="green">8645</FONT>         * rotation as defined by &lt;tt&gt;setPieSliceSize&lt;/tt&gt; defines the angular<a name="line.8645"></a>
<FONT color="green">8646</FONT>         * orientation of the second edge of the pie slice).<a name="line.8646"></a>
<FONT color="green">8647</FONT>         * &lt;p&gt;<a name="line.8647"></a>
<FONT color="green">8648</FONT>         * <a name="line.8648"></a>
<FONT color="green">8649</FONT>         * When specified explicitly, the value must be a fraction &gt;= 0 and &lt; 1,<a name="line.8649"></a>
<FONT color="green">8650</FONT>         * with 0 representing due south, 0.25 an additional clockwise angular<a name="line.8650"></a>
<FONT color="green">8651</FONT>         * rotation (starting at due south) that is 25% of the full, 360 degree<a name="line.8651"></a>
<FONT color="green">8652</FONT>         * rotation (and thus, if you can follow these gyrations, is due west), 0.5<a name="line.8652"></a>
<FONT color="green">8653</FONT>         * representing a 50% clockwise angular rotation from due south (thus, due<a name="line.8653"></a>
<FONT color="green">8654</FONT>         * north), .75 a 75% clockwise rotation (and thus, due east), etc.<a name="line.8654"></a>
<FONT color="green">8655</FONT>         * &lt;p&gt;<a name="line.8655"></a>
<FONT color="green">8656</FONT>         * <a name="line.8656"></a>
<FONT color="green">8657</FONT>         * If the specially recognized value, &lt;tt&gt;Double.NaN&lt;/tt&gt;, is specified,<a name="line.8657"></a>
<FONT color="green">8658</FONT>         * orientation is chosen so as to make this slice appear adjacent to the<a name="line.8658"></a>
<FONT color="green">8659</FONT>         * previous slice, (assuming it has the same x,y as the previous slice and<a name="line.8659"></a>
<FONT color="green">8660</FONT>         * is thus part of the same pie figure). If this symbol/point represents the<a name="line.8660"></a>
<FONT color="green">8661</FONT>         * very first pie slice, &lt;tt&gt;Double.NaN&lt;/tt&gt; causes the slice to be oriented<a name="line.8661"></a>
<FONT color="green">8662</FONT>         * as specified via the &lt;tt&gt;setInitialPieSliceOrientation&lt;/tt&gt; method (by<a name="line.8662"></a>
<FONT color="green">8663</FONT>         * default, that's due south).<a name="line.8663"></a>
<FONT color="green">8664</FONT>         * &lt;p&gt;<a name="line.8664"></a>
<FONT color="green">8665</FONT>         * <a name="line.8665"></a>
<FONT color="green">8666</FONT>         * Note that though this value can be set regardless of the symbol's<a name="line.8666"></a>
<FONT color="green">8667</FONT>         * &lt;tt&gt;SymbolType&lt;/tt&gt;, it only has an impact on how the symbol is rendered<a name="line.8667"></a>
<FONT color="green">8668</FONT>         * if the symbol has one of the pie slice symbol types (e.g.<a name="line.8668"></a>
<FONT color="green">8669</FONT>         * &lt;tt&gt;PIE_SLICE_VERTICAL_SHADING&lt;/tt&gt;).<a name="line.8669"></a>
<FONT color="green">8670</FONT>         * <a name="line.8670"></a>
<FONT color="green">8671</FONT>         * @param pieSliceOrientation<a name="line.8671"></a>
<FONT color="green">8672</FONT>         *          angle at which first edge of pie slice appears, expressed as a<a name="line.8672"></a>
<FONT color="green">8673</FONT>         *          fraction of a full 360 degree (2*Pi radians) clockwise rotation<a name="line.8673"></a>
<FONT color="green">8674</FONT>         *          from an initial due south position (the 6 o'clock position)<a name="line.8674"></a>
<FONT color="green">8675</FONT>         *          required to reach the first edge of the pie slice.<a name="line.8675"></a>
<FONT color="green">8676</FONT>         * <a name="line.8676"></a>
<FONT color="green">8677</FONT>         * @see #getPieSliceOrientation getPieSliceOrientation<a name="line.8677"></a>
<FONT color="green">8678</FONT>         * @see #setPieSliceSize setPieSliceSize<a name="line.8678"></a>
<FONT color="green">8679</FONT>         * @see GChart#setInitialPieSliceOrientation setInitialPieSliceOrientation<a name="line.8679"></a>
<FONT color="green">8680</FONT>         * <a name="line.8680"></a>
<FONT color="green">8681</FONT>         */<a name="line.8681"></a>
<FONT color="green">8682</FONT>        public void setPieSliceOrientation(double pieSliceOrientation) {<a name="line.8682"></a>
<FONT color="green">8683</FONT>          invalidateDependentSlices(getCurveIndex(getParent()));<a name="line.8683"></a>
<FONT color="green">8684</FONT>          if (pieSliceOrientation != Double.NaN<a name="line.8684"></a>
<FONT color="green">8685</FONT>              &amp;&amp; (pieSliceOrientation &lt; 0 || pieSliceOrientation &gt;= 1))<a name="line.8685"></a>
<FONT color="green">8686</FONT>            throw new IllegalArgumentException("pieSliceOrientation="<a name="line.8686"></a>
<FONT color="green">8687</FONT>                + pieSliceOrientation + "; "<a name="line.8687"></a>
<FONT color="green">8688</FONT>                + "pieSliceOrientation must be &gt;=0 and &lt; 1, or else "<a name="line.8688"></a>
<FONT color="green">8689</FONT>                + "equal to Double.NaN.");<a name="line.8689"></a>
<FONT color="green">8690</FONT>          this.pieSliceOrientation = pieSliceOrientation;<a name="line.8690"></a>
<FONT color="green">8691</FONT>        }<a name="line.8691"></a>
<FONT color="green">8692</FONT>    <a name="line.8692"></a>
<FONT color="green">8693</FONT>        /**<a name="line.8693"></a>
<FONT color="green">8694</FONT>         * Specifies a value that defines the angular size of any pie slice<a name="line.8694"></a>
<FONT color="green">8695</FONT>         * associated with this symbol.<a name="line.8695"></a>
<FONT color="green">8696</FONT>         * &lt;p&gt;<a name="line.8696"></a>
<FONT color="green">8697</FONT>         * <a name="line.8697"></a>
<FONT color="green">8698</FONT>         * This must be value between 0 and 1. 0.25 represents a quarter pie slice,<a name="line.8698"></a>
<FONT color="green">8699</FONT>         * 0.5 a half pie, 1 a full pie, etc.<a name="line.8699"></a>
<FONT color="green">8700</FONT>         * &lt;p&gt;<a name="line.8700"></a>
<FONT color="green">8701</FONT>         * <a name="line.8701"></a>
<FONT color="green">8702</FONT>         * &lt;i&gt;Note:&lt;/i&gt; To create a complete pie, you must arrange things so that<a name="line.8702"></a>
<FONT color="green">8703</FONT>         * the sum of all of your pie slice sizes adds up to exactly 1.0. If they<a name="line.8703"></a>
<FONT color="green">8704</FONT>         * sum to more than 1, some slices will cover up others; it they sum to<a name="line.8704"></a>
<FONT color="green">8705</FONT>         * less, your pie will have missing slices. You can assure you get a full<a name="line.8705"></a>
<FONT color="green">8706</FONT>         * pie, regardless of the original slice sizes by normalizing your slice<a name="line.8706"></a>
<FONT color="green">8707</FONT>         * sizes. Specifically, divide each original slice size by the sum over all<a name="line.8707"></a>
<FONT color="green">8708</FONT>         * of the original slice sizes. For example, if the original slice sizes<a name="line.8708"></a>
<FONT color="green">8709</FONT>         * were 1, 2, and 2 you could divide them by their sum (1 + 2 + 2 = 5) to<a name="line.8709"></a>
<FONT color="green">8710</FONT>         * obtain normalized slice sizes of 0.2, 0.4, and 0.4.<a name="line.8710"></a>
<FONT color="green">8711</FONT>         * &lt;p&gt;<a name="line.8711"></a>
<FONT color="green">8712</FONT>         * <a name="line.8712"></a>
<FONT color="green">8713</FONT>         * Note that though this value can be set regardless of the symbol's current<a name="line.8713"></a>
<FONT color="green">8714</FONT>         * &lt;tt&gt;SymbolType&lt;/tt&gt;, it only has an impact on how the symbol is rendered<a name="line.8714"></a>
<FONT color="green">8715</FONT>         * if the symbol has one of the pie slice symbol types (e.g.<a name="line.8715"></a>
<FONT color="green">8716</FONT>         * &lt;tt&gt;PIE_SLICE_VERTICAL_SHADING&lt;/tt&gt;).<a name="line.8716"></a>
<FONT color="green">8717</FONT>         * <a name="line.8717"></a>
<FONT color="green">8718</FONT>         * @param pieSliceSize<a name="line.8718"></a>
<FONT color="green">8719</FONT>         *          Fraction of a full pie subtended by this particular pie slice.<a name="line.8719"></a>
<FONT color="green">8720</FONT>         *          Must be between 0 and 1, inclusive.<a name="line.8720"></a>
<FONT color="green">8721</FONT>         * <a name="line.8721"></a>
<FONT color="green">8722</FONT>         * @see #getPieSliceSize getPieSliceSize<a name="line.8722"></a>
<FONT color="green">8723</FONT>         * @see #setPieSliceOrientation setPieSliceOrientation<a name="line.8723"></a>
<FONT color="green">8724</FONT>         * <a name="line.8724"></a>
<FONT color="green">8725</FONT>         */<a name="line.8725"></a>
<FONT color="green">8726</FONT>        public void setPieSliceSize(double pieSliceSize) {<a name="line.8726"></a>
<FONT color="green">8727</FONT>          invalidateDependentSlices(getCurveIndex(getParent()));<a name="line.8727"></a>
<FONT color="green">8728</FONT>          if (!withinRange(pieSliceSize, 0, 1))<a name="line.8728"></a>
<FONT color="green">8729</FONT>            throw new IllegalArgumentException("pieSliceSize="<a name="line.8729"></a>
<FONT color="green">8730</FONT>                + pieSliceSize + "; the requirement: "<a name="line.8730"></a>
<FONT color="green">8731</FONT>                + "0.0 &lt;= pieSliceSize &lt;= 1.0 must be satisfied.");<a name="line.8731"></a>
<FONT color="green">8732</FONT>          this.pieSliceSize = pieSliceSize;<a name="line.8732"></a>
<FONT color="green">8733</FONT>        }<a name="line.8733"></a>
<FONT color="green">8734</FONT>    <a name="line.8734"></a>
<FONT color="green">8735</FONT>        /**<a name="line.8735"></a>
<FONT color="green">8736</FONT>         * Sets the type of this symbol.<a name="line.8736"></a>
<FONT color="green">8737</FONT>         * &lt;p&gt;<a name="line.8737"></a>
<FONT color="green">8738</FONT>         * <a name="line.8738"></a>
<FONT color="green">8739</FONT>         * &lt;i&gt;Note:&lt;/i&gt; The special mouse related symbol types (those with names<a name="line.8739"></a>
<FONT color="green">8740</FONT>         * that begin with &lt;tt&gt;ANCHOR_MOUSE&lt;/tt&gt;) are intended for use in<a name="line.8740"></a>
<FONT color="green">8741</FONT>         * positioning hover popup annotations (via<a name="line.8741"></a>
<FONT color="green">8742</FONT>         * &lt;tt&gt;setHoverAnnotationSymbolType&lt;/tt&gt;). They are not expected to be<a name="line.8742"></a>
<FONT color="green">8743</FONT>         * useful, and could potentially cause confusion, if used as the symbol<a name="line.8743"></a>
<FONT color="green">8744</FONT>         * types of ordinary curves.<a name="line.8744"></a>
<FONT color="green">8745</FONT>         * <a name="line.8745"></a>
<FONT color="green">8746</FONT>         * @param symbolType<a name="line.8746"></a>
<FONT color="green">8747</FONT>         *          the new symbol type for this symbol.<a name="line.8747"></a>
<FONT color="green">8748</FONT>         * @see SymbolType SymbolType<a name="line.8748"></a>
<FONT color="green">8749</FONT>         * @see SymbolType#ANCHOR_MOUSE ANCHOR_MOUSE<a name="line.8749"></a>
<FONT color="green">8750</FONT>         * @see #setHoverAnnotationSymbolType setHoverAnnotationSymbolType<a name="line.8750"></a>
<FONT color="green">8751</FONT>         * <a name="line.8751"></a>
<FONT color="green">8752</FONT>         */<a name="line.8752"></a>
<FONT color="green">8753</FONT>        public void setSymbolType(SymbolType symbolType) {<a name="line.8753"></a>
<FONT color="green">8754</FONT>          getParent().invalidate();<a name="line.8754"></a>
<FONT color="green">8755</FONT>          // will invalidate dependent slices if it was previously a pie slice<a name="line.8755"></a>
<FONT color="green">8756</FONT>          invalidateDependentSlices(getCurveIndex(getParent()));<a name="line.8756"></a>
<FONT color="green">8757</FONT>          this.symbolType = symbolType;<a name="line.8757"></a>
<FONT color="green">8758</FONT>          // will invalidate dependent slices if it is now a pie slice<a name="line.8758"></a>
<FONT color="green">8759</FONT>          invalidateDependentSlices(getCurveIndex(getParent()));<a name="line.8759"></a>
<FONT color="green">8760</FONT>        }<a name="line.8760"></a>
<FONT color="green">8761</FONT>    <a name="line.8761"></a>
<FONT color="green">8762</FONT>        /**<a name="line.8762"></a>
<FONT color="green">8763</FONT>         * Sets the width of this symbol (including any specified border) in pixels.<a name="line.8763"></a>
<FONT color="green">8764</FONT>         * &lt;p&gt;<a name="line.8764"></a>
<FONT color="green">8765</FONT>         * <a name="line.8765"></a>
<FONT color="green">8766</FONT>         * Symbols for drawing horizontal bars often compute their widths<a name="line.8766"></a>
<FONT color="green">8767</FONT>         * automatically based on curve data, axes limits, specified baseline, etc.<a name="line.8767"></a>
<FONT color="green">8768</FONT>         * These symbols, namely &lt;tt&gt;YGRIDLINE&lt;/tt&gt; and all those whose names begin<a name="line.8768"></a>
<FONT color="green">8769</FONT>         * with &lt;tt&gt;HBAR_&lt;/tt&gt; will ignore this width setting.<a name="line.8769"></a>
<FONT color="green">8770</FONT>         * &lt;p&gt;<a name="line.8770"></a>
<FONT color="green">8771</FONT>         * <a name="line.8771"></a>
<FONT color="green">8772</FONT>         * @param width<a name="line.8772"></a>
<FONT color="green">8773</FONT>         *          width of this symbol, in pixels<a name="line.8773"></a>
<FONT color="green">8774</FONT>         * <a name="line.8774"></a>
<FONT color="green">8775</FONT>         * @see #getWidth getHeight<a name="line.8775"></a>
<FONT color="green">8776</FONT>         * @see #setHeight setHeight<a name="line.8776"></a>
<FONT color="green">8777</FONT>         * @see #setModelHeight setModelHeight<a name="line.8777"></a>
<FONT color="green">8778</FONT>         * @see #setModelWidth setModelWidth<a name="line.8778"></a>
<FONT color="green">8779</FONT>         * <a name="line.8779"></a>
<FONT color="green">8780</FONT>         */<a name="line.8780"></a>
<FONT color="green">8781</FONT>        public void setWidth(int width) {<a name="line.8781"></a>
<FONT color="green">8782</FONT>          getParent().invalidate();<a name="line.8782"></a>
<FONT color="green">8783</FONT>          this.width = width;<a name="line.8783"></a>
<FONT color="green">8784</FONT>          this.modelWidth = Double.NaN;<a name="line.8784"></a>
<FONT color="green">8785</FONT>        }<a name="line.8785"></a>
<FONT color="green">8786</FONT>    <a name="line.8786"></a>
<FONT color="green">8787</FONT>        /*<a name="line.8787"></a>
<FONT color="green">8788</FONT>         * Copies properties of the "from" symbol to this symbol.<a name="line.8788"></a>
<FONT color="green">8789</FONT>         * &lt;p&gt;<a name="line.8789"></a>
<FONT color="green">8790</FONT>         * <a name="line.8790"></a>
<FONT color="green">8791</FONT>         * This isn't a generic copy, but is used only when copying the properties<a name="line.8791"></a>
<FONT color="green">8792</FONT>         * of the hovered-over curve into the system curves used to render the<a name="line.8792"></a>
<FONT color="green">8793</FONT>         * selection feedback and hover annotations (it contains some special logic<a name="line.8793"></a>
<FONT color="green">8794</FONT>         * needed only in that context).<a name="line.8794"></a>
<FONT color="green">8795</FONT>         */<a name="line.8795"></a>
<FONT color="green">8796</FONT>        void copy(Symbol from) {<a name="line.8796"></a>
<FONT color="green">8797</FONT>          setBackgroundColor(from.getBackgroundColor());<a name="line.8797"></a>
<FONT color="green">8798</FONT>          setBaseline(from.getBaseline());<a name="line.8798"></a>
<FONT color="green">8799</FONT>          setBorderColor(from.getBorderColor());<a name="line.8799"></a>
<FONT color="green">8800</FONT>          setBorderStyle(from.getBorderStyle());<a name="line.8800"></a>
<FONT color="green">8801</FONT>          setBorderWidth(from.getBorderWidth());<a name="line.8801"></a>
<FONT color="green">8802</FONT>          setFillSpacing(from.getFillSpacing());<a name="line.8802"></a>
<FONT color="green">8803</FONT>          setFillThickness(from.getFillThickness());<a name="line.8803"></a>
<FONT color="green">8804</FONT>          // setHoverAnnotationEnabled(from.getHoverAnnotationEnabled());<a name="line.8804"></a>
<FONT color="green">8805</FONT>          setHoverFontColor(from.getHoverFontColor());<a name="line.8805"></a>
<FONT color="green">8806</FONT>          setHoverFontSize(from.getHoverFontSize());<a name="line.8806"></a>
<FONT color="green">8807</FONT>          setHoverFontFamily(from.getHoverFontFamily());<a name="line.8807"></a>
<FONT color="green">8808</FONT>          setHoverFontStyle(from.getHoverFontStyle());<a name="line.8808"></a>
<FONT color="green">8809</FONT>          setHoverFontWeight(from.getHoverFontWeight());<a name="line.8809"></a>
<FONT color="green">8810</FONT>          setHoverLocation(from.getHoverLocation());<a name="line.8810"></a>
<FONT color="green">8811</FONT>          setHoverAnnotationSymbolType(from.getHoverAnnotationSymbolType());<a name="line.8811"></a>
<FONT color="green">8812</FONT>          setHoverSelectionBackgroundColor(from<a name="line.8812"></a>
<FONT color="green">8813</FONT>              .getHoverSelectionBackgroundColor());<a name="line.8813"></a>
<FONT color="green">8814</FONT>          setHoverSelectionBorderColor(from.getHoverSelectionBorderColor());<a name="line.8814"></a>
<FONT color="green">8815</FONT>          setHoverSelectionBorderStyle(from.getHoverSelectionBorderStyle());<a name="line.8815"></a>
<FONT color="green">8816</FONT>          setHoverSelectionBorderWidth(from.getHoverSelectionBorderWidth());<a name="line.8816"></a>
<FONT color="green">8817</FONT>          // setHoverSelectionEnabled(from.getHoverSelectionEnabled());<a name="line.8817"></a>
<FONT color="green">8818</FONT>          setHovertextTemplate(from.getHovertextTemplate());<a name="line.8818"></a>
<FONT color="green">8819</FONT>          setHoverWidget(from.getHoverWidget());<a name="line.8819"></a>
<FONT color="green">8820</FONT>          setHoverXShift(from.getHoverXShift());<a name="line.8820"></a>
<FONT color="green">8821</FONT>          setHoverYShift(from.getHoverYShift());<a name="line.8821"></a>
<FONT color="green">8822</FONT>          setImageURL(from.getImageURL());<a name="line.8822"></a>
<FONT color="green">8823</FONT>          // Model and pixel variants of width/height actually<a name="line.8823"></a>
<FONT color="green">8824</FONT>          // represent a single underlying property (setting one,<a name="line.8824"></a>
<FONT color="green">8825</FONT>          // unsets the other, etc.). Logic below reflects this.<a name="line.8825"></a>
<FONT color="green">8826</FONT>          if (!Double.isNaN(from.getModelHeight()))<a name="line.8826"></a>
<FONT color="green">8827</FONT>            setModelHeight(from.getModelHeight());<a name="line.8827"></a>
<FONT color="green">8828</FONT>          else<a name="line.8828"></a>
<FONT color="green">8829</FONT>            setHeight(from.getHeight());<a name="line.8829"></a>
<FONT color="green">8830</FONT>          if (!Double.isNaN(from.getModelWidth()))<a name="line.8830"></a>
<FONT color="green">8831</FONT>            setModelWidth(from.getModelWidth());<a name="line.8831"></a>
<FONT color="green">8832</FONT>          else<a name="line.8832"></a>
<FONT color="green">8833</FONT>            setWidth(from.getWidth());<a name="line.8833"></a>
<FONT color="green">8834</FONT>    <a name="line.8834"></a>
<FONT color="green">8835</FONT>          setPieSliceOrientation(from.getPieSliceOrientation());<a name="line.8835"></a>
<FONT color="green">8836</FONT>          setDefaultPieSliceOrientation(from.getDefaultPieSliceOrientation());<a name="line.8836"></a>
<FONT color="green">8837</FONT>          setPieSliceSize(from.getPieSliceSize());<a name="line.8837"></a>
<FONT color="green">8838</FONT>          setSymbolType(from.getSymbolType());<a name="line.8838"></a>
<FONT color="green">8839</FONT>    <a name="line.8839"></a>
<FONT color="green">8840</FONT>        }<a name="line.8840"></a>
<FONT color="green">8841</FONT>    <a name="line.8841"></a>
<FONT color="green">8842</FONT>        // Pixel height of symbol when rendered on given plot panel<a name="line.8842"></a>
<FONT color="green">8843</FONT>        double getHeight(PlotPanel pp, boolean onY2) {<a name="line.8843"></a>
<FONT color="green">8844</FONT>          double result;<a name="line.8844"></a>
<FONT color="green">8845</FONT>          double mH = getModelHeight();<a name="line.8845"></a>
<FONT color="green">8846</FONT>          if ((mH != mH)) // x!=x is a faster isNaN<a name="line.8846"></a>
<FONT color="green">8847</FONT>            result = getHeight();<a name="line.8847"></a>
<FONT color="green">8848</FONT>          else<a name="line.8848"></a>
<FONT color="green">8849</FONT>            result = pp.dyToPixel(mH, onY2);<a name="line.8849"></a>
<FONT color="green">8850</FONT>    <a name="line.8850"></a>
<FONT color="green">8851</FONT>          return result;<a name="line.8851"></a>
<FONT color="green">8852</FONT>        }<a name="line.8852"></a>
<FONT color="green">8853</FONT>    <a name="line.8853"></a>
<FONT color="green">8854</FONT>        // Pixel width of symbol when rendered on given plot panel<a name="line.8854"></a>
<FONT color="green">8855</FONT>        double getWidth(PlotPanel pp) {<a name="line.8855"></a>
<FONT color="green">8856</FONT>          double result;<a name="line.8856"></a>
<FONT color="green">8857</FONT>          double mW = getModelWidth();<a name="line.8857"></a>
<FONT color="green">8858</FONT>          if ((mW != mW)) // x!=x is a faster isNaN<a name="line.8858"></a>
<FONT color="green">8859</FONT>            result = getWidth();<a name="line.8859"></a>
<FONT color="green">8860</FONT>          else<a name="line.8860"></a>
<FONT color="green">8861</FONT>            result = pp.dxToPixel(mW);<a name="line.8861"></a>
<FONT color="green">8862</FONT>    <a name="line.8862"></a>
<FONT color="green">8863</FONT>          return result;<a name="line.8863"></a>
<FONT color="green">8864</FONT>        }<a name="line.8864"></a>
<FONT color="green">8865</FONT>    <a name="line.8865"></a>
<FONT color="green">8866</FONT>    //    void realizeSymbol(PlotPanel pp, GraphicsRenderingPanel grp,<a name="line.8866"></a>
<FONT color="green">8867</FONT>    //        AnnotationRenderingPanel arp, Annotation annotation,<a name="line.8867"></a>
<FONT color="green">8868</FONT>    //        boolean onY2, boolean clipPlotArea, boolean clipDecoratedChart,<a name="line.8868"></a>
<FONT color="green">8869</FONT>    //        double rpf, boolean drawMainSymbol, double x, double y,<a name="line.8869"></a>
<FONT color="green">8870</FONT>    //        double prevX, double prevY, double nextX, double nextY) {<a name="line.8870"></a>
<FONT color="green">8871</FONT>    //      getSymbolType().realizeSymbol(pp, grp, arp, this, annotation, onY2,<a name="line.8871"></a>
<FONT color="green">8872</FONT>    //          clipPlotArea, clipDecoratedChart, rpf, drawMainSymbol, x,<a name="line.8872"></a>
<FONT color="green">8873</FONT>    //          y, prevX, prevY, nextX, nextY);<a name="line.8873"></a>
<FONT color="green">8874</FONT>    //<a name="line.8874"></a>
<FONT color="green">8875</FONT>    //    }<a name="line.8875"></a>
<FONT color="green">8876</FONT>    <a name="line.8876"></a>
<FONT color="green">8877</FONT>      } // end of class Symbol<a name="line.8877"></a>
<FONT color="green">8878</FONT>    <a name="line.8878"></a>
<FONT color="green">8879</FONT>      private static double lastPieSliceOrientation;<a name="line.8879"></a>
<FONT color="green">8880</FONT>    <a name="line.8880"></a>
<FONT color="green">8881</FONT>      static double getLastPieSliceOrientation() {<a name="line.8881"></a>
<FONT color="green">8882</FONT>        return lastPieSliceOrientation;<a name="line.8882"></a>
<FONT color="green">8883</FONT>      }<a name="line.8883"></a>
<FONT color="green">8884</FONT>    <a name="line.8884"></a>
<FONT color="green">8885</FONT>      static void setLastPieSliceOrientation(double lastOrientation) {<a name="line.8885"></a>
<FONT color="green">8886</FONT>        lastPieSliceOrientation = lastOrientation % 1.0;<a name="line.8886"></a>
<FONT color="green">8887</FONT>      }<a name="line.8887"></a>
<FONT color="green">8888</FONT>    <a name="line.8888"></a>
<FONT color="green">8889</FONT>    <a name="line.8889"></a>
<FONT color="green">8890</FONT>      /**<a name="line.8890"></a>
<FONT color="green">8891</FONT>       * Specifies the type of symbol used by a curve. GChart includes a<a name="line.8891"></a>
<FONT color="green">8892</FONT>       * &lt;tt&gt;LINE&lt;/tt&gt; symbol type (suitable for solidly connected line charts),<a name="line.8892"></a>
<FONT color="green">8893</FONT>       * various "box" symbol types (suitable for scatter and dotted-line charts),<a name="line.8893"></a>
<FONT color="green">8894</FONT>       * horizontal and vertical bars that extend to axis limits or a specified<a name="line.8894"></a>
<FONT color="green">8895</FONT>       * baseline (suitable for bar and area charts), and pie slices (suitable for<a name="line.8895"></a>
<FONT color="green">8896</FONT>       * pie charts) in these symbol types. Thus, choosing a curve's symbol type has<a name="line.8896"></a>
<FONT color="green">8897</FONT>       * a bigger impact on the kind of chart you create than in other charting APIs<a name="line.8897"></a>
<FONT color="green">8898</FONT>       * you may have used.<a name="line.8898"></a>
<FONT color="green">8899</FONT>       * &lt;p&gt;<a name="line.8899"></a>
<FONT color="green">8900</FONT>       * <a name="line.8900"></a>
<FONT color="green">8901</FONT>       * One advantage of this symbol type based approach: you can place multiple<a name="line.8901"></a>
<FONT color="green">8902</FONT>       * pies, lines and/or bars on a single chart simply by creating multiple<a name="line.8902"></a>
<FONT color="green">8903</FONT>       * curves whose associated symbols have appropriately different symbol types.<a name="line.8903"></a>
<FONT color="green">8904</FONT>       * &lt;p&gt;<a name="line.8904"></a>
<FONT color="green">8905</FONT>       * <a name="line.8905"></a>
<FONT color="green">8906</FONT>       * Note that, for line, area, or pie charts, the exact look of the<a name="line.8906"></a>
<FONT color="green">8907</FONT>       * non-rectangular aspects (connecting lines, filled-in areas, etc.) of these<a name="line.8907"></a>
<FONT color="green">8908</FONT>       * symbols in the chart is largely governed by the host &lt;tt&gt;Symbol&lt;/tt&gt;'s<a name="line.8908"></a>
<FONT color="green">8909</FONT>       * &lt;tt&gt;fillSpacing&lt;/tt&gt; and &lt;tt&gt;fillThickness&lt;/tt&gt; properties.<a name="line.8909"></a>
<FONT color="green">8910</FONT>       * &lt;p&gt;<a name="line.8910"></a>
<FONT color="green">8911</FONT>       * <a name="line.8911"></a>
<FONT color="green">8912</FONT>       * For instance, with the default &lt;tt&gt;fillThickness&lt;/tt&gt; of 0 for the<a name="line.8912"></a>
<FONT color="green">8913</FONT>       * &lt;tt&gt;BOX_CENTER&lt;/tt&gt; symbol, curves display only explicitly specified data<a name="line.8913"></a>
<FONT color="green">8914</FONT>       * points, without any connecting lines between them. But, if you set<a name="line.8914"></a>
<FONT color="green">8915</FONT>       * &lt;tt&gt;fillThickness&lt;/tt&gt; to 1, GChart interpolates a series of 1 pixel by 1<a name="line.8915"></a>
<FONT color="green">8916</FONT>       * pixel rectangular "dots" between successive data points, with an intra-dot<a name="line.8916"></a>
<FONT color="green">8917</FONT>       * spacing defined by the symbol's &lt;tt&gt;fillSpacing&lt;/tt&gt; setting.<a name="line.8917"></a>
<FONT color="green">8918</FONT>       * &lt;p&gt;<a name="line.8918"></a>
<FONT color="green">8919</FONT>       * <a name="line.8919"></a>
<FONT color="green">8920</FONT>       * Since v2.5, a new &lt;tt&gt;fillSpacing==0&lt;/tt&gt; setting, with the special meaning<a name="line.8920"></a>
<FONT color="green">8921</FONT>       * of "continuous filling", is allowed. If an external canvas library has been<a name="line.8921"></a>
<FONT color="green">8922</FONT>       * plugged into GChart via &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, higher quality,<a name="line.8922"></a>
<FONT color="green">8923</FONT>       * continuously filled pie, line, and area charts can be produced via the<a name="line.8923"></a>
<FONT color="green">8924</FONT>       * combination: &lt;tt&gt;fillSpacing==0&lt;/tt&gt; and &lt;tt&gt;fillThickness &amp;gt; 0&lt;/tt&gt; along<a name="line.8924"></a>
<FONT color="green">8925</FONT>       * with one of the pie, line, or bar symbol types described below.<a name="line.8925"></a>
<FONT color="green">8926</FONT>       * &lt;p&gt;<a name="line.8926"></a>
<FONT color="green">8927</FONT>       * <a name="line.8927"></a>
<FONT color="green">8928</FONT>       * You must select each curve's symbol type from the predefined set of<a name="line.8928"></a>
<FONT color="green">8929</FONT>       * supported types listed in the "Field Summary" section below. The default<a name="line.8929"></a>
<FONT color="green">8930</FONT>       * symbol type is &lt;tt&gt;BOX_CENTER&lt;/tt&gt;.<a name="line.8930"></a>
<FONT color="green">8931</FONT>       * <a name="line.8931"></a>
<FONT color="green">8932</FONT>       * @see Curve#getSymbol getSymbol<a name="line.8932"></a>
<FONT color="green">8933</FONT>       * @see Symbol#setSymbolType setSymbolType<a name="line.8933"></a>
<FONT color="green">8934</FONT>       * @see Symbol#setFillSpacing setFillSpacing<a name="line.8934"></a>
<FONT color="green">8935</FONT>       * @see Symbol#setFillThickness setFillThickness<a name="line.8935"></a>
<FONT color="green">8936</FONT>       * @see Symbol Symbol<a name="line.8936"></a>
<FONT color="green">8937</FONT>       * <a name="line.8937"></a>
<FONT color="green">8938</FONT>       */<a name="line.8938"></a>
<FONT color="green">8939</FONT>      public static class SymbolType {<a name="line.8939"></a>
<FONT color="green">8940</FONT>    <a name="line.8940"></a>
<FONT color="green">8941</FONT>        /*<a name="line.8941"></a>
<FONT color="green">8942</FONT>         * For efficiency during hit testing, points get separated into bins<a name="line.8942"></a>
<FONT color="green">8943</FONT>         * associated with adjacent vertical (or horizontal) bands that cover the<a name="line.8943"></a>
<FONT color="green">8944</FONT>         * plot area. &lt;p&gt;<a name="line.8944"></a>
<FONT color="green">8945</FONT>         * <a name="line.8945"></a>
<FONT color="green">8946</FONT>         * Subclasses (such as those for producing horizontal bar charts) whose<a name="line.8946"></a>
<FONT color="green">8947</FONT>         * rendered symbols do not have a fixed width across all the points on a<a name="line.8947"></a>
<FONT color="green">8948</FONT>         * single curve, MUST set this field to true within their constructors,<a name="line.8948"></a>
<FONT color="green">8949</FONT>         * because the hit testing approach assumes fixed "thickness" symbols for<a name="line.8949"></a>
<FONT color="green">8950</FONT>         * simplicity/efficiency. &lt;p&gt;<a name="line.8950"></a>
<FONT color="green">8951</FONT>         * <a name="line.8951"></a>
<FONT color="green">8952</FONT>         * Subclasses that have both a fixed width and height MAY set this to true<a name="line.8952"></a>
<FONT color="green">8953</FONT>         * if they are typically used in a way that tends to make horizontal banding<a name="line.8953"></a>
<FONT color="green">8954</FONT>         * a better (= tends to place same # of points in each band) binning<a name="line.8954"></a>
<FONT color="green">8955</FONT>         * strategy.<a name="line.8955"></a>
<FONT color="green">8956</FONT>         * &lt;p&gt;<a name="line.8956"></a>
<FONT color="green">8957</FONT>         * <a name="line.8957"></a>
<FONT color="green">8958</FONT>         * If &lt;tt&gt;null&lt;/tt&gt;, GChart uses a simple heuristic that assumes<a name="line.8958"></a>
<FONT color="green">8959</FONT>         * that a brush that is wider than high implies that the developer<a name="line.8959"></a>
<FONT color="green">8960</FONT>         * is trying to let the user distinguish finer y differences, and thus<a name="line.8960"></a>
<FONT color="green">8961</FONT>         * our bands should separate points more finely (and hence allow for<a name="line.8961"></a>
<FONT color="green">8962</FONT>         * faster band-indexed hit testing) if we use horizontal banding in<a name="line.8962"></a>
<FONT color="green">8963</FONT>         * this case (and vertical otherwise). &lt;p&gt;<a name="line.8963"></a>
<FONT color="green">8964</FONT>         * <a name="line.8964"></a>
<FONT color="green">8965</FONT>         * See the &lt;tt&gt;bandSeparatePoints&lt;/tt&gt; method for more info.<a name="line.8965"></a>
<FONT color="green">8966</FONT>         */<a name="line.8966"></a>
<FONT color="green">8967</FONT>        Boolean isHorizontallyBanded = null;<a name="line.8967"></a>
<FONT color="green">8968</FONT>        /*<a name="line.8968"></a>
<FONT color="green">8969</FONT>         * Use smallest min band size, since I expect per band<a name="line.8969"></a>
<FONT color="green">8970</FONT>         * cost to be small compared to per-point hit testing.<a name="line.8970"></a>
<FONT color="green">8971</FONT>         * <a name="line.8971"></a>
<FONT color="green">8972</FONT>         */ <a name="line.8972"></a>
<FONT color="green">8973</FONT>        protected final int MIN_BAND_SIZE = 1;  // in pixels<a name="line.8973"></a>
<FONT color="green">8974</FONT>    <a name="line.8974"></a>
<FONT color="green">8975</FONT>        /*<a name="line.8975"></a>
<FONT color="green">8976</FONT>         * Thickness (in pixels) of hit-test-bands used with this symbol type. &lt;p&gt;<a name="line.8976"></a>
<FONT color="green">8977</FONT>         * <a name="line.8977"></a>
<FONT color="green">8978</FONT>         * Gets overriden for pie slice symbol types, which base thickness on pie<a name="line.8978"></a>
<FONT color="green">8979</FONT>         * diameter.<a name="line.8979"></a>
<FONT color="green">8980</FONT>         */<a name="line.8980"></a>
<FONT color="green">8981</FONT>        protected double getBandThickness(PlotPanel pp, Symbol sym, boolean onY2) {<a name="line.8981"></a>
<FONT color="green">8982</FONT>          double result;<a name="line.8982"></a>
<FONT color="green">8983</FONT>          if (sym.isHorizontallyBanded())<a name="line.8983"></a>
<FONT color="green">8984</FONT>            result = Math.max(MIN_BAND_SIZE, sym.getHeight(pp, onY2));<a name="line.8984"></a>
<FONT color="green">8985</FONT>          else<a name="line.8985"></a>
<FONT color="green">8986</FONT>            result = Math.max(MIN_BAND_SIZE, sym.getWidth(pp));<a name="line.8986"></a>
<FONT color="green">8987</FONT>          return result;<a name="line.8987"></a>
<FONT color="green">8988</FONT>        }<a name="line.8988"></a>
<FONT color="green">8989</FONT>    <a name="line.8989"></a>
<FONT color="green">8990</FONT>        // is overridden by pie slices, which use a different brush shape<a name="line.8990"></a>
<FONT color="green">8991</FONT>        protected int getBrushHeight(Symbol sym) {<a name="line.8991"></a>
<FONT color="green">8992</FONT>          int result = sym.getBrushHeight();<a name="line.8992"></a>
<FONT color="green">8993</FONT>          return result;<a name="line.8993"></a>
<FONT color="green">8994</FONT>        }<a name="line.8994"></a>
<FONT color="green">8995</FONT>    <a name="line.8995"></a>
<FONT color="green">8996</FONT>        // again, pie slices will override<a name="line.8996"></a>
<FONT color="green">8997</FONT>        protected AnnotationLocation getBrushLocation(Symbol sym) {<a name="line.8997"></a>
<FONT color="green">8998</FONT>          AnnotationLocation result = sym.getBrushLocation();<a name="line.8998"></a>
<FONT color="green">8999</FONT>          return result;<a name="line.8999"></a>
<FONT color="green">9000</FONT>        }<a name="line.9000"></a>
<FONT color="green">9001</FONT>    <a name="line.9001"></a>
<FONT color="green">9002</FONT>        // is overridden by pie slices, which use a different brush shape<a name="line.9002"></a>
<FONT color="green">9003</FONT>        protected int getBrushWidth(Symbol sym) {<a name="line.9003"></a>
<FONT color="green">9004</FONT>          int result = sym.getBrushWidth();<a name="line.9004"></a>
<FONT color="green">9005</FONT>          return result;<a name="line.9005"></a>
<FONT color="green">9006</FONT>        }<a name="line.9006"></a>
<FONT color="green">9007</FONT>    <a name="line.9007"></a>
<FONT color="green">9008</FONT>        /*<a name="line.9008"></a>
<FONT color="green">9009</FONT>         * This symbol type provides a convenient anchor point at one of the<a name="line.9009"></a>
<FONT color="green">9010</FONT>         * standard 9 named positions within the plot area. The actual x,y of the<a name="line.9010"></a>
<FONT color="green">9011</FONT>         * points using this symbol type is ignored. Useful for placing annotations<a name="line.9011"></a>
<FONT color="green">9012</FONT>         * around and along the perimeter of, or centered on, the plot panel.&lt;p&gt;<a name="line.9012"></a>
<FONT color="green">9013</FONT>         * <a name="line.9013"></a>
<FONT color="green">9014</FONT>         * For example, chart decorations such as axis labels and footnotes<a name="line.9014"></a>
<FONT color="green">9015</FONT>         * internally use symbols of this type (with appropriate setAnnotationXShift<a name="line.9015"></a>
<FONT color="green">9016</FONT>         * or setAnnotationYShift adjustments to position the decoration<a name="line.9016"></a>
<FONT color="green">9017</FONT>         * appropriately relative to the anchor point). End-users can use a curve<a name="line.9017"></a>
<FONT color="green">9018</FONT>         * with this symbol type, along with a single point and appropriate<a name="line.9018"></a>
<FONT color="green">9019</FONT>         * widget-based annotation, to place a table in the upper left corner of the<a name="line.9019"></a>
<FONT color="green">9020</FONT>         * plot area, etc.<a name="line.9020"></a>
<FONT color="green">9021</FONT>         */<a name="line.9021"></a>
<FONT color="green">9022</FONT>    <a name="line.9022"></a>
<FONT color="green">9023</FONT>        private static class AnnotationAnchor extends SymbolType {<a name="line.9023"></a>
<FONT color="green">9024</FONT>          AnnotationLocation location;<a name="line.9024"></a>
<FONT color="green">9025</FONT>    <a name="line.9025"></a>
<FONT color="green">9026</FONT>          AnnotationAnchor(AnnotationLocation location) {<a name="line.9026"></a>
<FONT color="green">9027</FONT>            super(0, 0, 0, 0, 0, 0);<a name="line.9027"></a>
<FONT color="green">9028</FONT>            this.location = location;<a name="line.9028"></a>
<FONT color="green">9029</FONT>          }<a name="line.9029"></a>
<FONT color="green">9030</FONT>    <a name="line.9030"></a>
<FONT color="green">9031</FONT>          /*<a name="line.9031"></a>
<FONT color="green">9032</FONT>           * Actual curve symbol zero-sized so it does not<a name="line.9032"></a>
<FONT color="green">9033</FONT>           * appear--it's just for positioning the annotation.<a name="line.9033"></a>
<FONT color="green">9034</FONT>           *<a name="line.9034"></a>
<FONT color="green">9035</FONT>           */ <a name="line.9035"></a>
<FONT color="green">9036</FONT>          public double getAdjustedWidth(double width, double x,<a name="line.9036"></a>
<FONT color="green">9037</FONT>              double xPrev, double xNext, double xMin, double xMax,<a name="line.9037"></a>
<FONT color="green">9038</FONT>              double xMid) {<a name="line.9038"></a>
<FONT color="green">9039</FONT>            return 0;<a name="line.9039"></a>
<FONT color="green">9040</FONT>          }<a name="line.9040"></a>
<FONT color="green">9041</FONT>    <a name="line.9041"></a>
<FONT color="green">9042</FONT>          public double getAdjustedHeight(double height, double y,<a name="line.9042"></a>
<FONT color="green">9043</FONT>              double yPrev, double yNext, double yMin, double yMax,<a name="line.9043"></a>
<FONT color="green">9044</FONT>              double yMid) {<a name="line.9044"></a>
<FONT color="green">9045</FONT>            return 0;<a name="line.9045"></a>
<FONT color="green">9046</FONT>          }<a name="line.9046"></a>
<FONT color="green">9047</FONT>    <a name="line.9047"></a>
<FONT color="green">9048</FONT>          /*<a name="line.9048"></a>
<FONT color="green">9049</FONT>           * Just return one of the standard 9 positions, or the mouse<a name="line.9049"></a>
<FONT color="green">9050</FONT>           * coordinates, based on the location defined in the<a name="line.9050"></a>
<FONT color="green">9051</FONT>           * constructor.<a name="line.9051"></a>
<FONT color="green">9052</FONT>           * <a name="line.9052"></a>
<FONT color="green">9053</FONT>           */ <a name="line.9053"></a>
<FONT color="green">9054</FONT>          double getUpperLeftX(double width, double x, double xPrev,<a name="line.9054"></a>
<FONT color="green">9055</FONT>              double xNext, double xMin, double xMax, double xMid,<a name="line.9055"></a>
<FONT color="green">9056</FONT>              int xMouse) {<a name="line.9056"></a>
<FONT color="green">9057</FONT>            double result;<a name="line.9057"></a>
<FONT color="green">9058</FONT>            if (AnnotationLocation.AT_THE_MOUSE == location)<a name="line.9058"></a>
<FONT color="green">9059</FONT>              result = (GChart.NAI == xMouse) ? Double.NaN : xMouse;<a name="line.9059"></a>
<FONT color="green">9060</FONT>            else if (AnnotationLocation.AT_THE_MOUSE_SNAP_TO_X == location)<a name="line.9060"></a>
<FONT color="green">9061</FONT>              result = (GChart.NAI == xMouse) ? Double.NaN : x;<a name="line.9061"></a>
<FONT color="green">9062</FONT>            else if (AnnotationLocation.AT_THE_MOUSE_SNAP_TO_Y == location)<a name="line.9062"></a>
<FONT color="green">9063</FONT>              result = (GChart.NAI == xMouse) ? Double.NaN : xMouse;<a name="line.9063"></a>
<FONT color="green">9064</FONT>            else if (AnnotationLocation.NORTHWEST == location<a name="line.9064"></a>
<FONT color="green">9065</FONT>                || AnnotationLocation.WEST == location<a name="line.9065"></a>
<FONT color="green">9066</FONT>                || AnnotationLocation.SOUTHWEST == location)<a name="line.9066"></a>
<FONT color="green">9067</FONT>              result = xMin;<a name="line.9067"></a>
<FONT color="green">9068</FONT>            else if (AnnotationLocation.NORTHEAST == location<a name="line.9068"></a>
<FONT color="green">9069</FONT>                || AnnotationLocation.EAST == location<a name="line.9069"></a>
<FONT color="green">9070</FONT>                || AnnotationLocation.SOUTHEAST == location)<a name="line.9070"></a>
<FONT color="green">9071</FONT>              result = xMax;<a name="line.9071"></a>
<FONT color="green">9072</FONT>            else<a name="line.9072"></a>
<FONT color="green">9073</FONT>              // NORTH, CENTER, or SOUTH<a name="line.9073"></a>
<FONT color="green">9074</FONT>              result = (xMin + xMax) / 2;<a name="line.9074"></a>
<FONT color="green">9075</FONT>    <a name="line.9075"></a>
<FONT color="green">9076</FONT>            return result;<a name="line.9076"></a>
<FONT color="green">9077</FONT>    <a name="line.9077"></a>
<FONT color="green">9078</FONT>          }<a name="line.9078"></a>
<FONT color="green">9079</FONT>    <a name="line.9079"></a>
<FONT color="green">9080</FONT>          double getUpperLeftY(double height, double y, double yPrev,<a name="line.9080"></a>
<FONT color="green">9081</FONT>              double yNext, double yMin, double yMax, double yMid,<a name="line.9081"></a>
<FONT color="green">9082</FONT>              int yMouse) {<a name="line.9082"></a>
<FONT color="green">9083</FONT>            double result;<a name="line.9083"></a>
<FONT color="green">9084</FONT>            if (AnnotationLocation.AT_THE_MOUSE == location)<a name="line.9084"></a>
<FONT color="green">9085</FONT>              result = (GChart.NAI == yMouse) ? Double.NaN : yMouse;<a name="line.9085"></a>
<FONT color="green">9086</FONT>            else if (AnnotationLocation.AT_THE_MOUSE_SNAP_TO_X == location)<a name="line.9086"></a>
<FONT color="green">9087</FONT>              result = (GChart.NAI == yMouse) ? Double.NaN : yMouse;<a name="line.9087"></a>
<FONT color="green">9088</FONT>            else if (AnnotationLocation.AT_THE_MOUSE_SNAP_TO_Y == location)<a name="line.9088"></a>
<FONT color="green">9089</FONT>              result = (GChart.NAI == yMouse) ? Double.NaN : y;<a name="line.9089"></a>
<FONT color="green">9090</FONT>            else if (AnnotationLocation.NORTHWEST == location<a name="line.9090"></a>
<FONT color="green">9091</FONT>                || AnnotationLocation.NORTH == location<a name="line.9091"></a>
<FONT color="green">9092</FONT>                || AnnotationLocation.NORTHEAST == location)<a name="line.9092"></a>
<FONT color="green">9093</FONT>              result = yMin;<a name="line.9093"></a>
<FONT color="green">9094</FONT>            else if (AnnotationLocation.SOUTHWEST == location<a name="line.9094"></a>
<FONT color="green">9095</FONT>                || AnnotationLocation.SOUTH == location<a name="line.9095"></a>
<FONT color="green">9096</FONT>                || AnnotationLocation.SOUTHEAST == location)<a name="line.9096"></a>
<FONT color="green">9097</FONT>              result = yMax;<a name="line.9097"></a>
<FONT color="green">9098</FONT>            else<a name="line.9098"></a>
<FONT color="green">9099</FONT>              // WEST, CENTER, or EAST<a name="line.9099"></a>
<FONT color="green">9100</FONT>              result = (yMin + yMax) / 2;<a name="line.9100"></a>
<FONT color="green">9101</FONT>            return result;<a name="line.9101"></a>
<FONT color="green">9102</FONT>          }<a name="line.9102"></a>
<FONT color="green">9103</FONT>        }<a name="line.9103"></a>
<FONT color="green">9104</FONT>    <a name="line.9104"></a>
<FONT color="green">9105</FONT>        // horizontal baseline-based bars<a name="line.9105"></a>
<FONT color="green">9106</FONT>        private static class HBarBaseline extends SymbolType {<a name="line.9106"></a>
<FONT color="green">9107</FONT>          HBarBaseline(int wm, int hm) {<a name="line.9107"></a>
<FONT color="green">9108</FONT>            super(wm, hm, 0.5, 0.5, 0, 0, Boolean.TRUE);<a name="line.9108"></a>
<FONT color="green">9109</FONT>          }<a name="line.9109"></a>
<FONT color="green">9110</FONT>    <a name="line.9110"></a>
<FONT color="green">9111</FONT>          @Override<a name="line.9111"></a>
<FONT color="green">9112</FONT>          protected double defaultFillSpacing() {<a name="line.9112"></a>
<FONT color="green">9113</FONT>            return DEFAULT_BAR_FILL_SPACING;<a name="line.9113"></a>
<FONT color="green">9114</FONT>          }<a name="line.9114"></a>
<FONT color="green">9115</FONT>    <a name="line.9115"></a>
<FONT color="green">9116</FONT>          @Override<a name="line.9116"></a>
<FONT color="green">9117</FONT>          protected AnnotationLocation defaultHoverLocation() {<a name="line.9117"></a>
<FONT color="green">9118</FONT>            return DEFAULT_HBAR_BASELINE_HOVER_LOCATION;<a name="line.9118"></a>
<FONT color="green">9119</FONT>          }<a name="line.9119"></a>
<FONT color="green">9120</FONT>    <a name="line.9120"></a>
<FONT color="green">9121</FONT>          @Override<a name="line.9121"></a>
<FONT color="green">9122</FONT>          public double getAdjustedWidth(double width, double x,<a name="line.9122"></a>
<FONT color="green">9123</FONT>              double xPrev, double xNext, double xMin, double xMax,<a name="line.9123"></a>
<FONT color="green">9124</FONT>              double xMid) {<a name="line.9124"></a>
<FONT color="green">9125</FONT>            return x - xMid;<a name="line.9125"></a>
<FONT color="green">9126</FONT>          }<a name="line.9126"></a>
<FONT color="green">9127</FONT>    <a name="line.9127"></a>
<FONT color="green">9128</FONT>          @Override<a name="line.9128"></a>
<FONT color="green">9129</FONT>          double getUpperLeftX(double width, double x, double xPrev,<a name="line.9129"></a>
<FONT color="green">9130</FONT>              double xNext, double xMin, double xMax, double xMid,<a name="line.9130"></a>
<FONT color="green">9131</FONT>              int xMouse) {<a name="line.9131"></a>
<FONT color="green">9132</FONT>            return xMid;<a name="line.9132"></a>
<FONT color="green">9133</FONT>          }<a name="line.9133"></a>
<FONT color="green">9134</FONT>    <a name="line.9134"></a>
<FONT color="green">9135</FONT>          @Override<a name="line.9135"></a>
<FONT color="green">9136</FONT>          int getIconHeight(int legendFontSize) {<a name="line.9136"></a>
<FONT color="green">9137</FONT>            return (int) Math.round(legendFontSize / 2.);<a name="line.9137"></a>
<FONT color="green">9138</FONT>          }<a name="line.9138"></a>
<FONT color="green">9139</FONT>    <a name="line.9139"></a>
<FONT color="green">9140</FONT>          @Override<a name="line.9140"></a>
<FONT color="green">9141</FONT>          int getIconWidth(int legendFontSize) {<a name="line.9141"></a>
<FONT color="green">9142</FONT>            return legendFontSize;<a name="line.9142"></a>
<FONT color="green">9143</FONT>          }<a name="line.9143"></a>
<FONT color="green">9144</FONT>    <a name="line.9144"></a>
<FONT color="green">9145</FONT>        } // end of class HBarBaseline<a name="line.9145"></a>
<FONT color="green">9146</FONT>    <a name="line.9146"></a>
<FONT color="green">9147</FONT>        private static class HBarLeft extends SymbolType {<a name="line.9147"></a>
<FONT color="green">9148</FONT>          HBarLeft(int wm, int hm) {<a name="line.9148"></a>
<FONT color="green">9149</FONT>            super(wm, hm, 0.5, 0.5, 0.5, 0.5, Boolean.TRUE);<a name="line.9149"></a>
<FONT color="green">9150</FONT>          }<a name="line.9150"></a>
<FONT color="green">9151</FONT>    <a name="line.9151"></a>
<FONT color="green">9152</FONT>          @Override<a name="line.9152"></a>
<FONT color="green">9153</FONT>          protected double defaultFillSpacing() {<a name="line.9153"></a>
<FONT color="green">9154</FONT>            return DEFAULT_BAR_FILL_SPACING;<a name="line.9154"></a>
<FONT color="green">9155</FONT>          }<a name="line.9155"></a>
<FONT color="green">9156</FONT>    <a name="line.9156"></a>
<FONT color="green">9157</FONT>          @Override<a name="line.9157"></a>
<FONT color="green">9158</FONT>          protected AnnotationLocation defaultHoverLocation() {<a name="line.9158"></a>
<FONT color="green">9159</FONT>            return DEFAULT_HBARLEFT_HOVER_LOCATION;<a name="line.9159"></a>
<FONT color="green">9160</FONT>          }<a name="line.9160"></a>
<FONT color="green">9161</FONT>    <a name="line.9161"></a>
<FONT color="green">9162</FONT>          @Override<a name="line.9162"></a>
<FONT color="green">9163</FONT>          public double getAdjustedWidth(double width, double x,<a name="line.9163"></a>
<FONT color="green">9164</FONT>              double xPrev, double xNext, double xMin, double xMax,<a name="line.9164"></a>
<FONT color="green">9165</FONT>              double xMid) {<a name="line.9165"></a>
<FONT color="green">9166</FONT>            return x - xMin;<a name="line.9166"></a>
<FONT color="green">9167</FONT>          }<a name="line.9167"></a>
<FONT color="green">9168</FONT>    <a name="line.9168"></a>
<FONT color="green">9169</FONT>          @Override<a name="line.9169"></a>
<FONT color="green">9170</FONT>          int getIconHeight(int legendFontSize) {<a name="line.9170"></a>
<FONT color="green">9171</FONT>            return (int) Math.round(legendFontSize / 2.);<a name="line.9171"></a>
<FONT color="green">9172</FONT>          }<a name="line.9172"></a>
<FONT color="green">9173</FONT>    <a name="line.9173"></a>
<FONT color="green">9174</FONT>          @Override<a name="line.9174"></a>
<FONT color="green">9175</FONT>          int getIconWidth(int legendFontSize) {<a name="line.9175"></a>
<FONT color="green">9176</FONT>            return legendFontSize;<a name="line.9176"></a>
<FONT color="green">9177</FONT>          }<a name="line.9177"></a>
<FONT color="green">9178</FONT>    <a name="line.9178"></a>
<FONT color="green">9179</FONT>        } // end of class HBarLeft<a name="line.9179"></a>
<FONT color="green">9180</FONT>    <a name="line.9180"></a>
<FONT color="green">9181</FONT>        private static class HBarRight extends SymbolType {<a name="line.9181"></a>
<FONT color="green">9182</FONT>          HBarRight(int wm, int hm) {<a name="line.9182"></a>
<FONT color="green">9183</FONT>            super(wm, hm, 0.5, 0.5, 0.5, 0.5, Boolean.TRUE);<a name="line.9183"></a>
<FONT color="green">9184</FONT>          }<a name="line.9184"></a>
<FONT color="green">9185</FONT>    <a name="line.9185"></a>
<FONT color="green">9186</FONT>          @Override<a name="line.9186"></a>
<FONT color="green">9187</FONT>          protected double defaultFillSpacing() {<a name="line.9187"></a>
<FONT color="green">9188</FONT>            return DEFAULT_BAR_FILL_SPACING;<a name="line.9188"></a>
<FONT color="green">9189</FONT>          }<a name="line.9189"></a>
<FONT color="green">9190</FONT>    <a name="line.9190"></a>
<FONT color="green">9191</FONT>          @Override<a name="line.9191"></a>
<FONT color="green">9192</FONT>          protected AnnotationLocation defaultHoverLocation() {<a name="line.9192"></a>
<FONT color="green">9193</FONT>            return DEFAULT_HBARRIGHT_HOVER_LOCATION;<a name="line.9193"></a>
<FONT color="green">9194</FONT>          }<a name="line.9194"></a>
<FONT color="green">9195</FONT>    <a name="line.9195"></a>
<FONT color="green">9196</FONT>          @Override<a name="line.9196"></a>
<FONT color="green">9197</FONT>          public double getAdjustedWidth(double width, double x,<a name="line.9197"></a>
<FONT color="green">9198</FONT>              double xPrev, double xNext, double xMin, double xMax,<a name="line.9198"></a>
<FONT color="green">9199</FONT>              double xMid) {<a name="line.9199"></a>
<FONT color="green">9200</FONT>            return xMax - x;<a name="line.9200"></a>
<FONT color="green">9201</FONT>          }<a name="line.9201"></a>
<FONT color="green">9202</FONT>    <a name="line.9202"></a>
<FONT color="green">9203</FONT>          @Override<a name="line.9203"></a>
<FONT color="green">9204</FONT>          int getIconHeight(int legendFontSize) {<a name="line.9204"></a>
<FONT color="green">9205</FONT>            return (int) Math.round(legendFontSize / 2.);<a name="line.9205"></a>
<FONT color="green">9206</FONT>          }<a name="line.9206"></a>
<FONT color="green">9207</FONT>    <a name="line.9207"></a>
<FONT color="green">9208</FONT>          @Override<a name="line.9208"></a>
<FONT color="green">9209</FONT>          int getIconWidth(int legendFontSize) {<a name="line.9209"></a>
<FONT color="green">9210</FONT>            return legendFontSize;<a name="line.9210"></a>
<FONT color="green">9211</FONT>          }<a name="line.9211"></a>
<FONT color="green">9212</FONT>        } // end of class HBarRight<a name="line.9212"></a>
<FONT color="green">9213</FONT>    <a name="line.9213"></a>
<FONT color="green">9214</FONT>        // draws a connected straight line between successive points<a name="line.9214"></a>
<FONT color="green">9215</FONT>        private static class LineSymbolType extends SymbolType {<a name="line.9215"></a>
<FONT color="green">9216</FONT>          LineSymbolType() {<a name="line.9216"></a>
<FONT color="green">9217</FONT>            /*<a name="line.9217"></a>
<FONT color="green">9218</FONT>             * Same constructor as BOX_CENTER, which centers line segments on the<a name="line.9218"></a>
<FONT color="green">9219</FONT>             * points that they represent, as required.<a name="line.9219"></a>
<FONT color="green">9220</FONT>             *<a name="line.9220"></a>
<FONT color="green">9221</FONT>             */ <a name="line.9221"></a>
<FONT color="green">9222</FONT>            super(0, 0, 0, 0, 0, 0);<a name="line.9222"></a>
<FONT color="green">9223</FONT>          }<a name="line.9223"></a>
<FONT color="green">9224</FONT>    <a name="line.9224"></a>
<FONT color="green">9225</FONT>          @Override<a name="line.9225"></a>
<FONT color="green">9226</FONT>          protected double defaultFillSpacing() {<a name="line.9226"></a>
<FONT color="green">9227</FONT>            return DEFAULT_LINE_FILL_SPACING;<a name="line.9227"></a>
<FONT color="green">9228</FONT>          }<a name="line.9228"></a>
<FONT color="green">9229</FONT>    <a name="line.9229"></a>
<FONT color="green">9230</FONT>          @Override<a name="line.9230"></a>
<FONT color="green">9231</FONT>          protected int defaultFillThickness() {<a name="line.9231"></a>
<FONT color="green">9232</FONT>            return DEFAULT_LINE_FILL_THICKNESS;<a name="line.9232"></a>
<FONT color="green">9233</FONT>          }<a name="line.9233"></a>
<FONT color="green">9234</FONT>    <a name="line.9234"></a>
<FONT color="green">9235</FONT>          @Override<a name="line.9235"></a>
<FONT color="green">9236</FONT>          int getIconHeight(int legendFontSize) {<a name="line.9236"></a>
<FONT color="green">9237</FONT>            return 3; // leaves room for a 1px border and a center<a name="line.9237"></a>
<FONT color="green">9238</FONT>          }<a name="line.9238"></a>
<FONT color="green">9239</FONT>    <a name="line.9239"></a>
<FONT color="green">9240</FONT>          @Override<a name="line.9240"></a>
<FONT color="green">9241</FONT>          int getIconWidth(int legendFontSize) {<a name="line.9241"></a>
<FONT color="green">9242</FONT>            return Math.max(3, legendFontSize);<a name="line.9242"></a>
<FONT color="green">9243</FONT>          }<a name="line.9243"></a>
<FONT color="green">9244</FONT>    <a name="line.9244"></a>
<FONT color="green">9245</FONT>          /*<a name="line.9245"></a>
<FONT color="green">9246</FONT>           * Draws an approximate line from x,y to nextX, nextY, using an<a name="line.9246"></a>
<FONT color="green">9247</FONT>           * appropriate series of vertical (for a &gt; 45 degree slope) or (for a &lt; 45<a name="line.9247"></a>
<FONT color="green">9248</FONT>           * degree slope) horizontal line segments. If a GWT canvas is available<a name="line.9248"></a>
<FONT color="green">9249</FONT>           * and if continuous fill (fillSpacing==0) was requested the<a name="line.9249"></a>
<FONT color="green">9250</FONT>           * lineTo,stroke,etc. of the canvas Widget are instead used to draw the<a name="line.9250"></a>
<FONT color="green">9251</FONT>           * line. &lt;p&gt;<a name="line.9251"></a>
<FONT color="green">9252</FONT>           * <a name="line.9252"></a>
<FONT color="green">9253</FONT>           * The canvas part of this code assumes/requires that points on a curve<a name="line.9253"></a>
<FONT color="green">9254</FONT>           * are rendered in the order that they appear on the point list (GChart<a name="line.9254"></a>
<FONT color="green">9255</FONT>           * will assure this), and that on the first point on the curve<a name="line.9255"></a>
<FONT color="green">9256</FONT>           * &lt;tt&gt;prevX&lt;/tt&gt; and &lt;tt&gt;prevY&lt;/tt&gt;, and on the last point &lt;tt&gt;nextX&lt;/tt&gt;<a name="line.9256"></a>
<FONT color="green">9257</FONT>           * and &lt;tt&gt;nextY&lt;/tt&gt;, are undefined (Double.NaN)<a name="line.9257"></a>
<FONT color="green">9258</FONT>           */<a name="line.9258"></a>
<FONT color="green">9259</FONT>    <a name="line.9259"></a>
<FONT color="green">9260</FONT>          @Override<a name="line.9260"></a>
<FONT color="green">9261</FONT>          void realizeSymbol(PlotPanel pp, GraphicsRenderingPanel grp,<a name="line.9261"></a>
<FONT color="green">9262</FONT>              AnnotationRenderingPanel arp, Symbol symbol,<a name="line.9262"></a>
<FONT color="green">9263</FONT>              Annotation annotation, boolean onY2, boolean clipPlotArea,<a name="line.9263"></a>
<FONT color="green">9264</FONT>              boolean clipDecoratedChart, double renderPaddingFactor,<a name="line.9264"></a>
<FONT color="green">9265</FONT>              boolean drawMainSymbol, double x, double y, double prevX,<a name="line.9265"></a>
<FONT color="green">9266</FONT>              double prevY, double nextX, double nextY) {<a name="line.9266"></a>
<FONT color="green">9267</FONT>    <a name="line.9267"></a>
<FONT color="green">9268</FONT>            if ((x != x) || (y != y)) // this point undefined (isNaN)<a name="line.9268"></a>
<FONT color="green">9269</FONT>              return;<a name="line.9269"></a>
<FONT color="green">9270</FONT>            // else point itself is at least defined<a name="line.9270"></a>
<FONT color="green">9271</FONT>    <a name="line.9271"></a>
<FONT color="green">9272</FONT>            double spacing = symbol.getFillSpacing();<a name="line.9272"></a>
<FONT color="green">9273</FONT>            int thickness = symbol.getFillThickness();<a name="line.9273"></a>
<FONT color="green">9274</FONT>            GChartCanvasLite canvas = grp.getCanvas();<a name="line.9274"></a>
<FONT color="green">9275</FONT>    <a name="line.9275"></a>
<FONT color="green">9276</FONT>            if (0 == spacing &amp;&amp; null != canvas &amp;&amp; thickness &gt; 0) {<a name="line.9276"></a>
<FONT color="green">9277</FONT>              // when canvas is available and continuous fill requested,<a name="line.9277"></a>
<FONT color="green">9278</FONT>              // BOX_CENTER and LINE work exactly the same way<a name="line.9278"></a>
<FONT color="green">9279</FONT>              BOX_CENTER.realizeSymbol(pp, grp, arp, symbol, annotation,<a name="line.9279"></a>
<FONT color="green">9280</FONT>                  onY2, clipPlotArea, clipDecoratedChart, renderPaddingFactor,<a name="line.9280"></a>
<FONT color="green">9281</FONT>                  drawMainSymbol, x, y, prevX, prevY, nextX, nextY);<a name="line.9281"></a>
<FONT color="green">9282</FONT>              return;<a name="line.9282"></a>
<FONT color="green">9283</FONT>            }<a name="line.9283"></a>
<FONT color="green">9284</FONT>            <a name="line.9284"></a>
<FONT color="green">9285</FONT>            double xPx = pp.xToPixel(x);<a name="line.9285"></a>
<FONT color="green">9286</FONT>            double yPx = pp.yToPixel(y, onY2);<a name="line.9286"></a>
<FONT color="green">9287</FONT>            double nextXPx = pp.xToPixel(nextX);<a name="line.9287"></a>
<FONT color="green">9288</FONT>            double nextYPx = pp.yToPixel(nextY, onY2);<a name="line.9288"></a>
<FONT color="green">9289</FONT>    <a name="line.9289"></a>
<FONT color="green">9290</FONT>            if (nextX == nextX &amp;&amp; nextY == nextY &amp;&amp; // next point defined<a name="line.9290"></a>
<FONT color="green">9291</FONT>                thickness &gt; 0 &amp;&amp; // not a zero thickness connection<a name="line.9291"></a>
<FONT color="green">9292</FONT>                (x != nextX || y != nextY)) { // this/next are distinct<a name="line.9292"></a>
<FONT color="green">9293</FONT>              // draw HTML-element rendered line segment<a name="line.9293"></a>
<FONT color="green">9294</FONT>    <a name="line.9294"></a>
<FONT color="green">9295</FONT>              // Continuous fill not supported; 1px is reasonable approx.<a name="line.9295"></a>
<FONT color="green">9296</FONT>              if (0 == spacing)<a name="line.9296"></a>
<FONT color="green">9297</FONT>                spacing = 1;<a name="line.9297"></a>
<FONT color="green">9298</FONT>              double deltaX = nextXPx - xPx;<a name="line.9298"></a>
<FONT color="green">9299</FONT>              double deltaY = nextYPx - yPx;<a name="line.9299"></a>
<FONT color="green">9300</FONT>              boolean dXIsShorter = deltaX * deltaX &lt; deltaY * deltaY;<a name="line.9300"></a>
<FONT color="green">9301</FONT>              /*<a name="line.9301"></a>
<FONT color="green">9302</FONT>               * Increasing width by 1 adds half px on each edge<a name="line.9302"></a>
<FONT color="green">9303</FONT>               * to heal the occasional roundoff-induced gap<a name="line.9303"></a>
<FONT color="green">9304</FONT>               * <a name="line.9304"></a>
<FONT color="green">9305</FONT>               */ <a name="line.9305"></a>
<FONT color="green">9306</FONT>              final double EPS = 1;<a name="line.9306"></a>
<FONT color="green">9307</FONT>              /*<a name="line.9307"></a>
<FONT color="green">9308</FONT>               * TODO: the case in which the connecting line does not intersect the<a name="line.9308"></a>
<FONT color="green">9309</FONT>               * plot area, and off-plot-area points are not being drawn is handled<a name="line.9309"></a>
<FONT color="green">9310</FONT>               * very inefficiently, and not entirely correctly, by trying to draw<a name="line.9310"></a>
<FONT color="green">9311</FONT>               * the entire line and excluding each segment as we attempt to draw<a name="line.9311"></a>
<FONT color="green">9312</FONT>               * it.  Need to compute intersecting sub-line-segment and just draw<a name="line.9312"></a>
<FONT color="green">9313</FONT>               * that instead, ignoring lines with no intersecting segments<a name="line.9313"></a>
<FONT color="green">9314</FONT>               * completely. Can make a huge difference with lots of off-chart<a name="line.9314"></a>
<FONT color="green">9315</FONT>               * points, such as a deliberately narrowed x axis range.<a name="line.9315"></a>
<FONT color="green">9316</FONT>               * <a name="line.9316"></a>
<FONT color="green">9317</FONT>               */ <a name="line.9317"></a>
<FONT color="green">9318</FONT>              if (deltaX == 0) { // special-case of vertical line<a name="line.9318"></a>
<FONT color="green">9319</FONT>                realizeOneImageOfSymbol(pp, grp, arp, symbol, null,<a name="line.9319"></a>
<FONT color="green">9320</FONT>                    onY2, clipPlotArea, clipDecoratedChart, renderPaddingFactor,<a name="line.9320"></a>
<FONT color="green">9321</FONT>                    xPx, 0.5 * (yPx + nextYPx), Double.NaN,<a name="line.9321"></a>
<FONT color="green">9322</FONT>                    Double.NaN, nextXPx, nextYPx, thickness,<a name="line.9322"></a>
<FONT color="green">9323</FONT>                    Math.abs(nextYPx - yPx) + EPS);<a name="line.9323"></a>
<FONT color="green">9324</FONT>              } else if (deltaY == 0) { // special case of horizontal line<a name="line.9324"></a>
<FONT color="green">9325</FONT>                realizeOneImageOfSymbol(pp, grp, arp, symbol, null,<a name="line.9325"></a>
<FONT color="green">9326</FONT>                    onY2, clipPlotArea, clipDecoratedChart, renderPaddingFactor,<a name="line.9326"></a>
<FONT color="green">9327</FONT>                    0.5 * (xPx + nextXPx), yPx, Double.NaN,<a name="line.9327"></a>
<FONT color="green">9328</FONT>                    Double.NaN, nextXPx, nextYPx,<a name="line.9328"></a>
<FONT color="green">9329</FONT>                    Math.abs(nextXPx - xPx) + EPS, thickness);<a name="line.9329"></a>
<FONT color="green">9330</FONT>              } else if (dXIsShorter) { // series of vertical segments<a name="line.9330"></a>
<FONT color="green">9331</FONT>                double xMin = (xPx &lt; nextXPx) ? xPx : nextXPx;<a name="line.9331"></a>
<FONT color="green">9332</FONT>                double xMax = (xPx &gt; nextXPx) ? xPx : nextXPx;<a name="line.9332"></a>
<FONT color="green">9333</FONT>                double yAtXMin = (xPx &lt; nextXPx) ? yPx : nextYPx;<a name="line.9333"></a>
<FONT color="green">9334</FONT>                double yAtXMax = (xPx &gt; nextXPx) ? yPx : nextYPx;<a name="line.9334"></a>
<FONT color="green">9335</FONT>    <a name="line.9335"></a>
<FONT color="green">9336</FONT>                double xiPrev = xMin;<a name="line.9336"></a>
<FONT color="green">9337</FONT>                double yiPrev = yAtXMin;<a name="line.9337"></a>
<FONT color="green">9338</FONT>                double xi = xiPrev;<a name="line.9338"></a>
<FONT color="green">9339</FONT>                double yi = yiPrev;<a name="line.9339"></a>
<FONT color="green">9340</FONT>                // round up to err on side of providing more detail<a name="line.9340"></a>
<FONT color="green">9341</FONT>                int N = (int) Math.ceil((xMax - xMin) / spacing);<a name="line.9341"></a>
<FONT color="green">9342</FONT>                double dy = Math.abs((yAtXMax - yAtXMin) / N) + EPS;<a name="line.9342"></a>
<FONT color="green">9343</FONT>                for (int i = 1; i &lt;= N; i++) {<a name="line.9343"></a>
<FONT color="green">9344</FONT>                  xi = xMin + i * (xMax - xMin) / N;<a name="line.9344"></a>
<FONT color="green">9345</FONT>                  yi = yAtXMin + i * (yAtXMax - yAtXMin) / N;<a name="line.9345"></a>
<FONT color="green">9346</FONT>                  realizeOneImageOfSymbol(pp, grp, arp, symbol, null,<a name="line.9346"></a>
<FONT color="green">9347</FONT>                      onY2, clipPlotArea, clipDecoratedChart,<a name="line.9347"></a>
<FONT color="green">9348</FONT>                      renderPaddingFactor, 0.5 * (xiPrev + xi),<a name="line.9348"></a>
<FONT color="green">9349</FONT>                      0.5 * (yiPrev + yi), Double.NaN,<a name="line.9349"></a>
<FONT color="green">9350</FONT>                      Double.NaN, nextXPx, nextYPx, thickness, dy);<a name="line.9350"></a>
<FONT color="green">9351</FONT>                  xiPrev = xi;<a name="line.9351"></a>
<FONT color="green">9352</FONT>                  yiPrev = yi;<a name="line.9352"></a>
<FONT color="green">9353</FONT>                }<a name="line.9353"></a>
<FONT color="green">9354</FONT>              } else { // dY is shorter. Series of horizontal segments<a name="line.9354"></a>
<FONT color="green">9355</FONT>                double yMin = (yPx &lt; nextYPx) ? yPx : nextYPx;<a name="line.9355"></a>
<FONT color="green">9356</FONT>                double yMax = (yPx &gt; nextYPx) ? yPx : nextYPx;<a name="line.9356"></a>
<FONT color="green">9357</FONT>                double xAtYMin = (yPx &lt; nextYPx) ? xPx : nextXPx;<a name="line.9357"></a>
<FONT color="green">9358</FONT>                double xAtYMax = (yPx &gt; nextYPx) ? xPx : nextXPx;<a name="line.9358"></a>
<FONT color="green">9359</FONT>    <a name="line.9359"></a>
<FONT color="green">9360</FONT>                double xiPrev = xAtYMin;<a name="line.9360"></a>
<FONT color="green">9361</FONT>                double yiPrev = yMin;<a name="line.9361"></a>
<FONT color="green">9362</FONT>                double xi = xiPrev;<a name="line.9362"></a>
<FONT color="green">9363</FONT>                double yi = yiPrev;<a name="line.9363"></a>
<FONT color="green">9364</FONT>                int N = (int) Math.ceil((yMax - yMin) / spacing);<a name="line.9364"></a>
<FONT color="green">9365</FONT>                double dx = Math.abs((xAtYMax - xAtYMin) / N) + EPS;<a name="line.9365"></a>
<FONT color="green">9366</FONT>                for (int i = 1; i &lt;= N; i++) {<a name="line.9366"></a>
<FONT color="green">9367</FONT>                  yi = yMin + i * (yMax - yMin) / N;<a name="line.9367"></a>
<FONT color="green">9368</FONT>                  xi = xAtYMin + i * (xAtYMax - xAtYMin) / N;<a name="line.9368"></a>
<FONT color="green">9369</FONT>                  realizeOneImageOfSymbol(pp, grp, arp, symbol, null,<a name="line.9369"></a>
<FONT color="green">9370</FONT>                      onY2, clipPlotArea, clipDecoratedChart,<a name="line.9370"></a>
<FONT color="green">9371</FONT>                      renderPaddingFactor, 0.5 * (xiPrev + xi),<a name="line.9371"></a>
<FONT color="green">9372</FONT>                      0.5 * (yiPrev + yi), Double.NaN,<a name="line.9372"></a>
<FONT color="green">9373</FONT>                      Double.NaN, nextXPx, nextYPx, dx, thickness);<a name="line.9373"></a>
<FONT color="green">9374</FONT>                  xiPrev = xi;<a name="line.9374"></a>
<FONT color="green">9375</FONT>                  yiPrev = yi;<a name="line.9375"></a>
<FONT color="green">9376</FONT>                }<a name="line.9376"></a>
<FONT color="green">9377</FONT>              }<a name="line.9377"></a>
<FONT color="green">9378</FONT>            }<a name="line.9378"></a>
<FONT color="green">9379</FONT>    <a name="line.9379"></a>
<FONT color="green">9380</FONT>            // the "main" symbol (the one on the (x,y) point itself) is<a name="line.9380"></a>
<FONT color="green">9381</FONT>            // rendered last to put it on top of interpolated images<a name="line.9381"></a>
<FONT color="green">9382</FONT>            if (drawMainSymbol) {<a name="line.9382"></a>
<FONT color="green">9383</FONT>              double w = symbol.getWidth(pp);<a name="line.9383"></a>
<FONT color="green">9384</FONT>              double h = symbol.getHeight(pp, onY2);<a name="line.9384"></a>
<FONT color="green">9385</FONT>              realizeOneImageOfSymbol(pp, grp, arp, symbol, annotation,<a name="line.9385"></a>
<FONT color="green">9386</FONT>                  onY2, clipPlotArea, clipDecoratedChart, renderPaddingFactor, xPx,<a name="line.9386"></a>
<FONT color="green">9387</FONT>                  yPx, Double.NaN, Double.NaN, nextXPx, nextYPx, w, h);<a name="line.9387"></a>
<FONT color="green">9388</FONT>            }<a name="line.9388"></a>
<FONT color="green">9389</FONT>          } // realizeSymbol<a name="line.9389"></a>
<FONT color="green">9390</FONT>    <a name="line.9390"></a>
<FONT color="green">9391</FONT>        }<a name="line.9391"></a>
<FONT color="green">9392</FONT>    <a name="line.9392"></a>
<FONT color="green">9393</FONT>        /*<a name="line.9393"></a>
<FONT color="green">9394</FONT>         * Symbols that are assigned this symbol type can be used to represent a pie<a name="line.9394"></a>
<FONT color="green">9395</FONT>         * chart slice.<a name="line.9395"></a>
<FONT color="green">9396</FONT>         * &lt;p&gt;<a name="line.9396"></a>
<FONT color="green">9397</FONT>         * <a name="line.9397"></a>
<FONT color="green">9398</FONT>         * The pivot point (center of containing pie) is at the x,y location of the<a name="line.9398"></a>
<FONT color="green">9399</FONT>         * point. Typically, only a single point per pie-slice curve is used<a name="line.9399"></a>
<FONT color="green">9400</FONT>         * (multiple points simply translate the same pie slice symbol to another<a name="line.9400"></a>
<FONT color="green">9401</FONT>         * position, such behavior is useful if you want to use a pie slice as a<a name="line.9401"></a>
<FONT color="green">9402</FONT>         * traditional curve symbol, but it isn't needed for a typical pie chart).<a name="line.9402"></a>
<FONT color="green">9403</FONT>         * &lt;p&gt;<a name="line.9403"></a>
<FONT color="green">9404</FONT>         * <a name="line.9404"></a>
<FONT color="green">9405</FONT>         * The initial angle and angle subtended by the slice are specified by the<a name="line.9405"></a>
<FONT color="green">9406</FONT>         * &lt;tt&gt;pieSliceOrientation&lt;/tt&gt; and &lt;tt&gt;pieSliceSize&lt;/tt&gt; properties of the<a name="line.9406"></a>
<FONT color="green">9407</FONT>         * host &lt;tt&gt;Symbol&lt;/tt&gt; (these properties only have meaning with pie slice<a name="line.9407"></a>
<FONT color="green">9408</FONT>         * symbol types). Typically, several curves share a common pie center point<a name="line.9408"></a>
<FONT color="green">9409</FONT>         * (x,y) and have orientations and sizes that are coordinated so that the<a name="line.9409"></a>
<FONT color="green">9410</FONT>         * slices fit together to form a single complete pie. GChart facilitates<a name="line.9410"></a>
<FONT color="green">9411</FONT>         * this by choosing (by default) the next slice's orientation so that it is<a name="line.9411"></a>
<FONT color="green">9412</FONT>         * adjacent to the preceeding slice. However, other useful idioms include,<a name="line.9412"></a>
<FONT color="green">9413</FONT>         * for example, adjusting the x,y pivots to produce "exploded pie charts",<a name="line.9413"></a>
<FONT color="green">9414</FONT>         * or using a single slice that fills up the entire pie as a disc-like<a name="line.9414"></a>
<FONT color="green">9415</FONT>         * alternative to &lt;tt&gt;BOX_CENTER&lt;/tt&gt;. &lt;p&gt;<a name="line.9415"></a>
<FONT color="green">9416</FONT>         * <a name="line.9416"></a>
<FONT color="green">9417</FONT>         * The radius of the slice is chosen as the radius such that the rectangle<a name="line.9417"></a>
<FONT color="green">9418</FONT>         * defined by the hosting Symbol's width and height just barely fits within<a name="line.9418"></a>
<FONT color="green">9419</FONT>         * a circle with that radius. This convention allows users to define the pie<a name="line.9419"></a>
<FONT color="green">9420</FONT>         * radius in terms of the x model coordinates, y model coordinates, or in<a name="line.9420"></a>
<FONT color="green">9421</FONT>         * pixels, as desired. &lt;p&gt;<a name="line.9421"></a>
<FONT color="green">9422</FONT>         * <a name="line.9422"></a>
<FONT color="green">9423</FONT>         * The host &lt;tt&gt;Symbol&lt;/tt&gt;'s fillSpacing and fillThickness properties,<a name="line.9423"></a>
<FONT color="green">9424</FONT>         * along with horizontallyShaded and verticallyShaded properties of this<a name="line.9424"></a>
<FONT color="green">9425</FONT>         * SymbolType, govern how the slice is filled in.<a name="line.9425"></a>
<FONT color="green">9426</FONT>         * <a name="line.9426"></a>
<FONT color="green">9427</FONT>         * For more information with example code, see the discussion under the<a name="line.9427"></a>
<FONT color="green">9428</FONT>         * {@link #PIE_SLICE_OPTIMAL_SHADING PIE_SLICE_OPTIMAL_SHADING} symbol type.<a name="line.9428"></a>
<FONT color="green">9429</FONT>         */<a name="line.9429"></a>
<FONT color="green">9430</FONT>    <a name="line.9430"></a>
<FONT color="green">9431</FONT>        private static class PieSliceSymbolType extends SymbolType {<a name="line.9431"></a>
<FONT color="green">9432</FONT>          private boolean horizontallyShaded;<a name="line.9432"></a>
<FONT color="green">9433</FONT>          private boolean verticallyShaded;<a name="line.9433"></a>
<FONT color="green">9434</FONT>          private boolean optimallyShaded;<a name="line.9434"></a>
<FONT color="green">9435</FONT>    <a name="line.9435"></a>
<FONT color="green">9436</FONT>          PieSliceSymbolType(boolean horizontallyShaded,<a name="line.9436"></a>
<FONT color="green">9437</FONT>              boolean verticallyShaded, boolean optimallyShaded,<a name="line.9437"></a>
<FONT color="green">9438</FONT>              double pixelPadLeft, double pixelPadRight,<a name="line.9438"></a>
<FONT color="green">9439</FONT>              double pixelPadTop, double pixelPadBottom) {<a name="line.9439"></a>
<FONT color="green">9440</FONT>            // same as BOX_SOUTHEAST (allows shading bars to be<a name="line.9440"></a>
<FONT color="green">9441</FONT>            // easily positions by their upper left corners):<a name="line.9441"></a>
<FONT color="green">9442</FONT>            super(1, 1, pixelPadLeft, pixelPadRight, pixelPadTop,<a name="line.9442"></a>
<FONT color="green">9443</FONT>                pixelPadBottom);<a name="line.9443"></a>
<FONT color="green">9444</FONT>    <a name="line.9444"></a>
<FONT color="green">9445</FONT>            this.horizontallyShaded = horizontallyShaded;<a name="line.9445"></a>
<FONT color="green">9446</FONT>            this.verticallyShaded = verticallyShaded;<a name="line.9446"></a>
<FONT color="green">9447</FONT>            this.optimallyShaded = optimallyShaded;<a name="line.9447"></a>
<FONT color="green">9448</FONT>          }<a name="line.9448"></a>
<FONT color="green">9449</FONT>    <a name="line.9449"></a>
<FONT color="green">9450</FONT>          @Override<a name="line.9450"></a>
<FONT color="green">9451</FONT>          protected AnnotationLocation defaultHoverLocation() {<a name="line.9451"></a>
<FONT color="green">9452</FONT>            return DEFAULT_PIE_SLICE_HOVER_LOCATION;<a name="line.9452"></a>
<FONT color="green">9453</FONT>          }<a name="line.9453"></a>
<FONT color="green">9454</FONT>    <a name="line.9454"></a>
<FONT color="green">9455</FONT>          /*<a name="line.9455"></a>
<FONT color="green">9456</FONT>           * For simplicity, pie slices are given the upper bound band thickness of<a name="line.9456"></a>
<FONT color="green">9457</FONT>           * a slice that occupies the entire pie. &lt;p&gt;<a name="line.9457"></a>
<FONT color="green">9458</FONT>           * <a name="line.9458"></a>
<FONT color="green">9459</FONT>           * The case where hit test banding is most needed: lots of very small full<a name="line.9459"></a>
<FONT color="green">9460</FONT>           * pies on a single curve (pie used as circular alternative to a<a name="line.9460"></a>
<FONT color="green">9461</FONT>           * rectangular point marker) won't suffer from this up-sizing<a name="line.9461"></a>
<FONT color="green">9462</FONT>           * approximation, since it uses full pies anyway.<a name="line.9462"></a>
<FONT color="green">9463</FONT>           */<a name="line.9463"></a>
<FONT color="green">9464</FONT>          @Override<a name="line.9464"></a>
<FONT color="green">9465</FONT>          protected double getBandThickness(PlotPanel pp, Symbol sym,<a name="line.9465"></a>
<FONT color="green">9466</FONT>              boolean onY2) {<a name="line.9466"></a>
<FONT color="green">9467</FONT>              double result = Math.max(MIN_BAND_SIZE,<a name="line.9467"></a>
<FONT color="green">9468</FONT>                                       2 * sym.getPieSliceRadius(pp, onY2));<a name="line.9468"></a>
<FONT color="green">9469</FONT>            return result;<a name="line.9469"></a>
<FONT color="green">9470</FONT>          }<a name="line.9470"></a>
<FONT color="green">9471</FONT>    <a name="line.9471"></a>
<FONT color="green">9472</FONT>          /*<a name="line.9472"></a>
<FONT color="green">9473</FONT>           * Pie slices use a special radially oriented brush, whose radial<a name="line.9473"></a>
<FONT color="green">9474</FONT>           * dimension is the larger of the specified brush width and height. &lt;p&gt;<a name="line.9474"></a>
<FONT color="green">9475</FONT>           * <a name="line.9475"></a>
<FONT color="green">9476</FONT>           * So, from the point of view of the banded/binned hit testing algorithm,<a name="line.9476"></a>
<FONT color="green">9477</FONT>           * which works entirely with rectangles, treating the brush as a<a name="line.9477"></a>
<FONT color="green">9478</FONT>           * square with sides equal to the larger of the brush width and height,<a name="line.9478"></a>
<FONT color="green">9479</FONT>           * "gets you in the right bin" using the same bin testing algorithm as<a name="line.9479"></a>
<FONT color="green">9480</FONT>           * for rectangular symbols.<a name="line.9480"></a>
<FONT color="green">9481</FONT>           * &lt;p&gt;<a name="line.9481"></a>
<FONT color="green">9482</FONT>           * <a name="line.9482"></a>
<FONT color="green">9483</FONT>           * Thus, regardless of if the pie uses horizontal or vertical hit test<a name="line.9483"></a>
<FONT color="green">9484</FONT>           * banding, the as-if-rectangular brush used in binned/banded hit testing<a name="line.9484"></a>
<FONT color="green">9485</FONT>           * is same square box, given by this method and its companion,<a name="line.9485"></a>
<FONT color="green">9486</FONT>           * &lt;tt&gt;getBrushWidth&lt;/tt&gt;, below. &lt;p&gt;<a name="line.9486"></a>
<FONT color="green">9487</FONT>           * <a name="line.9487"></a>
<FONT color="green">9488</FONT>           * This code also relies on the fact that for pie slices, only the larger<a name="line.9488"></a>
<FONT color="green">9489</FONT>           * of width, height has an impact on the more exact, slice/angle/radius<a name="line.9489"></a>
<FONT color="green">9490</FONT>           * closeness testing that is applied only to the subset of nearby points<a name="line.9490"></a>
<FONT color="green">9491</FONT>           * determined by using the bins/bands hit test. So, making brush width and<a name="line.9491"></a>
<FONT color="green">9492</FONT>           * height the same for pie slices doesn't cause any detail hit testing<a name="line.9492"></a>
<FONT color="green">9493</FONT>           * errors (as it would for ordinary rectangular hit testing). &lt;p&gt;<a name="line.9493"></a>
<FONT color="green">9494</FONT>           * <a name="line.9494"></a>
<FONT color="green">9495</FONT>           * TODO: Above works (I think) but is convoluted. Try to find a clearer,<a name="line.9495"></a>
<FONT color="green">9496</FONT>           * simpler, way to express/handle pie slice differences. The special case<a name="line.9496"></a>
<FONT color="green">9497</FONT>           * brush location handling for pies also seems a bit obscure.<a name="line.9497"></a>
<FONT color="green">9498</FONT>           */<a name="line.9498"></a>
<FONT color="green">9499</FONT>          @Override<a name="line.9499"></a>
<FONT color="green">9500</FONT>          protected int getBrushHeight(Symbol sym) {<a name="line.9500"></a>
<FONT color="green">9501</FONT>            int result = Math.max(sym.getBrushHeight(),<a name="line.9501"></a>
<FONT color="green">9502</FONT>                                  sym.getBrushWidth());<a name="line.9502"></a>
<FONT color="green">9503</FONT>            return result;<a name="line.9503"></a>
<FONT color="green">9504</FONT>          }<a name="line.9504"></a>
<FONT color="green">9505</FONT>    <a name="line.9505"></a>
<FONT color="green">9506</FONT>          // pie slices always use a centered brush location<a name="line.9506"></a>
<FONT color="green">9507</FONT>          @Override<a name="line.9507"></a>
<FONT color="green">9508</FONT>          protected AnnotationLocation getBrushLocation(Symbol sym) {<a name="line.9508"></a>
<FONT color="green">9509</FONT>            AnnotationLocation result = AnnotationLocation.CENTER;<a name="line.9509"></a>
<FONT color="green">9510</FONT>            return result;<a name="line.9510"></a>
<FONT color="green">9511</FONT>          }<a name="line.9511"></a>
<FONT color="green">9512</FONT>    <a name="line.9512"></a>
<FONT color="green">9513</FONT>          // See comment on getBrushHeight above<a name="line.9513"></a>
<FONT color="green">9514</FONT>          @Override<a name="line.9514"></a>
<FONT color="green">9515</FONT>          protected int getBrushWidth(Symbol sym) {<a name="line.9515"></a>
<FONT color="green">9516</FONT>            int result = Math.max(sym.getBrushHeight(),<a name="line.9516"></a>
<FONT color="green">9517</FONT>                                  sym.getBrushWidth());<a name="line.9517"></a>
<FONT color="green">9518</FONT>            return result;<a name="line.9518"></a>
<FONT color="green">9519</FONT>          }<a name="line.9519"></a>
<FONT color="green">9520</FONT>    <a name="line.9520"></a>
<FONT color="green">9521</FONT>          @Override<a name="line.9521"></a>
<FONT color="green">9522</FONT>          protected double defaultFillSpacing() {<a name="line.9522"></a>
<FONT color="green">9523</FONT>            return DEFAULT_PIE_SLICE_FILL_SPACING;<a name="line.9523"></a>
<FONT color="green">9524</FONT>          }<a name="line.9524"></a>
<FONT color="green">9525</FONT>    <a name="line.9525"></a>
<FONT color="green">9526</FONT>          @Override<a name="line.9526"></a>
<FONT color="green">9527</FONT>          protected int defaultFillThickness() {<a name="line.9527"></a>
<FONT color="green">9528</FONT>            return DEFAULT_PIE_SLICE_FILL_THICKNESS;<a name="line.9528"></a>
<FONT color="green">9529</FONT>          }<a name="line.9529"></a>
<FONT color="green">9530</FONT>    <a name="line.9530"></a>
<FONT color="green">9531</FONT>          @Override<a name="line.9531"></a>
<FONT color="green">9532</FONT>          protected String defaultHovertextTemplate() {<a name="line.9532"></a>
<FONT color="green">9533</FONT>            return DEFAULT_PIE_SLICE_HOVERTEXT_TEMPLATE;<a name="line.9533"></a>
<FONT color="green">9534</FONT>          }<a name="line.9534"></a>
<FONT color="green">9535</FONT>    <a name="line.9535"></a>
<FONT color="green">9536</FONT>          // holds min/max x (cosine) and y (sine) over a "unit circle slice"<a name="line.9536"></a>
<FONT color="green">9537</FONT>          private static class SliceLimits {<a name="line.9537"></a>
<FONT color="green">9538</FONT>            double xMin;<a name="line.9538"></a>
<FONT color="green">9539</FONT>            double xMax;<a name="line.9539"></a>
<FONT color="green">9540</FONT>            double yMin;<a name="line.9540"></a>
<FONT color="green">9541</FONT>            double yMax;<a name="line.9541"></a>
<FONT color="green">9542</FONT>          }<a name="line.9542"></a>
<FONT color="green">9543</FONT>    <a name="line.9543"></a>
<FONT color="green">9544</FONT>          // Gets min/max sin, cos over slice cut from unit circle<a name="line.9544"></a>
<FONT color="green">9545</FONT>          private SliceLimits getSliceLimits(double tMin, double tMax) {<a name="line.9545"></a>
<FONT color="green">9546</FONT>            final SliceLimits result = new SliceLimits();<a name="line.9546"></a>
<FONT color="green">9547</FONT>            double xMin = 0; // origin of 0,0 present in every slice<a name="line.9547"></a>
<FONT color="green">9548</FONT>            double xMax = 0; // (it's the pie center/slice pivot point)<a name="line.9548"></a>
<FONT color="green">9549</FONT>            double yMin = 0;<a name="line.9549"></a>
<FONT color="green">9550</FONT>            double yMax = 0;<a name="line.9550"></a>
<FONT color="green">9551</FONT>            double tmp = 0;<a name="line.9551"></a>
<FONT color="green">9552</FONT>            // points where each edge intersects the arc could be<a name="line.9552"></a>
<FONT color="green">9553</FONT>            // extremal points--include them too.<a name="line.9553"></a>
<FONT color="green">9554</FONT>            tmp = Math.cos(tMin);<a name="line.9554"></a>
<FONT color="green">9555</FONT>            xMin = (xMin &lt; tmp) ? xMin : tmp;<a name="line.9555"></a>
<FONT color="green">9556</FONT>            xMax = (xMax &gt; tmp) ? xMax : tmp;<a name="line.9556"></a>
<FONT color="green">9557</FONT>            tmp = Math.sin(tMin);<a name="line.9557"></a>
<FONT color="green">9558</FONT>            yMin = (yMin &lt; tmp) ? yMin : tmp;<a name="line.9558"></a>
<FONT color="green">9559</FONT>            yMax = (yMax &gt; tmp) ? yMax : tmp;<a name="line.9559"></a>
<FONT color="green">9560</FONT>    <a name="line.9560"></a>
<FONT color="green">9561</FONT>            tmp = Math.cos(tMax);<a name="line.9561"></a>
<FONT color="green">9562</FONT>            xMin = (xMin &lt; tmp) ? xMin : tmp;<a name="line.9562"></a>
<FONT color="green">9563</FONT>            xMax = (xMax &gt; tmp) ? xMax : tmp;<a name="line.9563"></a>
<FONT color="green">9564</FONT>            tmp = Math.sin(tMax);<a name="line.9564"></a>
<FONT color="green">9565</FONT>            yMin = (yMin &lt; tmp) ? yMin : tmp;<a name="line.9565"></a>
<FONT color="green">9566</FONT>            yMax = (yMax &gt; tmp) ? yMax : tmp;<a name="line.9566"></a>
<FONT color="green">9567</FONT>    <a name="line.9567"></a>
<FONT color="green">9568</FONT>            // finally if slice includes any special extreme points<a name="line.9568"></a>
<FONT color="green">9569</FONT>            // on the arc (namely, points of the arc that are<a name="line.9569"></a>
<FONT color="green">9570</FONT>            // either due north, due south, due east or due west)<a name="line.9570"></a>
<FONT color="green">9571</FONT>            // include those points in determining the min/max x<a name="line.9571"></a>
<FONT color="green">9572</FONT>            // and min/max y included in the slice:<a name="line.9572"></a>
<FONT color="green">9573</FONT>            double halfPi = Math.PI / 2.;<a name="line.9573"></a>
<FONT color="green">9574</FONT>            for (int i = (int) Math.ceil(tMin / halfPi); i * halfPi &lt; tMax; i++) {<a name="line.9574"></a>
<FONT color="green">9575</FONT>              double t = i * halfPi;<a name="line.9575"></a>
<FONT color="green">9576</FONT>              tmp = Math.cos(t);<a name="line.9576"></a>
<FONT color="green">9577</FONT>              xMin = (xMin &lt; tmp) ? xMin : tmp;<a name="line.9577"></a>
<FONT color="green">9578</FONT>              xMax = (xMax &gt; tmp) ? xMax : tmp;<a name="line.9578"></a>
<FONT color="green">9579</FONT>              tmp = Math.sin(t);<a name="line.9579"></a>
<FONT color="green">9580</FONT>              yMin = (yMin &lt; tmp) ? yMin : tmp;<a name="line.9580"></a>
<FONT color="green">9581</FONT>              yMax = (yMax &gt; tmp) ? yMax : tmp;<a name="line.9581"></a>
<FONT color="green">9582</FONT>            }<a name="line.9582"></a>
<FONT color="green">9583</FONT>    <a name="line.9583"></a>
<FONT color="green">9584</FONT>            result.xMin = xMin;<a name="line.9584"></a>
<FONT color="green">9585</FONT>            result.xMax = xMax;<a name="line.9585"></a>
<FONT color="green">9586</FONT>            result.yMin = yMin;<a name="line.9586"></a>
<FONT color="green">9587</FONT>            result.yMax = yMax;<a name="line.9587"></a>
<FONT color="green">9588</FONT>    <a name="line.9588"></a>
<FONT color="green">9589</FONT>            return result;<a name="line.9589"></a>
<FONT color="green">9590</FONT>    <a name="line.9590"></a>
<FONT color="green">9591</FONT>          }<a name="line.9591"></a>
<FONT color="green">9592</FONT>    <a name="line.9592"></a>
<FONT color="green">9593</FONT>          @Override<a name="line.9593"></a>
<FONT color="green">9594</FONT>          protected double getEdgeLeft(PlotPanel pp, Symbol symbol, double x,<a name="line.9594"></a>
<FONT color="green">9595</FONT>              boolean onY2) {<a name="line.9595"></a>
<FONT color="green">9596</FONT>    <a name="line.9596"></a>
<FONT color="green">9597</FONT>            double r = symbol.getPieSliceRadius(pp, onY2);<a name="line.9597"></a>
<FONT color="green">9598</FONT>            double theta0 = symbol.getPieSliceTheta0();<a name="line.9598"></a>
<FONT color="green">9599</FONT>            double theta1 = symbol.getPieSliceTheta1();<a name="line.9599"></a>
<FONT color="green">9600</FONT>            SliceLimits sl = getSliceLimits(theta1, theta0);<a name="line.9600"></a>
<FONT color="green">9601</FONT>            double xPx = pp.xToPixel(x);<a name="line.9601"></a>
<FONT color="green">9602</FONT>            // scale up the xMin on unit circle to get to left edge<a name="line.9602"></a>
<FONT color="green">9603</FONT>            double result = xPx + sl.xMin * r;<a name="line.9603"></a>
<FONT color="green">9604</FONT>            return result;<a name="line.9604"></a>
<FONT color="green">9605</FONT>          }<a name="line.9605"></a>
<FONT color="green">9606</FONT>    <a name="line.9606"></a>
<FONT color="green">9607</FONT>          @Override<a name="line.9607"></a>
<FONT color="green">9608</FONT>          protected double getEdgeRight(PlotPanel pp, Symbol symbol,<a name="line.9608"></a>
<FONT color="green">9609</FONT>              double x, boolean onY2) {<a name="line.9609"></a>
<FONT color="green">9610</FONT>            double r = symbol.getPieSliceRadius(pp, onY2);<a name="line.9610"></a>
<FONT color="green">9611</FONT>            double theta0 = symbol.getPieSliceTheta0();<a name="line.9611"></a>
<FONT color="green">9612</FONT>            double theta1 = symbol.getPieSliceTheta1();<a name="line.9612"></a>
<FONT color="green">9613</FONT>            SliceLimits sl = getSliceLimits(theta1, theta0);<a name="line.9613"></a>
<FONT color="green">9614</FONT>            double xPx = pp.xToPixel(x);<a name="line.9614"></a>
<FONT color="green">9615</FONT>            // scale up the xMax on unit circle to get to right edge<a name="line.9615"></a>
<FONT color="green">9616</FONT>            double result = xPx + sl.xMax * r;<a name="line.9616"></a>
<FONT color="green">9617</FONT>            return result;<a name="line.9617"></a>
<FONT color="green">9618</FONT>          }<a name="line.9618"></a>
<FONT color="green">9619</FONT>    <a name="line.9619"></a>
<FONT color="green">9620</FONT>          @Override<a name="line.9620"></a>
<FONT color="green">9621</FONT>          protected double getEdgeTop(PlotPanel pp, Symbol symbol, double y,<a name="line.9621"></a>
<FONT color="green">9622</FONT>              boolean onY2) {<a name="line.9622"></a>
<FONT color="green">9623</FONT>    <a name="line.9623"></a>
<FONT color="green">9624</FONT>            double r = symbol.getPieSliceRadius(pp, onY2);<a name="line.9624"></a>
<FONT color="green">9625</FONT>            double theta0 = symbol.getPieSliceTheta0();<a name="line.9625"></a>
<FONT color="green">9626</FONT>            double theta1 = symbol.getPieSliceTheta1();<a name="line.9626"></a>
<FONT color="green">9627</FONT>            SliceLimits sl = getSliceLimits(theta1, theta0);<a name="line.9627"></a>
<FONT color="green">9628</FONT>            double yPx = pp.yToPixel(y, onY2);<a name="line.9628"></a>
<FONT color="green">9629</FONT>            // minus for the Cartesian to pixel-coord transform<a name="line.9629"></a>
<FONT color="green">9630</FONT>            double result = yPx - sl.yMax * r;<a name="line.9630"></a>
<FONT color="green">9631</FONT>            return result;<a name="line.9631"></a>
<FONT color="green">9632</FONT>          }<a name="line.9632"></a>
<FONT color="green">9633</FONT>    <a name="line.9633"></a>
<FONT color="green">9634</FONT>          @Override<a name="line.9634"></a>
<FONT color="green">9635</FONT>          protected double getEdgeBottom(PlotPanel pp, Symbol symbol,<a name="line.9635"></a>
<FONT color="green">9636</FONT>              double y, boolean onY2) {<a name="line.9636"></a>
<FONT color="green">9637</FONT>    <a name="line.9637"></a>
<FONT color="green">9638</FONT>            double r = symbol.getPieSliceRadius(pp, onY2);<a name="line.9638"></a>
<FONT color="green">9639</FONT>            double theta0 = symbol.getPieSliceTheta0();<a name="line.9639"></a>
<FONT color="green">9640</FONT>            double theta1 = symbol.getPieSliceTheta1();<a name="line.9640"></a>
<FONT color="green">9641</FONT>            SliceLimits sl = getSliceLimits(theta1, theta0);<a name="line.9641"></a>
<FONT color="green">9642</FONT>            double yPx = pp.yToPixel(y, onY2);<a name="line.9642"></a>
<FONT color="green">9643</FONT>            // minus for the Cartesian to pixel-coord transform<a name="line.9643"></a>
<FONT color="green">9644</FONT>            double result = yPx - sl.yMin * r;<a name="line.9644"></a>
<FONT color="green">9645</FONT>            return result;<a name="line.9645"></a>
<FONT color="green">9646</FONT>          }<a name="line.9646"></a>
<FONT color="green">9647</FONT>    <a name="line.9647"></a>
<FONT color="green">9648</FONT>          // returns the y coordinate where a pie slice edge<a name="line.9648"></a>
<FONT color="green">9649</FONT>          // intersects a given vertical line, or NaN if none.<a name="line.9649"></a>
<FONT color="green">9650</FONT>          private static double yWherePieEdgeIntersectsVerticalLine(<a name="line.9650"></a>
<FONT color="green">9651</FONT>              double xOfVerticalLine, double xPieCenter,<a name="line.9651"></a>
<FONT color="green">9652</FONT>              double yPieCenter, double pieRadius, double pieEdgeAngle) {<a name="line.9652"></a>
<FONT color="green">9653</FONT>            double result = Double.NaN;<a name="line.9653"></a>
<FONT color="green">9654</FONT>            double dxToArc = pieRadius * Math.cos(pieEdgeAngle);<a name="line.9654"></a>
<FONT color="green">9655</FONT>            if (dxToArc != 0) {<a name="line.9655"></a>
<FONT color="green">9656</FONT>              // The fraction of the way (from pie center to pie perimeter<a name="line.9656"></a>
<FONT color="green">9657</FONT>              // along the pie slice edge) that you must go to reach the<a name="line.9657"></a>
<FONT color="green">9658</FONT>              // point at which the vertical line intersects with the pie<a name="line.9658"></a>
<FONT color="green">9659</FONT>              // slice edge. For example, this fraction is 0.5 whenever the<a name="line.9659"></a>
<FONT color="green">9660</FONT>              // vertical line bisects the pie slice edge.<a name="line.9660"></a>
<FONT color="green">9661</FONT>              double t = (xOfVerticalLine - xPieCenter) / dxToArc;<a name="line.9661"></a>
<FONT color="green">9662</FONT>              if (GChart.withinRange(t, 0, 1)) {<a name="line.9662"></a>
<FONT color="green">9663</FONT>                result = yPieCenter - t * pieRadius<a name="line.9663"></a>
<FONT color="green">9664</FONT>                    * Math.sin(pieEdgeAngle);<a name="line.9664"></a>
<FONT color="green">9665</FONT>              }<a name="line.9665"></a>
<FONT color="green">9666</FONT>            }<a name="line.9666"></a>
<FONT color="green">9667</FONT>            return result;<a name="line.9667"></a>
<FONT color="green">9668</FONT>          }<a name="line.9668"></a>
<FONT color="green">9669</FONT>    <a name="line.9669"></a>
<FONT color="green">9670</FONT>          // returns the x coordinate where a pie slice edge<a name="line.9670"></a>
<FONT color="green">9671</FONT>          // intersects a given horizontal line, or NaN if none.<a name="line.9671"></a>
<FONT color="green">9672</FONT>          private static double xWherePieEdgeIntersectsHorizontalLine(<a name="line.9672"></a>
<FONT color="green">9673</FONT>              double yOfHorizontalLine, double xPieCenter,<a name="line.9673"></a>
<FONT color="green">9674</FONT>              double yPieCenter, double pieRadius, double pieEdgeAngle) {<a name="line.9674"></a>
<FONT color="green">9675</FONT>            double result = Double.NaN;<a name="line.9675"></a>
<FONT color="green">9676</FONT>            double dyToArc = pieRadius * Math.sin(pieEdgeAngle);<a name="line.9676"></a>
<FONT color="green">9677</FONT>            if (dyToArc != 0) {<a name="line.9677"></a>
<FONT color="green">9678</FONT>              // The fraction of the way (from pie center to pie perimeter<a name="line.9678"></a>
<FONT color="green">9679</FONT>              // along the pie slice edge) that you must go to reach the<a name="line.9679"></a>
<FONT color="green">9680</FONT>              // point at which the horizontal line intersects with the pie<a name="line.9680"></a>
<FONT color="green">9681</FONT>              // slice edge. For example, this fraction is 0.5 whenever the<a name="line.9681"></a>
<FONT color="green">9682</FONT>              // horizontal line bisects the pie slice edge.<a name="line.9682"></a>
<FONT color="green">9683</FONT>              double t = (yPieCenter - yOfHorizontalLine) / dyToArc;<a name="line.9683"></a>
<FONT color="green">9684</FONT>              if (GChart.withinRange(t, 0, 1)) {<a name="line.9684"></a>
<FONT color="green">9685</FONT>                result = xPieCenter + t * pieRadius<a name="line.9685"></a>
<FONT color="green">9686</FONT>                    * Math.cos(pieEdgeAngle);<a name="line.9686"></a>
<FONT color="green">9687</FONT>              }<a name="line.9687"></a>
<FONT color="green">9688</FONT>            }<a name="line.9688"></a>
<FONT color="green">9689</FONT>            return result;<a name="line.9689"></a>
<FONT color="green">9690</FONT>          }<a name="line.9690"></a>
<FONT color="green">9691</FONT>    <a name="line.9691"></a>
<FONT color="green">9692</FONT>          /*<a name="line.9692"></a>
<FONT color="green">9693</FONT>           * Returns the angle of a line extending from (0,0) to (x,y) in radians in<a name="line.9693"></a>
<FONT color="green">9694</FONT>           * the standard range, 0 to 2*Pi. For example, a line pointing due east<a name="line.9694"></a>
<FONT color="green">9695</FONT>           * such as (1,0) would return 0, one pointing due north such as (0,0.5)<a name="line.9695"></a>
<FONT color="green">9696</FONT>           * would return Pi/2, one pointing due west such as (-4.13,0) would return<a name="line.9696"></a>
<FONT color="green">9697</FONT>           * Pi and the point (1,1) returns Pi/4. &lt;p&gt;<a name="line.9697"></a>
<FONT color="green">9698</FONT>           * <a name="line.9698"></a>
<FONT color="green">9699</FONT>           * x,y are in the ordinary cartesian coordinate system (not in the typical<a name="line.9699"></a>
<FONT color="green">9700</FONT>           * graphics/pixel coordinates)<a name="line.9700"></a>
<FONT color="green">9701</FONT>           */<a name="line.9701"></a>
<FONT color="green">9702</FONT>          private static double angle(double x, double y) {<a name="line.9702"></a>
<FONT color="green">9703</FONT>            double result = Double.NaN;<a name="line.9703"></a>
<FONT color="green">9704</FONT>            if (x == 0) {<a name="line.9704"></a>
<FONT color="green">9705</FONT>              if (y &gt; 0)<a name="line.9705"></a>
<FONT color="green">9706</FONT>                result = Math.PI / 2.;<a name="line.9706"></a>
<FONT color="green">9707</FONT>              else if (y &lt; 0)<a name="line.9707"></a>
<FONT color="green">9708</FONT>                result = 3 * Math.PI / 2.;<a name="line.9708"></a>
<FONT color="green">9709</FONT>            } else if (x &gt; 0 &amp;&amp; y &gt;= 0)<a name="line.9709"></a>
<FONT color="green">9710</FONT>              result = Math.atan(y / x);<a name="line.9710"></a>
<FONT color="green">9711</FONT>            else if (x &lt; 0 &amp;&amp; y &gt;= 0)<a name="line.9711"></a>
<FONT color="green">9712</FONT>              result = Math.PI - Math.atan(-y / x);<a name="line.9712"></a>
<FONT color="green">9713</FONT>            else if (x &lt; 0 &amp;&amp; y &lt; 0)<a name="line.9713"></a>
<FONT color="green">9714</FONT>              result = Math.PI + Math.atan(y / x);<a name="line.9714"></a>
<FONT color="green">9715</FONT>            else if (x &gt; 0 &amp;&amp; y &lt; 0)<a name="line.9715"></a>
<FONT color="green">9716</FONT>              result = 2 * Math.PI - Math.atan(-y / x);<a name="line.9716"></a>
<FONT color="green">9717</FONT>    <a name="line.9717"></a>
<FONT color="green">9718</FONT>            return result;<a name="line.9718"></a>
<FONT color="green">9719</FONT>          }<a name="line.9719"></a>
<FONT color="green">9720</FONT>    <a name="line.9720"></a>
<FONT color="green">9721</FONT>          // is the given angle between the two angles given?<a name="line.9721"></a>
<FONT color="green">9722</FONT>          private static boolean angleInRange(double angle, double theta0,<a name="line.9722"></a>
<FONT color="green">9723</FONT>              double theta1) {<a name="line.9723"></a>
<FONT color="green">9724</FONT>    <a name="line.9724"></a>
<FONT color="green">9725</FONT>            if (theta0 &gt; theta1)<a name="line.9725"></a>
<FONT color="green">9726</FONT>              return angleInRange(angle, theta1, theta0);<a name="line.9726"></a>
<FONT color="green">9727</FONT>            // angle is in standard 0 to 2*Pi range, but thetas<a name="line.9727"></a>
<FONT color="green">9728</FONT>            // can be "wrapped around" several negative<a name="line.9728"></a>
<FONT color="green">9729</FONT>            // multiples of 2*Pi less than the standard range;<a name="line.9729"></a>
<FONT color="green">9730</FONT>            // this loop brings angle into same range as thetas<a name="line.9730"></a>
<FONT color="green">9731</FONT>            while (angle &gt; theta1)<a name="line.9731"></a>
<FONT color="green">9732</FONT>              angle -= 2 * Math.PI;<a name="line.9732"></a>
<FONT color="green">9733</FONT>    <a name="line.9733"></a>
<FONT color="green">9734</FONT>            boolean result = GChart.withinRange(angle, theta0, theta1);<a name="line.9734"></a>
<FONT color="green">9735</FONT>            return result;<a name="line.9735"></a>
<FONT color="green">9736</FONT>          }<a name="line.9736"></a>
<FONT color="green">9737</FONT>    <a name="line.9737"></a>
<FONT color="green">9738</FONT>          /*<a name="line.9738"></a>
<FONT color="green">9739</FONT>           * <a name="line.9739"></a>
<FONT color="green">9740</FONT>           * @Override<a name="line.9740"></a>
<FONT color="green">9741</FONT>           * <a name="line.9741"></a>
<FONT color="green">9742</FONT>           * The x, y coordinates at the "center" of the slice for hit testing<a name="line.9742"></a>
<FONT color="green">9743</FONT>           * purposes.<a name="line.9743"></a>
<FONT color="green">9744</FONT>           * <a name="line.9744"></a>
<FONT color="green">9745</FONT>           * During hit testing, if more than one symbol touches the brush, the<a name="line.9745"></a>
<FONT color="green">9746</FONT>           * point whose center is closest to the mouse position is selected.<a name="line.9746"></a>
<FONT color="green">9747</FONT>           * <a name="line.9747"></a>
<FONT color="green">9748</FONT>           * To simplify the calculation, that center point is taken to be the<a name="line.9748"></a>
<FONT color="green">9749</FONT>           * center of the pie containing the slice, rather than the center of the<a name="line.9749"></a>
<FONT color="green">9750</FONT>           * slice per se. Though not an ideal choice, it is unlikely to cause<a name="line.9750"></a>
<FONT color="green">9751</FONT>           * significant deviations from user expectations, given how pie slices<a name="line.9751"></a>
<FONT color="green">9752</FONT>           * tend to be used to compose full pies out of a series of non-overlapping<a name="line.9752"></a>
<FONT color="green">9753</FONT>           * slices.<a name="line.9753"></a>
<FONT color="green">9754</FONT>           */<a name="line.9754"></a>
<FONT color="green">9755</FONT>         @Override<a name="line.9755"></a>
<FONT color="green">9756</FONT>         protected double getCenterX(PlotPanel pp, Symbol symbol, int iPoint) {<a name="line.9756"></a>
<FONT color="green">9757</FONT>            Curve.Point p = symbol.getParent().getPoint(iPoint);<a name="line.9757"></a>
<FONT color="green">9758</FONT>            double result = pp.xToPixel(p.getX());<a name="line.9758"></a>
<FONT color="green">9759</FONT>            return result;<a name="line.9759"></a>
<FONT color="green">9760</FONT>          }<a name="line.9760"></a>
<FONT color="green">9761</FONT>    <a name="line.9761"></a>
<FONT color="green">9762</FONT>          /*<a name="line.9762"></a>
<FONT color="green">9763</FONT>           * @Override<a name="line.9763"></a>
<FONT color="green">9764</FONT>           * <a name="line.9764"></a>
<FONT color="green">9765</FONT>           * See comment on getCenterX above.<a name="line.9765"></a>
<FONT color="green">9766</FONT>           */<a name="line.9766"></a>
<FONT color="green">9767</FONT>          @Override<a name="line.9767"></a>
<FONT color="green">9768</FONT>          protected double getCenterY(PlotPanel pp, Symbol symbol,<a name="line.9768"></a>
<FONT color="green">9769</FONT>              int iPoint, boolean onY2) {<a name="line.9769"></a>
<FONT color="green">9770</FONT>            Curve.Point p = symbol.getParent().getPoint(iPoint);<a name="line.9770"></a>
<FONT color="green">9771</FONT>            double result = pp.yToPixel(p.getY(), onY2);<a name="line.9771"></a>
<FONT color="green">9772</FONT>            return result;<a name="line.9772"></a>
<FONT color="green">9773</FONT>          }<a name="line.9773"></a>
<FONT color="green">9774</FONT>    <a name="line.9774"></a>
<FONT color="green">9775</FONT>          /*<a name="line.9775"></a>
<FONT color="green">9776</FONT>           * @Override<a name="line.9776"></a>
<FONT color="green">9777</FONT>           * <a name="line.9777"></a>
<FONT color="green">9778</FONT>           * Pie slices redefine what constitutes intersection of the mouse-centered<a name="line.9778"></a>
<FONT color="green">9779</FONT>           * brush and the rendered symbol to be: "mouse position within a<a name="line.9779"></a>
<FONT color="green">9780</FONT>           * radially-expanded version of the slice". The pie radius is expanded by<a name="line.9780"></a>
<FONT color="green">9781</FONT>           * half the larger dimension of the point selection brush.<a name="line.9781"></a>
<FONT color="green">9782</FONT>           */<a name="line.9782"></a>
<FONT color="green">9783</FONT>         @Override<a name="line.9783"></a>
<FONT color="green">9784</FONT>         protected boolean isIntersecting(PlotPanel pp, Symbol symbol,<a name="line.9784"></a>
<FONT color="green">9785</FONT>              int iPoint, boolean onY2, int xBrush, int yBrush,<a name="line.9785"></a>
<FONT color="green">9786</FONT>              int brushWidth, int brushHeight) {<a name="line.9786"></a>
<FONT color="green">9787</FONT>    <a name="line.9787"></a>
<FONT color="green">9788</FONT>            boolean result = false;<a name="line.9788"></a>
<FONT color="green">9789</FONT>            Curve.Point p = symbol.getParent().getPoint(iPoint);<a name="line.9789"></a>
<FONT color="green">9790</FONT>            double x = p.getX(); // pie center point (slice pivot)<a name="line.9790"></a>
<FONT color="green">9791</FONT>            double y = p.getY();<a name="line.9791"></a>
<FONT color="green">9792</FONT>            double xPx = pp.xToPixel(x);<a name="line.9792"></a>
<FONT color="green">9793</FONT>            double yPx = pp.yToPixel(y, onY2);<a name="line.9793"></a>
<FONT color="green">9794</FONT>            double dx = xBrush - xPx;<a name="line.9794"></a>
<FONT color="green">9795</FONT>            // - represents switch from graphics to cartesian coordinates<a name="line.9795"></a>
<FONT color="green">9796</FONT>            double dy = -(yBrush - yPx);<a name="line.9796"></a>
<FONT color="green">9797</FONT>    <a name="line.9797"></a>
<FONT color="green">9798</FONT>            double rSquared = dx * dx + dy * dy;<a name="line.9798"></a>
<FONT color="green">9799</FONT>            double angle = angle(dx, dy);<a name="line.9799"></a>
<FONT color="green">9800</FONT>            // pie angles grow clockwise but radians counter-clockwise,<a name="line.9800"></a>
<FONT color="green">9801</FONT>            // hence the odd "0 into max, 1 into min" mapping below.<a name="line.9801"></a>
<FONT color="green">9802</FONT>            double thetaMax = symbol.getPieSliceTheta0();<a name="line.9802"></a>
<FONT color="green">9803</FONT>            double thetaMin = symbol.getPieSliceTheta1();<a name="line.9803"></a>
<FONT color="green">9804</FONT>            double rPiePlus = symbol.getPieSliceRadius(pp, onY2) + 0.5<a name="line.9804"></a>
<FONT color="green">9805</FONT>                * Math.max(brushWidth, brushHeight);<a name="line.9805"></a>
<FONT color="green">9806</FONT>    <a name="line.9806"></a>
<FONT color="green">9807</FONT>            /*<a name="line.9807"></a>
<FONT color="green">9808</FONT>             * Enforce a minimum slice angle for hit testing purposes, equivalent to<a name="line.9808"></a>
<FONT color="green">9809</FONT>             * +/- 1 px of play along the arcs of tiny slices, to make them easier<a name="line.9809"></a>
<FONT color="green">9810</FONT>             * to select:&lt;p&gt;<a name="line.9810"></a>
<FONT color="green">9811</FONT>             * <a name="line.9811"></a>
<FONT color="green">9812</FONT>             * &lt;pre&gt; r*minDTheta = 1 px &lt;/pre&gt;<a name="line.9812"></a>
<FONT color="green">9813</FONT>             * <a name="line.9813"></a>
<FONT color="green">9814</FONT>             * This helps with tiny slices adjacent to large ones, but if several<a name="line.9814"></a>
<FONT color="green">9815</FONT>             * tiny slices are adjacent to each other, or if both adjacent slices<a name="line.9815"></a>
<FONT color="green">9816</FONT>             * come after the tiny slice in the curve order (e.g. the tiny slice is<a name="line.9816"></a>
<FONT color="green">9817</FONT>             * the very first slice) it still won't be selectable. Developers can<a name="line.9817"></a>
<FONT color="green">9818</FONT>             * switch curve order to get around this, but it's not ideal. &lt;p&gt;<a name="line.9818"></a>
<FONT color="green">9819</FONT>             * <a name="line.9819"></a>
<FONT color="green">9820</FONT>             * TODO: Integrate a "closest to slice angle" criterion to resolve ties<a name="line.9820"></a>
<FONT color="green">9821</FONT>             * when hit testing slices to provide a better hit testing behavior with<a name="line.9821"></a>
<FONT color="green">9822</FONT>             * small or overlapping slices.<a name="line.9822"></a>
<FONT color="green">9823</FONT>             */<a name="line.9823"></a>
<FONT color="green">9824</FONT>            double minDTheta = (rPiePlus &lt; 1) ? 1.0 : 1. / rPiePlus;<a name="line.9824"></a>
<FONT color="green">9825</FONT>            if (thetaMax - thetaMin &lt; 2 * minDTheta) {<a name="line.9825"></a>
<FONT color="green">9826</FONT>              double thetaMid = 0.5 * (thetaMax + thetaMin);<a name="line.9826"></a>
<FONT color="green">9827</FONT>              thetaMin = thetaMid - minDTheta;<a name="line.9827"></a>
<FONT color="green">9828</FONT>              thetaMax = thetaMid + minDTheta;<a name="line.9828"></a>
<FONT color="green">9829</FONT>            }<a name="line.9829"></a>
<FONT color="green">9830</FONT>            if (rSquared &lt;= rPiePlus * rPiePlus<a name="line.9830"></a>
<FONT color="green">9831</FONT>                &amp;&amp; angleInRange(angle, thetaMin, thetaMax))<a name="line.9831"></a>
<FONT color="green">9832</FONT>              result = true;<a name="line.9832"></a>
<FONT color="green">9833</FONT>    <a name="line.9833"></a>
<FONT color="green">9834</FONT>            return result;<a name="line.9834"></a>
<FONT color="green">9835</FONT>          }<a name="line.9835"></a>
<FONT color="green">9836</FONT>    <a name="line.9836"></a>
<FONT color="green">9837</FONT>          /*<a name="line.9837"></a>
<FONT color="green">9838</FONT>           * Renders a pie slice symbol.<a name="line.9838"></a>
<FONT color="green">9839</FONT>           *<a name="line.9839"></a>
<FONT color="green">9840</FONT>           */<a name="line.9840"></a>
<FONT color="green">9841</FONT>          @Override<a name="line.9841"></a>
<FONT color="green">9842</FONT>          void realizeSymbol(PlotPanel pp, GraphicsRenderingPanel grp,<a name="line.9842"></a>
<FONT color="green">9843</FONT>              AnnotationRenderingPanel arp, Symbol symbol,<a name="line.9843"></a>
<FONT color="green">9844</FONT>              Annotation annotation, boolean onY2, boolean clipPlotArea,<a name="line.9844"></a>
<FONT color="green">9845</FONT>              boolean clipDecoratedChart, double renderPaddingFactor,<a name="line.9845"></a>
<FONT color="green">9846</FONT>              boolean drawMainSymbol, double x, double y, double prevX,<a name="line.9846"></a>
<FONT color="green">9847</FONT>              double prevY, double nextX, double nextY) {<a name="line.9847"></a>
<FONT color="green">9848</FONT>    <a name="line.9848"></a>
<FONT color="green">9849</FONT>            if (!drawMainSymbol)<a name="line.9849"></a>
<FONT color="green">9850</FONT>              return;<a name="line.9850"></a>
<FONT color="green">9851</FONT>            double xPx = pp.xToPixel(x);<a name="line.9851"></a>
<FONT color="green">9852</FONT>            double yPx = pp.yToPixel(y, onY2);<a name="line.9852"></a>
<FONT color="green">9853</FONT>            double spacing = symbol.getFillSpacing();<a name="line.9853"></a>
<FONT color="green">9854</FONT>            int thickness = symbol.getFillThickness();<a name="line.9854"></a>
<FONT color="green">9855</FONT>            double r = symbol.getPieSliceRadius(pp, onY2);<a name="line.9855"></a>
<FONT color="green">9856</FONT>            double theta0 = symbol.getPieSliceTheta0();<a name="line.9856"></a>
<FONT color="green">9857</FONT>            double theta1 = symbol.getPieSliceTheta1();<a name="line.9857"></a>
<FONT color="green">9858</FONT>            GChartCanvasLite canvas = grp.getCanvas();<a name="line.9858"></a>
<FONT color="green">9859</FONT>            // x!=x is a faster isNaN<a name="line.9859"></a>
<FONT color="green">9860</FONT>            if ((xPx != xPx) || (yPx != yPx))<a name="line.9860"></a>
<FONT color="green">9861</FONT>              return; // undefined slice pivot point<a name="line.9861"></a>
<FONT color="green">9862</FONT>            else if (clipPlotArea<a name="line.9862"></a>
<FONT color="green">9863</FONT>                     &amp;&amp; !paddedIntersects(renderPaddingFactor, 0, 0, <a name="line.9863"></a>
<FONT color="green">9864</FONT>                        pp.getXChartSize(), pp.getYChartSize(), xPx - r, <a name="line.9864"></a>
<FONT color="green">9865</FONT>                        yPx - r, xPx + r, yPx + r))<a name="line.9865"></a>
<FONT color="green">9866</FONT>              return; // rect containing pie is off plot area<a name="line.9866"></a>
<FONT color="green">9867</FONT>            else if (clipDecoratedChart) {<a name="line.9867"></a>
<FONT color="green">9868</FONT>              int leftOfY = pp.getLeftOfYWidth();<a name="line.9868"></a>
<FONT color="green">9869</FONT>              int titleThickness = pp.chartTitleThickness();<a name="line.9869"></a>
<FONT color="green">9870</FONT>              if (!paddedIntersects(renderPaddingFactor, 0.0 - leftOfY,<a name="line.9870"></a>
<FONT color="green">9871</FONT>                  0.0 - titleThickness, <a name="line.9871"></a>
<FONT color="green">9872</FONT>                  pp.getXChartSizeDecoratedQuickly() - leftOfY,<a name="line.9872"></a>
<FONT color="green">9873</FONT>                  pp.getYChartSizeDecoratedQuickly() - titleThickness,<a name="line.9873"></a>
<FONT color="green">9874</FONT>                  xPx - r, yPx - r, xPx + r, yPx + r))<a name="line.9874"></a>
<FONT color="green">9875</FONT>                return; // rect containing pie is off decorated chart<a name="line.9875"></a>
<FONT color="green">9876</FONT>            }<a name="line.9876"></a>
<FONT color="green">9877</FONT>            // else bounding rectangle of pie containing the slice visible<a name="line.9877"></a>
<FONT color="green">9878</FONT>    <a name="line.9878"></a>
<FONT color="green">9879</FONT>            if (0 == spacing &amp;&amp; null != canvas &amp;&amp; thickness &gt; 0) {<a name="line.9879"></a>
<FONT color="green">9880</FONT>              // continuous fill pie slice and canvas is available<a name="line.9880"></a>
<FONT color="green">9881</FONT>    <a name="line.9881"></a>
<FONT color="green">9882</FONT>              /*<a name="line.9882"></a>
<FONT color="green">9883</FONT>               * Solid fill pie slices implement the notion of internal vs external<a name="line.9883"></a>
<FONT color="green">9884</FONT>               * borders a bit differently than rectangular symbols. &lt;p&gt;<a name="line.9884"></a>
<FONT color="green">9885</FONT>               * <a name="line.9885"></a>
<FONT color="green">9886</FONT>               * Internal borders are always drawn "centered", that is, half<a name="line.9886"></a>
<FONT color="green">9887</FONT>               * internal, half external. In part, this is because that is how<a name="line.9887"></a>
<FONT color="green">9888</FONT>               * "stroke" of the canvas API does it, so it's easier to implement.<a name="line.9888"></a>
<FONT color="green">9889</FONT>               * But mainly it is because, when you assemble several slices into a<a name="line.9889"></a>
<FONT color="green">9890</FONT>               * full pie, a centered border, provided that each slice has the same<a name="line.9890"></a>
<FONT color="green">9891</FONT>               * border color, is really the only choice that looks right (this is a<a name="line.9891"></a>
<FONT color="green">9892</FONT>               * constraint of the geometry how the slices fit together into a pie).<a name="line.9892"></a>
<FONT color="green">9893</FONT>               * &lt;p&gt;<a name="line.9893"></a>
<FONT color="green">9894</FONT>               * <a name="line.9894"></a>
<FONT color="green">9895</FONT>               * External borders (negative border width) are drawn outside the<a name="line.9895"></a>
<FONT color="green">9896</FONT>               * slice proper by doubling the thickness, and then over-filling the<a name="line.9896"></a>
<FONT color="green">9897</FONT>               * internal part of the border by issuing the fill after, instead of<a name="line.9897"></a>
<FONT color="green">9898</FONT>               * before, the border is drawn. Though external borders don't look<a name="line.9898"></a>
<FONT color="green">9899</FONT>               * right within a pie (because of how the slices occlude each other's<a name="line.9899"></a>
<FONT color="green">9900</FONT>               * borders) they can be handy for making slice selection borders that<a name="line.9900"></a>
<FONT color="green">9901</FONT>               * are drawn entirely outside of the selected slice.<a name="line.9901"></a>
<FONT color="green">9902</FONT>               */<a name="line.9902"></a>
<FONT color="green">9903</FONT>              int borderWidth = symbol.getBorderWidth();<a name="line.9903"></a>
<FONT color="green">9904</FONT>              int adjustedBorderWidth = (borderWidth &gt;= 0) ? borderWidth<a name="line.9904"></a>
<FONT color="green">9905</FONT>                  : 2 * Math.abs(borderWidth);<a name="line.9905"></a>
<FONT color="green">9906</FONT>    <a name="line.9906"></a>
<FONT color="green">9907</FONT>              /*<a name="line.9907"></a>
<FONT color="green">9908</FONT>               * With incubator's &lt;tt&gt;GWTCanvas&lt;/tt&gt;, IE7 &amp; Chrome draw 0 and 2*Pi<a name="line.9908"></a>
<FONT color="green">9909</FONT>               * slices incorrectly. See issues #278 #282 for more information: &lt;p&gt;<a name="line.9909"></a>
<FONT color="green">9910</FONT>               * <a name="line.9910"></a>
<FONT color="green">9911</FONT>               * http://code.google.com/p/google-web-toolkit-incubator/issues/detail?id=278<a name="line.9911"></a>
<FONT color="green">9912</FONT>               * http://code.google.com/p/google-web-toolkit-incubator/issues/detail?id=282 &lt;p&gt;<a name="line.9912"></a>
<FONT color="green">9913</FONT>               * <a name="line.9913"></a>
<FONT color="green">9914</FONT>               * Pies with &gt; 500 px radii are unlikely (tried using 10000, but it<a name="line.9914"></a>
<FONT color="green">9915</FONT>               * didn't work in Chrome, tried 1000, but it didn't work in IE7 in<a name="line.9915"></a>
<FONT color="green">9916</FONT>               * Vista with the circle-selection cursor on the oil price simulation<a name="line.9916"></a>
<FONT color="green">9917</FONT>               * chart.). Such almost but not quite full pie slices could be<a name="line.9917"></a>
<FONT color="green">9918</FONT>               * inappropriately rendered as full pies due to this workaround with<a name="line.9918"></a>
<FONT color="green">9919</FONT>               * pies with large radii. A lesser evil than dropping the entire slice<a name="line.9919"></a>
<FONT color="green">9920</FONT>               * for full pies.<a name="line.9920"></a>
<FONT color="green">9921</FONT>               */<a name="line.9921"></a>
<FONT color="green">9922</FONT>              final double MIN_DTHETA = 1. / 500.0;<a name="line.9922"></a>
<FONT color="green">9923</FONT>              final double MAX_DTHETA = 2 * Math.PI - MIN_DTHETA;<a name="line.9923"></a>
<FONT color="green">9924</FONT>    <a name="line.9924"></a>
<FONT color="green">9925</FONT>              // canvas measures angles clockwise from +x-axis;<a name="line.9925"></a>
<FONT color="green">9926</FONT>              // our angles are counter-clockwise from +x-axis<a name="line.9926"></a>
<FONT color="green">9927</FONT>              double dTheta = theta0 - theta1;<a name="line.9927"></a>
<FONT color="green">9928</FONT>              double angleStart = 2 * Math.PI - theta0;<a name="line.9928"></a>
<FONT color="green">9929</FONT>              double angleEnd = angleStart<a name="line.9929"></a>
<FONT color="green">9930</FONT>                  + Math.max(MIN_DTHETA, Math.min(dTheta,MAX_DTHETA));<a name="line.9930"></a>
<FONT color="green">9931</FONT>    <a name="line.9931"></a>
<FONT color="green">9932</FONT>              if (dTheta &gt;= MIN_DTHETA || borderWidth &lt; 0) {<a name="line.9932"></a>
<FONT color="green">9933</FONT>                canvas.beginPath();<a name="line.9933"></a>
<FONT color="green">9934</FONT>                canvas.setLineWidth(adjustedBorderWidth);<a name="line.9934"></a>
<FONT color="green">9935</FONT>    <a name="line.9935"></a>
<FONT color="green">9936</FONT>                canvas.arc(xPx - grp.x0, yPx - grp.y0, r, angleStart,<a name="line.9936"></a>
<FONT color="green">9937</FONT>                    angleEnd, false);<a name="line.9937"></a>
<FONT color="green">9938</FONT>                if (dTheta &lt;= MAX_DTHETA)<a name="line.9938"></a>
<FONT color="green">9939</FONT>                  canvas.lineTo(xPx - grp.x0, yPx - grp.y0);<a name="line.9939"></a>
<FONT color="green">9940</FONT>                // else avoid "line to center" in full pies<a name="line.9940"></a>
<FONT color="green">9941</FONT>    <a name="line.9941"></a>
<FONT color="green">9942</FONT>                canvas.closePath();<a name="line.9942"></a>
<FONT color="green">9943</FONT>    <a name="line.9943"></a>
<FONT color="green">9944</FONT>                String borderColor = symbol.getBorderColor();<a name="line.9944"></a>
<FONT color="green">9945</FONT>                String backgroundColor = symbol.getBackgroundColor();<a name="line.9945"></a>
<FONT color="green">9946</FONT>                /*<a name="line.9946"></a>
<FONT color="green">9947</FONT>                 * XXX: The approach to transparent border/fill used below is to<a name="line.9947"></a>
<FONT color="green">9948</FONT>                 * simply not stroke the border or to not fill the inside of the<a name="line.9948"></a>
<FONT color="green">9949</FONT>                 * path. This isn't exactly right, because the region where the<a name="line.9949"></a>
<FONT color="green">9950</FONT>                 * border overlaps the filled area does not always become<a name="line.9950"></a>
<FONT color="green">9951</FONT>                 * transparent when it should. These errors likely won't be noticed<a name="line.9951"></a>
<FONT color="green">9952</FONT>                 * in most usage scenarios, and without the ability to replace<a name="line.9952"></a>
<FONT color="green">9953</FONT>                 * filled/stroked regions with transparent pixels (I don't think<a name="line.9953"></a>
<FONT color="green">9954</FONT>                 * GWTCanvas can do this?) there isn't an easy fix.<a name="line.9954"></a>
<FONT color="green">9955</FONT>                 */<a name="line.9955"></a>
<FONT color="green">9956</FONT>    <a name="line.9956"></a>
<FONT color="green">9957</FONT>                // non-negative borders fill before stroking (thus<a name="line.9957"></a>
<FONT color="green">9958</FONT>                // stroke overwrites internal half of border)<a name="line.9958"></a>
<FONT color="green">9959</FONT>                if (borderWidth &gt;= 0 &amp;&amp; thickness &gt; 0<a name="line.9959"></a>
<FONT color="green">9960</FONT>                    &amp;&amp; TRANSPARENT_BORDER_COLOR != backgroundColor<a name="line.9960"></a>
<FONT color="green">9961</FONT>                    // GWTCanvas throws an exception w "transparent"<a name="line.9961"></a>
<FONT color="green">9962</FONT>                    &amp;&amp; "transparent" != backgroundColor) {<a name="line.9962"></a>
<FONT color="green">9963</FONT>                  canvas.setFillStyle(backgroundColor);<a name="line.9963"></a>
<FONT color="green">9964</FONT>                  canvas.fill();<a name="line.9964"></a>
<FONT color="green">9965</FONT>                }<a name="line.9965"></a>
<FONT color="green">9966</FONT>    <a name="line.9966"></a>
<FONT color="green">9967</FONT>                // stroke whenever a border is present<a name="line.9967"></a>
<FONT color="green">9968</FONT>                if (borderWidth != 0<a name="line.9968"></a>
<FONT color="green">9969</FONT>                    &amp;&amp; TRANSPARENT_BORDER_COLOR != borderColor<a name="line.9969"></a>
<FONT color="green">9970</FONT>                    &amp;&amp; "transparent" != borderColor) {<a name="line.9970"></a>
<FONT color="green">9971</FONT>                  canvas.setStrokeStyle(borderColor);<a name="line.9971"></a>
<FONT color="green">9972</FONT>                  canvas.stroke();<a name="line.9972"></a>
<FONT color="green">9973</FONT>                }<a name="line.9973"></a>
<FONT color="green">9974</FONT>    <a name="line.9974"></a>
<FONT color="green">9975</FONT>                // negative borders fill AFTER stroking (thus zapping<a name="line.9975"></a>
<FONT color="green">9976</FONT>                // the internal half of the stroked border).<a name="line.9976"></a>
<FONT color="green">9977</FONT>                if (borderWidth &lt; 0 &amp;&amp; thickness &gt; 0<a name="line.9977"></a>
<FONT color="green">9978</FONT>                    &amp;&amp; TRANSPARENT_BORDER_COLOR != backgroundColor<a name="line.9978"></a>
<FONT color="green">9979</FONT>                    &amp;&amp; "transparent" != backgroundColor) {<a name="line.9979"></a>
<FONT color="green">9980</FONT>                  canvas.setFillStyle(backgroundColor);<a name="line.9980"></a>
<FONT color="green">9981</FONT>                  canvas.fill();<a name="line.9981"></a>
<FONT color="green">9982</FONT>                }<a name="line.9982"></a>
<FONT color="green">9983</FONT>              }<a name="line.9983"></a>
<FONT color="green">9984</FONT>              // else 0-sized slice, 0 or internal border, is just dropped<a name="line.9984"></a>
<FONT color="green">9985</FONT>            } else {<a name="line.9985"></a>
<FONT color="green">9986</FONT>              if (0 == spacing)<a name="line.9986"></a>
<FONT color="green">9987</FONT>                spacing = 1;<a name="line.9987"></a>
<FONT color="green">9988</FONT>              // if center point is on the chart, draw it:<a name="line.9988"></a>
<FONT color="green">9989</FONT>    <a name="line.9989"></a>
<FONT color="green">9990</FONT>              double prevXPx = pp.xToPixel(prevX);<a name="line.9990"></a>
<FONT color="green">9991</FONT>              double prevYPx = pp.yToPixel(prevY, onY2);<a name="line.9991"></a>
<FONT color="green">9992</FONT>              double nextXPx = pp.xToPixel(nextX);<a name="line.9992"></a>
<FONT color="green">9993</FONT>              double nextYPx = pp.yToPixel(nextY, onY2);<a name="line.9993"></a>
<FONT color="green">9994</FONT>              int nBands = (int) Math.round(r / spacing);<a name="line.9994"></a>
<FONT color="green">9995</FONT>              /*<a name="line.9995"></a>
<FONT color="green">9996</FONT>               * Holds positions at which the current vertical or horizontal<a name="line.9996"></a>
<FONT color="green">9997</FONT>               * "gridline-like band" intersects the outter perimeter of the current<a name="line.9997"></a>
<FONT color="green">9998</FONT>               * pie slice. These positions are used to define the location and size<a name="line.9998"></a>
<FONT color="green">9999</FONT>               * of shading bars required for each pie slice.<a name="line.9999"></a>
<FONT color="green">10000</FONT>               * <a name="line.10000"></a>
<FONT color="green">10001</FONT>               * Note: Although most pie slice perimeters are convex and thus have<a name="line.10001"></a>
<FONT color="green">10002</FONT>               * perimeters that intersect a gridline in at most two points, pie<a name="line.10002"></a>
<FONT color="green">10003</FONT>               * slices that take up more than half of the entire pie have<a name="line.10003"></a>
<FONT color="green">10004</FONT>               * perimeters that can (across their pacman-like mouth) intersect a<a name="line.10004"></a>
<FONT color="green">10005</FONT>               * gridline at up to four points.<a name="line.10005"></a>
<FONT color="green">10006</FONT>               */<a name="line.10006"></a>
<FONT color="green">10007</FONT>              final int MAX_PIE_SLICE_PERIMETER_INTERSECTIONS = 4;<a name="line.10007"></a>
<FONT color="green">10008</FONT>              double[] p = new double[MAX_PIE_SLICE_PERIMETER_INTERSECTIONS];<a name="line.10008"></a>
<FONT color="green">10009</FONT>              final double EPS = 0.5;<a name="line.10009"></a>
<FONT color="green">10010</FONT>              SliceLimits sl = getSliceLimits(theta1, theta0);<a name="line.10010"></a>
<FONT color="green">10011</FONT>              boolean optimalIsVertical = (sl.yMax - sl.yMin) &gt; (sl.xMax - sl.xMin);<a name="line.10011"></a>
<FONT color="green">10012</FONT>              boolean isFullPie = (symbol.getPieSliceSize() == 1.0);<a name="line.10012"></a>
<FONT color="green">10013</FONT>              // perform any vertical shading that may be required:<a name="line.10013"></a>
<FONT color="green">10014</FONT>              if (nBands &gt; 0<a name="line.10014"></a>
<FONT color="green">10015</FONT>                  &amp;&amp; (verticallyShaded || (optimallyShaded &amp;&amp; optimalIsVertical))) {<a name="line.10015"></a>
<FONT color="green">10016</FONT>                for (int i = (int) Math.round(nBands * sl.xMin); i &lt; sl.xMax<a name="line.10016"></a>
<FONT color="green">10017</FONT>                    * nBands; i++) {<a name="line.10017"></a>
<FONT color="green">10018</FONT>                  int nP = 0;<a name="line.10018"></a>
<FONT color="green">10019</FONT>                  double dxPx = r * (i + 0.5) / nBands;<a name="line.10019"></a>
<FONT color="green">10020</FONT>                  double dyPx = Math.sqrt(r * r - dxPx * dxPx);<a name="line.10020"></a>
<FONT color="green">10021</FONT>                  // x of vertical line bisecting the shading band<a name="line.10021"></a>
<FONT color="green">10022</FONT>                  double xi = xPx + dxPx;<a name="line.10022"></a>
<FONT color="green">10023</FONT>                  // y-positions where this band crosses circle<a name="line.10023"></a>
<FONT color="green">10024</FONT>                  // perimeter<a name="line.10024"></a>
<FONT color="green">10025</FONT>                  double c1 = yPx - dyPx;<a name="line.10025"></a>
<FONT color="green">10026</FONT>                  double c2 = yPx + dyPx;<a name="line.10026"></a>
<FONT color="green">10027</FONT>                  // y-positions where this band crosses each slice<a name="line.10027"></a>
<FONT color="green">10028</FONT>                  // edge<a name="line.10028"></a>
<FONT color="green">10029</FONT>                  // (full pies don't have pie slice edges)<a name="line.10029"></a>
<FONT color="green">10030</FONT>                  double e1 = isFullPie ? Double.NaN<a name="line.10030"></a>
<FONT color="green">10031</FONT>                      : yWherePieEdgeIntersectsVerticalLine(xi,<a name="line.10031"></a>
<FONT color="green">10032</FONT>                      xPx, yPx, r, theta0);<a name="line.10032"></a>
<FONT color="green">10033</FONT>                  double e2 = isFullPie ? Double.NaN<a name="line.10033"></a>
<FONT color="green">10034</FONT>                      : yWherePieEdgeIntersectsVerticalLine(xi,<a name="line.10034"></a>
<FONT color="green">10035</FONT>                      xPx, yPx, r, theta1);<a name="line.10035"></a>
<FONT color="green">10036</FONT>                  // Exclude circle perimeter intercepts outside of<a name="line.10036"></a>
<FONT color="green">10037</FONT>                  // the slice. Note: Pixel y coordinates used in<a name="line.10037"></a>
<FONT color="green">10038</FONT>                  // browser increase going down, but cartesian y<a name="line.10038"></a>
<FONT color="green">10039</FONT>                  // coordinates used in trig functions increase<a name="line.10039"></a>
<FONT color="green">10040</FONT>                  // going up, hence the sign-flipping on second arg<a name="line.10040"></a>
<FONT color="green">10041</FONT>                  // of angle function below.<a name="line.10041"></a>
<FONT color="green">10042</FONT>                  if (angleInRange(angle(xi - xPx, yPx - c1), theta0,<a name="line.10042"></a>
<FONT color="green">10043</FONT>                      theta1))<a name="line.10043"></a>
<FONT color="green">10044</FONT>                    p[nP++] = c1;<a name="line.10044"></a>
<FONT color="green">10045</FONT>                  // intersection points sorted by increasing y within<a name="line.10045"></a>
<FONT color="green">10046</FONT>                  // p[]<a name="line.10046"></a>
<FONT color="green">10047</FONT>                  if (e1 &lt; e2) {<a name="line.10047"></a>
<FONT color="green">10048</FONT>                    // x!=x is a faster isNaN<a name="line.10048"></a>
<FONT color="green">10049</FONT>                    if (!(e1 != e1))<a name="line.10049"></a>
<FONT color="green">10050</FONT>                      p[nP++] = e1;<a name="line.10050"></a>
<FONT color="green">10051</FONT>                    if (!(e2 != e2))<a name="line.10051"></a>
<FONT color="green">10052</FONT>                      p[nP++] = e2;<a name="line.10052"></a>
<FONT color="green">10053</FONT>                  } else {<a name="line.10053"></a>
<FONT color="green">10054</FONT>                    if (!(e2 != e2))<a name="line.10054"></a>
<FONT color="green">10055</FONT>                      p[nP++] = e2;<a name="line.10055"></a>
<FONT color="green">10056</FONT>                    if (!(e1 != e1))<a name="line.10056"></a>
<FONT color="green">10057</FONT>                      p[nP++] = e1;<a name="line.10057"></a>
<FONT color="green">10058</FONT>                  }<a name="line.10058"></a>
<FONT color="green">10059</FONT>    <a name="line.10059"></a>
<FONT color="green">10060</FONT>                  if (angleInRange(angle(xi - xPx, yPx - c2), theta0,<a name="line.10060"></a>
<FONT color="green">10061</FONT>                      theta1))<a name="line.10061"></a>
<FONT color="green">10062</FONT>                    p[nP++] = c2;<a name="line.10062"></a>
<FONT color="green">10063</FONT>                  for (int j = 1; j &lt; nP; j++) {<a name="line.10063"></a>
<FONT color="green">10064</FONT>                    // logic below avoids drawing a line across the<a name="line.10064"></a>
<FONT color="green">10065</FONT>                    // non-convex "pacman mouth" that occurs with<a name="line.10065"></a>
<FONT color="green">10066</FONT>                    // any<a name="line.10066"></a>
<FONT color="green">10067</FONT>                    // bigger-than-half-pie-sized slices, by<a name="line.10067"></a>
<FONT color="green">10068</FONT>                    // requiring that a line drawn from the pie<a name="line.10068"></a>
<FONT color="green">10069</FONT>                    // center to an interpolated point on each<a name="line.10069"></a>
<FONT color="green">10070</FONT>                    // shading bar forms an angle in the slice's<a name="line.10070"></a>
<FONT color="green">10071</FONT>                    // angular range. We use a point 30% rather than<a name="line.10071"></a>
<FONT color="green">10072</FONT>                    // 50% of the way inbetween to avoid ever<a name="line.10072"></a>
<FONT color="green">10073</FONT>                    // hitting the<a name="line.10073"></a>
<FONT color="green">10074</FONT>                    // center of the pie (where angle is ambiguous).<a name="line.10074"></a>
<FONT color="green">10075</FONT>                    //<a name="line.10075"></a>
<FONT color="green">10076</FONT>                    // Note that, due to roundoff error, you cannot<a name="line.10076"></a>
<FONT color="green">10077</FONT>                    // ALWAYS rely on the (mathematically correct)<a name="line.10077"></a>
<FONT color="green">10078</FONT>                    // fact that problematic bars always connect<a name="line.10078"></a>
<FONT color="green">10079</FONT>                    // p[1]<a name="line.10079"></a>
<FONT color="green">10080</FONT>                    // and p[2].<a name="line.10080"></a>
<FONT color="green">10081</FONT>                    if (Math.abs(theta0 - theta1) &lt;= Math.PI<a name="line.10081"></a>
<FONT color="green">10082</FONT>                        || angleInRange(<a name="line.10082"></a>
<FONT color="green">10083</FONT>                        angle(<a name="line.10083"></a>
<FONT color="green">10084</FONT>                        xi - xPx,<a name="line.10084"></a>
<FONT color="green">10085</FONT>                        yPx<a name="line.10085"></a>
<FONT color="green">10086</FONT>                        - (0.3 * p[j] + 0.7 * p[j - 1])),<a name="line.10086"></a>
<FONT color="green">10087</FONT>                        theta0, theta1)) {<a name="line.10087"></a>
<FONT color="green">10088</FONT>                      // widening of EPS pixels on either side<a name="line.10088"></a>
<FONT color="green">10089</FONT>                      // fills in<a name="line.10089"></a>
<FONT color="green">10090</FONT>                      // tiny intra-slice gaps (that can otherwise<a name="line.10090"></a>
<FONT color="green">10091</FONT>                      // appear<a name="line.10091"></a>
<FONT color="green">10092</FONT>                      // due to roundoff) by making each bar a tad<a name="line.10092"></a>
<FONT color="green">10093</FONT>                      // bigger.<a name="line.10093"></a>
<FONT color="green">10094</FONT>                      realizeOneImageOfSymbol(pp, grp, arp,<a name="line.10094"></a>
<FONT color="green">10095</FONT>                          symbol, null, onY2, clipPlotArea,<a name="line.10095"></a>
<FONT color="green">10096</FONT>                          clipDecoratedChart, renderPaddingFactor,<a name="line.10096"></a>
<FONT color="green">10097</FONT>                          xi - 0.5 * thickness,<a name="line.10097"></a>
<FONT color="green">10098</FONT>                          p[j - 1] - EPS, prevXPx, prevYPx,<a name="line.10098"></a>
<FONT color="green">10099</FONT>                          nextXPx, nextYPx, thickness, p[j]<a name="line.10099"></a>
<FONT color="green">10100</FONT>                          - p[j - 1] + 2 * EPS);<a name="line.10100"></a>
<FONT color="green">10101</FONT>                    }<a name="line.10101"></a>
<FONT color="green">10102</FONT>                  }<a name="line.10102"></a>
<FONT color="green">10103</FONT>                }<a name="line.10103"></a>
<FONT color="green">10104</FONT>              }<a name="line.10104"></a>
<FONT color="green">10105</FONT>    <a name="line.10105"></a>
<FONT color="green">10106</FONT>              // Now do any required horizontal shading. This is<a name="line.10106"></a>
<FONT color="green">10107</FONT>              // basically the same as the code for vertical shading<a name="line.10107"></a>
<FONT color="green">10108</FONT>              // above (w appropriate transposition/adjustments).<a name="line.10108"></a>
<FONT color="green">10109</FONT>              if (nBands &gt; 0<a name="line.10109"></a>
<FONT color="green">10110</FONT>                  &amp;&amp; (horizontallyShaded || (optimallyShaded &amp;&amp; !optimalIsVertical))) {<a name="line.10110"></a>
<FONT color="green">10111</FONT>                for (int i = (int) Math.round(-nBands * sl.yMax); i &lt; -nBands<a name="line.10111"></a>
<FONT color="green">10112</FONT>                    * sl.yMin; i++) {<a name="line.10112"></a>
<FONT color="green">10113</FONT>                  int nP = 0;<a name="line.10113"></a>
<FONT color="green">10114</FONT>                  double dyPx = r * (i + 0.5) / nBands;<a name="line.10114"></a>
<FONT color="green">10115</FONT>                  double dxPx = Math.sqrt(r * r - dyPx * dyPx);<a name="line.10115"></a>
<FONT color="green">10116</FONT>                  // y of the horizontal line bisecting the shading<a name="line.10116"></a>
<FONT color="green">10117</FONT>                  // band<a name="line.10117"></a>
<FONT color="green">10118</FONT>                  double yi = yPx + dyPx;<a name="line.10118"></a>
<FONT color="green">10119</FONT>    <a name="line.10119"></a>
<FONT color="green">10120</FONT>                  // x-positions where this band crosses circle<a name="line.10120"></a>
<FONT color="green">10121</FONT>                  // perimeter<a name="line.10121"></a>
<FONT color="green">10122</FONT>                  double c1 = xPx - dxPx;<a name="line.10122"></a>
<FONT color="green">10123</FONT>                  double c2 = xPx + dxPx;<a name="line.10123"></a>
<FONT color="green">10124</FONT>    <a name="line.10124"></a>
<FONT color="green">10125</FONT>                  // x-positions where this band crosses each slice<a name="line.10125"></a>
<FONT color="green">10126</FONT>                  // edge<a name="line.10126"></a>
<FONT color="green">10127</FONT>                  // (full pies don't have pie slice edges)<a name="line.10127"></a>
<FONT color="green">10128</FONT>                  double e1 = isFullPie ? Double.NaN<a name="line.10128"></a>
<FONT color="green">10129</FONT>                      : xWherePieEdgeIntersectsHorizontalLine(yi,<a name="line.10129"></a>
<FONT color="green">10130</FONT>                      xPx, yPx, r, theta0);<a name="line.10130"></a>
<FONT color="green">10131</FONT>                  double e2 = isFullPie ? Double.NaN<a name="line.10131"></a>
<FONT color="green">10132</FONT>                      : xWherePieEdgeIntersectsHorizontalLine(yi,<a name="line.10132"></a>
<FONT color="green">10133</FONT>                      xPx, yPx, r, theta1);<a name="line.10133"></a>
<FONT color="green">10134</FONT>                  // exclude circle perimeter intercepts outside of<a name="line.10134"></a>
<FONT color="green">10135</FONT>                  // the slice<a name="line.10135"></a>
<FONT color="green">10136</FONT>                  if (angleInRange(angle(c1 - xPx, yPx - yi), theta0,<a name="line.10136"></a>
<FONT color="green">10137</FONT>                      theta1))<a name="line.10137"></a>
<FONT color="green">10138</FONT>                    p[nP++] = c1;<a name="line.10138"></a>
<FONT color="green">10139</FONT>    <a name="line.10139"></a>
<FONT color="green">10140</FONT>                  // intersection points sorted by increasing x within<a name="line.10140"></a>
<FONT color="green">10141</FONT>                  // p[]<a name="line.10141"></a>
<FONT color="green">10142</FONT>                  if (e1 &lt; e2) {<a name="line.10142"></a>
<FONT color="green">10143</FONT>                    // x!=x is a faster isNaN<a name="line.10143"></a>
<FONT color="green">10144</FONT>                    if (!(e1 != e1))<a name="line.10144"></a>
<FONT color="green">10145</FONT>                      p[nP++] = e1;<a name="line.10145"></a>
<FONT color="green">10146</FONT>                    if (!(e2 != e2))<a name="line.10146"></a>
<FONT color="green">10147</FONT>                      p[nP++] = e2;<a name="line.10147"></a>
<FONT color="green">10148</FONT>                  } else {<a name="line.10148"></a>
<FONT color="green">10149</FONT>                    if (!(e2 != e2))<a name="line.10149"></a>
<FONT color="green">10150</FONT>                      p[nP++] = e2;<a name="line.10150"></a>
<FONT color="green">10151</FONT>                    if (!(e1 != e1))<a name="line.10151"></a>
<FONT color="green">10152</FONT>                      p[nP++] = e1;<a name="line.10152"></a>
<FONT color="green">10153</FONT>                  }<a name="line.10153"></a>
<FONT color="green">10154</FONT>    <a name="line.10154"></a>
<FONT color="green">10155</FONT>                  if (angleInRange(angle(c2 - xPx, yPx - yi), theta0,<a name="line.10155"></a>
<FONT color="green">10156</FONT>                      theta1))<a name="line.10156"></a>
<FONT color="green">10157</FONT>                    p[nP++] = c2;<a name="line.10157"></a>
<FONT color="green">10158</FONT>    <a name="line.10158"></a>
<FONT color="green">10159</FONT>                  for (int j = 1; j &lt; nP; j++) {<a name="line.10159"></a>
<FONT color="green">10160</FONT>                    // c.f. comment on corresponding vertical code<a name="line.10160"></a>
<FONT color="green">10161</FONT>                    // above.<a name="line.10161"></a>
<FONT color="green">10162</FONT>                    if (Math.abs(theta0 - theta1) &lt;= Math.PI<a name="line.10162"></a>
<FONT color="green">10163</FONT>                        || angleInRange(angle(<a name="line.10163"></a>
<FONT color="green">10164</FONT>                        (0.3 * p[j] + 0.7 * p[j - 1])<a name="line.10164"></a>
<FONT color="green">10165</FONT>                        - xPx, yPx - yi),<a name="line.10165"></a>
<FONT color="green">10166</FONT>                        theta0, theta1)) {<a name="line.10166"></a>
<FONT color="green">10167</FONT>                      // widening of EPS pixels on either side<a name="line.10167"></a>
<FONT color="green">10168</FONT>                      // fills in<a name="line.10168"></a>
<FONT color="green">10169</FONT>                      // tiny intra-slice gaps that can sometimes<a name="line.10169"></a>
<FONT color="green">10170</FONT>                      // appear<a name="line.10170"></a>
<FONT color="green">10171</FONT>                      // by making slices just a tad bigger.<a name="line.10171"></a>
<FONT color="green">10172</FONT>                      realizeOneImageOfSymbol(pp, grp, arp,<a name="line.10172"></a>
<FONT color="green">10173</FONT>                          symbol, null, onY2, clipPlotArea,<a name="line.10173"></a>
<FONT color="green">10174</FONT>                          clipDecoratedChart, renderPaddingFactor,<a name="line.10174"></a>
<FONT color="green">10175</FONT>                          p[j - 1] - EPS,<a name="line.10175"></a>
<FONT color="green">10176</FONT>                          yi - 0.5 * thickness, prevXPx,<a name="line.10176"></a>
<FONT color="green">10177</FONT>                          prevYPx, nextXPx, nextYPx, p[j]<a name="line.10177"></a>
<FONT color="green">10178</FONT>                          - p[j - 1] + 2 * EPS,<a name="line.10178"></a>
<FONT color="green">10179</FONT>                          thickness);<a name="line.10179"></a>
<FONT color="green">10180</FONT>                    }<a name="line.10180"></a>
<FONT color="green">10181</FONT>                  }<a name="line.10181"></a>
<FONT color="green">10182</FONT>                }<a name="line.10182"></a>
<FONT color="green">10183</FONT>              }<a name="line.10183"></a>
<FONT color="green">10184</FONT>            }<a name="line.10184"></a>
<FONT color="green">10185</FONT>    <a name="line.10185"></a>
<FONT color="green">10186</FONT>            // if the image has an attached label, realize that<a name="line.10186"></a>
<FONT color="green">10187</FONT>            if (annotation != null<a name="line.10187"></a>
<FONT color="green">10188</FONT>                &amp;&amp; (annotation.getText() != null ||<a name="line.10188"></a>
<FONT color="green">10189</FONT>                    annotation.getWidget() != null)<a name="line.10189"></a>
<FONT color="green">10190</FONT>                &amp;&amp; annotation.getVisible()) {<a name="line.10190"></a>
<FONT color="green">10191</FONT>    <a name="line.10191"></a>
<FONT color="green">10192</FONT>              // plus x-axis, for shifts, always corresponds to<a name="line.10192"></a>
<FONT color="green">10193</FONT>              // outward pointing radius that bisects the slice,<a name="line.10193"></a>
<FONT color="green">10194</FONT>              // with positive y axis, for shifts, at a 90 degree<a name="line.10194"></a>
<FONT color="green">10195</FONT>              // counter-clockwise rotation from this x. Basic<a name="line.10195"></a>
<FONT color="green">10196</FONT>              // trigonometry and this spec yeilds lines below.<a name="line.10196"></a>
<FONT color="green">10197</FONT>              double thetaMid = (theta0 + theta1) / 2.;<a name="line.10197"></a>
<FONT color="green">10198</FONT>              double dX = annotation.getXShift();<a name="line.10198"></a>
<FONT color="green">10199</FONT>              double dY = annotation.getYShift();<a name="line.10199"></a>
<FONT color="green">10200</FONT>              double sinTheta = Math.sin(thetaMid);<a name="line.10200"></a>
<FONT color="green">10201</FONT>              double cosTheta = Math.cos(thetaMid);<a name="line.10201"></a>
<FONT color="green">10202</FONT>              AnnotationLocation loc = annotation.getLocation();<a name="line.10202"></a>
<FONT color="green">10203</FONT>              if (null == loc)<a name="line.10203"></a>
<FONT color="green">10204</FONT>                loc = defaultAnnotationLocation();<a name="line.10204"></a>
<FONT color="green">10205</FONT>              // note: pixel Y increases down but yShift &amp; "trig Y"<a name="line.10205"></a>
<FONT color="green">10206</FONT>              // increase going up, which explains dY sign reversal<a name="line.10206"></a>
<FONT color="green">10207</FONT>              arp.renderAnnotation(annotation,<a name="line.10207"></a>
<FONT color="green">10208</FONT>                  loc.decodePieLocation(thetaMid), <a name="line.10208"></a>
<FONT color="green">10209</FONT>                  xPx + (r + dX) * cosTheta - dY * sinTheta, <a name="line.10209"></a>
<FONT color="green">10210</FONT>                  yPx - (r + dX) * sinTheta - dY * cosTheta, <a name="line.10210"></a>
<FONT color="green">10211</FONT>                  0, 0, symbol);<a name="line.10211"></a>
<FONT color="green">10212</FONT>            }<a name="line.10212"></a>
<FONT color="green">10213</FONT>          }<a name="line.10213"></a>
<FONT color="green">10214</FONT>        } // end of class PieSliceSymbolType<a name="line.10214"></a>
<FONT color="green">10215</FONT>    <a name="line.10215"></a>
<FONT color="green">10216</FONT>        private static class VBarBottom extends SymbolType {<a name="line.10216"></a>
<FONT color="green">10217</FONT>          VBarBottom(int wm, int hm) {<a name="line.10217"></a>
<FONT color="green">10218</FONT>            super(wm, hm, 0.5, 0.5, 0.5, 0.5, Boolean.FALSE);<a name="line.10218"></a>
<FONT color="green">10219</FONT>          }<a name="line.10219"></a>
<FONT color="green">10220</FONT>    <a name="line.10220"></a>
<FONT color="green">10221</FONT>          @Override<a name="line.10221"></a>
<FONT color="green">10222</FONT>          protected double defaultFillSpacing() {<a name="line.10222"></a>
<FONT color="green">10223</FONT>            return DEFAULT_BAR_FILL_SPACING;<a name="line.10223"></a>
<FONT color="green">10224</FONT>          }<a name="line.10224"></a>
<FONT color="green">10225</FONT>    <a name="line.10225"></a>
<FONT color="green">10226</FONT>          @Override<a name="line.10226"></a>
<FONT color="green">10227</FONT>          protected AnnotationLocation defaultHoverLocation() {<a name="line.10227"></a>
<FONT color="green">10228</FONT>            return DEFAULT_VBARBOTTOM_HOVER_LOCATION;<a name="line.10228"></a>
<FONT color="green">10229</FONT>          }<a name="line.10229"></a>
<FONT color="green">10230</FONT>    <a name="line.10230"></a>
<FONT color="green">10231</FONT>          @Override<a name="line.10231"></a>
<FONT color="green">10232</FONT>          public double getAdjustedHeight(double height, double y,<a name="line.10232"></a>
<FONT color="green">10233</FONT>              double yPrev, double yNext, double yMin, double yMax,<a name="line.10233"></a>
<FONT color="green">10234</FONT>              double yMid) {<a name="line.10234"></a>
<FONT color="green">10235</FONT>            return yMax - y;<a name="line.10235"></a>
<FONT color="green">10236</FONT>          }<a name="line.10236"></a>
<FONT color="green">10237</FONT>    <a name="line.10237"></a>
<FONT color="green">10238</FONT>          @Override<a name="line.10238"></a>
<FONT color="green">10239</FONT>          int getIconHeight(int legendFontSize) {<a name="line.10239"></a>
<FONT color="green">10240</FONT>            return legendFontSize;<a name="line.10240"></a>
<FONT color="green">10241</FONT>          }<a name="line.10241"></a>
<FONT color="green">10242</FONT>    <a name="line.10242"></a>
<FONT color="green">10243</FONT>          @Override<a name="line.10243"></a>
<FONT color="green">10244</FONT>          int getIconWidth(int legendFontSize) {<a name="line.10244"></a>
<FONT color="green">10245</FONT>            return (int) Math.round(legendFontSize / 2.);<a name="line.10245"></a>
<FONT color="green">10246</FONT>          }<a name="line.10246"></a>
<FONT color="green">10247</FONT>        } // end of class VBarBottom<a name="line.10247"></a>
<FONT color="green">10248</FONT>    <a name="line.10248"></a>
<FONT color="green">10249</FONT>        private static class VBarBaseline extends SymbolType {<a name="line.10249"></a>
<FONT color="green">10250</FONT>          VBarBaseline(int wm, int hm) {<a name="line.10250"></a>
<FONT color="green">10251</FONT>            super(wm, hm, 0, 0, 0.5, 0.5, Boolean.FALSE);<a name="line.10251"></a>
<FONT color="green">10252</FONT>          }<a name="line.10252"></a>
<FONT color="green">10253</FONT>    <a name="line.10253"></a>
<FONT color="green">10254</FONT>          @Override<a name="line.10254"></a>
<FONT color="green">10255</FONT>          protected double defaultFillSpacing() {<a name="line.10255"></a>
<FONT color="green">10256</FONT>            return DEFAULT_BAR_FILL_SPACING;<a name="line.10256"></a>
<FONT color="green">10257</FONT>          }<a name="line.10257"></a>
<FONT color="green">10258</FONT>    <a name="line.10258"></a>
<FONT color="green">10259</FONT>          @Override<a name="line.10259"></a>
<FONT color="green">10260</FONT>          protected AnnotationLocation defaultHoverLocation() {<a name="line.10260"></a>
<FONT color="green">10261</FONT>            return DEFAULT_VBAR_BASELINE_HOVER_LOCATION;<a name="line.10261"></a>
<FONT color="green">10262</FONT>          }<a name="line.10262"></a>
<FONT color="green">10263</FONT>    <a name="line.10263"></a>
<FONT color="green">10264</FONT>          @Override<a name="line.10264"></a>
<FONT color="green">10265</FONT>          public double getAdjustedHeight(double height, double y,<a name="line.10265"></a>
<FONT color="green">10266</FONT>              double yPrev, double yNext, double yMin, double yMax,<a name="line.10266"></a>
<FONT color="green">10267</FONT>              double yMid) {<a name="line.10267"></a>
<FONT color="green">10268</FONT>            return y - yMid;<a name="line.10268"></a>
<FONT color="green">10269</FONT>          }<a name="line.10269"></a>
<FONT color="green">10270</FONT>    <a name="line.10270"></a>
<FONT color="green">10271</FONT>          @Override<a name="line.10271"></a>
<FONT color="green">10272</FONT>          double getUpperLeftY(double height, double y, double yPrev,<a name="line.10272"></a>
<FONT color="green">10273</FONT>              double yNext, double yMin, double yMax, double yMid,<a name="line.10273"></a>
<FONT color="green">10274</FONT>              int yMouse) {<a name="line.10274"></a>
<FONT color="green">10275</FONT>            return yMid;<a name="line.10275"></a>
<FONT color="green">10276</FONT>          }<a name="line.10276"></a>
<FONT color="green">10277</FONT>    <a name="line.10277"></a>
<FONT color="green">10278</FONT>          @Override<a name="line.10278"></a>
<FONT color="green">10279</FONT>          int getIconHeight(int legendFontSize) {<a name="line.10279"></a>
<FONT color="green">10280</FONT>            return legendFontSize;<a name="line.10280"></a>
<FONT color="green">10281</FONT>          }<a name="line.10281"></a>
<FONT color="green">10282</FONT>    <a name="line.10282"></a>
<FONT color="green">10283</FONT>          @Override<a name="line.10283"></a>
<FONT color="green">10284</FONT>          int getIconWidth(int legendFontSize) {<a name="line.10284"></a>
<FONT color="green">10285</FONT>            return (int) Math.round(legendFontSize / 2.);<a name="line.10285"></a>
<FONT color="green">10286</FONT>          }<a name="line.10286"></a>
<FONT color="green">10287</FONT>        } // end of class VBarBaseline<a name="line.10287"></a>
<FONT color="green">10288</FONT>    <a name="line.10288"></a>
<FONT color="green">10289</FONT>        /**<a name="line.10289"></a>
<FONT color="green">10290</FONT>         * Use vertical bars that extend from the top of the chart to each point on<a name="line.10290"></a>
<FONT color="green">10291</FONT>         * the curve.<a name="line.10291"></a>
<FONT color="green">10292</FONT>         */<a name="line.10292"></a>
<FONT color="green">10293</FONT>        private static class VBarTop extends SymbolType {<a name="line.10293"></a>
<FONT color="green">10294</FONT>          VBarTop(int wm, int hm) {<a name="line.10294"></a>
<FONT color="green">10295</FONT>            super(wm, hm, 0.5, 0.5, 0.5, 0.5, Boolean.FALSE);<a name="line.10295"></a>
<FONT color="green">10296</FONT>          }<a name="line.10296"></a>
<FONT color="green">10297</FONT>    <a name="line.10297"></a>
<FONT color="green">10298</FONT>          @Override<a name="line.10298"></a>
<FONT color="green">10299</FONT>          protected double defaultFillSpacing() {<a name="line.10299"></a>
<FONT color="green">10300</FONT>            return DEFAULT_BAR_FILL_SPACING;<a name="line.10300"></a>
<FONT color="green">10301</FONT>          }<a name="line.10301"></a>
<FONT color="green">10302</FONT>    <a name="line.10302"></a>
<FONT color="green">10303</FONT>          @Override<a name="line.10303"></a>
<FONT color="green">10304</FONT>          protected AnnotationLocation defaultHoverLocation() {<a name="line.10304"></a>
<FONT color="green">10305</FONT>            return DEFAULT_VBARTOP_HOVER_LOCATION;<a name="line.10305"></a>
<FONT color="green">10306</FONT>          }<a name="line.10306"></a>
<FONT color="green">10307</FONT>    <a name="line.10307"></a>
<FONT color="green">10308</FONT>          @Override<a name="line.10308"></a>
<FONT color="green">10309</FONT>          public double getAdjustedHeight(double height, double y,<a name="line.10309"></a>
<FONT color="green">10310</FONT>              double yPrev, double yNext, double yMin, double yMax,<a name="line.10310"></a>
<FONT color="green">10311</FONT>              double yMid) {<a name="line.10311"></a>
<FONT color="green">10312</FONT>            return y - yMin;<a name="line.10312"></a>
<FONT color="green">10313</FONT>          }<a name="line.10313"></a>
<FONT color="green">10314</FONT>    <a name="line.10314"></a>
<FONT color="green">10315</FONT>          @Override<a name="line.10315"></a>
<FONT color="green">10316</FONT>          int getIconHeight(int legendFontSize) {<a name="line.10316"></a>
<FONT color="green">10317</FONT>            return legendFontSize;<a name="line.10317"></a>
<FONT color="green">10318</FONT>          }<a name="line.10318"></a>
<FONT color="green">10319</FONT>    <a name="line.10319"></a>
<FONT color="green">10320</FONT>          @Override<a name="line.10320"></a>
<FONT color="green">10321</FONT>          int getIconWidth(int legendFontSize) {<a name="line.10321"></a>
<FONT color="green">10322</FONT>            return (int) Math.round(legendFontSize / 2.);<a name="line.10322"></a>
<FONT color="green">10323</FONT>          }<a name="line.10323"></a>
<FONT color="green">10324</FONT>        } // end of class VBarTop<a name="line.10324"></a>
<FONT color="green">10325</FONT>    <a name="line.10325"></a>
<FONT color="green">10326</FONT>        /**<a name="line.10326"></a>
<FONT color="green">10327</FONT>         * Points on curves with this symbol type are positioned at the center of<a name="line.10327"></a>
<FONT color="green">10328</FONT>         * the plot area, and do not have a visible symbol.<a name="line.10328"></a>
<FONT color="green">10329</FONT>         * &lt;p&gt;<a name="line.10329"></a>
<FONT color="green">10330</FONT>         * <a name="line.10330"></a>
<FONT color="green">10331</FONT>         * Use this symbol type, along with the &lt;tt&gt;setAnnotationLocation&lt;/tt&gt;,<a name="line.10331"></a>
<FONT color="green">10332</FONT>         * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; and &lt;tt&gt;setAnnotationYShift&lt;/tt&gt; methods, to<a name="line.10332"></a>
<FONT color="green">10333</FONT>         * position annotations relative to the center of the plot area.<a name="line.10333"></a>
<FONT color="green">10334</FONT>         * &lt;p&gt;<a name="line.10334"></a>
<FONT color="green">10335</FONT>         * <a name="line.10335"></a>
<FONT color="green">10336</FONT>         * &lt;small&gt; &lt;i&gt;Position isn't everything, but it matters:&lt;/i&gt; The<a name="line.10336"></a>
<FONT color="green">10337</FONT>         * &lt;tt&gt;(x,y)&lt;/tt&gt; position of points on curves that employ one of these<a name="line.10337"></a>
<FONT color="green">10338</FONT>         * &lt;tt&gt;ANCHOR_*&lt;/tt&gt; symbol types does not determine where the annotation is<a name="line.10338"></a>
<FONT color="green">10339</FONT>         * placed. &lt;i&gt;But&lt;/i&gt; it &lt;i&gt;could&lt;/i&gt; determine if that annotation gets<a name="line.10339"></a>
<FONT color="green">10340</FONT>         * clipped off the chart entirely. So if, as is frequently the case, you<a name="line.10340"></a>
<FONT color="green">10341</FONT>         * never want your anchored annotations clipped off, use<a name="line.10341"></a>
<FONT color="green">10342</FONT>         * &lt;tt&gt;(+/-Double.MAX_VALUE,<a name="line.10342"></a>
<FONT color="green">10343</FONT>         * * +/-Double.MAX_VALUE)&lt;/tt&gt; as the coordinates of each annotatated point.<a name="line.10343"></a>
<FONT color="green">10344</FONT>         * Since GChart recognizes these special values as keywords the denote one<a name="line.10344"></a>
<FONT color="green">10345</FONT>         * of the corners of the plot area, the points associated with these<a name="line.10345"></a>
<FONT color="green">10346</FONT>         * annotations are always inside the plot area, and thus never clipped.<a name="line.10346"></a>
<FONT color="green">10347</FONT>         * &lt;/small&gt;<a name="line.10347"></a>
<FONT color="green">10348</FONT>         * <a name="line.10348"></a>
<FONT color="green">10349</FONT>         * <a name="line.10349"></a>
<FONT color="green">10350</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.10350"></a>
<FONT color="green">10351</FONT>         * @see Curve.Point#setAnnotationXShift setAnnotationXShift<a name="line.10351"></a>
<FONT color="green">10352</FONT>         * @see Curve.Point#setAnnotationYShift setAnnotationYShift<a name="line.10352"></a>
<FONT color="green">10353</FONT>         */<a name="line.10353"></a>
<FONT color="green">10354</FONT>        public static SymbolType ANCHOR_CENTER = new AnnotationAnchor(<a name="line.10354"></a>
<FONT color="green">10355</FONT>            AnnotationLocation.CENTER);<a name="line.10355"></a>
<FONT color="green">10356</FONT>    <a name="line.10356"></a>
<FONT color="green">10357</FONT>        /**<a name="line.10357"></a>
<FONT color="green">10358</FONT>         * Points on curves with this symbol type are positioned at the center of<a name="line.10358"></a>
<FONT color="green">10359</FONT>         * the right edge of the plot area, and do not have a visible symbol.<a name="line.10359"></a>
<FONT color="green">10360</FONT>         * &lt;p&gt;<a name="line.10360"></a>
<FONT color="green">10361</FONT>         * <a name="line.10361"></a>
<FONT color="green">10362</FONT>         * Use this symbol type, along with the &lt;tt&gt;setAnnotationLocation&lt;/tt&gt;,<a name="line.10362"></a>
<FONT color="green">10363</FONT>         * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; and &lt;tt&gt;setAnnotationYShift&lt;/tt&gt; methods, to<a name="line.10363"></a>
<FONT color="green">10364</FONT>         * position annotations relative to the center of the right edge of the plot<a name="line.10364"></a>
<FONT color="green">10365</FONT>         * area.<a name="line.10365"></a>
<FONT color="green">10366</FONT>         * <a name="line.10366"></a>
<FONT color="green">10367</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.10367"></a>
<FONT color="green">10368</FONT>         * @see Curve.Point#setAnnotationXShift setAnnotationXShift<a name="line.10368"></a>
<FONT color="green">10369</FONT>         * @see Curve.Point#setAnnotationYShift setAnnotationYShift<a name="line.10369"></a>
<FONT color="green">10370</FONT>         * @see #ANCHOR_CENTER ANCHOR_CENTER<a name="line.10370"></a>
<FONT color="green">10371</FONT>         * <a name="line.10371"></a>
<FONT color="green">10372</FONT>         */<a name="line.10372"></a>
<FONT color="green">10373</FONT>        public static SymbolType ANCHOR_EAST = new AnnotationAnchor(<a name="line.10373"></a>
<FONT color="green">10374</FONT>            AnnotationLocation.EAST);<a name="line.10374"></a>
<FONT color="green">10375</FONT>    <a name="line.10375"></a>
<FONT color="green">10376</FONT>        /**<a name="line.10376"></a>
<FONT color="green">10377</FONT>         * When passed to the &lt;tt&gt;setHoverAnnotationSymbolType&lt;/tt&gt; method, this<a name="line.10377"></a>
<FONT color="green">10378</FONT>         * symbol type enables &lt;tt&gt;setTitle&lt;/tt&gt;-like,<a name="line.10378"></a>
<FONT color="green">10379</FONT>         * "anchored at the mouse cursor" hover annotation positioning.<a name="line.10379"></a>
<FONT color="green">10380</FONT>         * Specifically, hover annotions act as if they were annotations of 1px x<a name="line.10380"></a>
<FONT color="green">10381</FONT>         * 1px points placed at the current mouse cursor position.<a name="line.10381"></a>
<FONT color="green">10382</FONT>         * &lt;p&gt;<a name="line.10382"></a>
<FONT color="green">10383</FONT>         * <a name="line.10383"></a>
<FONT color="green">10384</FONT>         * Because this and its related symbol types,<a name="line.10384"></a>
<FONT color="green">10385</FONT>         * &lt;tt&gt;ANCHOR_MOUSE_SNAP_TO_X&lt;/tt&gt; and &lt;tt&gt;ANCHOR_MOUSE_SNAP_TO_Y&lt;/tt&gt;, are<a name="line.10385"></a>
<FONT color="green">10386</FONT>         * intended only to facilitate positioning of hover-induced pop-up<a name="line.10386"></a>
<FONT color="green">10387</FONT>         * annotations (via the &lt;tt&gt;setHoverAnnotationSymbolType&lt;/tt&gt; method) I<a name="line.10387"></a>
<FONT color="green">10388</FONT>         * cannot imagine a scenario where it would make sense to use them as the<a name="line.10388"></a>
<FONT color="green">10389</FONT>         * symbol type of an ordinary, user defined, curve (if you find a use for<a name="line.10389"></a>
<FONT color="green">10390</FONT>         * this, please let me know).<a name="line.10390"></a>
<FONT color="green">10391</FONT>         * <a name="line.10391"></a>
<FONT color="green">10392</FONT>         * <a name="line.10392"></a>
<FONT color="green">10393</FONT>         * @see #ANCHOR_MOUSE_SNAP_TO_X ANCHOR_MOUSE_SNAP_TO_X<a name="line.10393"></a>
<FONT color="green">10394</FONT>         * @see #ANCHOR_MOUSE_SNAP_TO_Y ANCHOR_MOUSE_SNAP_TO_Y<a name="line.10394"></a>
<FONT color="green">10395</FONT>         * @see #ANCHOR_CENTER ANCHOR_CENTER<a name="line.10395"></a>
<FONT color="green">10396</FONT>         * @see Symbol#setHoverLocation setHoverLocation<a name="line.10396"></a>
<FONT color="green">10397</FONT>         * @see Symbol#setHoverAnnotationSymbolType setHoverAnnotationSymbolType<a name="line.10397"></a>
<FONT color="green">10398</FONT>         * @see Symbol#setHovertextTemplate setHovertextTemplate<a name="line.10398"></a>
<FONT color="green">10399</FONT>         * @see Symbol#setHoverXShift setHoverXShift<a name="line.10399"></a>
<FONT color="green">10400</FONT>         * @see Symbol#setHoverYShift setHoverYShift<a name="line.10400"></a>
<FONT color="green">10401</FONT>         * @see Symbol#setHoverWidget setHoverWidget<a name="line.10401"></a>
<FONT color="green">10402</FONT>         */<a name="line.10402"></a>
<FONT color="green">10403</FONT>        public static SymbolType ANCHOR_MOUSE = new AnnotationAnchor(<a name="line.10403"></a>
<FONT color="green">10404</FONT>            AnnotationLocation.AT_THE_MOUSE);<a name="line.10404"></a>
<FONT color="green">10405</FONT>    <a name="line.10405"></a>
<FONT color="green">10406</FONT>        /**<a name="line.10406"></a>
<FONT color="green">10407</FONT>         * The same as the ANCHOR_MOUSE symbol type, except that the x coordinate of<a name="line.10407"></a>
<FONT color="green">10408</FONT>         * the rendered symbol is taken from the x coordinate of the point, rather<a name="line.10408"></a>
<FONT color="green">10409</FONT>         * than the x coordinate of the mouse.<a name="line.10409"></a>
<FONT color="green">10410</FONT>         * <a name="line.10410"></a>
<FONT color="green">10411</FONT>         * @see #ANCHOR_MOUSE ANCHOR_MOUSE<a name="line.10411"></a>
<FONT color="green">10412</FONT>         * @see #ANCHOR_MOUSE_SNAP_TO_Y ANCHOR_MOUSE_SNAP_TO_Y<a name="line.10412"></a>
<FONT color="green">10413</FONT>         * <a name="line.10413"></a>
<FONT color="green">10414</FONT>         */<a name="line.10414"></a>
<FONT color="green">10415</FONT>        public static SymbolType ANCHOR_MOUSE_SNAP_TO_X = new AnnotationAnchor(<a name="line.10415"></a>
<FONT color="green">10416</FONT>            AnnotationLocation.AT_THE_MOUSE_SNAP_TO_X);<a name="line.10416"></a>
<FONT color="green">10417</FONT>        /**<a name="line.10417"></a>
<FONT color="green">10418</FONT>         * The same as the ANCHOR_MOUSE symbol type, except that the y coordinate of<a name="line.10418"></a>
<FONT color="green">10419</FONT>         * the rendered symbol is taken from the y coordinate of the point, rather<a name="line.10419"></a>
<FONT color="green">10420</FONT>         * than the y coordinate of the mouse.<a name="line.10420"></a>
<FONT color="green">10421</FONT>         * <a name="line.10421"></a>
<FONT color="green">10422</FONT>         * @see #ANCHOR_MOUSE ANCHOR_MOUSE<a name="line.10422"></a>
<FONT color="green">10423</FONT>         * @see #ANCHOR_MOUSE_SNAP_TO_X ANCHOR_MOUSE_SNAP_TO_X<a name="line.10423"></a>
<FONT color="green">10424</FONT>         * <a name="line.10424"></a>
<FONT color="green">10425</FONT>         */<a name="line.10425"></a>
<FONT color="green">10426</FONT>        public static SymbolType ANCHOR_MOUSE_SNAP_TO_Y = new AnnotationAnchor(<a name="line.10426"></a>
<FONT color="green">10427</FONT>            AnnotationLocation.AT_THE_MOUSE_SNAP_TO_Y);<a name="line.10427"></a>
<FONT color="green">10428</FONT>        /**<a name="line.10428"></a>
<FONT color="green">10429</FONT>         * Points on curves with this symbol type are positioned at the center of<a name="line.10429"></a>
<FONT color="green">10430</FONT>         * the top edge of the plot area, and do not have a visible symbol.<a name="line.10430"></a>
<FONT color="green">10431</FONT>         * &lt;p&gt;<a name="line.10431"></a>
<FONT color="green">10432</FONT>         * <a name="line.10432"></a>
<FONT color="green">10433</FONT>         * Use this symbol type, along with the &lt;tt&gt;setAnnotationLocation&lt;/tt&gt;,<a name="line.10433"></a>
<FONT color="green">10434</FONT>         * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; and &lt;tt&gt;setAnnotationYShift&lt;/tt&gt; methods, to<a name="line.10434"></a>
<FONT color="green">10435</FONT>         * position annotations relative to the center of the top edge of the plot<a name="line.10435"></a>
<FONT color="green">10436</FONT>         * area.<a name="line.10436"></a>
<FONT color="green">10437</FONT>         * <a name="line.10437"></a>
<FONT color="green">10438</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.10438"></a>
<FONT color="green">10439</FONT>         * @see Curve.Point#setAnnotationXShift setAnnotationXShift<a name="line.10439"></a>
<FONT color="green">10440</FONT>         * @see Curve.Point#setAnnotationYShift setAnnotationYShift<a name="line.10440"></a>
<FONT color="green">10441</FONT>         * @see #ANCHOR_CENTER ANCHOR_CENTER<a name="line.10441"></a>
<FONT color="green">10442</FONT>         * <a name="line.10442"></a>
<FONT color="green">10443</FONT>         */<a name="line.10443"></a>
<FONT color="green">10444</FONT>        public static SymbolType ANCHOR_NORTH = new AnnotationAnchor(<a name="line.10444"></a>
<FONT color="green">10445</FONT>            AnnotationLocation.NORTH);<a name="line.10445"></a>
<FONT color="green">10446</FONT>        /**<a name="line.10446"></a>
<FONT color="green">10447</FONT>         * Points on curves with this symbol type are positioned at the upper right<a name="line.10447"></a>
<FONT color="green">10448</FONT>         * corner of the plot area, and do not have a visible symbol.<a name="line.10448"></a>
<FONT color="green">10449</FONT>         * &lt;p&gt;<a name="line.10449"></a>
<FONT color="green">10450</FONT>         * <a name="line.10450"></a>
<FONT color="green">10451</FONT>         * Use this symbol type, along with the &lt;tt&gt;setAnnotationLocation&lt;/tt&gt;,<a name="line.10451"></a>
<FONT color="green">10452</FONT>         * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; and &lt;tt&gt;setAnnotationYShift&lt;/tt&gt; methods, to<a name="line.10452"></a>
<FONT color="green">10453</FONT>         * position annotations relative to the upper right corner of the plot area.<a name="line.10453"></a>
<FONT color="green">10454</FONT>         * <a name="line.10454"></a>
<FONT color="green">10455</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.10455"></a>
<FONT color="green">10456</FONT>         * @see Curve.Point#setAnnotationXShift setAnnotationXShift<a name="line.10456"></a>
<FONT color="green">10457</FONT>         * @see Curve.Point#setAnnotationYShift setAnnotationYShift<a name="line.10457"></a>
<FONT color="green">10458</FONT>         * @see #ANCHOR_CENTER ANCHOR_CENTER<a name="line.10458"></a>
<FONT color="green">10459</FONT>         * <a name="line.10459"></a>
<FONT color="green">10460</FONT>         */<a name="line.10460"></a>
<FONT color="green">10461</FONT>        public static SymbolType ANCHOR_NORTHEAST = new AnnotationAnchor(<a name="line.10461"></a>
<FONT color="green">10462</FONT>            AnnotationLocation.NORTHEAST);<a name="line.10462"></a>
<FONT color="green">10463</FONT>    <a name="line.10463"></a>
<FONT color="green">10464</FONT>        /**<a name="line.10464"></a>
<FONT color="green">10465</FONT>         * Points on curves with this symbol type are positioned at the upper left<a name="line.10465"></a>
<FONT color="green">10466</FONT>         * corner of the plot area, and do not have a visible symbol.<a name="line.10466"></a>
<FONT color="green">10467</FONT>         * &lt;p&gt;<a name="line.10467"></a>
<FONT color="green">10468</FONT>         * <a name="line.10468"></a>
<FONT color="green">10469</FONT>         * Use this symbol type, along with the &lt;tt&gt;setAnnotationLocation&lt;/tt&gt;,<a name="line.10469"></a>
<FONT color="green">10470</FONT>         * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; and &lt;tt&gt;setAnnotationYShift&lt;/tt&gt; methods, to<a name="line.10470"></a>
<FONT color="green">10471</FONT>         * position annotations relative to the upper left corner of the plot area.<a name="line.10471"></a>
<FONT color="green">10472</FONT>         * <a name="line.10472"></a>
<FONT color="green">10473</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.10473"></a>
<FONT color="green">10474</FONT>         * @see Curve.Point#setAnnotationXShift setAnnotationXShift<a name="line.10474"></a>
<FONT color="green">10475</FONT>         * @see Curve.Point#setAnnotationYShift setAnnotationYShift<a name="line.10475"></a>
<FONT color="green">10476</FONT>         * @see #ANCHOR_CENTER ANCHOR_CENTER<a name="line.10476"></a>
<FONT color="green">10477</FONT>         * <a name="line.10477"></a>
<FONT color="green">10478</FONT>         */<a name="line.10478"></a>
<FONT color="green">10479</FONT>        public static SymbolType ANCHOR_NORTHWEST = new AnnotationAnchor(<a name="line.10479"></a>
<FONT color="green">10480</FONT>            AnnotationLocation.NORTHWEST);<a name="line.10480"></a>
<FONT color="green">10481</FONT>    <a name="line.10481"></a>
<FONT color="green">10482</FONT>        /**<a name="line.10482"></a>
<FONT color="green">10483</FONT>         * Points on curves with this symbol type are positioned at the center of<a name="line.10483"></a>
<FONT color="green">10484</FONT>         * the bottom edge of the plot area, and do not have a visible symbol.<a name="line.10484"></a>
<FONT color="green">10485</FONT>         * &lt;p&gt;<a name="line.10485"></a>
<FONT color="green">10486</FONT>         * <a name="line.10486"></a>
<FONT color="green">10487</FONT>         * Use this symbol type, along with the &lt;tt&gt;setAnnotationLocation&lt;/tt&gt;,<a name="line.10487"></a>
<FONT color="green">10488</FONT>         * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; and &lt;tt&gt;setAnnotationYShift&lt;/tt&gt; methods, to<a name="line.10488"></a>
<FONT color="green">10489</FONT>         * position annotations relative to the center of the bottom edge of the<a name="line.10489"></a>
<FONT color="green">10490</FONT>         * plot area.<a name="line.10490"></a>
<FONT color="green">10491</FONT>         * <a name="line.10491"></a>
<FONT color="green">10492</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.10492"></a>
<FONT color="green">10493</FONT>         * @see Curve.Point#setAnnotationXShift setAnnotationXShift<a name="line.10493"></a>
<FONT color="green">10494</FONT>         * @see Curve.Point#setAnnotationYShift setAnnotationYShift<a name="line.10494"></a>
<FONT color="green">10495</FONT>         * @see #ANCHOR_CENTER ANCHOR_CENTER<a name="line.10495"></a>
<FONT color="green">10496</FONT>         * <a name="line.10496"></a>
<FONT color="green">10497</FONT>         */<a name="line.10497"></a>
<FONT color="green">10498</FONT>        public static SymbolType ANCHOR_SOUTH = new AnnotationAnchor(<a name="line.10498"></a>
<FONT color="green">10499</FONT>            AnnotationLocation.SOUTH);<a name="line.10499"></a>
<FONT color="green">10500</FONT>    <a name="line.10500"></a>
<FONT color="green">10501</FONT>        /**<a name="line.10501"></a>
<FONT color="green">10502</FONT>         * Points on curves with this symbol type are positioned at the lower right<a name="line.10502"></a>
<FONT color="green">10503</FONT>         * corner of the plot area, and do not have a visible symbol.<a name="line.10503"></a>
<FONT color="green">10504</FONT>         * &lt;p&gt;<a name="line.10504"></a>
<FONT color="green">10505</FONT>         * <a name="line.10505"></a>
<FONT color="green">10506</FONT>         * Use this symbol type, along with the &lt;tt&gt;setAnnotationLocation&lt;/tt&gt;,<a name="line.10506"></a>
<FONT color="green">10507</FONT>         * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; and &lt;tt&gt;setAnnotationYShift&lt;/tt&gt; methods, to<a name="line.10507"></a>
<FONT color="green">10508</FONT>         * position annotations relative to the lower right corner of the plot area.<a name="line.10508"></a>
<FONT color="green">10509</FONT>         * <a name="line.10509"></a>
<FONT color="green">10510</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.10510"></a>
<FONT color="green">10511</FONT>         * @see Curve.Point#setAnnotationXShift setAnnotationXShift<a name="line.10511"></a>
<FONT color="green">10512</FONT>         * @see Curve.Point#setAnnotationYShift setAnnotationYShift<a name="line.10512"></a>
<FONT color="green">10513</FONT>         * @see #ANCHOR_CENTER ANCHOR_CENTER<a name="line.10513"></a>
<FONT color="green">10514</FONT>         * <a name="line.10514"></a>
<FONT color="green">10515</FONT>         */<a name="line.10515"></a>
<FONT color="green">10516</FONT>        public static SymbolType ANCHOR_SOUTHEAST = new AnnotationAnchor(<a name="line.10516"></a>
<FONT color="green">10517</FONT>            AnnotationLocation.SOUTHEAST);<a name="line.10517"></a>
<FONT color="green">10518</FONT>    <a name="line.10518"></a>
<FONT color="green">10519</FONT>        /**<a name="line.10519"></a>
<FONT color="green">10520</FONT>         * Points on curves with this symbol type are positioned at the lower left<a name="line.10520"></a>
<FONT color="green">10521</FONT>         * corner of the plot area, and do not have a visible symbol.<a name="line.10521"></a>
<FONT color="green">10522</FONT>         * &lt;p&gt;<a name="line.10522"></a>
<FONT color="green">10523</FONT>         * <a name="line.10523"></a>
<FONT color="green">10524</FONT>         * Use this symbol type, along with the &lt;tt&gt;setAnnotationLocation&lt;/tt&gt;,<a name="line.10524"></a>
<FONT color="green">10525</FONT>         * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; and &lt;tt&gt;setAnnotationYShift&lt;/tt&gt; methods, to<a name="line.10525"></a>
<FONT color="green">10526</FONT>         * position annotations relative to the lower left corner of the plot area.<a name="line.10526"></a>
<FONT color="green">10527</FONT>         * <a name="line.10527"></a>
<FONT color="green">10528</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.10528"></a>
<FONT color="green">10529</FONT>         * @see Curve.Point#setAnnotationXShift setAnnotationXShift<a name="line.10529"></a>
<FONT color="green">10530</FONT>         * @see Curve.Point#setAnnotationYShift setAnnotationYShift<a name="line.10530"></a>
<FONT color="green">10531</FONT>         * @see #ANCHOR_CENTER ANCHOR_CENTER<a name="line.10531"></a>
<FONT color="green">10532</FONT>         * <a name="line.10532"></a>
<FONT color="green">10533</FONT>         */<a name="line.10533"></a>
<FONT color="green">10534</FONT>        public static SymbolType ANCHOR_SOUTHWEST = new AnnotationAnchor(<a name="line.10534"></a>
<FONT color="green">10535</FONT>            AnnotationLocation.SOUTHWEST);<a name="line.10535"></a>
<FONT color="green">10536</FONT>    <a name="line.10536"></a>
<FONT color="green">10537</FONT>        /**<a name="line.10537"></a>
<FONT color="green">10538</FONT>         * Points on curves with this symbol type are positioned at the center of<a name="line.10538"></a>
<FONT color="green">10539</FONT>         * the left edge of the plot area, and do not have a visible symbol.<a name="line.10539"></a>
<FONT color="green">10540</FONT>         * &lt;p&gt;<a name="line.10540"></a>
<FONT color="green">10541</FONT>         * <a name="line.10541"></a>
<FONT color="green">10542</FONT>         * Use this symbol type, along with the &lt;tt&gt;setAnnotationLocation&lt;/tt&gt;,<a name="line.10542"></a>
<FONT color="green">10543</FONT>         * &lt;tt&gt;setAnnotationXShift&lt;/tt&gt; and &lt;tt&gt;setAnnotationYShift&lt;/tt&gt; methods, to<a name="line.10543"></a>
<FONT color="green">10544</FONT>         * position annotations relative to the center of the left edge of the plot<a name="line.10544"></a>
<FONT color="green">10545</FONT>         * area.<a name="line.10545"></a>
<FONT color="green">10546</FONT>         * <a name="line.10546"></a>
<FONT color="green">10547</FONT>         * @see Curve.Point#setAnnotationLocation setAnnotationLocation<a name="line.10547"></a>
<FONT color="green">10548</FONT>         * @see Curve.Point#setAnnotationXShift setAnnotationXShift<a name="line.10548"></a>
<FONT color="green">10549</FONT>         * @see Curve.Point#setAnnotationYShift setAnnotationYShift<a name="line.10549"></a>
<FONT color="green">10550</FONT>         * @see #ANCHOR_CENTER ANCHOR_CENTER<a name="line.10550"></a>
<FONT color="green">10551</FONT>         * <a name="line.10551"></a>
<FONT color="green">10552</FONT>         */<a name="line.10552"></a>
<FONT color="green">10553</FONT>        public static SymbolType ANCHOR_WEST = new AnnotationAnchor(<a name="line.10553"></a>
<FONT color="green">10554</FONT>            AnnotationLocation.WEST);<a name="line.10554"></a>
<FONT color="green">10555</FONT>    <a name="line.10555"></a>
<FONT color="green">10556</FONT>        /**<a name="line.10556"></a>
<FONT color="green">10557</FONT>         * Use rectangles horizontally and vertically centered on each point of the<a name="line.10557"></a>
<FONT color="green">10558</FONT>         * curve<a name="line.10558"></a>
<FONT color="green">10559</FONT>         */<a name="line.10559"></a>
<FONT color="green">10560</FONT>        public static SymbolType BOX_CENTER = new SymbolType(0, 0, 0, 0, 0, 0);<a name="line.10560"></a>
<FONT color="green">10561</FONT>        /**<a name="line.10561"></a>
<FONT color="green">10562</FONT>         * Use rectangles just to the right of, and vertically centered on, each<a name="line.10562"></a>
<FONT color="green">10563</FONT>         * point of the curve<a name="line.10563"></a>
<FONT color="green">10564</FONT>         */<a name="line.10564"></a>
<FONT color="green">10565</FONT>        public static SymbolType BOX_EAST = new SymbolType(1, 0, 0.5, -0.5, 0,<a name="line.10565"></a>
<FONT color="green">10566</FONT>            0);<a name="line.10566"></a>
<FONT color="green">10567</FONT>        /**<a name="line.10567"></a>
<FONT color="green">10568</FONT>         * Use rectangles just above, and horizontally centered on, each point of<a name="line.10568"></a>
<FONT color="green">10569</FONT>         * the curve<a name="line.10569"></a>
<FONT color="green">10570</FONT>         */<a name="line.10570"></a>
<FONT color="green">10571</FONT>        public static SymbolType BOX_NORTH = new SymbolType(0, -1, 0, 0, -0.5,<a name="line.10571"></a>
<FONT color="green">10572</FONT>            0.5);<a name="line.10572"></a>
<FONT color="green">10573</FONT>    <a name="line.10573"></a>
<FONT color="green">10574</FONT>        /**<a name="line.10574"></a>
<FONT color="green">10575</FONT>         * Use rectangles just above, and to the right of, each point of the curve<a name="line.10575"></a>
<FONT color="green">10576</FONT>         */<a name="line.10576"></a>
<FONT color="green">10577</FONT>        public static SymbolType BOX_NORTHEAST = new SymbolType(1, -1, 0.5,<a name="line.10577"></a>
<FONT color="green">10578</FONT>            -0.5, -0.5, 0.5);<a name="line.10578"></a>
<FONT color="green">10579</FONT>    <a name="line.10579"></a>
<FONT color="green">10580</FONT>        /**<a name="line.10580"></a>
<FONT color="green">10581</FONT>         * Use rectangles just above and to the left of, each point of the curve<a name="line.10581"></a>
<FONT color="green">10582</FONT>         */<a name="line.10582"></a>
<FONT color="green">10583</FONT>        public static SymbolType BOX_NORTHWEST = new SymbolType(-1, -1, -0.5,<a name="line.10583"></a>
<FONT color="green">10584</FONT>            0.5, -0.5, 0.5);<a name="line.10584"></a>
<FONT color="green">10585</FONT>    <a name="line.10585"></a>
<FONT color="green">10586</FONT>        /**<a name="line.10586"></a>
<FONT color="green">10587</FONT>         * Use rectangles just below, and horizontally centered on, each point of<a name="line.10587"></a>
<FONT color="green">10588</FONT>         * the curve<a name="line.10588"></a>
<FONT color="green">10589</FONT>         */<a name="line.10589"></a>
<FONT color="green">10590</FONT>        public static SymbolType BOX_SOUTH = new SymbolType(0, 1, 0, 0, 0.5,<a name="line.10590"></a>
<FONT color="green">10591</FONT>            -0.5);<a name="line.10591"></a>
<FONT color="green">10592</FONT>    <a name="line.10592"></a>
<FONT color="green">10593</FONT>        /**<a name="line.10593"></a>
<FONT color="green">10594</FONT>         * Use rectangles just below, and to the right of, each point of the curve<a name="line.10594"></a>
<FONT color="green">10595</FONT>         */<a name="line.10595"></a>
<FONT color="green">10596</FONT>        public static SymbolType BOX_SOUTHEAST = new SymbolType(1, 1, 0.5,<a name="line.10596"></a>
<FONT color="green">10597</FONT>            -0.5, 0.5, -0.5);<a name="line.10597"></a>
<FONT color="green">10598</FONT>    <a name="line.10598"></a>
<FONT color="green">10599</FONT>        /**<a name="line.10599"></a>
<FONT color="green">10600</FONT>         * Use rectangles just below, and to the left of, each point of the curve<a name="line.10600"></a>
<FONT color="green">10601</FONT>         */<a name="line.10601"></a>
<FONT color="green">10602</FONT>        public static SymbolType BOX_SOUTHWEST = new SymbolType(-1, 1, -0.5,<a name="line.10602"></a>
<FONT color="green">10603</FONT>            0.5, 0.5, -0.5);<a name="line.10603"></a>
<FONT color="green">10604</FONT>    <a name="line.10604"></a>
<FONT color="green">10605</FONT>        /**<a name="line.10605"></a>
<FONT color="green">10606</FONT>         * Use rectangles just to the left of, and vertically centered on, each<a name="line.10606"></a>
<FONT color="green">10607</FONT>         * point of the curve<a name="line.10607"></a>
<FONT color="green">10608</FONT>         */<a name="line.10608"></a>
<FONT color="green">10609</FONT>        public static SymbolType BOX_WEST = new SymbolType(-1, 0, -0.5, 0.5, 0,<a name="line.10609"></a>
<FONT color="green">10610</FONT>            0);<a name="line.10610"></a>
<FONT color="green">10611</FONT>        /**<a name="line.10611"></a>
<FONT color="green">10612</FONT>         * Use horizontal bars that extend from the x,y position associated with<a name="line.10612"></a>
<FONT color="green">10613</FONT>         * each point, to the x position defined by the host &lt;tt&gt;Symbol&lt;/tt&gt;'s<a name="line.10613"></a>
<FONT color="green">10614</FONT>         * baseline property, and that are vertically centered on the data point.<a name="line.10614"></a>
<FONT color="green">10615</FONT>         * <a name="line.10615"></a>
<FONT color="green">10616</FONT>         * @see Symbol#setBaseline setBaseline<a name="line.10616"></a>
<FONT color="green">10617</FONT>         * @see #HBAR_BASELINE_CENTER HBAR_BASELINE_CENTER<a name="line.10617"></a>
<FONT color="green">10618</FONT>         * @see #HBAR_BASELINE_SOUTH HBAR_BASELINE_SOUTH<a name="line.10618"></a>
<FONT color="green">10619</FONT>         * @see #HBAR_BASELINE_NORTH HBAR_BASELINE_NORTH<a name="line.10619"></a>
<FONT color="green">10620</FONT>         * @see #VBAR_BASELINE_CENTER VBAR_BASELINE_CENTER<a name="line.10620"></a>
<FONT color="green">10621</FONT>         * @see #VBAR_BASELINE_EAST VBAR_BASELINE_EAST<a name="line.10621"></a>
<FONT color="green">10622</FONT>         * @see #VBAR_BASELINE_WEST VBAR_BASELINE_WEST<a name="line.10622"></a>
<FONT color="green">10623</FONT>         * @see Symbol Symbol<a name="line.10623"></a>
<FONT color="green">10624</FONT>         * <a name="line.10624"></a>
<FONT color="green">10625</FONT>         */<a name="line.10625"></a>
<FONT color="green">10626</FONT>        public static SymbolType HBAR_BASELINE_CENTER = new HBarBaseline(0, 0);<a name="line.10626"></a>
<FONT color="green">10627</FONT>        /**<a name="line.10627"></a>
<FONT color="green">10628</FONT>         * Use horizontal bars that extend from the x,y position associated with<a name="line.10628"></a>
<FONT color="green">10629</FONT>         * each point, to the x position defined by the host &lt;tt&gt;Symbol&lt;/tt&gt;'s<a name="line.10629"></a>
<FONT color="green">10630</FONT>         * baseline property, and whose bottom edge passes through the data point.<a name="line.10630"></a>
<FONT color="green">10631</FONT>         * <a name="line.10631"></a>
<FONT color="green">10632</FONT>         * @see Symbol#setBaseline setBaseline<a name="line.10632"></a>
<FONT color="green">10633</FONT>         * @see #HBAR_BASELINE_CENTER HBAR_BASELINE_CENTER<a name="line.10633"></a>
<FONT color="green">10634</FONT>         * @see #HBAR_BASELINE_SOUTH HBAR_BASELINE_SOUTH<a name="line.10634"></a>
<FONT color="green">10635</FONT>         * @see #HBAR_BASELINE_NORTH HBAR_BASELINE_NORTH<a name="line.10635"></a>
<FONT color="green">10636</FONT>         * @see #VBAR_BASELINE_CENTER VBAR_BASELINE_CENTER<a name="line.10636"></a>
<FONT color="green">10637</FONT>         * @see #VBAR_BASELINE_EAST VBAR_BASELINE_EAST<a name="line.10637"></a>
<FONT color="green">10638</FONT>         * @see #VBAR_BASELINE_WEST VBAR_BASELINE_WEST<a name="line.10638"></a>
<FONT color="green">10639</FONT>         * @see Symbol Symbol<a name="line.10639"></a>
<FONT color="green">10640</FONT>         * <a name="line.10640"></a>
<FONT color="green">10641</FONT>         */<a name="line.10641"></a>
<FONT color="green">10642</FONT>        public static SymbolType HBAR_BASELINE_NORTH = new HBarBaseline(0, -1);<a name="line.10642"></a>
<FONT color="green">10643</FONT>        /**<a name="line.10643"></a>
<FONT color="green">10644</FONT>         * Use horizontal bars that extend from the x,y position associated with<a name="line.10644"></a>
<FONT color="green">10645</FONT>         * each point, to the x position defined by the host &lt;tt&gt;Symbol&lt;/tt&gt;'s<a name="line.10645"></a>
<FONT color="green">10646</FONT>         * baseline property, and whose top edge passes through the data point.<a name="line.10646"></a>
<FONT color="green">10647</FONT>         * <a name="line.10647"></a>
<FONT color="green">10648</FONT>         * @see Symbol#setBaseline setBaseline<a name="line.10648"></a>
<FONT color="green">10649</FONT>         * @see #HBAR_BASELINE_CENTER HBAR_BASELINE_CENTER<a name="line.10649"></a>
<FONT color="green">10650</FONT>         * @see #HBAR_BASELINE_SOUTH HBAR_BASELINE_SOUTH<a name="line.10650"></a>
<FONT color="green">10651</FONT>         * @see #HBAR_BASELINE_NORTH HBAR_BASELINE_NORTH<a name="line.10651"></a>
<FONT color="green">10652</FONT>         * @see #VBAR_BASELINE_CENTER VBAR_BASELINE_CENTER<a name="line.10652"></a>
<FONT color="green">10653</FONT>         * @see #VBAR_BASELINE_EAST VBAR_BASELINE_EAST<a name="line.10653"></a>
<FONT color="green">10654</FONT>         * @see #VBAR_BASELINE_WEST VBAR_BASELINE_WEST<a name="line.10654"></a>
<FONT color="green">10655</FONT>         * <a name="line.10655"></a>
<FONT color="green">10656</FONT>         */<a name="line.10656"></a>
<FONT color="green">10657</FONT>        public static SymbolType HBAR_BASELINE_SOUTH = new HBarBaseline(0, 1);<a name="line.10657"></a>
<FONT color="green">10658</FONT>        /**<a name="line.10658"></a>
<FONT color="green">10659</FONT>         * Use horizontal bars that extend from the right y-axis to each point on<a name="line.10659"></a>
<FONT color="green">10660</FONT>         * the curve, and that are vertically centered on the point.<a name="line.10660"></a>
<FONT color="green">10661</FONT>         */<a name="line.10661"></a>
<FONT color="green">10662</FONT>        public static SymbolType HBAR_EAST = new HBarRight(1, 0);<a name="line.10662"></a>
<FONT color="green">10663</FONT>        private static SymbolType line = new LineSymbolType();<a name="line.10663"></a>
<FONT color="green">10664</FONT>        /**<a name="line.10664"></a>
<FONT color="green">10665</FONT>         * @deprecated<a name="line.10665"></a>
<FONT color="green">10666</FONT>         * <a name="line.10666"></a>
<FONT color="green">10667</FONT>         *             As of version 2.4, this symbol has been redefined to be<a name="line.10667"></a>
<FONT color="green">10668</FONT>         *             synonomous with the LINE symbol type.<a name="line.10668"></a>
<FONT color="green">10669</FONT>         *             &lt;p&gt;<a name="line.10669"></a>
<FONT color="green">10670</FONT>         * <a name="line.10670"></a>
<FONT color="green">10671</FONT>         *             Prior to v2.4, this symbol drew a horizontal bar from each<a name="line.10671"></a>
<FONT color="green">10672</FONT>         *             point to the x coordinate of the next point. Some<a name="line.10672"></a>
<FONT color="green">10673</FONT>         *             applications may need to use a revised point set in order to<a name="line.10673"></a>
<FONT color="green">10674</FONT>         *             produce the same curves using &lt;tt&gt;LINE&lt;/tt&gt; that they used to<a name="line.10674"></a>
<FONT color="green">10675</FONT>         *             produce with this symbol.<a name="line.10675"></a>
<FONT color="green">10676</FONT>         *             &lt;p&gt;<a name="line.10676"></a>
<FONT color="green">10677</FONT>         * <a name="line.10677"></a>
<FONT color="green">10678</FONT>         *             See the discussion within the {@link #VBAR_NEXT VBAR_NEXT}<a name="line.10678"></a>
<FONT color="green">10679</FONT>         *             symbol for more information about why support for these<a name="line.10679"></a>
<FONT color="green">10680</FONT>         *             vertically and horizontally constrained connecting line<a name="line.10680"></a>
<FONT color="green">10681</FONT>         *             symbol types was dropped.<a name="line.10681"></a>
<FONT color="green">10682</FONT>         * <a name="line.10682"></a>
<FONT color="green">10683</FONT>         * @see #LINE LINE<a name="line.10683"></a>
<FONT color="green">10684</FONT>         * @see #HBAR_PREV HBAR_PREV<a name="line.10684"></a>
<FONT color="green">10685</FONT>         * @see #VBAR_PREV VBAR_PREV<a name="line.10685"></a>
<FONT color="green">10686</FONT>         * @see #VBAR_NEXT VBAR_NEXT<a name="line.10686"></a>
<FONT color="green">10687</FONT>         * <a name="line.10687"></a>
<FONT color="green">10688</FONT>         */<a name="line.10688"></a>
<FONT color="green">10689</FONT>        public static SymbolType HBAR_NEXT = line;<a name="line.10689"></a>
<FONT color="green">10690</FONT>        /**<a name="line.10690"></a>
<FONT color="green">10691</FONT>         * Use horizontal bars that extend from the right y-axis to each point on<a name="line.10691"></a>
<FONT color="green">10692</FONT>         * the curve, and that are vertically just above the point.<a name="line.10692"></a>
<FONT color="green">10693</FONT>         */<a name="line.10693"></a>
<FONT color="green">10694</FONT>        public static SymbolType HBAR_NORTHEAST = new HBarRight(1, -1);<a name="line.10694"></a>
<FONT color="green">10695</FONT>    <a name="line.10695"></a>
<FONT color="green">10696</FONT>        /**<a name="line.10696"></a>
<FONT color="green">10697</FONT>         * Use horizontal bars that extend from the left y-axis to each point on the<a name="line.10697"></a>
<FONT color="green">10698</FONT>         * curve, and that are vertically just above point.<a name="line.10698"></a>
<FONT color="green">10699</FONT>         */<a name="line.10699"></a>
<FONT color="green">10700</FONT>        public static SymbolType HBAR_NORTHWEST = new HBarLeft(-1, -1);<a name="line.10700"></a>
<FONT color="green">10701</FONT>        /**<a name="line.10701"></a>
<FONT color="green">10702</FONT>         * @deprecated<a name="line.10702"></a>
<FONT color="green">10703</FONT>         * <a name="line.10703"></a>
<FONT color="green">10704</FONT>         *             As of version 2.4, this symbol has been redefined to be<a name="line.10704"></a>
<FONT color="green">10705</FONT>         *             synonymous with the LINE symbol type.<a name="line.10705"></a>
<FONT color="green">10706</FONT>         *             &lt;p&gt;<a name="line.10706"></a>
<FONT color="green">10707</FONT>         * <a name="line.10707"></a>
<FONT color="green">10708</FONT>         *             Prior to v2.4, this symbol drew a horizontal bar from each<a name="line.10708"></a>
<FONT color="green">10709</FONT>         *             point to the x coordinate of the previous point. Some<a name="line.10709"></a>
<FONT color="green">10710</FONT>         *             applications may need to use a revised point set in order to<a name="line.10710"></a>
<FONT color="green">10711</FONT>         *             produce the same curves using &lt;tt&gt;LINE&lt;/tt&gt; that they used to<a name="line.10711"></a>
<FONT color="green">10712</FONT>         *             produce with this symbol.<a name="line.10712"></a>
<FONT color="green">10713</FONT>         *             &lt;p&gt;<a name="line.10713"></a>
<FONT color="green">10714</FONT>         * <a name="line.10714"></a>
<FONT color="green">10715</FONT>         *             See the discussion within the {@link #VBAR_NEXT VBAR_NEXT}<a name="line.10715"></a>
<FONT color="green">10716</FONT>         *             symbol for more information about why support for these<a name="line.10716"></a>
<FONT color="green">10717</FONT>         *             vertically and horizontally constrained connecting line<a name="line.10717"></a>
<FONT color="green">10718</FONT>         *             symbol types was dropped.<a name="line.10718"></a>
<FONT color="green">10719</FONT>         * <a name="line.10719"></a>
<FONT color="green">10720</FONT>         * @see #LINE LINE<a name="line.10720"></a>
<FONT color="green">10721</FONT>         * @see #HBAR_NEXT HBAR_NEXT<a name="line.10721"></a>
<FONT color="green">10722</FONT>         * @see #VBAR_PREV VBAR_PREV<a name="line.10722"></a>
<FONT color="green">10723</FONT>         * @see #VBAR_NEXT VBAR_NEXT<a name="line.10723"></a>
<FONT color="green">10724</FONT>         * <a name="line.10724"></a>
<FONT color="green">10725</FONT>         * <a name="line.10725"></a>
<FONT color="green">10726</FONT>         */<a name="line.10726"></a>
<FONT color="green">10727</FONT>        public static SymbolType HBAR_PREV = line;<a name="line.10727"></a>
<FONT color="green">10728</FONT>        /**<a name="line.10728"></a>
<FONT color="green">10729</FONT>         * Use horizontal bars that extend from the right y-axis to each point on<a name="line.10729"></a>
<FONT color="green">10730</FONT>         * the curve, and that are vertically just below the point.<a name="line.10730"></a>
<FONT color="green">10731</FONT>         */<a name="line.10731"></a>
<FONT color="green">10732</FONT>        public static SymbolType HBAR_SOUTHEAST = new HBarRight(1, 1);<a name="line.10732"></a>
<FONT color="green">10733</FONT>        /**<a name="line.10733"></a>
<FONT color="green">10734</FONT>         * Use horizontal bars that extend from the left y-axis to each point on the<a name="line.10734"></a>
<FONT color="green">10735</FONT>         * curve, and that are vertically just below the point.<a name="line.10735"></a>
<FONT color="green">10736</FONT>         */<a name="line.10736"></a>
<FONT color="green">10737</FONT>        public static SymbolType HBAR_SOUTHWEST = new HBarLeft(-1, 1);<a name="line.10737"></a>
<FONT color="green">10738</FONT>    <a name="line.10738"></a>
<FONT color="green">10739</FONT>        /**<a name="line.10739"></a>
<FONT color="green">10740</FONT>         * Use horizontal bars that extend from the left y-axis to each point on the<a name="line.10740"></a>
<FONT color="green">10741</FONT>         * curve, and that are vertically centered on the point.<a name="line.10741"></a>
<FONT color="green">10742</FONT>         */<a name="line.10742"></a>
<FONT color="green">10743</FONT>        public static SymbolType HBAR_WEST = new HBarLeft(-1, 0);<a name="line.10743"></a>
<FONT color="green">10744</FONT>    <a name="line.10744"></a>
<FONT color="green">10745</FONT>        /**<a name="line.10745"></a>
<FONT color="green">10746</FONT>         * This symbol type draws a continuous straight line between successive<a name="line.10746"></a>
<FONT color="green">10747</FONT>         * individual data points. By default, the line is drawn via an appropriate<a name="line.10747"></a>
<FONT color="green">10748</FONT>         * series of rectangular HTML elements, which can produce a "stair-step"<a name="line.10748"></a>
<FONT color="green">10749</FONT>         * look at certain angles.<a name="line.10749"></a>
<FONT color="green">10750</FONT>         * <a name="line.10750"></a>
<FONT color="green">10751</FONT>         * &lt;small&gt;&lt;blockquote&gt; &lt;i&gt;Tip:&lt;/i&gt; You can get order-of-magnitude faster,<a name="line.10751"></a>
<FONT color="green">10752</FONT>         * and crisper, line charts by adding an external vector graphics library to<a name="line.10752"></a>
<FONT color="green">10753</FONT>         * GChart via the &lt;tt&gt;setCanvasFactory&lt;/tt&gt; method.&lt;/small&gt;<a name="line.10753"></a>
<FONT color="green">10754</FONT>         * &lt;p&gt;<a name="line.10754"></a>
<FONT color="green">10755</FONT>         * <a name="line.10755"></a>
<FONT color="green">10756</FONT>         * Apart from this connecting line, the individual data points are displayed<a name="line.10756"></a>
<FONT color="green">10757</FONT>         * exactly as they would have been displayed via BOX_CENTER.<a name="line.10757"></a>
<FONT color="green">10758</FONT>         * &lt;p&gt;<a name="line.10758"></a>
<FONT color="green">10759</FONT>         * <a name="line.10759"></a>
<FONT color="green">10760</FONT>         * Produces a connecting line similar to what could be produced via<a name="line.10760"></a>
<FONT color="green">10761</FONT>         * BOX_CENTER with a fill spacing of 1px, except that it uses a more<a name="line.10761"></a>
<FONT color="green">10762</FONT>         * efficient representation that merges vertical or horizontal "dot blocks"<a name="line.10762"></a>
<FONT color="green">10763</FONT>         * into single HTML elements whenever possible.<a name="line.10763"></a>
<FONT color="green">10764</FONT>         * &lt;p&gt;<a name="line.10764"></a>
<FONT color="green">10765</FONT>         * <a name="line.10765"></a>
<FONT color="green">10766</FONT>         * To produce a line without showing the individual data points as separate<a name="line.10766"></a>
<FONT color="green">10767</FONT>         * rectangular symbols, set width and height to match your symbol's<a name="line.10767"></a>
<FONT color="green">10768</FONT>         * specified &lt;tt&gt;fillThickness&lt;/tt&gt;.<a name="line.10768"></a>
<FONT color="green">10769</FONT>         * <a name="line.10769"></a>
<FONT color="green">10770</FONT>         * @see #BOX_CENTER BOX_CENTER<a name="line.10770"></a>
<FONT color="green">10771</FONT>         * @see #setCanvasFactory setCanvasFactory<a name="line.10771"></a>
<FONT color="green">10772</FONT>         * @see Symbol#setFillThickness setFillThickness<a name="line.10772"></a>
<FONT color="green">10773</FONT>         * <a name="line.10773"></a>
<FONT color="green">10774</FONT>         * <a name="line.10774"></a>
<FONT color="green">10775</FONT>         * <a name="line.10775"></a>
<FONT color="green">10776</FONT>         */<a name="line.10776"></a>
<FONT color="green">10777</FONT>        public static SymbolType LINE = line;<a name="line.10777"></a>
<FONT color="green">10778</FONT>    <a name="line.10778"></a>
<FONT color="green">10779</FONT>        /**<a name="line.10779"></a>
<FONT color="green">10780</FONT>         * @deprecated<a name="line.10780"></a>
<FONT color="green">10781</FONT>         * <a name="line.10781"></a>
<FONT color="green">10782</FONT>         *             In GChart 2.3, you had to use this special symbol type to get<a name="line.10782"></a>
<FONT color="green">10783</FONT>         *             GChart to use an external canvas library to draw crisp<a name="line.10783"></a>
<FONT color="green">10784</FONT>         *             connecting lines.<a name="line.10784"></a>
<FONT color="green">10785</FONT>         *             &lt;p&gt;<a name="line.10785"></a>
<FONT color="green">10786</FONT>         * <a name="line.10786"></a>
<FONT color="green">10787</FONT>         *             As of GChart 2.5, the &lt;tt&gt;LINE&lt;/tt&gt; symbol type will, by<a name="line.10787"></a>
<FONT color="green">10788</FONT>         *             default, be rendered with whatever external canvas library<a name="line.10788"></a>
<FONT color="green">10789</FONT>         *             you provide to GChart via the &lt;tt&gt;setCanvasFactory&lt;/tt&gt;<a name="line.10789"></a>
<FONT color="green">10790</FONT>         *             method.<a name="line.10790"></a>
<FONT color="green">10791</FONT>         * <a name="line.10791"></a>
<FONT color="green">10792</FONT>         *             &lt;p&gt;<a name="line.10792"></a>
<FONT color="green">10793</FONT>         * <a name="line.10793"></a>
<FONT color="green">10794</FONT>         *             So now, &lt;tt&gt;LINE_CANVAS&lt;/tt&gt; is just another name for<a name="line.10794"></a>
<FONT color="green">10795</FONT>         *             &lt;tt&gt;LINE&lt;/tt&gt;. Please replace &lt;tt&gt;LINE_CANVAS&lt;/tt&gt; with<a name="line.10795"></a>
<FONT color="green">10796</FONT>         *             &lt;tt&gt;LINE&lt;/tt&gt; in your code.<a name="line.10796"></a>
<FONT color="green">10797</FONT>         *             &lt;p&gt;<a name="line.10797"></a>
<FONT color="green">10798</FONT>         * <a name="line.10798"></a>
<FONT color="green">10799</FONT>         *             &lt;small&gt; Note that &lt;tt&gt;LINE&lt;/tt&gt; only draws continuous lines<a name="line.10799"></a>
<FONT color="green">10800</FONT>         *             if fill spacing (&lt;tt&gt;setFillSpacing&lt;/tt&gt;) is &lt;tt&gt;0&lt;/tt&gt;. With<a name="line.10800"></a>
<FONT color="green">10801</FONT>         *             fill spacing &gt; 0, it uses the old HTML-rendering method.<a name="line.10801"></a>
<FONT color="green">10802</FONT>         *             Since &lt;tt&gt;0&lt;/tt&gt; is now the new default fill spacing for the<a name="line.10802"></a>
<FONT color="green">10803</FONT>         *             &lt;tt&gt;LINE&lt;/tt&gt; symbol type, normally &lt;tt&gt;LINE&lt;/tt&gt; works<a name="line.10803"></a>
<FONT color="green">10804</FONT>         *             exactly like &lt;tt&gt;LINE_CANVAS&lt;/tt&gt; did. But, if you had<a name="line.10804"></a>
<FONT color="green">10805</FONT>         *             explicitly set the fill spacing, you may have to remove this<a name="line.10805"></a>
<FONT color="green">10806</FONT>         *             specification, or set it to &lt;tt&gt;0&lt;/tt&gt;, to get the same<a name="line.10806"></a>
<FONT color="green">10807</FONT>         *             behavior you had before with &lt;tt&gt;LINE_CANVAS&lt;/tt&gt;.<a name="line.10807"></a>
<FONT color="green">10808</FONT>         *             &lt;p&gt;<a name="line.10808"></a>
<FONT color="green">10809</FONT>         *             &lt;/small&gt;<a name="line.10809"></a>
<FONT color="green">10810</FONT>         * <a name="line.10810"></a>
<FONT color="green">10811</FONT>         * @see #LINE LINE<a name="line.10811"></a>
<FONT color="green">10812</FONT>         * @see #setCanvasFactory setCanvasFactory<a name="line.10812"></a>
<FONT color="green">10813</FONT>         * @see Symbol#setFillSpacing setFillSpacing<a name="line.10813"></a>
<FONT color="green">10814</FONT>         * <a name="line.10814"></a>
<FONT color="green">10815</FONT>         */<a name="line.10815"></a>
<FONT color="green">10816</FONT>        public static SymbolType LINE_CANVAS = line;<a name="line.10816"></a>
<FONT color="green">10817</FONT>        /**<a name="line.10817"></a>
<FONT color="green">10818</FONT>         * A symbol type that does not draw any main symbol. Use this symbol type<a name="line.10818"></a>
<FONT color="green">10819</FONT>         * for curves whose points exist solely for the purpose of positioning their<a name="line.10819"></a>
<FONT color="green">10820</FONT>         * associated annotations. Note that if &lt;tt&gt;fillThickness&lt;/tt&gt; is non-zero,<a name="line.10820"></a>
<FONT color="green">10821</FONT>         * any connecting dots between the points will still be drawn.<a name="line.10821"></a>
<FONT color="green">10822</FONT>         * &lt;p&gt;<a name="line.10822"></a>
<FONT color="green">10823</FONT>         * <a name="line.10823"></a>
<FONT color="green">10824</FONT>         * Equivalent to using the &lt;tt&gt;BOX_CENTER&lt;/tt&gt; symbol type, but with the<a name="line.10824"></a>
<FONT color="green">10825</FONT>         * host symbol's width and height both set to zero, so that no box symbol is<a name="line.10825"></a>
<FONT color="green">10826</FONT>         * ever visible.<a name="line.10826"></a>
<FONT color="green">10827</FONT>         * &lt;p&gt;<a name="line.10827"></a>
<FONT color="green">10828</FONT>         * <a name="line.10828"></a>
<FONT color="green">10829</FONT>         * On Disabling hover selection feedback via &lt;tt&gt;NONE&lt;/tt&gt;:<a name="line.10829"></a>
<FONT color="green">10830</FONT>         * &lt;p&gt;<a name="line.10830"></a>
<FONT color="green">10831</FONT>         * <a name="line.10831"></a>
<FONT color="green">10832</FONT>         * &lt;blockquote&gt;&lt;small&gt; Note that if the border width of the host symbol is<a name="line.10832"></a>
<FONT color="green">10833</FONT>         * negative, consistent with a 0 x 0 px &lt;tt&gt;BOX_CENTER&lt;/tt&gt; symbol type, an<a name="line.10833"></a>
<FONT color="green">10834</FONT>         * external border will still appear around the &lt;tt&gt;SymbolType.NONE&lt;/tt&gt;<a name="line.10834"></a>
<FONT color="green">10835</FONT>         * symbol. Because the default hover selection border width is &lt;tt&gt;-1&lt;/tt&gt;,<a name="line.10835"></a>
<FONT color="green">10836</FONT>         * when passing &lt;tt&gt;SymbolType.NONE&lt;/tt&gt; to<a name="line.10836"></a>
<FONT color="green">10837</FONT>         * &lt;tt&gt;setHoverSelectionSymbolType&lt;/tt&gt;, you generally will also need to add<a name="line.10837"></a>
<FONT color="green">10838</FONT>         * a code line such as:<a name="line.10838"></a>
<FONT color="green">10839</FONT>         * <a name="line.10839"></a>
<FONT color="green">10840</FONT>         * &lt;pre&gt;<a name="line.10840"></a>
<FONT color="green">10841</FONT>         * getCurve().getSymbol().setHoverSelectionBorderWidth(0);<a name="line.10841"></a>
<FONT color="green">10842</FONT>         * &lt;/pre&gt;<a name="line.10842"></a>
<FONT color="green">10843</FONT>         * &lt;p&gt;<a name="line.10843"></a>
<FONT color="green">10844</FONT>         * <a name="line.10844"></a>
<FONT color="green">10845</FONT>         * If your intention is to disable hover selection feedback, it's probably<a name="line.10845"></a>
<FONT color="green">10846</FONT>         * easier to just use &lt;tt&gt;setHoverSelectionEnabled(false)&lt;/tt&gt;, rather than<a name="line.10846"></a>
<FONT color="green">10847</FONT>         * setting the hover selection symbol type to &lt;tt&gt;NONE&lt;/tt&gt;.<a name="line.10847"></a>
<FONT color="green">10848</FONT>         * <a name="line.10848"></a>
<FONT color="green">10849</FONT>         *&lt;/small&gt;&lt;/blockquote&gt;<a name="line.10849"></a>
<FONT color="green">10850</FONT>         * <a name="line.10850"></a>
<FONT color="green">10851</FONT>         * @see #BOX_CENTER BOX_CENTER<a name="line.10851"></a>
<FONT color="green">10852</FONT>         * @see Symbol#setFillThickness setFillThickness<a name="line.10852"></a>
<FONT color="green">10853</FONT>         * @see Symbol#setHoverSelectionSymbolType setHoverSelectionSymbolType<a name="line.10853"></a>
<FONT color="green">10854</FONT>         * @see Symbol#setHoverSelectionEnabled setHoverSelectionEnabled<a name="line.10854"></a>
<FONT color="green">10855</FONT>         */<a name="line.10855"></a>
<FONT color="green">10856</FONT>        public static SymbolType NONE = new SymbolType(0, 0, 0, 0, 0, 0) {<a name="line.10856"></a>
<FONT color="green">10857</FONT>          public double getAdjustedWidth(double width, double x,<a name="line.10857"></a>
<FONT color="green">10858</FONT>              double xPrev, double xNext, double xMin, double xMax,<a name="line.10858"></a>
<FONT color="green">10859</FONT>              double xMid) {<a name="line.10859"></a>
<FONT color="green">10860</FONT>            return 0;<a name="line.10860"></a>
<FONT color="green">10861</FONT>          }<a name="line.10861"></a>
<FONT color="green">10862</FONT>    <a name="line.10862"></a>
<FONT color="green">10863</FONT>          public double getAdjustedHeight(double height, double y,<a name="line.10863"></a>
<FONT color="green">10864</FONT>              double yPrev, double yNext, double yMin, double yMax,<a name="line.10864"></a>
<FONT color="green">10865</FONT>              double yMid) {<a name="line.10865"></a>
<FONT color="green">10866</FONT>            return 0;<a name="line.10866"></a>
<FONT color="green">10867</FONT>          }<a name="line.10867"></a>
<FONT color="green">10868</FONT>    <a name="line.10868"></a>
<FONT color="green">10869</FONT>          int getIconHeight(int legendFontSize) {<a name="line.10869"></a>
<FONT color="green">10870</FONT>            return 0;<a name="line.10870"></a>
<FONT color="green">10871</FONT>          }<a name="line.10871"></a>
<FONT color="green">10872</FONT>    <a name="line.10872"></a>
<FONT color="green">10873</FONT>          int getIconWidth(int legendFontSize) {<a name="line.10873"></a>
<FONT color="green">10874</FONT>            return 0;<a name="line.10874"></a>
<FONT color="green">10875</FONT>          }<a name="line.10875"></a>
<FONT color="green">10876</FONT>    <a name="line.10876"></a>
<FONT color="green">10877</FONT>        };<a name="line.10877"></a>
<FONT color="green">10878</FONT>        /**<a name="line.10878"></a>
<FONT color="green">10879</FONT>         * Draws a pie slice whose area is shaded using horizontal bars.<a name="line.10879"></a>
<FONT color="green">10880</FONT>         * <a name="line.10880"></a>
<FONT color="green">10881</FONT>         * &lt;p&gt;<a name="line.10881"></a>
<FONT color="green">10882</FONT>         * The vertical distance between corresponding edges of successive bars is<a name="line.10882"></a>
<FONT color="green">10883</FONT>         * governed by the symbol's fill spacing property; the height of each bar is<a name="line.10883"></a>
<FONT color="green">10884</FONT>         * defined by the symbol's fill thickness property; the border and<a name="line.10884"></a>
<FONT color="green">10885</FONT>         * background of each shading bar are defined by the symbol's border color,<a name="line.10885"></a>
<FONT color="green">10886</FONT>         * border width, border style, and background color properties.<a name="line.10886"></a>
<FONT color="green">10887</FONT>         * <a name="line.10887"></a>
<FONT color="green">10888</FONT>         * &lt;p&gt;<a name="line.10888"></a>
<FONT color="green">10889</FONT>         * The radius of the pie slice (length of the non-arc sides of the slice) is<a name="line.10889"></a>
<FONT color="green">10890</FONT>         * chosen such that a circle with this radius circumscribes the host<a name="line.10890"></a>
<FONT color="green">10891</FONT>         * &lt;tt&gt;Symbol&lt;/tt&gt;'s width/height determined rectangle. The slice pivot<a name="line.10891"></a>
<FONT color="green">10892</FONT>         * point is defined by each point's x,y position, and the orientation and<a name="line.10892"></a>
<FONT color="green">10893</FONT>         * size of the slice by the corresponding properties (see links below) of<a name="line.10893"></a>
<FONT color="green">10894</FONT>         * the host &lt;tt&gt;Symbol&lt;/tt&gt;.<a name="line.10894"></a>
<FONT color="green">10895</FONT>         * <a name="line.10895"></a>
<FONT color="green">10896</FONT>         * @see Symbol#setFillSpacing setFillSpacing<a name="line.10896"></a>
<FONT color="green">10897</FONT>         * @see Symbol#setFillThickness setFillThickness<a name="line.10897"></a>
<FONT color="green">10898</FONT>         * @see Symbol#setBorderColor setBorderColor<a name="line.10898"></a>
<FONT color="green">10899</FONT>         * @see Symbol#setBorderWidth setBorderWidth<a name="line.10899"></a>
<FONT color="green">10900</FONT>         * @see Symbol#setBackgroundColor setBackgroundColor<a name="line.10900"></a>
<FONT color="green">10901</FONT>         * @see Symbol#setPieSliceOrientation setPieSliceOrientation<a name="line.10901"></a>
<FONT color="green">10902</FONT>         * @see Symbol#setPieSliceSize setPieSliceSize<a name="line.10902"></a>
<FONT color="green">10903</FONT>         * @see Curve.Point#setX setX<a name="line.10903"></a>
<FONT color="green">10904</FONT>         * @see Curve.Point#setY setY<a name="line.10904"></a>
<FONT color="green">10905</FONT>         * @see #PIE_SLICE_VERTICAL_SHADING PIE_SLICE_VERTICAL_SHADING<a name="line.10905"></a>
<FONT color="green">10906</FONT>         * @see #PIE_SLICE_HATCHED_SHADING PIE_SLICE_HATCHED_SHADING<a name="line.10906"></a>
<FONT color="green">10907</FONT>         * @see #PIE_SLICE_OPTIMAL_SHADING PIE_SLICE_OPTIMAL_SHADING<a name="line.10907"></a>
<FONT color="green">10908</FONT>         * @see Symbol Symbol<a name="line.10908"></a>
<FONT color="green">10909</FONT>         * <a name="line.10909"></a>
<FONT color="green">10910</FONT>         * <a name="line.10910"></a>
<FONT color="green">10911</FONT>         */<a name="line.10911"></a>
<FONT color="green">10912</FONT>        public static SymbolType PIE_SLICE_HORIZONTAL_SHADING = <a name="line.10912"></a>
<FONT color="green">10913</FONT>          new PieSliceSymbolType(true, false, false, 0, 0, 0, 0);<a name="line.10913"></a>
<FONT color="green">10914</FONT>        /**<a name="line.10914"></a>
<FONT color="green">10915</FONT>         * Draws a pie slice whose area is shaded using vertical bars.<a name="line.10915"></a>
<FONT color="green">10916</FONT>         * &lt;p&gt;<a name="line.10916"></a>
<FONT color="green">10917</FONT>         * <a name="line.10917"></a>
<FONT color="green">10918</FONT>         * The horizontal distance between corresponding edges of successive bars is<a name="line.10918"></a>
<FONT color="green">10919</FONT>         * governed by the symbol's fill spacing property; the width of each bar is<a name="line.10919"></a>
<FONT color="green">10920</FONT>         * defined by the symbol's fill thickness property; the border and<a name="line.10920"></a>
<FONT color="green">10921</FONT>         * background of each shading bar are defined by the symbol's border color,<a name="line.10921"></a>
<FONT color="green">10922</FONT>         * border width, and background color properties.<a name="line.10922"></a>
<FONT color="green">10923</FONT>         * <a name="line.10923"></a>
<FONT color="green">10924</FONT>         * &lt;p&gt;<a name="line.10924"></a>
<FONT color="green">10925</FONT>         * The radius of the pie slice (length of the non-arc sides of the slice) is<a name="line.10925"></a>
<FONT color="green">10926</FONT>         * chosen such that a circle with this radius circumscribes the host<a name="line.10926"></a>
<FONT color="green">10927</FONT>         * &lt;tt&gt;Symbol&lt;/tt&gt;'s width/height determined rectangle. The slice pivot<a name="line.10927"></a>
<FONT color="green">10928</FONT>         * point is defined by each point's x,y position, and the orientation and<a name="line.10928"></a>
<FONT color="green">10929</FONT>         * size of the slice by the corresponding properties (see links below) of<a name="line.10929"></a>
<FONT color="green">10930</FONT>         * the host &lt;tt&gt;Symbol&lt;/tt&gt;.<a name="line.10930"></a>
<FONT color="green">10931</FONT>         * <a name="line.10931"></a>
<FONT color="green">10932</FONT>         * @see Symbol#setFillSpacing setFillSpacing<a name="line.10932"></a>
<FONT color="green">10933</FONT>         * @see Symbol#setFillThickness setFillThickness<a name="line.10933"></a>
<FONT color="green">10934</FONT>         * @see Symbol#setBorderColor setBorderColor<a name="line.10934"></a>
<FONT color="green">10935</FONT>         * @see Symbol#setBorderWidth setBorderWidth<a name="line.10935"></a>
<FONT color="green">10936</FONT>         * @see Symbol#setBackgroundColor setBackgroundColor<a name="line.10936"></a>
<FONT color="green">10937</FONT>         * @see Symbol#setPieSliceOrientation setPieSliceOrientation<a name="line.10937"></a>
<FONT color="green">10938</FONT>         * @see Symbol#setPieSliceSize setPieSliceSize<a name="line.10938"></a>
<FONT color="green">10939</FONT>         * @see Curve.Point#setX setX<a name="line.10939"></a>
<FONT color="green">10940</FONT>         * @see Curve.Point#setY setY<a name="line.10940"></a>
<FONT color="green">10941</FONT>         * @see #PIE_SLICE_HORIZONTAL_SHADING PIE_SLICE_HORIZONTAL_SHADING<a name="line.10941"></a>
<FONT color="green">10942</FONT>         * @see #PIE_SLICE_HATCHED_SHADING PIE_SLICE_HATCHED_SHADING<a name="line.10942"></a>
<FONT color="green">10943</FONT>         * @see #PIE_SLICE_OPTIMAL_SHADING PIE_SLICE_OPTIMAL_SHADING<a name="line.10943"></a>
<FONT color="green">10944</FONT>         * @see Symbol Symbol<a name="line.10944"></a>
<FONT color="green">10945</FONT>         * <a name="line.10945"></a>
<FONT color="green">10946</FONT>         * <a name="line.10946"></a>
<FONT color="green">10947</FONT>         */<a name="line.10947"></a>
<FONT color="green">10948</FONT>        public static SymbolType PIE_SLICE_VERTICAL_SHADING = new PieSliceSymbolType(<a name="line.10948"></a>
<FONT color="green">10949</FONT>            false, true, false, 0, 0, 0, 0);<a name="line.10949"></a>
<FONT color="green">10950</FONT>        /**<a name="line.10950"></a>
<FONT color="green">10951</FONT>         * Draws a pie slice whose area is shaded using both vertical and horizontal<a name="line.10951"></a>
<FONT color="green">10952</FONT>         * bars, which produces a "cross-hatched" pattern.<a name="line.10952"></a>
<FONT color="green">10953</FONT>         * &lt;p&gt;<a name="line.10953"></a>
<FONT color="green">10954</FONT>         * <a name="line.10954"></a>
<FONT color="green">10955</FONT>         * The distance between corresponding edges of successive bars is governed<a name="line.10955"></a>
<FONT color="green">10956</FONT>         * by the symbol's fill spacing property; the thickness of each bar is<a name="line.10956"></a>
<FONT color="green">10957</FONT>         * defined by the symbol's fill thickness property; the border and<a name="line.10957"></a>
<FONT color="green">10958</FONT>         * background of each shading bar are defined by the symbol's border color,<a name="line.10958"></a>
<FONT color="green">10959</FONT>         * border width, border style, and background color properties.<a name="line.10959"></a>
<FONT color="green">10960</FONT>         * <a name="line.10960"></a>
<FONT color="green">10961</FONT>         * &lt;p&gt;<a name="line.10961"></a>
<FONT color="green">10962</FONT>         * The radius of the pie slice (length of the non-arc sides of the slice) is<a name="line.10962"></a>
<FONT color="green">10963</FONT>         * chosen such that a circle with this radius circumscribes the host<a name="line.10963"></a>
<FONT color="green">10964</FONT>         * &lt;tt&gt;Symbol&lt;/tt&gt;'s width/height determined rectangle. The slice pivot<a name="line.10964"></a>
<FONT color="green">10965</FONT>         * point (i.e. pie center) is defined by each point's x,y position, and the<a name="line.10965"></a>
<FONT color="green">10966</FONT>         * orientation and size of the slice by the corresponding properties (see<a name="line.10966"></a>
<FONT color="green">10967</FONT>         * links below) of the host &lt;tt&gt;Symbol&lt;/tt&gt;.<a name="line.10967"></a>
<FONT color="green">10968</FONT>         * <a name="line.10968"></a>
<FONT color="green">10969</FONT>         * @see Symbol#setFillSpacing setFillSpacing<a name="line.10969"></a>
<FONT color="green">10970</FONT>         * @see Symbol#setFillThickness setFillThickness<a name="line.10970"></a>
<FONT color="green">10971</FONT>         * @see Symbol#setBorderColor setBorderColor<a name="line.10971"></a>
<FONT color="green">10972</FONT>         * @see Symbol#setBorderWidth setBorderWidth<a name="line.10972"></a>
<FONT color="green">10973</FONT>         * @see Symbol#setBackgroundColor setBackgroundColor<a name="line.10973"></a>
<FONT color="green">10974</FONT>         * @see Symbol#setPieSliceOrientation setPieSliceOrientation<a name="line.10974"></a>
<FONT color="green">10975</FONT>         * @see Symbol#setPieSliceSize setPieSliceSize<a name="line.10975"></a>
<FONT color="green">10976</FONT>         * @see Curve.Point#setX setX<a name="line.10976"></a>
<FONT color="green">10977</FONT>         * @see Curve.Point#setY setY<a name="line.10977"></a>
<FONT color="green">10978</FONT>         * @see #PIE_SLICE_VERTICAL_SHADING PIE_SLICE_VERTICAL_SHADING<a name="line.10978"></a>
<FONT color="green">10979</FONT>         * @see #PIE_SLICE_HORIZONTAL_SHADING PIE_SLICE_HORIZONTAL_SHADING<a name="line.10979"></a>
<FONT color="green">10980</FONT>         * @see #PIE_SLICE_OPTIMAL_SHADING PIE_SLICE_OPTIMAL_SHADING<a name="line.10980"></a>
<FONT color="green">10981</FONT>         * @see Symbol Symbol<a name="line.10981"></a>
<FONT color="green">10982</FONT>         * <a name="line.10982"></a>
<FONT color="green">10983</FONT>         * <a name="line.10983"></a>
<FONT color="green">10984</FONT>         */<a name="line.10984"></a>
<FONT color="green">10985</FONT>        public static SymbolType PIE_SLICE_HATCHED_SHADING = new PieSliceSymbolType(<a name="line.10985"></a>
<FONT color="green">10986</FONT>            true, true, false, 0, 0, 0, 0);<a name="line.10986"></a>
<FONT color="green">10987</FONT>        /**<a name="line.10987"></a>
<FONT color="green">10988</FONT>         * Draw a pie slice whose area is shaded using either vertical bars or<a name="line.10988"></a>
<FONT color="green">10989</FONT>         * horizontal bars--whichever renders the slice more efficiently.<a name="line.10989"></a>
<FONT color="green">10990</FONT>         * Specifically, pie slices that are wider than they are tall use horizontal<a name="line.10990"></a>
<FONT color="green">10991</FONT>         * shading and pie slices that are taller than they are wide use vertical<a name="line.10991"></a>
<FONT color="green">10992</FONT>         * shading. These choices minimize the the number of shading bars (and thus<a name="line.10992"></a>
<FONT color="green">10993</FONT>         * memory and time) required to render the pie slice.<a name="line.10993"></a>
<FONT color="green">10994</FONT>         * <a name="line.10994"></a>
<FONT color="green">10995</FONT>         * &lt;p&gt;<a name="line.10995"></a>
<FONT color="green">10996</FONT>         * <a name="line.10996"></a>
<FONT color="green">10997</FONT>         * The distance between corresponding edges of successive bars is governed<a name="line.10997"></a>
<FONT color="green">10998</FONT>         * by the symbol's fill spacing property; the thickness of each bar is<a name="line.10998"></a>
<FONT color="green">10999</FONT>         * defined by the symbol's fill thickness property; the border and<a name="line.10999"></a>
<FONT color="green">11000</FONT>         * background of each shading bar are defined by the symbol's border color,<a name="line.11000"></a>
<FONT color="green">11001</FONT>         * border width, and background color properties.<a name="line.11001"></a>
<FONT color="green">11002</FONT>         * &lt;p&gt;<a name="line.11002"></a>
<FONT color="green">11003</FONT>         * <a name="line.11003"></a>
<FONT color="green">11004</FONT>         * The pie slice radius is always determined by the formula:<a name="line.11004"></a>
<FONT color="green">11005</FONT>         * <a name="line.11005"></a>
<FONT color="green">11006</FONT>         * &lt;p&gt;<a name="line.11006"></a>
<FONT color="green">11007</FONT>         * &lt;blockquote&gt;<a name="line.11007"></a>
<FONT color="green">11008</FONT>         * <a name="line.11008"></a>
<FONT color="green">11009</FONT>         * &lt;pre&gt;<a name="line.11009"></a>
<FONT color="green">11010</FONT>         * sqrt(symbolWidth &amp;circ; 2 + symbolHeight &amp;circ; 2) / 2<a name="line.11010"></a>
<FONT color="green">11011</FONT>         * &lt;/pre&gt;<a name="line.11011"></a>
<FONT color="green">11012</FONT>         * <a name="line.11012"></a>
<FONT color="green">11013</FONT>         * &lt;/blockquote&gt;<a name="line.11013"></a>
<FONT color="green">11014</FONT>         * <a name="line.11014"></a>
<FONT color="green">11015</FONT>         * &lt;p&gt;<a name="line.11015"></a>
<FONT color="green">11016</FONT>         * Here &lt;tt&gt;symbolWidth&lt;/tt&gt; and &lt;tt&gt;symbolHeight&lt;/tt&gt; are the pie slice<a name="line.11016"></a>
<FONT color="green">11017</FONT>         * symbol's width and height, in pixels.<a name="line.11017"></a>
<FONT color="green">11018</FONT>         * &lt;p&gt;<a name="line.11018"></a>
<FONT color="green">11019</FONT>         * <a name="line.11019"></a>
<FONT color="green">11020</FONT>         * Note that this formula implies that the pie slice radius is the one<a name="line.11020"></a>
<FONT color="green">11021</FONT>         * associated with the circle that circumscribes the symbol, that is, the<a name="line.11021"></a>
<FONT color="green">11022</FONT>         * smallest circle that is big enough to completely contain the symbol's<a name="line.11022"></a>
<FONT color="green">11023</FONT>         * width/height defined bounding rectangle. Equivalently, the length of the<a name="line.11023"></a>
<FONT color="green">11024</FONT>         * pie slice radius equals the half the length of the diagonal across the<a name="line.11024"></a>
<FONT color="green">11025</FONT>         * symbol's bounding rectangle.<a name="line.11025"></a>
<FONT color="green">11026</FONT>         * <a name="line.11026"></a>
<FONT color="green">11027</FONT>         * &lt;p&gt;<a name="line.11027"></a>
<FONT color="green">11028</FONT>         * <a name="line.11028"></a>
<FONT color="green">11029</FONT>         * To assure an integral number of shading bars and thus improve the visual<a name="line.11029"></a>
<FONT color="green">11030</FONT>         * look of the pie chart, GChart automatically rounds the radius to the<a name="line.11030"></a>
<FONT color="green">11031</FONT>         * nearest multiple of the specified &lt;tt&gt;fillSpacing&lt;/tt&gt;. For example, if<a name="line.11031"></a>
<FONT color="green">11032</FONT>         * the radius computed from the above formula were 96 pixels and the<a name="line.11032"></a>
<FONT color="green">11033</FONT>         * &lt;tt&gt;fillSpacing&lt;/tt&gt; were 10 pixels, GChart would actually use a radius<a name="line.11033"></a>
<FONT color="green">11034</FONT>         * of 100 pixels.<a name="line.11034"></a>
<FONT color="green">11035</FONT>         * <a name="line.11035"></a>
<FONT color="green">11036</FONT>         * &lt;p&gt;<a name="line.11036"></a>
<FONT color="green">11037</FONT>         * <a name="line.11037"></a>
<FONT color="green">11038</FONT>         * &lt;i&gt;Tip:&lt;/i&gt; To produce a pie slice with a radius, r, set the symbol's<a name="line.11038"></a>
<FONT color="green">11039</FONT>         * height to 0, and its width to 2*r (or visa-versa). To specify the radius<a name="line.11039"></a>
<FONT color="green">11040</FONT>         * in pixels, use the symbol's &lt;tt&gt;setWidth&lt;/tt&gt; and &lt;tt&gt;setHeight&lt;/tt&gt;<a name="line.11040"></a>
<FONT color="green">11041</FONT>         * methods; to specify the radius in "model units" (which scale up or down<a name="line.11041"></a>
<FONT color="green">11042</FONT>         * with the chart dimensions) use &lt;tt&gt;setModelWidth&lt;/tt&gt; and<a name="line.11042"></a>
<FONT color="green">11043</FONT>         * &lt;tt&gt;setModelHeight&lt;/tt&gt; instead.<a name="line.11043"></a>
<FONT color="green">11044</FONT>         * <a name="line.11044"></a>
<FONT color="green">11045</FONT>         * &lt;p&gt;<a name="line.11045"></a>
<FONT color="green">11046</FONT>         * <a name="line.11046"></a>
<FONT color="green">11047</FONT>         * <a name="line.11047"></a>
<FONT color="green">11048</FONT>         * &lt;p&gt;<a name="line.11048"></a>
<FONT color="green">11049</FONT>         * The slice pivot point (i.e. pie center) is defined by each point's x,y<a name="line.11049"></a>
<FONT color="green">11050</FONT>         * position, and the orientation and size of the slice by the<a name="line.11050"></a>
<FONT color="green">11051</FONT>         * &lt;tt&gt;setPieSliceOrientation&lt;/tt&gt; and &lt;tt&gt;setPieSliceSize&lt;/tt&gt; methods of<a name="line.11051"></a>
<FONT color="green">11052</FONT>         * the host &lt;tt&gt;Symbol&lt;/tt&gt;.<a name="line.11052"></a>
<FONT color="green">11053</FONT>         * &lt;p&gt;<a name="line.11053"></a>
<FONT color="green">11054</FONT>         * <a name="line.11054"></a>
<FONT color="green">11055</FONT>         * Creating a pie chart from such pie slices requires that you define a<a name="line.11055"></a>
<FONT color="green">11056</FONT>         * separate curve for each slice, as illustrated in the code below:<a name="line.11056"></a>
<FONT color="green">11057</FONT>         * <a name="line.11057"></a>
<FONT color="green">11058</FONT>         * {@code.sample ../../../../../../gcharttestapp/src/com/googlecode/gchart/gcharttestapp/client/GChartExample09.java}<a name="line.11058"></a>
<FONT color="green">11059</FONT>         * <a name="line.11059"></a>
<FONT color="green">11060</FONT>         * &lt;p&gt;<a name="line.11060"></a>
<FONT color="green">11061</FONT>         * <a name="line.11061"></a>
<FONT color="green">11062</FONT>         * Which produces this:<a name="line.11062"></a>
<FONT color="green">11063</FONT>         * &lt;p&gt;<a name="line.11063"></a>
<FONT color="green">11064</FONT>         * <a name="line.11064"></a>
<FONT color="green">11065</FONT>         * &lt;img src="{@docRoot}/com/googlecode/gchart/client/doc-files/gchartexample09.png"&gt;<a name="line.11065"></a>
<FONT color="green">11066</FONT>         * <a name="line.11066"></a>
<FONT color="green">11067</FONT>         * &lt;p&gt;<a name="line.11067"></a>
<FONT color="green">11068</FONT>         * Note how, because &lt;tt&gt;PIE_SLICE_OPTIMAL_SHADING&lt;/tt&gt; was used, vertical<a name="line.11068"></a>
<FONT color="green">11069</FONT>         * or horizontal shading is automatically selected so as to minimize the<a name="line.11069"></a>
<FONT color="green">11070</FONT>         * number of shading bars in each slice.<a name="line.11070"></a>
<FONT color="green">11071</FONT>         * <a name="line.11071"></a>
<FONT color="green">11072</FONT>         * @see Symbol Symbol<a name="line.11072"></a>
<FONT color="green">11073</FONT>         * @see Symbol#setFillSpacing setFillSpacing<a name="line.11073"></a>
<FONT color="green">11074</FONT>         * @see Symbol#setFillThickness setFillThickness<a name="line.11074"></a>
<FONT color="green">11075</FONT>         * @see Symbol#setBorderColor setBorderColor<a name="line.11075"></a>
<FONT color="green">11076</FONT>         * @see Symbol#setBorderWidth setBorderWidth<a name="line.11076"></a>
<FONT color="green">11077</FONT>         * @see Symbol#setBackgroundColor setBackgroundColor<a name="line.11077"></a>
<FONT color="green">11078</FONT>         * @see Symbol#setPieSliceOrientation setPieSliceOrientation<a name="line.11078"></a>
<FONT color="green">11079</FONT>         * @see Symbol#setPieSliceSize setPieSliceSize<a name="line.11079"></a>
<FONT color="green">11080</FONT>         * @see Symbol#setWidth setWidth<a name="line.11080"></a>
<FONT color="green">11081</FONT>         * @see Symbol#setHeight setHeight<a name="line.11081"></a>
<FONT color="green">11082</FONT>         * @see Symbol#setModelWidth setModelWidth<a name="line.11082"></a>
<FONT color="green">11083</FONT>         * @see Symbol#setModelHeight setModelHeight<a name="line.11083"></a>
<FONT color="green">11084</FONT>         * @see Curve.Point#setX setX<a name="line.11084"></a>
<FONT color="green">11085</FONT>         * @see Curve.Point#setY setY<a name="line.11085"></a>
<FONT color="green">11086</FONT>         * @see #PIE_SLICE_VERTICAL_SHADING PIE_SLICE_VERTICAL_SHADING<a name="line.11086"></a>
<FONT color="green">11087</FONT>         * @see #PIE_SLICE_HORIZONTAL_SHADING PIE_SLICE_HORIZONTAL_SHADING<a name="line.11087"></a>
<FONT color="green">11088</FONT>         * @see #PIE_SLICE_HATCHED_SHADING PIE_SLICE_HATCHED_SHADING<a name="line.11088"></a>
<FONT color="green">11089</FONT>         * <a name="line.11089"></a>
<FONT color="green">11090</FONT>         */<a name="line.11090"></a>
<FONT color="green">11091</FONT>        public static SymbolType PIE_SLICE_OPTIMAL_SHADING = new PieSliceSymbolType(<a name="line.11091"></a>
<FONT color="green">11092</FONT>            false, false, true, 0, 0, 0, 0);<a name="line.11092"></a>
<FONT color="green">11093</FONT>    <a name="line.11093"></a>
<FONT color="green">11094</FONT>        /**<a name="line.11094"></a>
<FONT color="green">11095</FONT>         * Use vertical bars that extend from the x,y position associated with each<a name="line.11095"></a>
<FONT color="green">11096</FONT>         * point, to the y position defined by the host &lt;tt&gt;Symbol&lt;/tt&gt;'s baseline<a name="line.11096"></a>
<FONT color="green">11097</FONT>         * property, and that are horizontally centered on the data point.<a name="line.11097"></a>
<FONT color="green">11098</FONT>         * <a name="line.11098"></a>
<FONT color="green">11099</FONT>         * @see Symbol Symbol<a name="line.11099"></a>
<FONT color="green">11100</FONT>         * @see Symbol#setBaseline setBaseline<a name="line.11100"></a>
<FONT color="green">11101</FONT>         * @see #HBAR_BASELINE_CENTER HBAR_BASELINE_CENTER<a name="line.11101"></a>
<FONT color="green">11102</FONT>         * @see #HBAR_BASELINE_SOUTH HBAR_BASELINE_SOUTH<a name="line.11102"></a>
<FONT color="green">11103</FONT>         * @see #HBAR_BASELINE_NORTH HBAR_BASELINE_NORTH<a name="line.11103"></a>
<FONT color="green">11104</FONT>         * @see #VBAR_BASELINE_CENTER VBAR_BASELINE_CENTER<a name="line.11104"></a>
<FONT color="green">11105</FONT>         * @see #VBAR_BASELINE_EAST VBAR_BASELINE_EAST<a name="line.11105"></a>
<FONT color="green">11106</FONT>         * @see #VBAR_BASELINE_WEST VBAR_BASELINE_WEST<a name="line.11106"></a>
<FONT color="green">11107</FONT>         * <a name="line.11107"></a>
<FONT color="green">11108</FONT>         */<a name="line.11108"></a>
<FONT color="green">11109</FONT>        public static SymbolType VBAR_BASELINE_CENTER = new VBarBaseline(0, 0);<a name="line.11109"></a>
<FONT color="green">11110</FONT>        /**<a name="line.11110"></a>
<FONT color="green">11111</FONT>         * Use vertical bars that extend from the x,y position associated with each<a name="line.11111"></a>
<FONT color="green">11112</FONT>         * point, to the y position defined by the host &lt;tt&gt;Symbol&lt;/tt&gt;'s baseline<a name="line.11112"></a>
<FONT color="green">11113</FONT>         * property, and whose right edge passes through the data point.<a name="line.11113"></a>
<FONT color="green">11114</FONT>         * <a name="line.11114"></a>
<FONT color="green">11115</FONT>         * @see Symbol Symbol<a name="line.11115"></a>
<FONT color="green">11116</FONT>         * @see Symbol#setBaseline setBaseline<a name="line.11116"></a>
<FONT color="green">11117</FONT>         * @see #HBAR_BASELINE_CENTER HBAR_BASELINE_CENTER<a name="line.11117"></a>
<FONT color="green">11118</FONT>         * @see #HBAR_BASELINE_SOUTH HBAR_BASELINE_SOUTH<a name="line.11118"></a>
<FONT color="green">11119</FONT>         * @see #HBAR_BASELINE_NORTH HBAR_BASELINE_NORTH<a name="line.11119"></a>
<FONT color="green">11120</FONT>         * @see #VBAR_BASELINE_CENTER VBAR_BASELINE_CENTER<a name="line.11120"></a>
<FONT color="green">11121</FONT>         * @see #VBAR_BASELINE_EAST VBAR_BASELINE_EAST<a name="line.11121"></a>
<FONT color="green">11122</FONT>         * @see #VBAR_BASELINE_WEST VBAR_BASELINE_WEST<a name="line.11122"></a>
<FONT color="green">11123</FONT>         * <a name="line.11123"></a>
<FONT color="green">11124</FONT>         */<a name="line.11124"></a>
<FONT color="green">11125</FONT>        public static SymbolType VBAR_BASELINE_WEST = new VBarBaseline(-1, 0);<a name="line.11125"></a>
<FONT color="green">11126</FONT>        /**<a name="line.11126"></a>
<FONT color="green">11127</FONT>         * Use vertical bars that extend from the x,y position associated with each<a name="line.11127"></a>
<FONT color="green">11128</FONT>         * point, to the y position defined by the host &lt;tt&gt;Symbol&lt;/tt&gt;'s baseline<a name="line.11128"></a>
<FONT color="green">11129</FONT>         * property, and whose left edge passes through the data point.<a name="line.11129"></a>
<FONT color="green">11130</FONT>         * <a name="line.11130"></a>
<FONT color="green">11131</FONT>         * @see Symbol#setBaseline setBaseline<a name="line.11131"></a>
<FONT color="green">11132</FONT>         * @see #HBAR_BASELINE_CENTER HBAR_BASELINE_CENTER<a name="line.11132"></a>
<FONT color="green">11133</FONT>         * @see #HBAR_BASELINE_SOUTH HBAR_BASELINE_SOUTH<a name="line.11133"></a>
<FONT color="green">11134</FONT>         * @see #HBAR_BASELINE_NORTH HBAR_BASELINE_NORTH<a name="line.11134"></a>
<FONT color="green">11135</FONT>         * @see #VBAR_BASELINE_CENTER VBAR_BASELINE_CENTER<a name="line.11135"></a>
<FONT color="green">11136</FONT>         * @see #VBAR_BASELINE_EAST VBAR_BASELINE_EAST<a name="line.11136"></a>
<FONT color="green">11137</FONT>         * @see #VBAR_BASELINE_WEST VBAR_BASELINE_WEST<a name="line.11137"></a>
<FONT color="green">11138</FONT>         * <a name="line.11138"></a>
<FONT color="green">11139</FONT>         */<a name="line.11139"></a>
<FONT color="green">11140</FONT>        public static SymbolType VBAR_BASELINE_EAST = new VBarBaseline(1, 0);<a name="line.11140"></a>
<FONT color="green">11141</FONT>        /**<a name="line.11141"></a>
<FONT color="green">11142</FONT>         * @deprecated<a name="line.11142"></a>
<FONT color="green">11143</FONT>         * <a name="line.11143"></a>
<FONT color="green">11144</FONT>         *             As of version 2.4, this symbol has been redefined to be<a name="line.11144"></a>
<FONT color="green">11145</FONT>         *             synonomous with the LINE symbol type.<a name="line.11145"></a>
<FONT color="green">11146</FONT>         *             &lt;p&gt;<a name="line.11146"></a>
<FONT color="green">11147</FONT>         * <a name="line.11147"></a>
<FONT color="green">11148</FONT>         *             Prior to v2.4, this symbol drew a vertical bar from each<a name="line.11148"></a>
<FONT color="green">11149</FONT>         *             point to the y coordinate of the next point. Some<a name="line.11149"></a>
<FONT color="green">11150</FONT>         *             applications may need to use a revised point set in order to<a name="line.11150"></a>
<FONT color="green">11151</FONT>         *             produce the same curves with &lt;tt&gt;LINE&lt;/tt&gt; that they used to<a name="line.11151"></a>
<FONT color="green">11152</FONT>         *             produce with this symbol.<a name="line.11152"></a>
<FONT color="green">11153</FONT>         *             &lt;p&gt;<a name="line.11153"></a>
<FONT color="green">11154</FONT>         * <a name="line.11154"></a>
<FONT color="green">11155</FONT>         *             Support was dropped because:<a name="line.11155"></a>
<FONT color="green">11156</FONT>         * <a name="line.11156"></a>
<FONT color="green">11157</FONT>         *             &lt;p&gt;<a name="line.11157"></a>
<FONT color="green">11158</FONT>         *             &lt;ol&gt;<a name="line.11158"></a>
<FONT color="green">11159</FONT>         * <a name="line.11159"></a>
<FONT color="green">11160</FONT>         *             &lt;li&gt;Continued support would have complicated implementation<a name="line.11160"></a>
<FONT color="green">11161</FONT>         *             of the new hover feedback system introduced with v2.4 (these<a name="line.11161"></a>
<FONT color="green">11162</FONT>         *             are the only symbols whose hit-testing-related size depends<a name="line.11162"></a>
<FONT color="green">11163</FONT>         *             on preceding or subsequent points).<a name="line.11163"></a>
<FONT color="green">11164</FONT>         *             &lt;p&gt;<a name="line.11164"></a>
<FONT color="green">11165</FONT>         * <a name="line.11165"></a>
<FONT color="green">11166</FONT>         *             &lt;li&gt;With the introduction of &lt;tt&gt;LINE&lt;/tt&gt; the main reason<a name="line.11166"></a>
<FONT color="green">11167</FONT>         *             for this, and related, vertically (or horizontally)<a name="line.11167"></a>
<FONT color="green">11168</FONT>         *             constrained line drawing symbol types had been eliminated<a name="line.11168"></a>
<FONT color="green">11169</FONT>         *             (had &lt;tt&gt;LINE&lt;/tt&gt; existed at the beginning, these<a name="line.11169"></a>
<FONT color="green">11170</FONT>         *             constrained line drawing symbol types would never have been<a name="line.11170"></a>
<FONT color="green">11171</FONT>         *             added).<a name="line.11171"></a>
<FONT color="green">11172</FONT>         *             &lt;p&gt;<a name="line.11172"></a>
<FONT color="green">11173</FONT>         * <a name="line.11173"></a>
<FONT color="green">11174</FONT>         *             &lt;/ol&gt;<a name="line.11174"></a>
<FONT color="green">11175</FONT>         *             &lt;p&gt;<a name="line.11175"></a>
<FONT color="green">11176</FONT>         * <a name="line.11176"></a>
<FONT color="green">11177</FONT>         *             Finally, note that if lines are vertical or horizontal, and<a name="line.11177"></a>
<FONT color="green">11178</FONT>         *             solidly connected, &lt;tt&gt;LINE&lt;/tt&gt; automatically collapses them<a name="line.11178"></a>
<FONT color="green">11179</FONT>         *             into a single element, so no element-based efficiency losses<a name="line.11179"></a>
<FONT color="green">11180</FONT>         *             need be associated with replacing curves using such<a name="line.11180"></a>
<FONT color="green">11181</FONT>         *             rectilinear symbol types with equivalent curves rendered via<a name="line.11181"></a>
<FONT color="green">11182</FONT>         *             the &lt;tt&gt;LINE&lt;/tt&gt; symbol type.<a name="line.11182"></a>
<FONT color="green">11183</FONT>         *             &lt;p&gt;<a name="line.11183"></a>
<FONT color="green">11184</FONT>         * <a name="line.11184"></a>
<FONT color="green">11185</FONT>         * <a name="line.11185"></a>
<FONT color="green">11186</FONT>         * @see #HBAR_PREV HBAR_PREV<a name="line.11186"></a>
<FONT color="green">11187</FONT>         * @see #HBAR_NEXT HBAR_NEXT<a name="line.11187"></a>
<FONT color="green">11188</FONT>         * @see #LINE LINE<a name="line.11188"></a>
<FONT color="green">11189</FONT>         * @see #VBAR_PREV VBAR_PREV<a name="line.11189"></a>
<FONT color="green">11190</FONT>         * <a name="line.11190"></a>
<FONT color="green">11191</FONT>         */<a name="line.11191"></a>
<FONT color="green">11192</FONT>        public static SymbolType VBAR_NEXT = line;<a name="line.11192"></a>
<FONT color="green">11193</FONT>    <a name="line.11193"></a>
<FONT color="green">11194</FONT>        /**<a name="line.11194"></a>
<FONT color="green">11195</FONT>         * Use vertical bars that extend from the top of the chart to each point on<a name="line.11195"></a>
<FONT color="green">11196</FONT>         * the curve, and are horizontally centered on the point.<a name="line.11196"></a>
<FONT color="green">11197</FONT>         */<a name="line.11197"></a>
<FONT color="green">11198</FONT>        public static SymbolType VBAR_NORTH = new VBarTop(0, -1);<a name="line.11198"></a>
<FONT color="green">11199</FONT>        /**<a name="line.11199"></a>
<FONT color="green">11200</FONT>         * Use vertical bars that extend from the top of the chart to each point on<a name="line.11200"></a>
<FONT color="green">11201</FONT>         * the curve, and are horizontally to the right of the point.<a name="line.11201"></a>
<FONT color="green">11202</FONT>         */<a name="line.11202"></a>
<FONT color="green">11203</FONT>        public static SymbolType VBAR_NORTHEAST = new VBarTop(1, -1);<a name="line.11203"></a>
<FONT color="green">11204</FONT>    <a name="line.11204"></a>
<FONT color="green">11205</FONT>        /**<a name="line.11205"></a>
<FONT color="green">11206</FONT>         * Use vertical bars that extend from the top of the chart to each point on<a name="line.11206"></a>
<FONT color="green">11207</FONT>         * the curve, and are horizontally to the left of the point.<a name="line.11207"></a>
<FONT color="green">11208</FONT>         */<a name="line.11208"></a>
<FONT color="green">11209</FONT>        public static SymbolType VBAR_NORTHWEST = new VBarTop(-1, -1);<a name="line.11209"></a>
<FONT color="green">11210</FONT>        /**<a name="line.11210"></a>
<FONT color="green">11211</FONT>         * @deprecated<a name="line.11211"></a>
<FONT color="green">11212</FONT>         * <a name="line.11212"></a>
<FONT color="green">11213</FONT>         *             As of version 2.4, this symbol has been redefined to be<a name="line.11213"></a>
<FONT color="green">11214</FONT>         *             synonomous with the LINE symbol type.<a name="line.11214"></a>
<FONT color="green">11215</FONT>         *             &lt;p&gt;<a name="line.11215"></a>
<FONT color="green">11216</FONT>         * <a name="line.11216"></a>
<FONT color="green">11217</FONT>         *             Prior to v2.4, this symbol drew a vertical bar from each<a name="line.11217"></a>
<FONT color="green">11218</FONT>         *             point to the y coordinate of the previous point. Some<a name="line.11218"></a>
<FONT color="green">11219</FONT>         *             applications may need to use a revised point set in order to<a name="line.11219"></a>
<FONT color="green">11220</FONT>         *             produce the same curves using &lt;tt&gt;LINE&lt;/tt&gt; that they used to<a name="line.11220"></a>
<FONT color="green">11221</FONT>         *             produce with this symbol.<a name="line.11221"></a>
<FONT color="green">11222</FONT>         *             &lt;p&gt;<a name="line.11222"></a>
<FONT color="green">11223</FONT>         * <a name="line.11223"></a>
<FONT color="green">11224</FONT>         *             See the discussion within the {@link #VBAR_NEXT VBAR_NEXT}<a name="line.11224"></a>
<FONT color="green">11225</FONT>         *             symbol for more information about why support for these<a name="line.11225"></a>
<FONT color="green">11226</FONT>         *             vertically and horizontally constrained connecting line<a name="line.11226"></a>
<FONT color="green">11227</FONT>         *             symbol types was dropped.<a name="line.11227"></a>
<FONT color="green">11228</FONT>         * <a name="line.11228"></a>
<FONT color="green">11229</FONT>         * @see #LINE LINE<a name="line.11229"></a>
<FONT color="green">11230</FONT>         * @see #HBAR_PREV HBAR_PREV<a name="line.11230"></a>
<FONT color="green">11231</FONT>         * @see #HBAR_NEXT HBAR_NEXT<a name="line.11231"></a>
<FONT color="green">11232</FONT>         * @see #VBAR_NEXT VBAR_NEXT<a name="line.11232"></a>
<FONT color="green">11233</FONT>         * <a name="line.11233"></a>
<FONT color="green">11234</FONT>         */<a name="line.11234"></a>
<FONT color="green">11235</FONT>    <a name="line.11235"></a>
<FONT color="green">11236</FONT>        public static SymbolType VBAR_PREV = line;<a name="line.11236"></a>
<FONT color="green">11237</FONT>    <a name="line.11237"></a>
<FONT color="green">11238</FONT>        /**<a name="line.11238"></a>
<FONT color="green">11239</FONT>         * Use vertical bars that extend from the x-axis to each point on the curve,<a name="line.11239"></a>
<FONT color="green">11240</FONT>         * and that are horizontally centered on the point.<a name="line.11240"></a>
<FONT color="green">11241</FONT>         */<a name="line.11241"></a>
<FONT color="green">11242</FONT>        public static SymbolType VBAR_SOUTH = new VBarBottom(0, 1);<a name="line.11242"></a>
<FONT color="green">11243</FONT>        /**<a name="line.11243"></a>
<FONT color="green">11244</FONT>         * Use vertical bars that extend from the x-axis to each point on the curve,<a name="line.11244"></a>
<FONT color="green">11245</FONT>         * and that are horizontally to the right of the point.<a name="line.11245"></a>
<FONT color="green">11246</FONT>         */<a name="line.11246"></a>
<FONT color="green">11247</FONT>        public static SymbolType VBAR_SOUTHEAST = new VBarBottom(1, 1);<a name="line.11247"></a>
<FONT color="green">11248</FONT>    <a name="line.11248"></a>
<FONT color="green">11249</FONT>        /**<a name="line.11249"></a>
<FONT color="green">11250</FONT>         * Use vertical bars that extend from the x-axis to each point on the curve,<a name="line.11250"></a>
<FONT color="green">11251</FONT>         * and that are horizontally to the left of the point.<a name="line.11251"></a>
<FONT color="green">11252</FONT>         */<a name="line.11252"></a>
<FONT color="green">11253</FONT>        public static SymbolType VBAR_SOUTHWEST = new VBarBottom(-1, 1);<a name="line.11253"></a>
<FONT color="green">11254</FONT>        /**<a name="line.11254"></a>
<FONT color="green">11255</FONT>         * Represents a single x-axis grid-line. You can use this symbol to draw a<a name="line.11255"></a>
<FONT color="green">11256</FONT>         * single vertical bar across the chart.<a name="line.11256"></a>
<FONT color="green">11257</FONT>         * <a name="line.11257"></a>
<FONT color="green">11258</FONT>         */<a name="line.11258"></a>
<FONT color="green">11259</FONT>        public static SymbolType XGRIDLINE = new SymbolType(0, 0, 0, 0, 0.5,<a name="line.11259"></a>
<FONT color="green">11260</FONT>            0.5, Boolean.FALSE) {<a name="line.11260"></a>
<FONT color="green">11261</FONT>          public double getAdjustedHeight(double height, double y,<a name="line.11261"></a>
<FONT color="green">11262</FONT>              double yPrev, double yNext, double yMin, double yMax,<a name="line.11262"></a>
<FONT color="green">11263</FONT>              double yMid) {<a name="line.11263"></a>
<FONT color="green">11264</FONT>            return yMax - yMin;<a name="line.11264"></a>
<FONT color="green">11265</FONT>          }<a name="line.11265"></a>
<FONT color="green">11266</FONT>    <a name="line.11266"></a>
<FONT color="green">11267</FONT>          public double getUpperLeftY(double height, double y, double yPrev,<a name="line.11267"></a>
<FONT color="green">11268</FONT>              double yNext, double yMin, double yMax, double yMid,<a name="line.11268"></a>
<FONT color="green">11269</FONT>              int yMouse) {<a name="line.11269"></a>
<FONT color="green">11270</FONT>            return yMin;<a name="line.11270"></a>
<FONT color="green">11271</FONT>          }<a name="line.11271"></a>
<FONT color="green">11272</FONT>    <a name="line.11272"></a>
<FONT color="green">11273</FONT>          int getIconHeight(int legendFontSize) {<a name="line.11273"></a>
<FONT color="green">11274</FONT>            return legendFontSize;<a name="line.11274"></a>
<FONT color="green">11275</FONT>          }<a name="line.11275"></a>
<FONT color="green">11276</FONT>    <a name="line.11276"></a>
<FONT color="green">11277</FONT>          int getIconWidth(int legendFontSize) {<a name="line.11277"></a>
<FONT color="green">11278</FONT>            return 1;<a name="line.11278"></a>
<FONT color="green">11279</FONT>          }<a name="line.11279"></a>
<FONT color="green">11280</FONT>    <a name="line.11280"></a>
<FONT color="green">11281</FONT>        };<a name="line.11281"></a>
<FONT color="green">11282</FONT>        /**<a name="line.11282"></a>
<FONT color="green">11283</FONT>         * Represents a single y-axis (or y2-axis) grid-line. You can use this<a name="line.11283"></a>
<FONT color="green">11284</FONT>         * symbol to draw a single horizontal line (or bar) across the chart, for<a name="line.11284"></a>
<FONT color="green">11285</FONT>         * example, to display an upper bound or control limit.<a name="line.11285"></a>
<FONT color="green">11286</FONT>         * <a name="line.11286"></a>
<FONT color="green">11287</FONT>         */<a name="line.11287"></a>
<FONT color="green">11288</FONT>        public static SymbolType YGRIDLINE = new SymbolType(0, 0, 0.5, 0.5, 0,<a name="line.11288"></a>
<FONT color="green">11289</FONT>            0, Boolean.TRUE) {<a name="line.11289"></a>
<FONT color="green">11290</FONT>          public double getAdjustedWidth(double width, double x,<a name="line.11290"></a>
<FONT color="green">11291</FONT>              double xPrev, double xNext, double xMin, double xMax,<a name="line.11291"></a>
<FONT color="green">11292</FONT>              double xMid) {<a name="line.11292"></a>
<FONT color="green">11293</FONT>            return xMax - xMin;<a name="line.11293"></a>
<FONT color="green">11294</FONT>          }<a name="line.11294"></a>
<FONT color="green">11295</FONT>    <a name="line.11295"></a>
<FONT color="green">11296</FONT>          public double getUpperLeftX(double width, double x, double xPrev,<a name="line.11296"></a>
<FONT color="green">11297</FONT>              double xNext, double xMin, double xMax, double xMid,<a name="line.11297"></a>
<FONT color="green">11298</FONT>              int xMouse) {<a name="line.11298"></a>
<FONT color="green">11299</FONT>            return xMin;<a name="line.11299"></a>
<FONT color="green">11300</FONT>          }<a name="line.11300"></a>
<FONT color="green">11301</FONT>    <a name="line.11301"></a>
<FONT color="green">11302</FONT>          int getIconHeight(int legendFontSize) {<a name="line.11302"></a>
<FONT color="green">11303</FONT>            return 1;<a name="line.11303"></a>
<FONT color="green">11304</FONT>          }<a name="line.11304"></a>
<FONT color="green">11305</FONT>    <a name="line.11305"></a>
<FONT color="green">11306</FONT>          int getIconWidth(int legendFontSize) {<a name="line.11306"></a>
<FONT color="green">11307</FONT>            return legendFontSize;<a name="line.11307"></a>
<FONT color="green">11308</FONT>          }<a name="line.11308"></a>
<FONT color="green">11309</FONT>    <a name="line.11309"></a>
<FONT color="green">11310</FONT>        };<a name="line.11310"></a>
<FONT color="green">11311</FONT>    <a name="line.11311"></a>
<FONT color="green">11312</FONT>        /**<a name="line.11312"></a>
<FONT color="green">11313</FONT>         * @deprecated<a name="line.11313"></a>
<FONT color="green">11314</FONT>         * <a name="line.11314"></a>
<FONT color="green">11315</FONT>         *             This symbol is the same as &lt;tt&gt;YGRIDLINE&lt;/tt&gt; and was added<a name="line.11315"></a>
<FONT color="green">11316</FONT>         *             by mistake in version 1. (the y-axis isn't defined by the<a name="line.11316"></a>
<FONT color="green">11317</FONT>         *             symbol type, but rather by the curve's &lt;tt&gt;setYAxis&lt;/tt&gt;<a name="line.11317"></a>
<FONT color="green">11318</FONT>         *             method).<a name="line.11318"></a>
<FONT color="green">11319</FONT>         *             &lt;p&gt;<a name="line.11319"></a>
<FONT color="green">11320</FONT>         *             Please use &lt;tt&gt;YGRIDLINE&lt;/tt&gt; instead.<a name="line.11320"></a>
<FONT color="green">11321</FONT>         * <a name="line.11321"></a>
<FONT color="green">11322</FONT>         * @see #YGRIDLINE YGRIDLINE<a name="line.11322"></a>
<FONT color="green">11323</FONT>         * @see GChart.Curve#setYAxis setYAxis<a name="line.11323"></a>
<FONT color="green">11324</FONT>         * <a name="line.11324"></a>
<FONT color="green">11325</FONT>         */<a name="line.11325"></a>
<FONT color="green">11326</FONT>    <a name="line.11326"></a>
<FONT color="green">11327</FONT>        public static SymbolType Y2GRIDLINE = YGRIDLINE;<a name="line.11327"></a>
<FONT color="green">11328</FONT>    <a name="line.11328"></a>
<FONT color="green">11329</FONT>        // play similar role as same-named fields of AnnotationLocation<a name="line.11329"></a>
<FONT color="green">11330</FONT>        protected int heightMultiplier;<a name="line.11330"></a>
<FONT color="green">11331</FONT>        protected int widthMultiplier;<a name="line.11331"></a>
<FONT color="green">11332</FONT>        /*<a name="line.11332"></a>
<FONT color="green">11333</FONT>         * If a symbol's left, right, top, or bottom edge represents the x or y<a name="line.11333"></a>
<FONT color="green">11334</FONT>         * location associated with this symbol, the corresponding pixel paddings<a name="line.11334"></a>
<FONT color="green">11335</FONT>         * are 0.<a name="line.11335"></a>
<FONT color="green">11336</FONT>         * <a name="line.11336"></a>
<FONT color="green">11337</FONT>         * If a position 1/2 pixel to the right, left, below, or above<a name="line.11337"></a>
<FONT color="green">11338</FONT>         * (respectively) those edges represents the position of the x or y in<a name="line.11338"></a>
<FONT color="green">11339</FONT>         * question, the values are 0.5.<a name="line.11339"></a>
<FONT color="green">11340</FONT>         * <a name="line.11340"></a>
<FONT color="green">11341</FONT>         * Why is this needed? Because GChart uses 1 px gridlines whose center<a name="line.11341"></a>
<FONT color="green">11342</FONT>         * represents the point associated with the gridline, and to get a<a name="line.11342"></a>
<FONT color="green">11343</FONT>         * corresponding edge to perfectly overlay a gridline when its associated<a name="line.11343"></a>
<FONT color="green">11344</FONT>         * position is the same as that gridline, we need to associated the position<a name="line.11344"></a>
<FONT color="green">11345</FONT>         * of the represented x or y coordinate not with the symbol's box edge<a name="line.11345"></a>
<FONT color="green">11346</FONT>         * itself, but rather with a position 1/2 px towards the center of the<a name="line.11346"></a>
<FONT color="green">11347</FONT>         * symbol. If you don't specify an extra half pixel for, say, a vertical<a name="line.11347"></a>
<FONT color="green">11348</FONT>         * bar, it won't align right on top of gridlines when it has the same height<a name="line.11348"></a>
<FONT color="green">11349</FONT>         * as the associated gridline. &lt;p&gt;<a name="line.11349"></a>
<FONT color="green">11350</FONT>         * <a name="line.11350"></a>
<FONT color="green">11351</FONT>         * In effect, we deliberately add a 1/2 px error to certain symbols so that<a name="line.11351"></a>
<FONT color="green">11352</FONT>         * they appear to line up perfectly with the gridlines.<a name="line.11352"></a>
<FONT color="green">11353</FONT>         */<a name="line.11353"></a>
<FONT color="green">11354</FONT>        protected double pixelPadLeft;<a name="line.11354"></a>
<FONT color="green">11355</FONT>        protected double pixelPadRight;<a name="line.11355"></a>
<FONT color="green">11356</FONT>        protected double pixelPadTop;<a name="line.11356"></a>
<FONT color="green">11357</FONT>        protected double pixelPadBottom;<a name="line.11357"></a>
<FONT color="green">11358</FONT>    <a name="line.11358"></a>
<FONT color="green">11359</FONT>        // symbols are part of the internals of a GChart,<a name="line.11359"></a>
<FONT color="green">11360</FONT>        // so only we should instantiate them.<a name="line.11360"></a>
<FONT color="green">11361</FONT>        private SymbolType(int widthMultiplier, int heightMultiplier,<a name="line.11361"></a>
<FONT color="green">11362</FONT>            double pixelPadLeft, double pixelPadRight, double pixelPadTop,<a name="line.11362"></a>
<FONT color="green">11363</FONT>            double pixelPadBottom, Boolean isHorizontallyBanded) {<a name="line.11363"></a>
<FONT color="green">11364</FONT>          validateMultipliers(widthMultiplier, heightMultiplier);<a name="line.11364"></a>
<FONT color="green">11365</FONT>          this.widthMultiplier = widthMultiplier;<a name="line.11365"></a>
<FONT color="green">11366</FONT>          this.heightMultiplier = heightMultiplier;<a name="line.11366"></a>
<FONT color="green">11367</FONT>          this.pixelPadLeft = pixelPadLeft;<a name="line.11367"></a>
<FONT color="green">11368</FONT>          this.pixelPadRight = pixelPadRight;<a name="line.11368"></a>
<FONT color="green">11369</FONT>          this.pixelPadTop = pixelPadTop;<a name="line.11369"></a>
<FONT color="green">11370</FONT>          this.pixelPadBottom = pixelPadBottom;<a name="line.11370"></a>
<FONT color="green">11371</FONT>          this.isHorizontallyBanded = isHorizontallyBanded;<a name="line.11371"></a>
<FONT color="green">11372</FONT>        }<a name="line.11372"></a>
<FONT color="green">11373</FONT>    <a name="line.11373"></a>
<FONT color="green">11374</FONT>        private SymbolType(int widthMultiplier, int heightMultiplier,<a name="line.11374"></a>
<FONT color="green">11375</FONT>            double pixelPadLeft, double pixelPadRight, double pixelPadTop,<a name="line.11375"></a>
<FONT color="green">11376</FONT>            double pixelPadBottom) {<a name="line.11376"></a>
<FONT color="green">11377</FONT>          this(widthMultiplier, heightMultiplier, pixelPadLeft,<a name="line.11377"></a>
<FONT color="green">11378</FONT>              pixelPadRight, pixelPadTop, pixelPadBottom, null);<a name="line.11378"></a>
<FONT color="green">11379</FONT>        }<a name="line.11379"></a>
<FONT color="green">11380</FONT>    <a name="line.11380"></a>
<FONT color="green">11381</FONT>        double getAdjustedHeight(double height, double y, double yPrev,<a name="line.11381"></a>
<FONT color="green">11382</FONT>            double yNext, double yMin, double yMax, double yMid) {<a name="line.11382"></a>
<FONT color="green">11383</FONT>          return height;<a name="line.11383"></a>
<FONT color="green">11384</FONT>        }<a name="line.11384"></a>
<FONT color="green">11385</FONT>    <a name="line.11385"></a>
<FONT color="green">11386</FONT>        double getAdjustedWidth(double width, double x, double xPrev,<a name="line.11386"></a>
<FONT color="green">11387</FONT>            double xNext, double xMin, double xMax, double xMid) {<a name="line.11387"></a>
<FONT color="green">11388</FONT>          return width;<a name="line.11388"></a>
<FONT color="green">11389</FONT>        }<a name="line.11389"></a>
<FONT color="green">11390</FONT>    <a name="line.11390"></a>
<FONT color="green">11391</FONT>        /*<a name="line.11391"></a>
<FONT color="green">11392</FONT>         * Pixel x-coordinate at center of bounding rectangle surrounding given<a name="line.11392"></a>
<FONT color="green">11393</FONT>         * symbol rendered with this symbol type. &lt;p&gt;<a name="line.11393"></a>
<FONT color="green">11394</FONT>         * <a name="line.11394"></a>
<FONT color="green">11395</FONT>         * This method defines the x-coordinate of the rendered symbol's<a name="line.11395"></a>
<FONT color="green">11396</FONT>         * center-point (used for hit testing purposes) for all symbols except pie<a name="line.11396"></a>
<FONT color="green">11397</FONT>         * slices.<a name="line.11397"></a>
<FONT color="green">11398</FONT>         */<a name="line.11398"></a>
<FONT color="green">11399</FONT>        protected double getCenterX(PlotPanel pp, Symbol symbol, double prevX,<a name="line.11399"></a>
<FONT color="green">11400</FONT>            double x, double nextX) {<a name="line.11400"></a>
<FONT color="green">11401</FONT>          double xMin = pp.getXMin();<a name="line.11401"></a>
<FONT color="green">11402</FONT>          double xMax = pp.getXMax();<a name="line.11402"></a>
<FONT color="green">11403</FONT>          double xMid = symbol.getBaseline();<a name="line.11403"></a>
<FONT color="green">11404</FONT>          // x!=x is a faster isNaN<a name="line.11404"></a>
<FONT color="green">11405</FONT>          if ((xMid != xMid))<a name="line.11405"></a>
<FONT color="green">11406</FONT>            xMid = (xMin + xMax) / 2.;<a name="line.11406"></a>
<FONT color="green">11407</FONT>          double xMinPx = pp.xToPixel(xMin);<a name="line.11407"></a>
<FONT color="green">11408</FONT>          double xMaxPx = pp.xToPixel(xMax);<a name="line.11408"></a>
<FONT color="green">11409</FONT>          double xMidPx = pp.xToPixel(xMid);<a name="line.11409"></a>
<FONT color="green">11410</FONT>          double xPx = pp.xToPixel(x);<a name="line.11410"></a>
<FONT color="green">11411</FONT>          double prevXPx = pp.xToPixel(prevX);<a name="line.11411"></a>
<FONT color="green">11412</FONT>          double nextXPx = pp.xToPixel(nextX);<a name="line.11412"></a>
<FONT color="green">11413</FONT>          double width = symbol.getWidth(pp);<a name="line.11413"></a>
<FONT color="green">11414</FONT>    <a name="line.11414"></a>
<FONT color="green">11415</FONT>          double symWidth = getAdjustedWidth(width, xPx, prevXPx, nextXPx,<a name="line.11415"></a>
<FONT color="green">11416</FONT>              xMinPx, xMaxPx, xMidPx);<a name="line.11416"></a>
<FONT color="green">11417</FONT>          if ((symWidth != symWidth))<a name="line.11417"></a>
<FONT color="green">11418</FONT>            return Double.NaN;<a name="line.11418"></a>
<FONT color="green">11419</FONT>    <a name="line.11419"></a>
<FONT color="green">11420</FONT>          double xLeft = getUpperLeftX(width, xPx, prevXPx, nextXPx, xMinPx,<a name="line.11420"></a>
<FONT color="green">11421</FONT>              xMaxPx, xMidPx, pp.getXMousePlotArea());<a name="line.11421"></a>
<FONT color="green">11422</FONT>          if ((xLeft != xLeft))<a name="line.11422"></a>
<FONT color="green">11423</FONT>            return Double.NaN;<a name="line.11423"></a>
<FONT color="green">11424</FONT>    <a name="line.11424"></a>
<FONT color="green">11425</FONT>          double xCenter = xLeft + symWidth / 2.;<a name="line.11425"></a>
<FONT color="green">11426</FONT>    <a name="line.11426"></a>
<FONT color="green">11427</FONT>          return xCenter;<a name="line.11427"></a>
<FONT color="green">11428</FONT>    <a name="line.11428"></a>
<FONT color="green">11429</FONT>        }<a name="line.11429"></a>
<FONT color="green">11430</FONT>    <a name="line.11430"></a>
<FONT color="green">11431</FONT>        /*<a name="line.11431"></a>
<FONT color="green">11432</FONT>         * Pixel x-coordinate at center of the symbol, used for hit-testing purposes<a name="line.11432"></a>
<FONT color="green">11433</FONT>         * by rectangular symbol types. &lt;p&gt;<a name="line.11433"></a>
<FONT color="green">11434</FONT>         * <a name="line.11434"></a>
<FONT color="green">11435</FONT>         * Overridden by pie slice symbol types.<a name="line.11435"></a>
<FONT color="green">11436</FONT>         */<a name="line.11436"></a>
<FONT color="green">11437</FONT>        protected double getCenterX(PlotPanel pp, Symbol symbol, int iPoint) {<a name="line.11437"></a>
<FONT color="green">11438</FONT>    <a name="line.11438"></a>
<FONT color="green">11439</FONT>          Curve c = symbol.getParent();<a name="line.11439"></a>
<FONT color="green">11440</FONT>          Curve.Point p = c.getPoint(iPoint);<a name="line.11440"></a>
<FONT color="green">11441</FONT>          double prevX = Double.NaN;<a name="line.11441"></a>
<FONT color="green">11442</FONT>          double x = p.getX();<a name="line.11442"></a>
<FONT color="green">11443</FONT>          double nextX = Double.NaN;<a name="line.11443"></a>
<FONT color="green">11444</FONT>          if (iPoint &gt; 0)<a name="line.11444"></a>
<FONT color="green">11445</FONT>            prevX = c.getPoint(iPoint - 1).getX();<a name="line.11445"></a>
<FONT color="green">11446</FONT>          if (iPoint + 1 &lt; c.getNPoints())<a name="line.11446"></a>
<FONT color="green">11447</FONT>            nextX = c.getPoint(iPoint + 1).getX();<a name="line.11447"></a>
<FONT color="green">11448</FONT>    <a name="line.11448"></a>
<FONT color="green">11449</FONT>          double result = getCenterX(pp, symbol, prevX, x, nextX);<a name="line.11449"></a>
<FONT color="green">11450</FONT>    <a name="line.11450"></a>
<FONT color="green">11451</FONT>          return result;<a name="line.11451"></a>
<FONT color="green">11452</FONT>        }<a name="line.11452"></a>
<FONT color="green">11453</FONT>    <a name="line.11453"></a>
<FONT color="green">11454</FONT>        /*<a name="line.11454"></a>
<FONT color="green">11455</FONT>         * Pixel y-coordinate at center of bounding rectangle surrounding given<a name="line.11455"></a>
<FONT color="green">11456</FONT>         * symbol rendered with this symbol type. &lt;p&gt;<a name="line.11456"></a>
<FONT color="green">11457</FONT>         * <a name="line.11457"></a>
<FONT color="green">11458</FONT>         * This method defines the y-coordinate of the rendered symbol's<a name="line.11458"></a>
<FONT color="green">11459</FONT>         * center-point (used for hit testing purposes) for all symbols except pie<a name="line.11459"></a>
<FONT color="green">11460</FONT>         * slices.<a name="line.11460"></a>
<FONT color="green">11461</FONT>         */<a name="line.11461"></a>
<FONT color="green">11462</FONT>        protected double getCenterY(PlotPanel pp, Symbol symbol, double prevY,<a name="line.11462"></a>
<FONT color="green">11463</FONT>            double y, double nextY, boolean onY2) {<a name="line.11463"></a>
<FONT color="green">11464</FONT>    <a name="line.11464"></a>
<FONT color="green">11465</FONT>          // the cartesian data and pixel Y coordinates are<a name="line.11465"></a>
<FONT color="green">11466</FONT>          // flipped, hence the (counter-intuitive) min/max<a name="line.11466"></a>
<FONT color="green">11467</FONT>          // interchange below:<a name="line.11467"></a>
<FONT color="green">11468</FONT>          double yMin = onY2 ? pp.getY2Max() : pp.getYMax();<a name="line.11468"></a>
<FONT color="green">11469</FONT>          double yMax = onY2 ? pp.getY2Min() : pp.getYMin();<a name="line.11469"></a>
<FONT color="green">11470</FONT>          double yMid = symbol.getBaseline();<a name="line.11470"></a>
<FONT color="green">11471</FONT>          // x!=x is a faster isNaN<a name="line.11471"></a>
<FONT color="green">11472</FONT>          if ((yMid != yMid))<a name="line.11472"></a>
<FONT color="green">11473</FONT>            yMid = (yMin + yMax) / 2.;<a name="line.11473"></a>
<FONT color="green">11474</FONT>          double yMinPx = pp.yToPixel(yMin, onY2);<a name="line.11474"></a>
<FONT color="green">11475</FONT>          double yMaxPx = pp.yToPixel(yMax, onY2);<a name="line.11475"></a>
<FONT color="green">11476</FONT>          double yMidPx = pp.yToPixel(yMid, onY2);<a name="line.11476"></a>
<FONT color="green">11477</FONT>          double yPx = pp.yToPixel(y, onY2);<a name="line.11477"></a>
<FONT color="green">11478</FONT>          double prevYPx = pp.yToPixel(prevY, onY2);<a name="line.11478"></a>
<FONT color="green">11479</FONT>          double nextYPx = pp.yToPixel(nextY, onY2);<a name="line.11479"></a>
<FONT color="green">11480</FONT>          double height = symbol.getHeight(pp, onY2);<a name="line.11480"></a>
<FONT color="green">11481</FONT>    <a name="line.11481"></a>
<FONT color="green">11482</FONT>          double symHeight = getAdjustedHeight(height, yPx, prevYPx, nextYPx,<a name="line.11482"></a>
<FONT color="green">11483</FONT>              yMinPx, yMaxPx, yMidPx);<a name="line.11483"></a>
<FONT color="green">11484</FONT>          if ((symHeight != symHeight))<a name="line.11484"></a>
<FONT color="green">11485</FONT>            return Double.NaN;<a name="line.11485"></a>
<FONT color="green">11486</FONT>    <a name="line.11486"></a>
<FONT color="green">11487</FONT>          double yTop = getUpperLeftY(height, yPx, prevYPx, nextYPx, yMinPx,<a name="line.11487"></a>
<FONT color="green">11488</FONT>              yMaxPx, yMidPx, pp.getYMousePlotArea());<a name="line.11488"></a>
<FONT color="green">11489</FONT>          if ((yTop != yTop))<a name="line.11489"></a>
<FONT color="green">11490</FONT>            return Double.NaN;<a name="line.11490"></a>
<FONT color="green">11491</FONT>    <a name="line.11491"></a>
<FONT color="green">11492</FONT>          double yCenter = yTop + symHeight / 2.;<a name="line.11492"></a>
<FONT color="green">11493</FONT>    <a name="line.11493"></a>
<FONT color="green">11494</FONT>          return yCenter;<a name="line.11494"></a>
<FONT color="green">11495</FONT>    <a name="line.11495"></a>
<FONT color="green">11496</FONT>        }<a name="line.11496"></a>
<FONT color="green">11497</FONT>    <a name="line.11497"></a>
<FONT color="green">11498</FONT>        /*<a name="line.11498"></a>
<FONT color="green">11499</FONT>         * Pixel y-coordinate at center of the symbol, used for hit-testing purposes<a name="line.11499"></a>
<FONT color="green">11500</FONT>         * by rectangular symbol types. &lt;p&gt;<a name="line.11500"></a>
<FONT color="green">11501</FONT>         * <a name="line.11501"></a>
<FONT color="green">11502</FONT>         * Overridden by pie slice symbol types.<a name="line.11502"></a>
<FONT color="green">11503</FONT>         */<a name="line.11503"></a>
<FONT color="green">11504</FONT>        protected double getCenterY(PlotPanel pp, Symbol symbol, int iPoint,<a name="line.11504"></a>
<FONT color="green">11505</FONT>            boolean onY2) {<a name="line.11505"></a>
<FONT color="green">11506</FONT>    <a name="line.11506"></a>
<FONT color="green">11507</FONT>          Curve c = symbol.getParent();<a name="line.11507"></a>
<FONT color="green">11508</FONT>          Curve.Point p = c.getPoint(iPoint);<a name="line.11508"></a>
<FONT color="green">11509</FONT>          double prevY = Double.NaN;<a name="line.11509"></a>
<FONT color="green">11510</FONT>          double y = p.getY();<a name="line.11510"></a>
<FONT color="green">11511</FONT>          double nextY = Double.NaN;<a name="line.11511"></a>
<FONT color="green">11512</FONT>          if (iPoint &gt; 0)<a name="line.11512"></a>
<FONT color="green">11513</FONT>            prevY = c.getPoint(iPoint - 1).getY();<a name="line.11513"></a>
<FONT color="green">11514</FONT>          if (iPoint + 1 &lt; c.getNPoints())<a name="line.11514"></a>
<FONT color="green">11515</FONT>            nextY = c.getPoint(iPoint + 1).getY();<a name="line.11515"></a>
<FONT color="green">11516</FONT>    <a name="line.11516"></a>
<FONT color="green">11517</FONT>          double result = getCenterY(pp, symbol, prevY, y, nextY, onY2);<a name="line.11517"></a>
<FONT color="green">11518</FONT>    <a name="line.11518"></a>
<FONT color="green">11519</FONT>          return result;<a name="line.11519"></a>
<FONT color="green">11520</FONT>        }<a name="line.11520"></a>
<FONT color="green">11521</FONT>    <a name="line.11521"></a>
<FONT color="green">11522</FONT>        // pixel coordinate of left edge of symbol if rendered at given x<a name="line.11522"></a>
<FONT color="green">11523</FONT>        // Note: this can actually be the right edge if the symbol<a name="line.11523"></a>
<FONT color="green">11524</FONT>        // width is negative, as can occur with baseline-based bars<a name="line.11524"></a>
<FONT color="green">11525</FONT>        protected double getEdgeLeft(PlotPanel pp, Symbol symbol, double x,<a name="line.11525"></a>
<FONT color="green">11526</FONT>            boolean onY2) {<a name="line.11526"></a>
<FONT color="green">11527</FONT>          double xMin = pp.getXMin();<a name="line.11527"></a>
<FONT color="green">11528</FONT>          double xMax = pp.getXMax();<a name="line.11528"></a>
<FONT color="green">11529</FONT>          double xMid = symbol.getBaseline();<a name="line.11529"></a>
<FONT color="green">11530</FONT>          // x!=x is a faster isNaN<a name="line.11530"></a>
<FONT color="green">11531</FONT>          if ((xMid != xMid))<a name="line.11531"></a>
<FONT color="green">11532</FONT>            xMid = (xMin + xMax) / 2.;<a name="line.11532"></a>
<FONT color="green">11533</FONT>          double xMinPx = pp.xToPixel(xMin);<a name="line.11533"></a>
<FONT color="green">11534</FONT>          double xMaxPx = pp.xToPixel(xMax);<a name="line.11534"></a>
<FONT color="green">11535</FONT>          double xMidPx = pp.xToPixel(xMid);<a name="line.11535"></a>
<FONT color="green">11536</FONT>          double xPx = pp.xToPixel(x);<a name="line.11536"></a>
<FONT color="green">11537</FONT>          double prevXPx = Double.NaN;<a name="line.11537"></a>
<FONT color="green">11538</FONT>          double nextXPx = Double.NaN;<a name="line.11538"></a>
<FONT color="green">11539</FONT>          double width = symbol.getWidth(pp);<a name="line.11539"></a>
<FONT color="green">11540</FONT>    <a name="line.11540"></a>
<FONT color="green">11541</FONT>          double symWidth = getAdjustedWidth(width, xPx, prevXPx, nextXPx,<a name="line.11541"></a>
<FONT color="green">11542</FONT>              xMinPx, xMaxPx, xMidPx);<a name="line.11542"></a>
<FONT color="green">11543</FONT>          if ((symWidth != symWidth))<a name="line.11543"></a>
<FONT color="green">11544</FONT>            return Double.NaN;<a name="line.11544"></a>
<FONT color="green">11545</FONT>    <a name="line.11545"></a>
<FONT color="green">11546</FONT>          double xLeft = getUpperLeftX(width, xPx, prevXPx, nextXPx, xMinPx,<a name="line.11546"></a>
<FONT color="green">11547</FONT>              xMaxPx, xMidPx, pp.getXMousePlotArea());<a name="line.11547"></a>
<FONT color="green">11548</FONT>          if ((xLeft != xLeft))<a name="line.11548"></a>
<FONT color="green">11549</FONT>            return Double.NaN;<a name="line.11549"></a>
<FONT color="green">11550</FONT>          double result = xLeft;<a name="line.11550"></a>
<FONT color="green">11551</FONT>          return result;<a name="line.11551"></a>
<FONT color="green">11552</FONT>        }<a name="line.11552"></a>
<FONT color="green">11553</FONT>    <a name="line.11553"></a>
<FONT color="green">11554</FONT>        // pixel coordinate of right edge of symbol if rendered at given x<a name="line.11554"></a>
<FONT color="green">11555</FONT>        // Note: this can actually be the left edge if the symbol<a name="line.11555"></a>
<FONT color="green">11556</FONT>        // width is negative, as can occur with baseline-based bars<a name="line.11556"></a>
<FONT color="green">11557</FONT>        protected double getEdgeRight(PlotPanel pp, Symbol symbol, double x,<a name="line.11557"></a>
<FONT color="green">11558</FONT>            boolean onY2) {<a name="line.11558"></a>
<FONT color="green">11559</FONT>          double xMin = pp.getXMin();<a name="line.11559"></a>
<FONT color="green">11560</FONT>          double xMax = pp.getXMax();<a name="line.11560"></a>
<FONT color="green">11561</FONT>          double xMid = symbol.getBaseline();<a name="line.11561"></a>
<FONT color="green">11562</FONT>          // x!=x is a faster isNaN<a name="line.11562"></a>
<FONT color="green">11563</FONT>          if ((xMid != xMid))<a name="line.11563"></a>
<FONT color="green">11564</FONT>            xMid = (xMin + xMax) / 2.;<a name="line.11564"></a>
<FONT color="green">11565</FONT>          double xMinPx = pp.xToPixel(xMin);<a name="line.11565"></a>
<FONT color="green">11566</FONT>          double xMaxPx = pp.xToPixel(xMax);<a name="line.11566"></a>
<FONT color="green">11567</FONT>          double xMidPx = pp.xToPixel(xMid);<a name="line.11567"></a>
<FONT color="green">11568</FONT>          double xPx = pp.xToPixel(x);<a name="line.11568"></a>
<FONT color="green">11569</FONT>          double prevXPx = Double.NaN;<a name="line.11569"></a>
<FONT color="green">11570</FONT>          double nextXPx = Double.NaN;<a name="line.11570"></a>
<FONT color="green">11571</FONT>          double width = symbol.getWidth(pp);<a name="line.11571"></a>
<FONT color="green">11572</FONT>    <a name="line.11572"></a>
<FONT color="green">11573</FONT>          double symWidth = getAdjustedWidth(width, xPx, prevXPx, nextXPx,<a name="line.11573"></a>
<FONT color="green">11574</FONT>              xMinPx, xMaxPx, xMidPx);<a name="line.11574"></a>
<FONT color="green">11575</FONT>          if ((symWidth != symWidth))<a name="line.11575"></a>
<FONT color="green">11576</FONT>            return Double.NaN;<a name="line.11576"></a>
<FONT color="green">11577</FONT>    <a name="line.11577"></a>
<FONT color="green">11578</FONT>          double xLeft = getUpperLeftX(width, xPx, prevXPx, nextXPx, xMinPx,<a name="line.11578"></a>
<FONT color="green">11579</FONT>              xMaxPx, xMidPx, pp.getXMousePlotArea());<a name="line.11579"></a>
<FONT color="green">11580</FONT>          if ((xLeft != xLeft))<a name="line.11580"></a>
<FONT color="green">11581</FONT>            return Double.NaN;<a name="line.11581"></a>
<FONT color="green">11582</FONT>    <a name="line.11582"></a>
<FONT color="green">11583</FONT>          double result = xLeft + symWidth;<a name="line.11583"></a>
<FONT color="green">11584</FONT>    <a name="line.11584"></a>
<FONT color="green">11585</FONT>          return result;<a name="line.11585"></a>
<FONT color="green">11586</FONT>    <a name="line.11586"></a>
<FONT color="green">11587</FONT>        }<a name="line.11587"></a>
<FONT color="green">11588</FONT>    <a name="line.11588"></a>
<FONT color="green">11589</FONT>        // pixel coordinate of top edge of symbol if rendered at given y<a name="line.11589"></a>
<FONT color="green">11590</FONT>        // Note: this can actually be the bottom edge if the symbol<a name="line.11590"></a>
<FONT color="green">11591</FONT>        // width is negative, as can occur with baseline-based bars<a name="line.11591"></a>
<FONT color="green">11592</FONT>        protected double getEdgeTop(PlotPanel pp, Symbol symbol, double y,<a name="line.11592"></a>
<FONT color="green">11593</FONT>            boolean onY2) {<a name="line.11593"></a>
<FONT color="green">11594</FONT>    <a name="line.11594"></a>
<FONT color="green">11595</FONT>          // the cartesian data and pixel Y coordinates are<a name="line.11595"></a>
<FONT color="green">11596</FONT>          // flipped, hence the (counter-intuitive) min/max<a name="line.11596"></a>
<FONT color="green">11597</FONT>          // interchange below:<a name="line.11597"></a>
<FONT color="green">11598</FONT>          double yMin = onY2 ? pp.getY2Max() : pp.getYMax();<a name="line.11598"></a>
<FONT color="green">11599</FONT>          double yMax = onY2 ? pp.getY2Min() : pp.getYMin();<a name="line.11599"></a>
<FONT color="green">11600</FONT>          double yMid = symbol.getBaseline();<a name="line.11600"></a>
<FONT color="green">11601</FONT>          // x!=x is a faster isNaN<a name="line.11601"></a>
<FONT color="green">11602</FONT>          if ((yMid != yMid))<a name="line.11602"></a>
<FONT color="green">11603</FONT>            yMid = (yMin + yMax) / 2.;<a name="line.11603"></a>
<FONT color="green">11604</FONT>          double yMinPx = pp.yToPixel(yMin, onY2);<a name="line.11604"></a>
<FONT color="green">11605</FONT>          double yMaxPx = pp.yToPixel(yMax, onY2);<a name="line.11605"></a>
<FONT color="green">11606</FONT>          double yMidPx = pp.yToPixel(yMid, onY2);<a name="line.11606"></a>
<FONT color="green">11607</FONT>          double yPx = pp.yToPixel(y, onY2);<a name="line.11607"></a>
<FONT color="green">11608</FONT>          double prevYPx = Double.NaN;<a name="line.11608"></a>
<FONT color="green">11609</FONT>          double nextYPx = Double.NaN;<a name="line.11609"></a>
<FONT color="green">11610</FONT>          double height = symbol.getHeight(pp, onY2);<a name="line.11610"></a>
<FONT color="green">11611</FONT>    <a name="line.11611"></a>
<FONT color="green">11612</FONT>          double symHeight = getAdjustedHeight(height, yPx, prevYPx, nextYPx,<a name="line.11612"></a>
<FONT color="green">11613</FONT>              yMinPx, yMaxPx, yMidPx);<a name="line.11613"></a>
<FONT color="green">11614</FONT>          if ((symHeight != symHeight))<a name="line.11614"></a>
<FONT color="green">11615</FONT>            return Double.NaN;<a name="line.11615"></a>
<FONT color="green">11616</FONT>    <a name="line.11616"></a>
<FONT color="green">11617</FONT>          double yTop = getUpperLeftY(height, yPx, prevYPx, nextYPx, yMinPx,<a name="line.11617"></a>
<FONT color="green">11618</FONT>              yMaxPx, yMidPx, pp.getYMousePlotArea());<a name="line.11618"></a>
<FONT color="green">11619</FONT>          if ((yTop != yTop))<a name="line.11619"></a>
<FONT color="green">11620</FONT>            return Double.NaN;<a name="line.11620"></a>
<FONT color="green">11621</FONT>    <a name="line.11621"></a>
<FONT color="green">11622</FONT>          double result = yTop;<a name="line.11622"></a>
<FONT color="green">11623</FONT>    <a name="line.11623"></a>
<FONT color="green">11624</FONT>          return result;<a name="line.11624"></a>
<FONT color="green">11625</FONT>    <a name="line.11625"></a>
<FONT color="green">11626</FONT>        }<a name="line.11626"></a>
<FONT color="green">11627</FONT>    <a name="line.11627"></a>
<FONT color="green">11628</FONT>        // pixel coordinate of bottom edge of symbol if rendered at given y<a name="line.11628"></a>
<FONT color="green">11629</FONT>        // Note: this can actually be the top edge if the symbol<a name="line.11629"></a>
<FONT color="green">11630</FONT>        // width is negative, as can occur with baseline-based bars<a name="line.11630"></a>
<FONT color="green">11631</FONT>        protected double getEdgeBottom(PlotPanel pp, Symbol symbol, double y,<a name="line.11631"></a>
<FONT color="green">11632</FONT>            boolean onY2) {<a name="line.11632"></a>
<FONT color="green">11633</FONT>    <a name="line.11633"></a>
<FONT color="green">11634</FONT>          // the cartesian data and pixel Y coordinates are<a name="line.11634"></a>
<FONT color="green">11635</FONT>          // flipped, hence the (counter-intuitive) min/max<a name="line.11635"></a>
<FONT color="green">11636</FONT>          // interchange below:<a name="line.11636"></a>
<FONT color="green">11637</FONT>          double yMin = onY2 ? pp.getY2Max() : pp.getYMax();<a name="line.11637"></a>
<FONT color="green">11638</FONT>          double yMax = onY2 ? pp.getY2Min() : pp.getYMin();<a name="line.11638"></a>
<FONT color="green">11639</FONT>          double yMid = symbol.getBaseline();<a name="line.11639"></a>
<FONT color="green">11640</FONT>          // x!=x is a faster isNaN<a name="line.11640"></a>
<FONT color="green">11641</FONT>          if ((yMid != yMid))<a name="line.11641"></a>
<FONT color="green">11642</FONT>            yMid = (yMin + yMax) / 2.;<a name="line.11642"></a>
<FONT color="green">11643</FONT>          double yMinPx = pp.yToPixel(yMin, onY2);<a name="line.11643"></a>
<FONT color="green">11644</FONT>          double yMaxPx = pp.yToPixel(yMax, onY2);<a name="line.11644"></a>
<FONT color="green">11645</FONT>          double yMidPx = pp.yToPixel(yMid, onY2);<a name="line.11645"></a>
<FONT color="green">11646</FONT>          double yPx = pp.yToPixel(y, onY2);<a name="line.11646"></a>
<FONT color="green">11647</FONT>          double prevYPx = Double.NaN;<a name="line.11647"></a>
<FONT color="green">11648</FONT>          double nextYPx = Double.NaN;<a name="line.11648"></a>
<FONT color="green">11649</FONT>          double height = symbol.getHeight(pp, onY2);<a name="line.11649"></a>
<FONT color="green">11650</FONT>    <a name="line.11650"></a>
<FONT color="green">11651</FONT>          double symHeight = getAdjustedHeight(height, yPx, prevYPx, nextYPx,<a name="line.11651"></a>
<FONT color="green">11652</FONT>              yMinPx, yMaxPx, yMidPx);<a name="line.11652"></a>
<FONT color="green">11653</FONT>          if ((symHeight != symHeight))<a name="line.11653"></a>
<FONT color="green">11654</FONT>            return Double.NaN;<a name="line.11654"></a>
<FONT color="green">11655</FONT>    <a name="line.11655"></a>
<FONT color="green">11656</FONT>          double yTop = getUpperLeftY(height, yPx, prevYPx, nextYPx, yMinPx,<a name="line.11656"></a>
<FONT color="green">11657</FONT>              yMaxPx, yMidPx, pp.getYMousePlotArea());<a name="line.11657"></a>
<FONT color="green">11658</FONT>          if ((yTop != yTop))<a name="line.11658"></a>
<FONT color="green">11659</FONT>            return Double.NaN;<a name="line.11659"></a>
<FONT color="green">11660</FONT>    <a name="line.11660"></a>
<FONT color="green">11661</FONT>          double result = yTop + symHeight;<a name="line.11661"></a>
<FONT color="green">11662</FONT>    <a name="line.11662"></a>
<FONT color="green">11663</FONT>          return result;<a name="line.11663"></a>
<FONT color="green">11664</FONT>    <a name="line.11664"></a>
<FONT color="green">11665</FONT>        }<a name="line.11665"></a>
<FONT color="green">11666</FONT>    <a name="line.11666"></a>
<FONT color="green">11667</FONT>        // gets edge that is furthest away from the point, horizontally<a name="line.11667"></a>
<FONT color="green">11668</FONT>        // Note: for bar charts, this is the edge of the symbol<a name="line.11668"></a>
<FONT color="green">11669</FONT>        // along the y-axis, y2-axis, or vertical baseline.<a name="line.11669"></a>
<FONT color="green">11670</FONT>        protected double getEdgeOppositeHorizontally(PlotPanel pp,<a name="line.11670"></a>
<FONT color="green">11671</FONT>            Symbol symbol, double x, boolean onY2) {<a name="line.11671"></a>
<FONT color="green">11672</FONT>          double xMin = pp.getXMin();<a name="line.11672"></a>
<FONT color="green">11673</FONT>          double xMax = pp.getXMax();<a name="line.11673"></a>
<FONT color="green">11674</FONT>          double xMid = symbol.getBaseline();<a name="line.11674"></a>
<FONT color="green">11675</FONT>          // x!=x is a faster isNaN<a name="line.11675"></a>
<FONT color="green">11676</FONT>          if ((xMid != xMid))<a name="line.11676"></a>
<FONT color="green">11677</FONT>            xMid = (xMin + xMax) / 2.;<a name="line.11677"></a>
<FONT color="green">11678</FONT>          double xMinPx = pp.xToPixel(xMin);<a name="line.11678"></a>
<FONT color="green">11679</FONT>          double xMaxPx = pp.xToPixel(xMax);<a name="line.11679"></a>
<FONT color="green">11680</FONT>          double xMidPx = pp.xToPixel(xMid);<a name="line.11680"></a>
<FONT color="green">11681</FONT>          double xPx = pp.xToPixel(x);<a name="line.11681"></a>
<FONT color="green">11682</FONT>          double prevXPx = Double.NaN;<a name="line.11682"></a>
<FONT color="green">11683</FONT>          double nextXPx = Double.NaN;<a name="line.11683"></a>
<FONT color="green">11684</FONT>          double width = symbol.getWidth(pp);<a name="line.11684"></a>
<FONT color="green">11685</FONT>    <a name="line.11685"></a>
<FONT color="green">11686</FONT>          double symWidth = getAdjustedWidth(width, xPx, prevXPx, nextXPx,<a name="line.11686"></a>
<FONT color="green">11687</FONT>              xMinPx, xMaxPx, xMidPx);<a name="line.11687"></a>
<FONT color="green">11688</FONT>          if ((symWidth != symWidth))<a name="line.11688"></a>
<FONT color="green">11689</FONT>            return Double.NaN;<a name="line.11689"></a>
<FONT color="green">11690</FONT>    <a name="line.11690"></a>
<FONT color="green">11691</FONT>          double xLeft = getUpperLeftX(width, xPx, prevXPx, nextXPx, xMinPx,<a name="line.11691"></a>
<FONT color="green">11692</FONT>              xMaxPx, xMidPx, pp.getXMousePlotArea());<a name="line.11692"></a>
<FONT color="green">11693</FONT>          if ((xLeft != xLeft))<a name="line.11693"></a>
<FONT color="green">11694</FONT>            return Double.NaN;<a name="line.11694"></a>
<FONT color="green">11695</FONT>    <a name="line.11695"></a>
<FONT color="green">11696</FONT>          double result = xLeft + symWidth;<a name="line.11696"></a>
<FONT color="green">11697</FONT>          if (Math.abs(xLeft - xPx) &gt; Math.abs(result - xPx))<a name="line.11697"></a>
<FONT color="green">11698</FONT>            result = xLeft;<a name="line.11698"></a>
<FONT color="green">11699</FONT>    <a name="line.11699"></a>
<FONT color="green">11700</FONT>          return result;<a name="line.11700"></a>
<FONT color="green">11701</FONT>    <a name="line.11701"></a>
<FONT color="green">11702</FONT>        }<a name="line.11702"></a>
<FONT color="green">11703</FONT>    <a name="line.11703"></a>
<FONT color="green">11704</FONT>        // gets edge that is furthest away from the point, vertically<a name="line.11704"></a>
<FONT color="green">11705</FONT>        // Note: for bar charts, this is the edge of the symbol<a name="line.11705"></a>
<FONT color="green">11706</FONT>        // along the x-axis, x2-axis, or horizontal baseline.<a name="line.11706"></a>
<FONT color="green">11707</FONT>        protected double getEdgeOppositeVertically(PlotPanel pp, Symbol symbol,<a name="line.11707"></a>
<FONT color="green">11708</FONT>            double y, boolean onY2) {<a name="line.11708"></a>
<FONT color="green">11709</FONT>    <a name="line.11709"></a>
<FONT color="green">11710</FONT>          // the cartesian data and pixel Y coordinates are<a name="line.11710"></a>
<FONT color="green">11711</FONT>          // flipped, hence the (counter-intuitive) min/max<a name="line.11711"></a>
<FONT color="green">11712</FONT>          // interchange below:<a name="line.11712"></a>
<FONT color="green">11713</FONT>          double yMin = onY2 ? pp.getY2Max() : pp.getYMax();<a name="line.11713"></a>
<FONT color="green">11714</FONT>          double yMax = onY2 ? pp.getY2Min() : pp.getYMin();<a name="line.11714"></a>
<FONT color="green">11715</FONT>          double yMid = symbol.getBaseline();<a name="line.11715"></a>
<FONT color="green">11716</FONT>          // x!=x is a faster isNaN<a name="line.11716"></a>
<FONT color="green">11717</FONT>          if ((yMid != yMid))<a name="line.11717"></a>
<FONT color="green">11718</FONT>            yMid = (yMin + yMax) / 2.;<a name="line.11718"></a>
<FONT color="green">11719</FONT>          double yMinPx = pp.yToPixel(yMin, onY2);<a name="line.11719"></a>
<FONT color="green">11720</FONT>          double yMaxPx = pp.yToPixel(yMax, onY2);<a name="line.11720"></a>
<FONT color="green">11721</FONT>          double yMidPx = pp.yToPixel(yMid, onY2);<a name="line.11721"></a>
<FONT color="green">11722</FONT>          double yPx = pp.yToPixel(y, onY2);<a name="line.11722"></a>
<FONT color="green">11723</FONT>          double prevYPx = Double.NaN;<a name="line.11723"></a>
<FONT color="green">11724</FONT>          double nextYPx = Double.NaN;<a name="line.11724"></a>
<FONT color="green">11725</FONT>          double height = symbol.getHeight(pp, onY2);<a name="line.11725"></a>
<FONT color="green">11726</FONT>    <a name="line.11726"></a>
<FONT color="green">11727</FONT>          double symHeight = getAdjustedHeight(height, yPx, prevYPx, nextYPx,<a name="line.11727"></a>
<FONT color="green">11728</FONT>              yMinPx, yMaxPx, yMidPx);<a name="line.11728"></a>
<FONT color="green">11729</FONT>          if ((symHeight != symHeight))<a name="line.11729"></a>
<FONT color="green">11730</FONT>            return Double.NaN;<a name="line.11730"></a>
<FONT color="green">11731</FONT>    <a name="line.11731"></a>
<FONT color="green">11732</FONT>          double yTop = getUpperLeftY(height, yPx, prevYPx, nextYPx, yMinPx,<a name="line.11732"></a>
<FONT color="green">11733</FONT>              yMaxPx, yMidPx, pp.getYMousePlotArea());<a name="line.11733"></a>
<FONT color="green">11734</FONT>          if ((yTop != yTop))<a name="line.11734"></a>
<FONT color="green">11735</FONT>            return Double.NaN;<a name="line.11735"></a>
<FONT color="green">11736</FONT>    <a name="line.11736"></a>
<FONT color="green">11737</FONT>          double result = yTop + symHeight;<a name="line.11737"></a>
<FONT color="green">11738</FONT>          if (Math.abs(yTop - yPx) &gt; Math.abs(result - yPx))<a name="line.11738"></a>
<FONT color="green">11739</FONT>            result = yTop;<a name="line.11739"></a>
<FONT color="green">11740</FONT>    <a name="line.11740"></a>
<FONT color="green">11741</FONT>          return result;<a name="line.11741"></a>
<FONT color="green">11742</FONT>    <a name="line.11742"></a>
<FONT color="green">11743</FONT>        }<a name="line.11743"></a>
<FONT color="green">11744</FONT>    <a name="line.11744"></a>
<FONT color="green">11745</FONT>        /*<a name="line.11745"></a>
<FONT color="green">11746</FONT>         * Determines if a symbol, rendered at the specified position (and with the<a name="line.11746"></a>
<FONT color="green">11747</FONT>         * given positions of the previous and subsequent points, and the y-axis on<a name="line.11747"></a>
<FONT color="green">11748</FONT>         * which it is rendered) intersects with a given rectangle.<a name="line.11748"></a>
<FONT color="green">11749</FONT>         */<a name="line.11749"></a>
<FONT color="green">11750</FONT>        private boolean isIntersecting(PlotPanel pp, Symbol symbol,<a name="line.11750"></a>
<FONT color="green">11751</FONT>            double prevX, double x, double nextX, double prevY, double y,<a name="line.11751"></a>
<FONT color="green">11752</FONT>            double nextY, boolean onY2, double top, double right,<a name="line.11752"></a>
<FONT color="green">11753</FONT>            double bottom, double left) {<a name="line.11753"></a>
<FONT color="green">11754</FONT>    <a name="line.11754"></a>
<FONT color="green">11755</FONT>          double xMin = pp.getXMin();<a name="line.11755"></a>
<FONT color="green">11756</FONT>          double xMax = pp.getXMax();<a name="line.11756"></a>
<FONT color="green">11757</FONT>          double xMid = symbol.getBaseline();<a name="line.11757"></a>
<FONT color="green">11758</FONT>          // x!=x is a faster isNaN<a name="line.11758"></a>
<FONT color="green">11759</FONT>          if ((xMid != xMid))<a name="line.11759"></a>
<FONT color="green">11760</FONT>            xMid = (xMin + xMax) / 2.;<a name="line.11760"></a>
<FONT color="green">11761</FONT>          double xMinPx = pp.xToPixel(xMin);<a name="line.11761"></a>
<FONT color="green">11762</FONT>          double xMaxPx = pp.xToPixel(xMax);<a name="line.11762"></a>
<FONT color="green">11763</FONT>          double xMidPx = pp.xToPixel(xMid);<a name="line.11763"></a>
<FONT color="green">11764</FONT>          double xPx = pp.xToPixel(x);<a name="line.11764"></a>
<FONT color="green">11765</FONT>          double prevXPx = pp.xToPixel(prevX);<a name="line.11765"></a>
<FONT color="green">11766</FONT>          double nextXPx = pp.xToPixel(nextX);<a name="line.11766"></a>
<FONT color="green">11767</FONT>          double width = symbol.getWidth(pp);<a name="line.11767"></a>
<FONT color="green">11768</FONT>    <a name="line.11768"></a>
<FONT color="green">11769</FONT>          double symWidth = getAdjustedWidth(width, xPx, prevXPx, nextXPx,<a name="line.11769"></a>
<FONT color="green">11770</FONT>              xMinPx, xMaxPx, xMidPx);<a name="line.11770"></a>
<FONT color="green">11771</FONT>          if ((symWidth != symWidth))<a name="line.11771"></a>
<FONT color="green">11772</FONT>            return false;<a name="line.11772"></a>
<FONT color="green">11773</FONT>    <a name="line.11773"></a>
<FONT color="green">11774</FONT>          double xLeft = getUpperLeftX(width, xPx, prevXPx, nextXPx, xMinPx,<a name="line.11774"></a>
<FONT color="green">11775</FONT>              xMaxPx, xMidPx, pp.getXMousePlotArea());<a name="line.11775"></a>
<FONT color="green">11776</FONT>          if ((xLeft != xLeft))<a name="line.11776"></a>
<FONT color="green">11777</FONT>            return false;<a name="line.11777"></a>
<FONT color="green">11778</FONT>    <a name="line.11778"></a>
<FONT color="green">11779</FONT>          // note: symWidth can be negative.<a name="line.11779"></a>
<FONT color="green">11780</FONT>          if (Math.max(xLeft, xLeft + symWidth) &lt; left)<a name="line.11780"></a>
<FONT color="green">11781</FONT>            return false; // symbol is entirely to left of rectangle<a name="line.11781"></a>
<FONT color="green">11782</FONT>          else if (Math.min(xLeft, xLeft + symWidth) &gt; right)<a name="line.11782"></a>
<FONT color="green">11783</FONT>            return false; // symbol is entirely to right of rectangle<a name="line.11783"></a>
<FONT color="green">11784</FONT>          // else brush and symbol have overlapping x-intervals<a name="line.11784"></a>
<FONT color="green">11785</FONT>    <a name="line.11785"></a>
<FONT color="green">11786</FONT>          // the cartesian data and pixel Y coordinates are flipped,<a name="line.11786"></a>
<FONT color="green">11787</FONT>          // hence the (counter-intuitive) min/max interchange below:<a name="line.11787"></a>
<FONT color="green">11788</FONT>          double yMin = onY2 ? pp.getY2Max() : pp.getYMax();<a name="line.11788"></a>
<FONT color="green">11789</FONT>          double yMax = onY2 ? pp.getY2Min() : pp.getYMin();<a name="line.11789"></a>
<FONT color="green">11790</FONT>          double yMid = symbol.getBaseline();<a name="line.11790"></a>
<FONT color="green">11791</FONT>          // x!=x is a faster isNaN<a name="line.11791"></a>
<FONT color="green">11792</FONT>          if ((yMid != yMid))<a name="line.11792"></a>
<FONT color="green">11793</FONT>            yMid = (yMin + yMax) / 2.;<a name="line.11793"></a>
<FONT color="green">11794</FONT>          double yMinPx = pp.yToPixel(yMin, onY2);<a name="line.11794"></a>
<FONT color="green">11795</FONT>          double yMaxPx = pp.yToPixel(yMax, onY2);<a name="line.11795"></a>
<FONT color="green">11796</FONT>          double yMidPx = pp.yToPixel(yMid, onY2);<a name="line.11796"></a>
<FONT color="green">11797</FONT>          double yPx = pp.yToPixel(y, onY2);<a name="line.11797"></a>
<FONT color="green">11798</FONT>          double prevYPx = pp.yToPixel(prevY, onY2);<a name="line.11798"></a>
<FONT color="green">11799</FONT>          double nextYPx = pp.yToPixel(nextY, onY2);<a name="line.11799"></a>
<FONT color="green">11800</FONT>          double height = symbol.getHeight(pp, onY2);<a name="line.11800"></a>
<FONT color="green">11801</FONT>    <a name="line.11801"></a>
<FONT color="green">11802</FONT>          double symHeight = getAdjustedHeight(height, yPx, prevYPx, nextYPx,<a name="line.11802"></a>
<FONT color="green">11803</FONT>              yMinPx, yMaxPx, yMidPx);<a name="line.11803"></a>
<FONT color="green">11804</FONT>          if ((symHeight != symHeight))<a name="line.11804"></a>
<FONT color="green">11805</FONT>            return false;<a name="line.11805"></a>
<FONT color="green">11806</FONT>    <a name="line.11806"></a>
<FONT color="green">11807</FONT>          double yTop = getUpperLeftY(height, yPx, prevYPx, nextYPx, yMinPx,<a name="line.11807"></a>
<FONT color="green">11808</FONT>              yMaxPx, yMidPx, pp.getYMousePlotArea());<a name="line.11808"></a>
<FONT color="green">11809</FONT>          if ((yTop != yTop))<a name="line.11809"></a>
<FONT color="green">11810</FONT>            return false;<a name="line.11810"></a>
<FONT color="green">11811</FONT>    <a name="line.11811"></a>
<FONT color="green">11812</FONT>          // note: symHeight can be negative.<a name="line.11812"></a>
<FONT color="green">11813</FONT>          if (Math.max(yTop, yTop + symHeight) &lt; top)<a name="line.11813"></a>
<FONT color="green">11814</FONT>            return false; // symbol is entirely above rectangle<a name="line.11814"></a>
<FONT color="green">11815</FONT>          else if (Math.min(yTop, yTop + symHeight) &gt; bottom)<a name="line.11815"></a>
<FONT color="green">11816</FONT>            return false; // symbol is entirely below the rectangle<a name="line.11816"></a>
<FONT color="green">11817</FONT>          // else rectangle and symbol have overlapping y-intervals<a name="line.11817"></a>
<FONT color="green">11818</FONT>    <a name="line.11818"></a>
<FONT color="green">11819</FONT>          // overlapping x and y intervals ==&gt; rectangle intersects symbol<a name="line.11819"></a>
<FONT color="green">11820</FONT>          return true;<a name="line.11820"></a>
<FONT color="green">11821</FONT>    <a name="line.11821"></a>
<FONT color="green">11822</FONT>        }<a name="line.11822"></a>
<FONT color="green">11823</FONT>    <a name="line.11823"></a>
<FONT color="green">11824</FONT>        /*<a name="line.11824"></a>
<FONT color="green">11825</FONT>         * Determines if a symbol, when rendered at a given point, intersects with a<a name="line.11825"></a>
<FONT color="green">11826</FONT>         * "rectangular brush". &lt;p&gt;<a name="line.11826"></a>
<FONT color="green">11827</FONT>         * <a name="line.11827"></a>
<FONT color="green">11828</FONT>         * This brush is typically centered at the current mouse position, and<a name="line.11828"></a>
<FONT color="green">11829</FONT>         * allows the user to select the point on a curve, the pie slice, etc. for<a name="line.11829"></a>
<FONT color="green">11830</FONT>         * which hover feedback will be displayed. &lt;p&gt;<a name="line.11830"></a>
<FONT color="green">11831</FONT>         * <a name="line.11831"></a>
<FONT color="green">11832</FONT>         * This method gets overridden for pie slices (due to their non-rectangular<a name="line.11832"></a>
<FONT color="green">11833</FONT>         * shape).<a name="line.11833"></a>
<FONT color="green">11834</FONT>         */<a name="line.11834"></a>
<FONT color="green">11835</FONT>        protected boolean isIntersecting(PlotPanel pp, Symbol symbol,<a name="line.11835"></a>
<FONT color="green">11836</FONT>            int iPoint, boolean onY2, int xBrush, int yBrush,<a name="line.11836"></a>
<FONT color="green">11837</FONT>            int brushWidth, int brushHeight) {<a name="line.11837"></a>
<FONT color="green">11838</FONT>    <a name="line.11838"></a>
<FONT color="green">11839</FONT>          Curve c = symbol.getParent();<a name="line.11839"></a>
<FONT color="green">11840</FONT>          Curve.Point p = c.getPoint(iPoint);<a name="line.11840"></a>
<FONT color="green">11841</FONT>          double prevX = Double.NaN;<a name="line.11841"></a>
<FONT color="green">11842</FONT>          double x = p.getX();<a name="line.11842"></a>
<FONT color="green">11843</FONT>          double nextX = Double.NaN;<a name="line.11843"></a>
<FONT color="green">11844</FONT>          double prevY = Double.NaN;<a name="line.11844"></a>
<FONT color="green">11845</FONT>          double y = p.getY();<a name="line.11845"></a>
<FONT color="green">11846</FONT>          double nextY = Double.NaN;<a name="line.11846"></a>
<FONT color="green">11847</FONT>          if (iPoint &gt; 0) {<a name="line.11847"></a>
<FONT color="green">11848</FONT>            prevX = c.getPoint(iPoint - 1).getX();<a name="line.11848"></a>
<FONT color="green">11849</FONT>            prevY = c.getPoint(iPoint - 1).getY();<a name="line.11849"></a>
<FONT color="green">11850</FONT>          }<a name="line.11850"></a>
<FONT color="green">11851</FONT>          if (iPoint + 1 &lt; c.getNPoints()) {<a name="line.11851"></a>
<FONT color="green">11852</FONT>            nextX = c.getPoint(iPoint + 1).getX();<a name="line.11852"></a>
<FONT color="green">11853</FONT>            nextY = c.getPoint(iPoint + 1).getY();<a name="line.11853"></a>
<FONT color="green">11854</FONT>          }<a name="line.11854"></a>
<FONT color="green">11855</FONT>    <a name="line.11855"></a>
<FONT color="green">11856</FONT>          // Treat mouse cursor as if it were a 0x0 pixel symbol<a name="line.11856"></a>
<FONT color="green">11857</FONT>          // centered at xBrush, yBrush to which an annotation of<a name="line.11857"></a>
<FONT color="green">11858</FONT>          // the width, height of the brush is attached.<a name="line.11858"></a>
<FONT color="green">11859</FONT>          int top = symbol.getBrushLocation().getUpperLeftY(yBrush,<a name="line.11859"></a>
<FONT color="green">11860</FONT>              brushHeight, 0);<a name="line.11860"></a>
<FONT color="green">11861</FONT>          int bottom = top + brushHeight;<a name="line.11861"></a>
<FONT color="green">11862</FONT>          int left = symbol.getBrushLocation().getUpperLeftX(xBrush,<a name="line.11862"></a>
<FONT color="green">11863</FONT>              brushWidth, 0);<a name="line.11863"></a>
<FONT color="green">11864</FONT>          int right = left + brushWidth;<a name="line.11864"></a>
<FONT color="green">11865</FONT>    <a name="line.11865"></a>
<FONT color="green">11866</FONT>          boolean result = isIntersecting(pp, symbol, prevX, x, nextX, prevY,<a name="line.11866"></a>
<FONT color="green">11867</FONT>              y, nextY, onY2, top, right, bottom, left);<a name="line.11867"></a>
<FONT color="green">11868</FONT>    <a name="line.11868"></a>
<FONT color="green">11869</FONT>          return result;<a name="line.11869"></a>
<FONT color="green">11870</FONT>        }<a name="line.11870"></a>
<FONT color="green">11871</FONT>    <a name="line.11871"></a>
<FONT color="green">11872</FONT>        // width of border of symbol displayed in legend key<a name="line.11872"></a>
<FONT color="green">11873</FONT>        int getIconBorderWidth(int legendFontSize, double symBorderFraction) {<a name="line.11873"></a>
<FONT color="green">11874</FONT>          int result = 0;<a name="line.11874"></a>
<FONT color="green">11875</FONT>          if (symBorderFraction &gt; 0) {<a name="line.11875"></a>
<FONT color="green">11876</FONT>            result = (int) Math.max(1.0, Math.floor(symBorderFraction<a name="line.11876"></a>
<FONT color="green">11877</FONT>                * Math.min(getIconWidth(legendFontSize),<a name="line.11877"></a>
<FONT color="green">11878</FONT>                getIconHeight(legendFontSize))));<a name="line.11878"></a>
<FONT color="green">11879</FONT>          }<a name="line.11879"></a>
<FONT color="green">11880</FONT>          return result;<a name="line.11880"></a>
<FONT color="green">11881</FONT>        }<a name="line.11881"></a>
<FONT color="green">11882</FONT>    <a name="line.11882"></a>
<FONT color="green">11883</FONT>        int getIconHeight(int legendFontSize) {<a name="line.11883"></a>
<FONT color="green">11884</FONT>          return (int) Math.round(0.75 * legendFontSize);<a name="line.11884"></a>
<FONT color="green">11885</FONT>        }<a name="line.11885"></a>
<FONT color="green">11886</FONT>    <a name="line.11886"></a>
<FONT color="green">11887</FONT>        int getIconWidth(int legendFontSize) {<a name="line.11887"></a>
<FONT color="green">11888</FONT>          return (int) Math.round(0.75 * legendFontSize);<a name="line.11888"></a>
<FONT color="green">11889</FONT>        }<a name="line.11889"></a>
<FONT color="green">11890</FONT>    <a name="line.11890"></a>
<FONT color="green">11891</FONT>        double getUpperLeftX(double width, double x, double xPrev,<a name="line.11891"></a>
<FONT color="green">11892</FONT>            double xNext, double xMin, double xMax, double xMid, int xMouse) {<a name="line.11892"></a>
<FONT color="green">11893</FONT>          double adjWidth = getAdjustedWidth(width, x, xPrev, xNext, xMin,<a name="line.11893"></a>
<FONT color="green">11894</FONT>              xMax, xMid);<a name="line.11894"></a>
<FONT color="green">11895</FONT>          double result = x + (0.5 * (widthMultiplier - 1)) * adjWidth;<a name="line.11895"></a>
<FONT color="green">11896</FONT>          return result;<a name="line.11896"></a>
<FONT color="green">11897</FONT>        }<a name="line.11897"></a>
<FONT color="green">11898</FONT>    <a name="line.11898"></a>
<FONT color="green">11899</FONT>        double getUpperLeftY(double height, double y, double yPrev,<a name="line.11899"></a>
<FONT color="green">11900</FONT>            double yNext, double yMin, double yMax, double yMid, int yMouse) {<a name="line.11900"></a>
<FONT color="green">11901</FONT>          double adjHeight = getAdjustedHeight(height, y, yPrev, yNext, yMin,<a name="line.11901"></a>
<FONT color="green">11902</FONT>              yMax, yMid);<a name="line.11902"></a>
<FONT color="green">11903</FONT>          double result = y + (0.5 * (heightMultiplier - 1)) * adjHeight;<a name="line.11903"></a>
<FONT color="green">11904</FONT>          return result;<a name="line.11904"></a>
<FONT color="green">11905</FONT>    <a name="line.11905"></a>
<FONT color="green">11906</FONT>        }<a name="line.11906"></a>
<FONT color="green">11907</FONT>    <a name="line.11907"></a>
<FONT color="green">11908</FONT>        protected AnnotationLocation defaultAnnotationLocation() {<a name="line.11908"></a>
<FONT color="green">11909</FONT>          // return AnnotationLocation.SOUTH;<a name="line.11909"></a>
<FONT color="green">11910</FONT>          AnnotationLocation result = defaultHoverLocation();<a name="line.11910"></a>
<FONT color="green">11911</FONT>          return result;<a name="line.11911"></a>
<FONT color="green">11912</FONT>        }<a name="line.11912"></a>
<FONT color="green">11913</FONT>    <a name="line.11913"></a>
<FONT color="green">11914</FONT>        // fillSpacing to use when a symbol's fillSpacing is Double.NaN<a name="line.11914"></a>
<FONT color="green">11915</FONT>        protected double defaultFillSpacing() {<a name="line.11915"></a>
<FONT color="green">11916</FONT>          return DEFAULT_SYMBOL_FILL_SPACING;<a name="line.11916"></a>
<FONT color="green">11917</FONT>        }<a name="line.11917"></a>
<FONT color="green">11918</FONT>    <a name="line.11918"></a>
<FONT color="green">11919</FONT>        // fillThickness to use when a symbol's fillThickness is<a name="line.11919"></a>
<FONT color="green">11920</FONT>        // GChart.NAI<a name="line.11920"></a>
<FONT color="green">11921</FONT>        protected int defaultFillThickness() {<a name="line.11921"></a>
<FONT color="green">11922</FONT>          return DEFAULT_SYMBOL_FILL_THICKNESS;<a name="line.11922"></a>
<FONT color="green">11923</FONT>        }<a name="line.11923"></a>
<FONT color="green">11924</FONT>    <a name="line.11924"></a>
<FONT color="green">11925</FONT>        // symbol-type-specific default hovertextTemplate<a name="line.11925"></a>
<FONT color="green">11926</FONT>        protected String defaultHovertextTemplate() {<a name="line.11926"></a>
<FONT color="green">11927</FONT>          return DEFAULT_HOVERTEXT_TEMPLATE;<a name="line.11927"></a>
<FONT color="green">11928</FONT>        }<a name="line.11928"></a>
<FONT color="green">11929</FONT>    <a name="line.11929"></a>
<FONT color="green">11930</FONT>        // symbol-type-specific default location of hover feedback<a name="line.11930"></a>
<FONT color="green">11931</FONT>        protected AnnotationLocation defaultHoverLocation() {<a name="line.11931"></a>
<FONT color="green">11932</FONT>          return DEFAULT_HOVER_LOCATION;<a name="line.11932"></a>
<FONT color="green">11933</FONT>        }<a name="line.11933"></a>
<FONT color="green">11934</FONT>    <a name="line.11934"></a>
<FONT color="green">11935</FONT>        /*<a name="line.11935"></a>
<FONT color="green">11936</FONT>         * Unmanaged images. Supports older code that simply zaps/recreates each<a name="line.11936"></a>
<FONT color="green">11937</FONT>         * image, relying on browser's garbage collector to deal with the reuse<a name="line.11937"></a>
<FONT color="green">11938</FONT>         * issue (that's slower).<a name="line.11938"></a>
<FONT color="green">11939</FONT>         */<a name="line.11939"></a>
<FONT color="green">11940</FONT>        private Image createImage(Symbol symbol, double width, double height,<a name="line.11940"></a>
<FONT color="green">11941</FONT>            int borderWidth, String url) {<a name="line.11941"></a>
<FONT color="green">11942</FONT>    <a name="line.11942"></a>
<FONT color="green">11943</FONT>          Image result = new Image(url);<a name="line.11943"></a>
<FONT color="green">11944</FONT>          // if smaller of width, height is at least twice<a name="line.11944"></a>
<FONT color="green">11945</FONT>          // the border width, border width is used as is, otherwise,<a name="line.11945"></a>
<FONT color="green">11946</FONT>          // it's replaced with half the smaller of width, height:<a name="line.11946"></a>
<FONT color="green">11947</FONT>          int cappedBW = (int) ((2 * borderWidth &lt;= ((width &lt; height) ? width<a name="line.11947"></a>
<FONT color="green">11948</FONT>              : height)) ? borderWidth : (((width &lt; height) ? width<a name="line.11948"></a>
<FONT color="green">11949</FONT>              : height) / 2));<a name="line.11949"></a>
<FONT color="green">11950</FONT>    <a name="line.11950"></a>
<FONT color="green">11951</FONT>          String borderColor = symbol.getBorderColorCSS();<a name="line.11951"></a>
<FONT color="green">11952</FONT>          // If border was too big to fit inside rectangle, since GChart<a name="line.11952"></a>
<FONT color="green">11953</FONT>          // borders are uniform around the rectangle, odd-sized<a name="line.11953"></a>
<FONT color="green">11954</FONT>          // dimensions can leave a single "leftover" 1px inside the<a name="line.11954"></a>
<FONT color="green">11955</FONT>          // border. Set background to the border's color so that the<a name="line.11955"></a>
<FONT color="green">11956</FONT>          // border, in effect, takes up the entire rectangle.<a name="line.11956"></a>
<FONT color="green">11957</FONT>          String backgroundColor = (cappedBW == borderWidth) ? symbol<a name="line.11957"></a>
<FONT color="green">11958</FONT>              .getBackgroundColorCSS() : borderColor;<a name="line.11958"></a>
<FONT color="green">11959</FONT>          // In principle, x,y position should also change with transparency<a name="line.11959"></a>
<FONT color="green">11960</FONT>          // emulation in some cases. But these images are only used in<a name="line.11960"></a>
<FONT color="green">11961</FONT>          // tables on the legend key, where they are always centered, so<a name="line.11961"></a>
<FONT color="green">11962</FONT>          // that doesn't matter.<a name="line.11962"></a>
<FONT color="green">11963</FONT>    <a name="line.11963"></a>
<FONT color="green">11964</FONT>          if (TRANSPARENT_BORDER_COLOR == borderColor) {// transparency emulation<a name="line.11964"></a>
<FONT color="green">11965</FONT>            if (cappedBW &gt; 0) {<a name="line.11965"></a>
<FONT color="green">11966</FONT>              // to emulate an internal transparent border using a 0 width<a name="line.11966"></a>
<FONT color="green">11967</FONT>              // border, we need to shrink the size by twice the amount<a name="line.11967"></a>
<FONT color="green">11968</FONT>              // of the border.<a name="line.11968"></a>
<FONT color="green">11969</FONT>              height -= 2 * cappedBW; // shrink size<a name="line.11969"></a>
<FONT color="green">11970</FONT>              width -= 2 * cappedBW;<a name="line.11970"></a>
<FONT color="green">11971</FONT>            }<a name="line.11971"></a>
<FONT color="green">11972</FONT>            // else, external border is just eliminated, no adjustment<a name="line.11972"></a>
<FONT color="green">11973</FONT>            // needed<a name="line.11973"></a>
<FONT color="green">11974</FONT>            cappedBW = 0;<a name="line.11974"></a>
<FONT color="green">11975</FONT>            borderColor = "transparent";<a name="line.11975"></a>
<FONT color="green">11976</FONT>            if (TRANSPARENT_BORDER_COLOR == backgroundColor)<a name="line.11976"></a>
<FONT color="green">11977</FONT>              backgroundColor = "transparent";<a name="line.11977"></a>
<FONT color="green">11978</FONT>          } else if (cappedBW &gt; 0) {<a name="line.11978"></a>
<FONT color="green">11979</FONT>            height -= 2 * cappedBW; // shrink size to incorporate<a name="line.11979"></a>
<FONT color="green">11980</FONT>            width -= 2 * cappedBW; // impact of internal border.<a name="line.11980"></a>
<FONT color="green">11981</FONT>          }<a name="line.11981"></a>
<FONT color="green">11982</FONT>          GChart.setBackgroundColor(result, backgroundColor);<a name="line.11982"></a>
<FONT color="green">11983</FONT>          GChart.setBorderColor(result, borderColor);<a name="line.11983"></a>
<FONT color="green">11984</FONT>          GChart.setBorderStyle(result, symbol.getBorderStyle());<a name="line.11984"></a>
<FONT color="green">11985</FONT>          GChart.setBorderWidth(result, Math.abs(cappedBW));<a name="line.11985"></a>
<FONT color="green">11986</FONT>          result.setPixelSize((int) Math.round(width), (int) Math.round(height));<a name="line.11986"></a>
<FONT color="green">11987</FONT>          return result;<a name="line.11987"></a>
<FONT color="green">11988</FONT>        }<a name="line.11988"></a>
<FONT color="green">11989</FONT>    <a name="line.11989"></a>
<FONT color="green">11990</FONT>        // creates small image of symbol (used in the chart legend).<a name="line.11990"></a>
<FONT color="green">11991</FONT>        Image createIconImage(Symbol symbol, int legendFontSize,<a name="line.11991"></a>
<FONT color="green">11992</FONT>            double symBorderFraction) {<a name="line.11992"></a>
<FONT color="green">11993</FONT>          Image result = createImage(symbol, getIconWidth(legendFontSize),<a name="line.11993"></a>
<FONT color="green">11994</FONT>              getIconHeight(legendFontSize), getIconBorderWidth(<a name="line.11994"></a>
<FONT color="green">11995</FONT>              legendFontSize, symBorderFraction), symbol.getImageURL());<a name="line.11995"></a>
<FONT color="green">11996</FONT>          return result;<a name="line.11996"></a>
<FONT color="green">11997</FONT>        }<a name="line.11997"></a>
<FONT color="green">11998</FONT>    <a name="line.11998"></a>
<FONT color="green">11999</FONT>        // are two one-dimensional ranges (x1...x2 and y1...y2) disjoint?<a name="line.11999"></a>
<FONT color="green">12000</FONT>        static private boolean areDisjointRanges(double x1, double x2,<a name="line.12000"></a>
<FONT color="green">12001</FONT>            double y1, double y2) {<a name="line.12001"></a>
<FONT color="green">12002</FONT>          boolean result = false;<a name="line.12002"></a>
<FONT color="green">12003</FONT>          if ((x1 &lt; y1 &amp;&amp; x2 &lt; y1 &amp;&amp; x1 &lt; y2 &amp;&amp; x2 &lt; y2)<a name="line.12003"></a>
<FONT color="green">12004</FONT>              || (y1 &lt; x1 &amp;&amp; y2 &lt; x1 &amp;&amp; y1 &lt; x2 &amp;&amp; y2 &lt; x2))<a name="line.12004"></a>
<FONT color="green">12005</FONT>            result = true;<a name="line.12005"></a>
<FONT color="green">12006</FONT>          return result;<a name="line.12006"></a>
<FONT color="green">12007</FONT>        }<a name="line.12007"></a>
<FONT color="green">12008</FONT>    <a name="line.12008"></a>
<FONT color="green">12009</FONT>        // do two rectangular regions intersect (left/right and/or<a name="line.12009"></a>
<FONT color="green">12010</FONT>        // top/bottom can be interchanged and it still works)<a name="line.12010"></a>
<FONT color="green">12011</FONT>        static boolean intersects(double left1, double top1, double right1,<a name="line.12011"></a>
<FONT color="green">12012</FONT>            double bottom1, double left2, double top2, double right2,<a name="line.12012"></a>
<FONT color="green">12013</FONT>            double bottom2) {<a name="line.12013"></a>
<FONT color="green">12014</FONT>          boolean result = true;<a name="line.12014"></a>
<FONT color="green">12015</FONT>          if (areDisjointRanges(left1, right1, left2, right2)<a name="line.12015"></a>
<FONT color="green">12016</FONT>              || areDisjointRanges(top1, bottom1, top2, bottom2))<a name="line.12016"></a>
<FONT color="green">12017</FONT>            result = false;<a name="line.12017"></a>
<FONT color="green">12018</FONT>          return result;<a name="line.12018"></a>
<FONT color="green">12019</FONT>        }<a name="line.12019"></a>
<FONT color="green">12020</FONT>    <a name="line.12020"></a>
<FONT color="green">12021</FONT>        // Does 2nd rectangle intersect the 'padded' first rectangle?<a name="line.12021"></a>
<FONT color="green">12022</FONT>        // <a name="line.12022"></a>
<FONT color="green">12023</FONT>        // rpf is the "render padding factor", the fraction of the width<a name="line.12023"></a>
<FONT color="green">12024</FONT>        // (height) of the first rectangle to add as padding to its left and<a name="line.12024"></a>
<FONT color="green">12025</FONT>        // right (top and bottom) edges.<a name="line.12025"></a>
<FONT color="green">12026</FONT>        static boolean paddedIntersects(double rpf, double left1, double top1,<a name="line.12026"></a>
<FONT color="green">12027</FONT>            double right1, double bottom1, double left2, double top2,<a name="line.12027"></a>
<FONT color="green">12028</FONT>            double right2, double bottom2) {<a name="line.12028"></a>
<FONT color="green">12029</FONT>          boolean result = intersects(left1 - rpf * (right1 - left1), top1<a name="line.12029"></a>
<FONT color="green">12030</FONT>              - rpf * (bottom1 - top1), right1 + rpf * (right1 - left1),<a name="line.12030"></a>
<FONT color="green">12031</FONT>              bottom1 + rpf * (bottom1 - top1), left2, top2, right2,<a name="line.12031"></a>
<FONT color="green">12032</FONT>              bottom2);<a name="line.12032"></a>
<FONT color="green">12033</FONT>          return result;<a name="line.12033"></a>
<FONT color="green">12034</FONT>        }<a name="line.12034"></a>
<FONT color="green">12035</FONT>    <a name="line.12035"></a>
<FONT color="green">12036</FONT>        /*<a name="line.12036"></a>
<FONT color="green">12037</FONT>         * renders a single image that is part of a (possibly multi-image) symbol,<a name="line.12037"></a>
<FONT color="green">12038</FONT>         * along with that image's annotation<a name="line.12038"></a>
<FONT color="green">12039</FONT>         */<a name="line.12039"></a>
<FONT color="green">12040</FONT>        protected void realizeOneImageOfSymbol(PlotPanel pp,<a name="line.12040"></a>
<FONT color="green">12041</FONT>            GraphicsRenderingPanel grp, AnnotationRenderingPanel arp,<a name="line.12041"></a>
<FONT color="green">12042</FONT>            Symbol symbol, Annotation annotation, boolean onY2,<a name="line.12042"></a>
<FONT color="green">12043</FONT>            boolean clipPlotArea, boolean clipDecoratedChart, <a name="line.12043"></a>
<FONT color="green">12044</FONT>            double renderPaddingFactor, double xPx, double yPx, <a name="line.12044"></a>
<FONT color="green">12045</FONT>            double prevXPx, double prevYPx, double nextXPx, double nextYPx, <a name="line.12045"></a>
<FONT color="green">12046</FONT>            double width, double height) {<a name="line.12046"></a>
<FONT color="green">12047</FONT>    <a name="line.12047"></a>
<FONT color="green">12048</FONT>          double xMin = pp.getXMin();<a name="line.12048"></a>
<FONT color="green">12049</FONT>          double xMax = pp.getXMax();<a name="line.12049"></a>
<FONT color="green">12050</FONT>          double xMid = symbol.getBaseline();<a name="line.12050"></a>
<FONT color="green">12051</FONT>          // x!=x is a faster isNaN<a name="line.12051"></a>
<FONT color="green">12052</FONT>          if ((xMid != xMid))<a name="line.12052"></a>
<FONT color="green">12053</FONT>            xMid = (xMin + xMax) / 2.;<a name="line.12053"></a>
<FONT color="green">12054</FONT>          double xMinPx = pp.xToPixel(xMin);<a name="line.12054"></a>
<FONT color="green">12055</FONT>          double xMaxPx = pp.xToPixel(xMax);<a name="line.12055"></a>
<FONT color="green">12056</FONT>          double xMidPx = pp.xToPixel(xMid);<a name="line.12056"></a>
<FONT color="green">12057</FONT>    <a name="line.12057"></a>
<FONT color="green">12058</FONT>          double symWidth = getAdjustedWidth(width, xPx, prevXPx, nextXPx,<a name="line.12058"></a>
<FONT color="green">12059</FONT>              xMinPx, xMaxPx, xMidPx);<a name="line.12059"></a>
<FONT color="green">12060</FONT>          if ((symWidth != symWidth))<a name="line.12060"></a>
<FONT color="green">12061</FONT>            return; // x!=x is a faster isNaN<a name="line.12061"></a>
<FONT color="green">12062</FONT>    <a name="line.12062"></a>
<FONT color="green">12063</FONT>          double xLeft = getUpperLeftX(width, xPx, prevXPx, nextXPx, xMinPx,<a name="line.12063"></a>
<FONT color="green">12064</FONT>              xMaxPx, xMidPx, pp.getXMousePlotArea());<a name="line.12064"></a>
<FONT color="green">12065</FONT>          if ((xLeft != xLeft))<a name="line.12065"></a>
<FONT color="green">12066</FONT>            return; // x!=x is a faster isNaN<a name="line.12066"></a>
<FONT color="green">12067</FONT>    <a name="line.12067"></a>
<FONT color="green">12068</FONT>          double xCenter = xLeft + symWidth / 2.;<a name="line.12068"></a>
<FONT color="green">12069</FONT>          // the data and pixel Y coordinates are flipped, hence<a name="line.12069"></a>
<FONT color="green">12070</FONT>          // the (counter-intuitive) min/max interchange below:<a name="line.12070"></a>
<FONT color="green">12071</FONT>          double yMin = onY2 ? pp.getY2Max() : pp.getYMax();<a name="line.12071"></a>
<FONT color="green">12072</FONT>          double yMax = onY2 ? pp.getY2Min() : pp.getYMin();<a name="line.12072"></a>
<FONT color="green">12073</FONT>          double yMid = symbol.getBaseline();<a name="line.12073"></a>
<FONT color="green">12074</FONT>          // x!=x is a faster isNaN<a name="line.12074"></a>
<FONT color="green">12075</FONT>          if ((yMid != yMid))<a name="line.12075"></a>
<FONT color="green">12076</FONT>            yMid = (yMin + yMax) / 2.;<a name="line.12076"></a>
<FONT color="green">12077</FONT>          double yMinPx = pp.yToPixel(yMin, onY2);<a name="line.12077"></a>
<FONT color="green">12078</FONT>          double yMaxPx = pp.yToPixel(yMax, onY2);<a name="line.12078"></a>
<FONT color="green">12079</FONT>          double yMidPx = pp.yToPixel(yMid, onY2);<a name="line.12079"></a>
<FONT color="green">12080</FONT>    <a name="line.12080"></a>
<FONT color="green">12081</FONT>          double symHeight = getAdjustedHeight(height, yPx, prevYPx, nextYPx,<a name="line.12081"></a>
<FONT color="green">12082</FONT>              yMinPx, yMaxPx, yMidPx);<a name="line.12082"></a>
<FONT color="green">12083</FONT>          if ((symHeight != symHeight))<a name="line.12083"></a>
<FONT color="green">12084</FONT>            return; // x!=x is a faster isNaN<a name="line.12084"></a>
<FONT color="green">12085</FONT>    <a name="line.12085"></a>
<FONT color="green">12086</FONT>          double yTop = getUpperLeftY(height, yPx, prevYPx, nextYPx, yMinPx,<a name="line.12086"></a>
<FONT color="green">12087</FONT>              yMaxPx, yMidPx, pp.getYMousePlotArea());<a name="line.12087"></a>
<FONT color="green">12088</FONT>          if ((yTop != yTop))<a name="line.12088"></a>
<FONT color="green">12089</FONT>            return; // x!=x is a faster isNaN<a name="line.12089"></a>
<FONT color="green">12090</FONT>    <a name="line.12090"></a>
<FONT color="green">12091</FONT>          double yCenter = yTop + symHeight / 2.;<a name="line.12091"></a>
<FONT color="green">12092</FONT>    <a name="line.12092"></a>
<FONT color="green">12093</FONT>          if (clipPlotArea<a name="line.12093"></a>
<FONT color="green">12094</FONT>              &amp;&amp; !paddedIntersects(renderPaddingFactor, <a name="line.12094"></a>
<FONT color="green">12095</FONT>              xMinPx, yMinPx, xMaxPx, yMaxPx,<a name="line.12095"></a>
<FONT color="green">12096</FONT>              xLeft, yTop, xLeft + symWidth, yTop + symHeight))<a name="line.12096"></a>
<FONT color="green">12097</FONT>            return; // image is completely off plot area, so skip it.<a name="line.12097"></a>
<FONT color="green">12098</FONT>          else if (clipDecoratedChart) {<a name="line.12098"></a>
<FONT color="green">12099</FONT>            int leftOfY = pp.getLeftOfYWidth();<a name="line.12099"></a>
<FONT color="green">12100</FONT>            int titleThickness = pp.chartTitleThickness();<a name="line.12100"></a>
<FONT color="green">12101</FONT>            if (!paddedIntersects(renderPaddingFactor, <a name="line.12101"></a>
<FONT color="green">12102</FONT>                 xMinPx - leftOfY, yMinPx - titleThickness, <a name="line.12102"></a>
<FONT color="green">12103</FONT>                 pp.getXChartSizeDecoratedQuickly() - leftOfY, <a name="line.12103"></a>
<FONT color="green">12104</FONT>                 pp.getYChartSizeDecoratedQuickly() - titleThickness, <a name="line.12104"></a>
<FONT color="green">12105</FONT>                 xLeft, yTop, xLeft + symWidth, yTop + symHeight))<a name="line.12105"></a>
<FONT color="green">12106</FONT>              return; // image completely off decorated chart, so skip<a name="line.12106"></a>
<FONT color="green">12107</FONT>          }<a name="line.12107"></a>
<FONT color="green">12108</FONT>          // translate negative width, height to equivalent<a name="line.12108"></a>
<FONT color="green">12109</FONT>          // positive values that image tags can handle<a name="line.12109"></a>
<FONT color="green">12110</FONT>          int signWidth = 1;<a name="line.12110"></a>
<FONT color="green">12111</FONT>          if (symWidth &lt; 0) {<a name="line.12111"></a>
<FONT color="green">12112</FONT>            xLeft = xLeft + symWidth;<a name="line.12112"></a>
<FONT color="green">12113</FONT>            symWidth *= -1;<a name="line.12113"></a>
<FONT color="green">12114</FONT>            signWidth = -1;<a name="line.12114"></a>
<FONT color="green">12115</FONT>          }<a name="line.12115"></a>
<FONT color="green">12116</FONT>          int signHeight = 1;<a name="line.12116"></a>
<FONT color="green">12117</FONT>          if (symHeight &lt; 0) {<a name="line.12117"></a>
<FONT color="green">12118</FONT>            yTop = yTop + symHeight;<a name="line.12118"></a>
<FONT color="green">12119</FONT>            symHeight *= -1;<a name="line.12119"></a>
<FONT color="green">12120</FONT>            signHeight = -1;<a name="line.12120"></a>
<FONT color="green">12121</FONT>          }<a name="line.12121"></a>
<FONT color="green">12122</FONT>    <a name="line.12122"></a>
<FONT color="green">12123</FONT>          // Positive pixel padding pushes the specified edge<a name="line.12123"></a>
<FONT color="green">12124</FONT>          // outward from the center by the given amount, without<a name="line.12124"></a>
<FONT color="green">12125</FONT>          // changing the location of the center the symbol.<a name="line.12125"></a>
<FONT color="green">12126</FONT>          // Similarly, negative padding, pushes the edge inward.<a name="line.12126"></a>
<FONT color="green">12127</FONT>    <a name="line.12127"></a>
<FONT color="green">12128</FONT>          if (symWidth != 0) {<a name="line.12128"></a>
<FONT color="green">12129</FONT>            xLeft -= pixelPadLeft;<a name="line.12129"></a>
<FONT color="green">12130</FONT>            symWidth += pixelPadLeft + pixelPadRight;<a name="line.12130"></a>
<FONT color="green">12131</FONT>          }<a name="line.12131"></a>
<FONT color="green">12132</FONT>          // else, zero width, keep it that way (no padding added)<a name="line.12132"></a>
<FONT color="green">12133</FONT>    <a name="line.12133"></a>
<FONT color="green">12134</FONT>          if (symHeight != 0) {<a name="line.12134"></a>
<FONT color="green">12135</FONT>            yTop -= pixelPadTop;<a name="line.12135"></a>
<FONT color="green">12136</FONT>            symHeight += pixelPadTop + pixelPadBottom;<a name="line.12136"></a>
<FONT color="green">12137</FONT>          }<a name="line.12137"></a>
<FONT color="green">12138</FONT>          // else, zero height, keep it that way (no padding added)<a name="line.12138"></a>
<FONT color="green">12139</FONT>    <a name="line.12139"></a>
<FONT color="green">12140</FONT>          int borderWidth = symbol.getBorderWidth();<a name="line.12140"></a>
<FONT color="green">12141</FONT>          // borderWidth &lt; 0 ==&gt; external border<a name="line.12141"></a>
<FONT color="green">12142</FONT>          if ((symWidth &gt; 0 &amp;&amp; symHeight &gt; 0) || borderWidth &lt; 0) {<a name="line.12142"></a>
<FONT color="green">12143</FONT>            grp.renderBorderedImage(symbol.getBackgroundColorCSS(), symbol<a name="line.12143"></a>
<FONT color="green">12144</FONT>                .getBorderColorCSS(), symbol.getBorderStyle(),<a name="line.12144"></a>
<FONT color="green">12145</FONT>                borderWidth, symWidth, symHeight, xLeft, yTop, symbol<a name="line.12145"></a>
<FONT color="green">12146</FONT>                .getImageURL());<a name="line.12146"></a>
<FONT color="green">12147</FONT>          }<a name="line.12147"></a>
<FONT color="green">12148</FONT>          // if the image has an attached label, realize that<a name="line.12148"></a>
<FONT color="green">12149</FONT>          if (annotation != null<a name="line.12149"></a>
<FONT color="green">12150</FONT>              &amp;&amp; (annotation.getText() != null || annotation.getWidget() != null)<a name="line.12150"></a>
<FONT color="green">12151</FONT>              &amp;&amp; annotation.getVisible()) {<a name="line.12151"></a>
<FONT color="green">12152</FONT>            AnnotationLocation loc = annotation.getLocation();<a name="line.12152"></a>
<FONT color="green">12153</FONT>            if (null == loc)<a name="line.12153"></a>
<FONT color="green">12154</FONT>              loc = defaultAnnotationLocation();<a name="line.12154"></a>
<FONT color="green">12155</FONT>            loc = AnnotationLocation.transform(loc, signWidth, signHeight);<a name="line.12155"></a>
<FONT color="green">12156</FONT>            // Note: yShift follows orientation of cartesian y<a name="line.12156"></a>
<FONT color="green">12157</FONT>            // Axis, which is 180 degrees different from pixel y<a name="line.12157"></a>
<FONT color="green">12158</FONT>            // coordinates, hence the extra "-" below.<a name="line.12158"></a>
<FONT color="green">12159</FONT>            //<a name="line.12159"></a>
<FONT color="green">12160</FONT>            // signWidth, signHeight multipliers assure that shifts are<a name="line.12160"></a>
<FONT color="green">12161</FONT>            // appropriately symetrical for bars above and below or to the<a name="line.12161"></a>
<FONT color="green">12162</FONT>            // left or right of their baselines (only baseline bars use<a name="line.12162"></a>
<FONT color="green">12163</FONT>            // negative symbol widths) For example, a yShift of<a name="line.12163"></a>
<FONT color="green">12164</FONT>            // 10px would shift up for bars above the baseline, and down<a name="line.12164"></a>
<FONT color="green">12165</FONT>            // for bars below the baseline, which is usually what you<a name="line.12165"></a>
<FONT color="green">12166</FONT>            // want (e.g. placing labels above or below the bars).<a name="line.12166"></a>
<FONT color="green">12167</FONT>            arp.renderAnnotation(annotation, loc, xCenter + signWidth<a name="line.12167"></a>
<FONT color="green">12168</FONT>                * annotation.getXShift(), yCenter - signHeight<a name="line.12168"></a>
<FONT color="green">12169</FONT>                * annotation.getYShift(), symWidth, symHeight, symbol);<a name="line.12169"></a>
<FONT color="green">12170</FONT>          }<a name="line.12170"></a>
<FONT color="green">12171</FONT>    <a name="line.12171"></a>
<FONT color="green">12172</FONT>        }<a name="line.12172"></a>
<FONT color="green">12173</FONT>    <a name="line.12173"></a>
<FONT color="green">12174</FONT>        // Distance from the point (x1, y1) to the point (x2, y2)<a name="line.12174"></a>
<FONT color="green">12175</FONT>        protected double distance(double x1, double y1, double x2, double y2) {<a name="line.12175"></a>
<FONT color="green">12176</FONT>          double result = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1)<a name="line.12176"></a>
<FONT color="green">12177</FONT>              * (y2 - y1));<a name="line.12177"></a>
<FONT color="green">12178</FONT>          return result;<a name="line.12178"></a>
<FONT color="green">12179</FONT>        }<a name="line.12179"></a>
<FONT color="green">12180</FONT>    <a name="line.12180"></a>
<FONT color="green">12181</FONT>        /*<a name="line.12181"></a>
<FONT color="green">12182</FONT>         * Renders the symbol at the specified position within the plot panel, by<a name="line.12182"></a>
<FONT color="green">12183</FONT>         * creating appropriately positioned Canvas, Image and/or Label objects within the<a name="line.12183"></a>
<FONT color="green">12184</FONT>         * given rendering panel. &lt;p&gt;<a name="line.12184"></a>
<FONT color="green">12185</FONT>         * <a name="line.12185"></a>
<FONT color="green">12186</FONT>         * Most of the Image widgets will be replaced with drawing on the rendering<a name="line.12186"></a>
<FONT color="green">12187</FONT>         * panel's dedicated canas Widget if an external canvas capability has been<a name="line.12187"></a>
<FONT color="green">12188</FONT>         * bolted onto GChart, and continuous fill (fillSpacing == 0) has been<a name="line.12188"></a>
<FONT color="green">12189</FONT>         * requested for the curve.<a name="line.12189"></a>
<FONT color="green">12190</FONT>         * &lt;p&gt;<a name="line.12190"></a>
<FONT color="green">12191</FONT>         * <a name="line.12191"></a>
<FONT color="green">12192</FONT>         * So-rendered symbols are used to represent: each point on a curve<a name="line.12192"></a>
<FONT color="green">12193</FONT>         * (including any "filled" elements linearly interpolated between successive<a name="line.12193"></a>
<FONT color="green">12194</FONT>         * points, such as, point-to-point connecting lines and<a name="line.12194"></a>
<FONT color="green">12195</FONT>         * "areas under the curve") and (via special hidden system curves) axes,<a name="line.12195"></a>
<FONT color="green">12196</FONT>         * gridlines, ticks, tick-labels, titles, footnotes, and the legend key. &lt;p&gt;<a name="line.12196"></a>
<FONT color="green">12197</FONT>         * <a name="line.12197"></a>
<FONT color="green">12198</FONT>         * This method is overridden for pie slice symbols and the LINE symbol type.<a name="line.12198"></a>
<FONT color="green">12199</FONT>         */<a name="line.12199"></a>
<FONT color="green">12200</FONT>        // retains coord of an area chart's "filled to" axis/baseline<a name="line.12200"></a>
<FONT color="green">12201</FONT>        static double oppositeEdge = Double.NaN;<a name="line.12201"></a>
<FONT color="green">12202</FONT>    <a name="line.12202"></a>
<FONT color="green">12203</FONT>        void realizeSymbol(PlotPanel pp, GraphicsRenderingPanel grp,<a name="line.12203"></a>
<FONT color="green">12204</FONT>            AnnotationRenderingPanel arp, Symbol symbol,<a name="line.12204"></a>
<FONT color="green">12205</FONT>            Annotation annotation, boolean onY2, boolean clipPlotArea,<a name="line.12205"></a>
<FONT color="green">12206</FONT>            boolean clipDecoratedChart, double renderPaddingFactor, <a name="line.12206"></a>
<FONT color="green">12207</FONT>            boolean drawMainSymbol, double x, double y, <a name="line.12207"></a>
<FONT color="green">12208</FONT>            double prevX, double prevY, double nextX, double nextY) {<a name="line.12208"></a>
<FONT color="green">12209</FONT>    <a name="line.12209"></a>
<FONT color="green">12210</FONT>          if ((x != x) || (y != y)) // this point undefined (isNaN)<a name="line.12210"></a>
<FONT color="green">12211</FONT>            return;<a name="line.12211"></a>
<FONT color="green">12212</FONT>    <a name="line.12212"></a>
<FONT color="green">12213</FONT>          double xPx = pp.xToPixel(x);<a name="line.12213"></a>
<FONT color="green">12214</FONT>          double yPx = pp.yToPixel(y, onY2);<a name="line.12214"></a>
<FONT color="green">12215</FONT>          double prevXPx = pp.xToPixel(prevX);<a name="line.12215"></a>
<FONT color="green">12216</FONT>          double prevYPx = pp.yToPixel(prevY, onY2);<a name="line.12216"></a>
<FONT color="green">12217</FONT>          double nextXPx = pp.xToPixel(nextX);<a name="line.12217"></a>
<FONT color="green">12218</FONT>          double nextYPx = pp.yToPixel(nextY, onY2);<a name="line.12218"></a>
<FONT color="green">12219</FONT>          double spacing = symbol.getFillSpacing();<a name="line.12219"></a>
<FONT color="green">12220</FONT>          int thickness = symbol.getFillThickness();<a name="line.12220"></a>
<FONT color="green">12221</FONT>          GChartCanvasLite canvas = grp.getCanvas();<a name="line.12221"></a>
<FONT color="green">12222</FONT>    <a name="line.12222"></a>
<FONT color="green">12223</FONT>          if (0 == spacing &amp;&amp; null != canvas &amp;&amp; thickness &gt; 0) {<a name="line.12223"></a>
<FONT color="green">12224</FONT>            // if canvas rendered<a name="line.12224"></a>
<FONT color="green">12225</FONT>            if (null == isHorizontallyBanded) {<a name="line.12225"></a>
<FONT color="green">12226</FONT>              /*<a name="line.12226"></a>
<FONT color="green">12227</FONT>               * Continuous fill, canvas available, and not explicitly horizontally<a name="line.12227"></a>
<FONT color="green">12228</FONT>               * or vertically banded. For example, BOX_* symbol types are not<a name="line.12228"></a>
<FONT color="green">12229</FONT>               * explicitly oriented, but VBAR_* (vertically) and HBAR_*<a name="line.12229"></a>
<FONT color="green">12230</FONT>               * (horizontally) are: use canvas to draw a straight line between<a name="line.12230"></a>
<FONT color="green">12231</FONT>               * points. &lt;p&gt;<a name="line.12231"></a>
<FONT color="green">12232</FONT>               * <a name="line.12232"></a>
<FONT color="green">12233</FONT>               * Code in this branch also gets executed by the LINE symbol type.<a name="line.12233"></a>
<FONT color="green">12234</FONT>               */<a name="line.12234"></a>
<FONT color="green">12235</FONT>              int borderWidth = symbol.getBorderWidth();<a name="line.12235"></a>
<FONT color="green">12236</FONT>              // negative (external) border widens line by 2*|borderWidth|<a name="line.12236"></a>
<FONT color="green">12237</FONT>              int externalLineWidth = (borderWidth &gt;= 0) ? thickness<a name="line.12237"></a>
<FONT color="green">12238</FONT>                  : (thickness + 2 * Math.abs(borderWidth));<a name="line.12238"></a>
<FONT color="green">12239</FONT>              int internalLineWidth = (borderWidth &gt;= 0) ? Math.max(<a name="line.12239"></a>
<FONT color="green">12240</FONT>                  thickness - 2 * borderWidth, 0) : thickness;<a name="line.12240"></a>
<FONT color="green">12241</FONT>              String borderColor = symbol.getBorderColor();<a name="line.12241"></a>
<FONT color="green">12242</FONT>              String backgroundColor = symbol.getBackgroundColor();<a name="line.12242"></a>
<FONT color="green">12243</FONT>              if (externalLineWidth &gt; 0<a name="line.12243"></a>
<FONT color="green">12244</FONT>                  &amp;&amp; ((TRANSPARENT_BORDER_COLOR != borderColor &amp;&amp; <a name="line.12244"></a>
<FONT color="green">12245</FONT>                       "transparent" != borderColor) || <a name="line.12245"></a>
<FONT color="green">12246</FONT>                       (TRANSPARENT_BORDER_COLOR != backgroundColor &amp;&amp; <a name="line.12246"></a>
<FONT color="green">12247</FONT>                        "transparent" != backgroundColor))) {<a name="line.12247"></a>
<FONT color="green">12248</FONT>                if (prevX != prevX || prevY != prevY) {<a name="line.12248"></a>
<FONT color="green">12249</FONT>                  // first defined point after an undefined point ==&gt; new<a name="line.12249"></a>
<FONT color="green">12250</FONT>                  // path (need to draw zero-thickness lines for possible<a name="line.12250"></a>
<FONT color="green">12251</FONT>                  // line endings user may have defined by overriding<a name="line.12251"></a>
<FONT color="green">12252</FONT>                  // beginPath)<a name="line.12252"></a>
<FONT color="green">12253</FONT>                  canvas.beginPath();<a name="line.12253"></a>
<FONT color="green">12254</FONT>                  canvas.moveTo(xPx - grp.x0, yPx - grp.y0);<a name="line.12254"></a>
<FONT color="green">12255</FONT>                }<a name="line.12255"></a>
<FONT color="green">12256</FONT>                if (nextX != nextX || nextY != nextY) {<a name="line.12256"></a>
<FONT color="green">12257</FONT>                  // last defined point before undefined point ==&gt;<a name="line.12257"></a>
<FONT color="green">12258</FONT>                  // draw accumulated path<a name="line.12258"></a>
<FONT color="green">12259</FONT>                  if (TRANSPARENT_BORDER_COLOR != borderColor<a name="line.12259"></a>
<FONT color="green">12260</FONT>                      &amp;&amp; "transparent" != borderColor<a name="line.12260"></a>
<FONT color="green">12261</FONT>                      &amp;&amp; externalLineWidth &gt; 0) {<a name="line.12261"></a>
<FONT color="green">12262</FONT>                    canvas.setStrokeStyle(borderColor);<a name="line.12262"></a>
<FONT color="green">12263</FONT>                    canvas.setLineWidth(externalLineWidth);<a name="line.12263"></a>
<FONT color="green">12264</FONT>                    canvas.stroke();<a name="line.12264"></a>
<FONT color="green">12265</FONT>                  }<a name="line.12265"></a>
<FONT color="green">12266</FONT>                  if (TRANSPARENT_BORDER_COLOR != backgroundColor<a name="line.12266"></a>
<FONT color="green">12267</FONT>                      &amp;&amp; "transparent" != backgroundColor<a name="line.12267"></a>
<FONT color="green">12268</FONT>                      &amp;&amp; internalLineWidth &gt; 0) {<a name="line.12268"></a>
<FONT color="green">12269</FONT>                    canvas.setLineWidth(internalLineWidth);<a name="line.12269"></a>
<FONT color="green">12270</FONT>                    canvas.setStrokeStyle(backgroundColor);<a name="line.12270"></a>
<FONT color="green">12271</FONT>                    canvas.stroke();<a name="line.12271"></a>
<FONT color="green">12272</FONT>                  }<a name="line.12272"></a>
<FONT color="green">12273</FONT>                } else<a name="line.12273"></a>
<FONT color="green">12274</FONT>                  // not at end of chain ==&gt; add one more segment to the<a name="line.12274"></a>
<FONT color="green">12275</FONT>                  // path (need to draw doubled points for possibly "line<a name="line.12275"></a>
<FONT color="green">12276</FONT>                  // join" user may have defined via overriding beginPath)<a name="line.12276"></a>
<FONT color="green">12277</FONT>                  canvas.lineTo(nextXPx - grp.x0, nextYPx - grp.y0);<a name="line.12277"></a>
<FONT color="green">12278</FONT>              }<a name="line.12278"></a>
<FONT color="green">12279</FONT>              // else lines are 0-width or transparent, so not rendered<a name="line.12279"></a>
<FONT color="green">12280</FONT>            } else {<a name="line.12280"></a>
<FONT color="green">12281</FONT>              /*<a name="line.12281"></a>
<FONT color="green">12282</FONT>               * Explicitly oriented bandedness occurs only for vert or horizontal<a name="line.12282"></a>
<FONT color="green">12283</FONT>               * bars. x,y coordinates are connected into a path (as in a line<a name="line.12283"></a>
<FONT color="green">12284</FONT>               * chart), and then that path is extended into a closed polygon by<a name="line.12284"></a>
<FONT color="green">12285</FONT>               * adding a closing segment formed from an appropriate section of an<a name="line.12285"></a>
<FONT color="green">12286</FONT>               * axis or baseline.<a name="line.12286"></a>
<FONT color="green">12287</FONT>               */<a name="line.12287"></a>
<FONT color="green">12288</FONT>    <a name="line.12288"></a>
<FONT color="green">12289</FONT>              /*<a name="line.12289"></a>
<FONT color="green">12290</FONT>               * Draw area interpolated between successive bars.<a name="line.12290"></a>
<FONT color="green">12291</FONT>               * <a name="line.12291"></a>
<FONT color="green">12292</FONT>               * Note that the "opposite" edge could be a point on an x or y axis,<a name="line.12292"></a>
<FONT color="green">12293</FONT>               * or on the curve's baseline, depending on the kind of bar chart<a name="line.12293"></a>
<FONT color="green">12294</FONT>               * involved: it's the edge of the bar that is furthest from the x,y<a name="line.12294"></a>
<FONT color="green">12295</FONT>               * point.<a name="line.12295"></a>
<FONT color="green">12296</FONT>               */<a name="line.12296"></a>
<FONT color="green">12297</FONT>              boolean closeStrokeAndFill = false;<a name="line.12297"></a>
<FONT color="green">12298</FONT>              if (Boolean.FALSE == isHorizontallyBanded) {<a name="line.12298"></a>
<FONT color="green">12299</FONT>                if (prevX != prevX || prevY != prevY) {<a name="line.12299"></a>
<FONT color="green">12300</FONT>                  // 1st point, or 1st point after a break in the line<a name="line.12300"></a>
<FONT color="green">12301</FONT>                  oppositeEdge = getEdgeOppositeVertically(pp,<a name="line.12301"></a>
<FONT color="green">12302</FONT>                      symbol, y, onY2);<a name="line.12302"></a>
<FONT color="green">12303</FONT>                  canvas.beginPath();<a name="line.12303"></a>
<FONT color="green">12304</FONT>                  canvas.moveTo(xPx - grp.x0, oppositeEdge - grp.y0);<a name="line.12304"></a>
<FONT color="green">12305</FONT>                  canvas.lineTo(xPx - grp.x0, yPx - grp.y0);<a name="line.12305"></a>
<FONT color="green">12306</FONT>                }<a name="line.12306"></a>
<FONT color="green">12307</FONT>                if (nextX != nextX || nextY != nextY) {<a name="line.12307"></a>
<FONT color="green">12308</FONT>                  // last point, or last point before a break in the line<a name="line.12308"></a>
<FONT color="green">12309</FONT>                  canvas.lineTo(xPx - grp.x0, oppositeEdge - grp.y0);<a name="line.12309"></a>
<FONT color="green">12310</FONT>                  closeStrokeAndFill = true;<a name="line.12310"></a>
<FONT color="green">12311</FONT>                } else {<a name="line.12311"></a>
<FONT color="green">12312</FONT>                  canvas.lineTo(nextXPx - grp.x0, nextYPx - grp.y0);<a name="line.12312"></a>
<FONT color="green">12313</FONT>                }<a name="line.12313"></a>
<FONT color="green">12314</FONT>              } else {<a name="line.12314"></a>
<FONT color="green">12315</FONT>    <a name="line.12315"></a>
<FONT color="green">12316</FONT>                if (prevX != prevX || prevY != prevY) {<a name="line.12316"></a>
<FONT color="green">12317</FONT>                  // 1st point, or 1st point after a break in the line<a name="line.12317"></a>
<FONT color="green">12318</FONT>                  oppositeEdge = getEdgeOppositeHorizontally(pp,<a name="line.12318"></a>
<FONT color="green">12319</FONT>                      symbol, x, onY2);<a name="line.12319"></a>
<FONT color="green">12320</FONT>                  canvas.beginPath();<a name="line.12320"></a>
<FONT color="green">12321</FONT>                  canvas.moveTo(oppositeEdge - grp.x0, yPx - grp.y0);<a name="line.12321"></a>
<FONT color="green">12322</FONT>                  canvas.lineTo(xPx - grp.x0, yPx - grp.y0);<a name="line.12322"></a>
<FONT color="green">12323</FONT>                }<a name="line.12323"></a>
<FONT color="green">12324</FONT>                if (nextX != nextX || nextY != nextY) {<a name="line.12324"></a>
<FONT color="green">12325</FONT>                  // last point, or last point before a break in the line<a name="line.12325"></a>
<FONT color="green">12326</FONT>                  canvas.lineTo(oppositeEdge - grp.x0, yPx - grp.y0);<a name="line.12326"></a>
<FONT color="green">12327</FONT>                  closeStrokeAndFill = true;<a name="line.12327"></a>
<FONT color="green">12328</FONT>                } else {<a name="line.12328"></a>
<FONT color="green">12329</FONT>                  canvas.lineTo(nextXPx - grp.x0, nextYPx - grp.y0);<a name="line.12329"></a>
<FONT color="green">12330</FONT>                }<a name="line.12330"></a>
<FONT color="green">12331</FONT>    <a name="line.12331"></a>
<FONT color="green">12332</FONT>              }<a name="line.12332"></a>
<FONT color="green">12333</FONT>    <a name="line.12333"></a>
<FONT color="green">12334</FONT>              if (closeStrokeAndFill) {<a name="line.12334"></a>
<FONT color="green">12335</FONT>    <a name="line.12335"></a>
<FONT color="green">12336</FONT>                canvas.closePath();<a name="line.12336"></a>
<FONT color="green">12337</FONT>                int borderWidth = symbol.getBorderWidth();<a name="line.12337"></a>
<FONT color="green">12338</FONT>                // negative (external) border requires double-wide stroke<a name="line.12338"></a>
<FONT color="green">12339</FONT>                int lineWidth = (borderWidth &gt;= 0) ? borderWidth<a name="line.12339"></a>
<FONT color="green">12340</FONT>                    : (2 * Math.abs(borderWidth));<a name="line.12340"></a>
<FONT color="green">12341</FONT>                String borderColor = symbol.getBorderColor();<a name="line.12341"></a>
<FONT color="green">12342</FONT>                String backgroundColor = symbol.getBackgroundColor();<a name="line.12342"></a>
<FONT color="green">12343</FONT>    <a name="line.12343"></a>
<FONT color="green">12344</FONT>                /*<a name="line.12344"></a>
<FONT color="green">12345</FONT>                 * XXX: Simply dropping the rendering as we do below does not<a name="line.12345"></a>
<FONT color="green">12346</FONT>                 * exactly simulate the effect of transparent border/fill,<a name="line.12346"></a>
<FONT color="green">12347</FONT>                 * specifically:<a name="line.12347"></a>
<FONT color="green">12348</FONT>                 * <a name="line.12348"></a>
<FONT color="green">12349</FONT>                 * &lt;ol&gt; &lt;li&gt; Transparent internal border ==&gt; the background fill<a name="line.12349"></a>
<FONT color="green">12350</FONT>                 * shines through the inner half of that border &lt;li&gt; Transparent<a name="line.12350"></a>
<FONT color="green">12351</FONT>                 * external border ==&gt; Works OK &lt;li&gt; Transparent fill w external<a name="line.12351"></a>
<FONT color="green">12352</FONT>                 * border ==&gt; border extended internally to double width &lt;li&gt;<a name="line.12352"></a>
<FONT color="green">12353</FONT>                 * Transparent fill w internal border ==&gt; works OK &lt;/ol&gt;<a name="line.12353"></a>
<FONT color="green">12354</FONT>                 * <a name="line.12354"></a>
<FONT color="green">12355</FONT>                 * GWTCanvas does not provide a mechanism to "stroke transparent<a name="line.12355"></a>
<FONT color="green">12356</FONT>                 * pixels", which is what I really needed. And emulating this,<a name="line.12356"></a>
<FONT color="green">12357</FONT>                 * though possible via properly positioned inner/outter regions,<a name="line.12357"></a>
<FONT color="green">12358</FONT>                 * etc. would have required a lot of effort to assure that sharply<a name="line.12358"></a>
<FONT color="green">12359</FONT>                 * peaked angles, say, get rendered right.<a name="line.12359"></a>
<FONT color="green">12360</FONT>                 */                <a name="line.12360"></a>
<FONT color="green">12361</FONT>    <a name="line.12361"></a>
<FONT color="green">12362</FONT>                // non-negative borders fill before stroking (thus<a name="line.12362"></a>
<FONT color="green">12363</FONT>                // stroke overwrites internal half of border)<a name="line.12363"></a>
<FONT color="green">12364</FONT>                if (borderWidth &gt;= 0 &amp;&amp; thickness &gt; 0<a name="line.12364"></a>
<FONT color="green">12365</FONT>                    &amp;&amp; TRANSPARENT_BORDER_COLOR != backgroundColor<a name="line.12365"></a>
<FONT color="green">12366</FONT>                    &amp;&amp; "transparent" != backgroundColor) {<a name="line.12366"></a>
<FONT color="green">12367</FONT>                  canvas.setFillStyle(backgroundColor);<a name="line.12367"></a>
<FONT color="green">12368</FONT>                  canvas.fill();<a name="line.12368"></a>
<FONT color="green">12369</FONT>                }<a name="line.12369"></a>
<FONT color="green">12370</FONT>    <a name="line.12370"></a>
<FONT color="green">12371</FONT>                // stroke whenever a border is present<a name="line.12371"></a>
<FONT color="green">12372</FONT>                if (borderWidth != 0<a name="line.12372"></a>
<FONT color="green">12373</FONT>                    &amp;&amp; TRANSPARENT_BORDER_COLOR != borderColor<a name="line.12373"></a>
<FONT color="green">12374</FONT>                    &amp;&amp; "transparent" != borderColor) {<a name="line.12374"></a>
<FONT color="green">12375</FONT>                  canvas.setStrokeStyle(borderColor);<a name="line.12375"></a>
<FONT color="green">12376</FONT>                  canvas.setLineWidth(lineWidth);<a name="line.12376"></a>
<FONT color="green">12377</FONT>                  canvas.stroke();<a name="line.12377"></a>
<FONT color="green">12378</FONT>                }<a name="line.12378"></a>
<FONT color="green">12379</FONT>    <a name="line.12379"></a>
<FONT color="green">12380</FONT>                // negative borders fill AFTER stroking (thus zapping<a name="line.12380"></a>
<FONT color="green">12381</FONT>                // the internal half of the stroked border).<a name="line.12381"></a>
<FONT color="green">12382</FONT>                if (borderWidth &lt; 0 &amp;&amp; thickness &gt; 0<a name="line.12382"></a>
<FONT color="green">12383</FONT>                    &amp;&amp; TRANSPARENT_BORDER_COLOR != backgroundColor<a name="line.12383"></a>
<FONT color="green">12384</FONT>                    &amp;&amp; "transparent" != backgroundColor) {<a name="line.12384"></a>
<FONT color="green">12385</FONT>                  canvas.setFillStyle(backgroundColor);<a name="line.12385"></a>
<FONT color="green">12386</FONT>                  canvas.fill();<a name="line.12386"></a>
<FONT color="green">12387</FONT>                }<a name="line.12387"></a>
<FONT color="green">12388</FONT>              }<a name="line.12388"></a>
<FONT color="green">12389</FONT>            }<a name="line.12389"></a>
<FONT color="green">12390</FONT>          } // if (0 == spacing &amp;&amp; null != canvas &amp;&amp; thickness &gt; 0)<a name="line.12390"></a>
<FONT color="green">12391</FONT>          else if (nextX == nextX &amp;&amp; nextY == nextY &amp;&amp; // next point defined<a name="line.12391"></a>
<FONT color="green">12392</FONT>              thickness &gt; 0 &amp;&amp; // not a zero thickness connection<a name="line.12392"></a>
<FONT color="green">12393</FONT>              (x != nextX || y != nextY)) { // this/next point not overlayed<a name="line.12393"></a>
<FONT color="green">12394</FONT>            if (0 == spacing) // 1px is as close as HTML-element<a name="line.12394"></a>
<FONT color="green">12395</FONT>              spacing = 1; // based filling can get to continuous<a name="line.12395"></a>
<FONT color="green">12396</FONT>            double d = distance(xPx, yPx, nextXPx, nextYPx);<a name="line.12396"></a>
<FONT color="green">12397</FONT>            int nChunks = (int) Math.round(d / spacing);<a name="line.12397"></a>
<FONT color="green">12398</FONT>            if (nChunks &gt; 1) {<a name="line.12398"></a>
<FONT color="green">12399</FONT>              double deltaX = nextXPx - xPx;<a name="line.12399"></a>
<FONT color="green">12400</FONT>              double deltaY = nextYPx - yPx;<a name="line.12400"></a>
<FONT color="green">12401</FONT>              boolean dXIsLonger = deltaX * deltaX &gt; deltaY * deltaY;<a name="line.12401"></a>
<FONT color="green">12402</FONT>              if (dXIsLonger) {<a name="line.12402"></a>
<FONT color="green">12403</FONT>                deltaY /= deltaX; // from now on, dy is really dy/dx<a name="line.12403"></a>
<FONT color="green">12404</FONT>                deltaX /= nChunks;// from now on, dx is for 1 chunk<a name="line.12404"></a>
<FONT color="green">12405</FONT>              } else {<a name="line.12405"></a>
<FONT color="green">12406</FONT>                deltaX /= deltaY; // from now on, dx is really dx/dy<a name="line.12406"></a>
<FONT color="green">12407</FONT>                deltaY /= nChunks; // from now on, dy is for 1 chunk<a name="line.12407"></a>
<FONT color="green">12408</FONT>              }<a name="line.12408"></a>
<FONT color="green">12409</FONT>              // i==0 corresponds to the (to-be-drawn-last) symbol on<a name="line.12409"></a>
<FONT color="green">12410</FONT>              // (x,y).<a name="line.12410"></a>
<FONT color="green">12411</FONT>              for (int i = 1; i &lt; nChunks; i++) {<a name="line.12411"></a>
<FONT color="green">12412</FONT>                // linearly interpolate forwards towards the next<a name="line.12412"></a>
<FONT color="green">12413</FONT>                // point; forward interpolation (usually) lets us<a name="line.12413"></a>
<FONT color="green">12414</FONT>                // place the "main" symbol for the original point on<a name="line.12414"></a>
<FONT color="green">12415</FONT>                // top of these interpolated symbols, in one pass.<a name="line.12415"></a>
<FONT color="green">12416</FONT>                double xi;<a name="line.12416"></a>
<FONT color="green">12417</FONT>                double yi;<a name="line.12417"></a>
<FONT color="green">12418</FONT>    <a name="line.12418"></a>
<FONT color="green">12419</FONT>                // Rounding to the longer dimension first, then<a name="line.12419"></a>
<FONT color="green">12420</FONT>                // using that pixelated position to determine other<a name="line.12420"></a>
<FONT color="green">12421</FONT>                // dimension tends to keep points closer to being<a name="line.12421"></a>
<FONT color="green">12422</FONT>                // on the mathematically ideal line (at the cost of<a name="line.12422"></a>
<FONT color="green">12423</FONT>                // being less evenly spaced along that line). It's<a name="line.12423"></a>
<FONT color="green">12424</FONT>                // not too hard to see the improved alignment on<a name="line.12424"></a>
<FONT color="green">12425</FONT>                // GChartExample03, for example.<a name="line.12425"></a>
<FONT color="green">12426</FONT>                if (dXIsLonger) {<a name="line.12426"></a>
<FONT color="green">12427</FONT>                  xi = Math.round(xPx + deltaX * i);<a name="line.12427"></a>
<FONT color="green">12428</FONT>                  yi = Math.round(yPx + deltaY * (xi - xPx));<a name="line.12428"></a>
<FONT color="green">12429</FONT>                } else { // delta y is longer<a name="line.12429"></a>
<FONT color="green">12430</FONT>                  yi = Math.round(yPx + deltaY * i);<a name="line.12430"></a>
<FONT color="green">12431</FONT>                  xi = Math.round(xPx + deltaX * (yi - yPx));<a name="line.12431"></a>
<FONT color="green">12432</FONT>                }<a name="line.12432"></a>
<FONT color="green">12433</FONT>    <a name="line.12433"></a>
<FONT color="green">12434</FONT>                // interpolated symbols set width &amp; height to<a name="line.12434"></a>
<FONT color="green">12435</FONT>                // thickness, but are otherwise the same as main<a name="line.12435"></a>
<FONT color="green">12436</FONT>                // symbol at (x,y)<a name="line.12436"></a>
<FONT color="green">12437</FONT>                realizeOneImageOfSymbol(pp, grp, arp, symbol, null,<a name="line.12437"></a>
<FONT color="green">12438</FONT>                    onY2, clipPlotArea, clipDecoratedChart, renderPaddingFactor,<a name="line.12438"></a>
<FONT color="green">12439</FONT>                    xi, yi, prevXPx, prevYPx, nextXPx, nextYPx,<a name="line.12439"></a>
<FONT color="green">12440</FONT>                    thickness, thickness);<a name="line.12440"></a>
<FONT color="green">12441</FONT>              }<a name="line.12441"></a>
<FONT color="green">12442</FONT>            }<a name="line.12442"></a>
<FONT color="green">12443</FONT>            // else points too close to require any "filler" elements<a name="line.12443"></a>
<FONT color="green">12444</FONT>          }<a name="line.12444"></a>
<FONT color="green">12445</FONT>          // the "main" symbol (the one on the (x,y) point itself) is<a name="line.12445"></a>
<FONT color="green">12446</FONT>          // rendered last to put it on top of interpolated images; this<a name="line.12446"></a>
<FONT color="green">12447</FONT>          // is also where any annotation on the point gets rendered.<a name="line.12447"></a>
<FONT color="green">12448</FONT>          if (drawMainSymbol) {<a name="line.12448"></a>
<FONT color="green">12449</FONT>            realizeOneImageOfSymbol(pp, grp, arp, symbol, annotation, onY2,<a name="line.12449"></a>
<FONT color="green">12450</FONT>                clipPlotArea, clipDecoratedChart, renderPaddingFactor, <a name="line.12450"></a>
<FONT color="green">12451</FONT>                xPx, yPx, prevXPx, prevYPx, nextXPx, nextYPx,<a name="line.12451"></a>
<FONT color="green">12452</FONT>                symbol.getWidth(pp), symbol.getHeight(pp, onY2));<a name="line.12452"></a>
<FONT color="green">12453</FONT>          }<a name="line.12453"></a>
<FONT color="green">12454</FONT>        }<a name="line.12454"></a>
<FONT color="green">12455</FONT>    <a name="line.12455"></a>
<FONT color="green">12456</FONT>      } // end of class SymbolType<a name="line.12456"></a>
<FONT color="green">12457</FONT>    <a name="line.12457"></a>
<FONT color="green">12458</FONT>      /**<a name="line.12458"></a>
<FONT color="green">12459</FONT>       * Defines keywords &lt;tt&gt;INSIDE&lt;/tt&gt;, &lt;tt&gt;OUTSIDE&lt;/tt&gt;, and &lt;tt&gt;CENTERED&lt;/tt&gt;<a name="line.12459"></a>
<FONT color="green">12460</FONT>       * that specify the location of ticks relative to their axis.<a name="line.12460"></a>
<FONT color="green">12461</FONT>       * &lt;p&gt;<a name="line.12461"></a>
<FONT color="green">12462</FONT>       * <a name="line.12462"></a>
<FONT color="green">12463</FONT>       * @see Axis#setTickLocation setTickLocation<a name="line.12463"></a>
<FONT color="green">12464</FONT>       * <a name="line.12464"></a>
<FONT color="green">12465</FONT>       */<a name="line.12465"></a>
<FONT color="green">12466</FONT>      public static final class TickLocation {<a name="line.12466"></a>
<FONT color="green">12467</FONT>        /*<a name="line.12467"></a>
<FONT color="green">12468</FONT>         * An integer form of the tick location (-1 - OUTSIDE, 0 - CENTERED, +1 -<a name="line.12468"></a>
<FONT color="green">12469</FONT>         * INSIDE) that facilitates generating appropriate symbol types for<a name="line.12469"></a>
<FONT color="green">12470</FONT>         * rendering ticks.<a name="line.12470"></a>
<FONT color="green">12471</FONT>         */<a name="line.12471"></a>
<FONT color="green">12472</FONT>        int locationIndex;<a name="line.12472"></a>
<FONT color="green">12473</FONT>    <a name="line.12473"></a>
<FONT color="green">12474</FONT>        private TickLocation(int locationIndex) {<a name="line.12474"></a>
<FONT color="green">12475</FONT>          this.locationIndex = locationIndex;<a name="line.12475"></a>
<FONT color="green">12476</FONT>        }<a name="line.12476"></a>
<FONT color="green">12477</FONT>    <a name="line.12477"></a>
<FONT color="green">12478</FONT>        /**<a name="line.12478"></a>
<FONT color="green">12479</FONT>         * Indicates that ticks are located outside of the axis.<a name="line.12479"></a>
<FONT color="green">12480</FONT>         * <a name="line.12480"></a>
<FONT color="green">12481</FONT>         * @see Axis#setTickLocation setTickLocation<a name="line.12481"></a>
<FONT color="green">12482</FONT>         */<a name="line.12482"></a>
<FONT color="green">12483</FONT>        public static final TickLocation OUTSIDE = new TickLocation(-1);<a name="line.12483"></a>
<FONT color="green">12484</FONT>        /**<a name="line.12484"></a>
<FONT color="green">12485</FONT>         * Indicates that ticks are centered on the axis.<a name="line.12485"></a>
<FONT color="green">12486</FONT>         * <a name="line.12486"></a>
<FONT color="green">12487</FONT>         * @see Axis#setTickLocation setTickLocation<a name="line.12487"></a>
<FONT color="green">12488</FONT>         */<a name="line.12488"></a>
<FONT color="green">12489</FONT>        public static final TickLocation CENTERED = new TickLocation(0);<a name="line.12489"></a>
<FONT color="green">12490</FONT>        /**<a name="line.12490"></a>
<FONT color="green">12491</FONT>         * Indicates that ticks are located inside of the axis.<a name="line.12491"></a>
<FONT color="green">12492</FONT>         * <a name="line.12492"></a>
<FONT color="green">12493</FONT>         * @see Axis#setTickLocation setTickLocation<a name="line.12493"></a>
<FONT color="green">12494</FONT>         */<a name="line.12494"></a>
<FONT color="green">12495</FONT>        public static final TickLocation INSIDE = new TickLocation(1);<a name="line.12495"></a>
<FONT color="green">12496</FONT>    <a name="line.12496"></a>
<FONT color="green">12497</FONT>        // symbol type representing ticks on x axes at given position<a name="line.12497"></a>
<FONT color="green">12498</FONT>        // axisPosition of -1 is x-axis, +1 is x2-axis.<a name="line.12498"></a>
<FONT color="green">12499</FONT>        //<a name="line.12499"></a>
<FONT color="green">12500</FONT>        // (symbols representing ticks depend on the axis they are on)<a name="line.12500"></a>
<FONT color="green">12501</FONT>        SymbolType getXAxisSymbolType(int axisPosition) {<a name="line.12501"></a>
<FONT color="green">12502</FONT>          final SymbolType[] symbolMap = { SymbolType.BOX_NORTH,<a name="line.12502"></a>
<FONT color="green">12503</FONT>              SymbolType.BOX_CENTER, SymbolType.BOX_SOUTH };<a name="line.12503"></a>
<FONT color="green">12504</FONT>          SymbolType result = symbolMap[axisPosition * locationIndex + 1];<a name="line.12504"></a>
<FONT color="green">12505</FONT>          return result;<a name="line.12505"></a>
<FONT color="green">12506</FONT>        }<a name="line.12506"></a>
<FONT color="green">12507</FONT>    <a name="line.12507"></a>
<FONT color="green">12508</FONT>        // symbol type representing ticks on y axes at given position<a name="line.12508"></a>
<FONT color="green">12509</FONT>        // axisPosition of -1 is y-axis, +1 is y2-axis<a name="line.12509"></a>
<FONT color="green">12510</FONT>        //<a name="line.12510"></a>
<FONT color="green">12511</FONT>        // (symbols representing ticks depend on the axis they are on)<a name="line.12511"></a>
<FONT color="green">12512</FONT>        SymbolType getYAxisSymbolType(int axisPosition) {<a name="line.12512"></a>
<FONT color="green">12513</FONT>          final SymbolType[] symbolMap = { SymbolType.BOX_EAST,<a name="line.12513"></a>
<FONT color="green">12514</FONT>              SymbolType.BOX_CENTER, SymbolType.BOX_WEST };<a name="line.12514"></a>
<FONT color="green">12515</FONT>          SymbolType result = symbolMap[axisPosition * locationIndex + 1];<a name="line.12515"></a>
<FONT color="green">12516</FONT>          return result;<a name="line.12516"></a>
<FONT color="green">12517</FONT>        }<a name="line.12517"></a>
<FONT color="green">12518</FONT>    <a name="line.12518"></a>
<FONT color="green">12519</FONT>      } // class TickLocation<a name="line.12519"></a>
<FONT color="green">12520</FONT>    <a name="line.12520"></a>
<FONT color="green">12521</FONT>      /**<a name="line.12521"></a>
<FONT color="green">12522</FONT>       * Defines how the &lt;tt&gt;update&lt;/tt&gt; method updates the touched point, that is,<a name="line.12522"></a>
<FONT color="green">12523</FONT>       * the point the user is considered to be hovered over.<a name="line.12523"></a>
<FONT color="green">12524</FONT>       * <a name="line.12524"></a>
<FONT color="green">12525</FONT>       * @see #update(TouchedPointUpdateOption) update<a name="line.12525"></a>
<FONT color="green">12526</FONT>       * <a name="line.12526"></a>
<FONT color="green">12527</FONT>       */<a name="line.12527"></a>
<FONT color="green">12528</FONT>    <a name="line.12528"></a>
<FONT color="green">12529</FONT>      public static final class TouchedPointUpdateOption {<a name="line.12529"></a>
<FONT color="green">12530</FONT>        private TouchedPointUpdateOption() {<a name="line.12530"></a>
<FONT color="green">12531</FONT>          super();<a name="line.12531"></a>
<FONT color="green">12532</FONT>        }<a name="line.12532"></a>
<FONT color="green">12533</FONT>    <a name="line.12533"></a>
<FONT color="green">12534</FONT>        /**<a name="line.12534"></a>
<FONT color="green">12535</FONT>         * When this option is passed to the update method, any touched point is<a name="line.12535"></a>
<FONT color="green">12536</FONT>         * cleared as a consequence of the update.<a name="line.12536"></a>
<FONT color="green">12537</FONT>         * &lt;p&gt;<a name="line.12537"></a>
<FONT color="green">12538</FONT>         * <a name="line.12538"></a>
<FONT color="green">12539</FONT>         * This option can be used when you want to "start fresh" with regards to<a name="line.12539"></a>
<FONT color="green">12540</FONT>         * hover feedback after an update, and want to assure that only explicit<a name="line.12540"></a>
<FONT color="green">12541</FONT>         * user-generated mouse move actions (rather than objects moving<a name="line.12541"></a>
<FONT color="green">12542</FONT>         * &lt;i&gt;underneath&lt;/i&gt; a fixed-position mouse cursor) can trigger hover<a name="line.12542"></a>
<FONT color="green">12543</FONT>         * feedback.<a name="line.12543"></a>
<FONT color="green">12544</FONT>         * <a name="line.12544"></a>
<FONT color="green">12545</FONT>         * @see #update update<a name="line.12545"></a>
<FONT color="green">12546</FONT>         * @see #TOUCHED_POINT_LOCKED TOUCHED_POINT_LOCKED<a name="line.12546"></a>
<FONT color="green">12547</FONT>         * @see #TOUCHED_POINT_UPDATED TOUCHED_POINT_UPDATED<a name="line.12547"></a>
<FONT color="green">12548</FONT>         * <a name="line.12548"></a>
<FONT color="green">12549</FONT>         */<a name="line.12549"></a>
<FONT color="green">12550</FONT>        public static final TouchedPointUpdateOption TOUCHED_POINT_CLEARED = new TouchedPointUpdateOption();<a name="line.12550"></a>
<FONT color="green">12551</FONT>    <a name="line.12551"></a>
<FONT color="green">12552</FONT>        /**<a name="line.12552"></a>
<FONT color="green">12553</FONT>         * When this option is passed to the update method, any previously touched<a name="line.12553"></a>
<FONT color="green">12554</FONT>         * point is locked in (remains unchanged).<a name="line.12554"></a>
<FONT color="green">12555</FONT>         * &lt;p&gt;<a name="line.12555"></a>
<FONT color="green">12556</FONT>         * <a name="line.12556"></a>
<FONT color="green">12557</FONT>         * For example, if the mouse is over a certain point before the update, and<a name="line.12557"></a>
<FONT color="green">12558</FONT>         * that point moves away from the mouse (without the mouse moving otherwise)<a name="line.12558"></a>
<FONT color="green">12559</FONT>         * as a consequence of the update, the hover feedback remains "locked in" to<a name="line.12559"></a>
<FONT color="green">12560</FONT>         * the original point, even though the mouse is no longer on top of that<a name="line.12560"></a>
<FONT color="green">12561</FONT>         * point.<a name="line.12561"></a>
<FONT color="green">12562</FONT>         * &lt;p&gt;<a name="line.12562"></a>
<FONT color="green">12563</FONT>         * <a name="line.12563"></a>
<FONT color="green">12564</FONT>         * This option is useful for hover widgets that modify the position, size,<a name="line.12564"></a>
<FONT color="green">12565</FONT>         * symbol of points/curves, and do not want the selected point/curve (and<a name="line.12565"></a>
<FONT color="green">12566</FONT>         * popup hover widget) to change as a consequence of such changes.<a name="line.12566"></a>
<FONT color="green">12567</FONT>         * &lt;p&gt;<a name="line.12567"></a>
<FONT color="green">12568</FONT>         * <a name="line.12568"></a>
<FONT color="green">12569</FONT>         * &lt;i&gt;Note:&lt;/i&gt; If the currently touched point or the curve containing it is<a name="line.12569"></a>
<FONT color="green">12570</FONT>         * deleted, GChart sets the touched point reference to &lt;tt&gt;null&lt;/tt&gt;. In<a name="line.12570"></a>
<FONT color="green">12571</FONT>         * that case, this option and &lt;tt&gt;TOUCHED_POINT_CLEARED&lt;/tt&gt; behave the same<a name="line.12571"></a>
<FONT color="green">12572</FONT>         * way.<a name="line.12572"></a>
<FONT color="green">12573</FONT>         * <a name="line.12573"></a>
<FONT color="green">12574</FONT>         * <a name="line.12574"></a>
<FONT color="green">12575</FONT>         * @see #update update<a name="line.12575"></a>
<FONT color="green">12576</FONT>         * @see #TOUCHED_POINT_CLEARED TOUCHED_POINT_CLEARED<a name="line.12576"></a>
<FONT color="green">12577</FONT>         * @see #TOUCHED_POINT_UPDATED TOUCHED_POINT_UPDATED<a name="line.12577"></a>
<FONT color="green">12578</FONT>         * <a name="line.12578"></a>
<FONT color="green">12579</FONT>         */<a name="line.12579"></a>
<FONT color="green">12580</FONT>        public static final TouchedPointUpdateOption TOUCHED_POINT_LOCKED = new TouchedPointUpdateOption();<a name="line.12580"></a>
<FONT color="green">12581</FONT>        /**<a name="line.12581"></a>
<FONT color="green">12582</FONT>         * When this option is passed to the update method, the touched point is<a name="line.12582"></a>
<FONT color="green">12583</FONT>         * updated so that it reflects whatever point is underneath the mouse cursor<a name="line.12583"></a>
<FONT color="green">12584</FONT>         * after the update completes.<a name="line.12584"></a>
<FONT color="green">12585</FONT>         * &lt;p&gt;<a name="line.12585"></a>
<FONT color="green">12586</FONT>         * <a name="line.12586"></a>
<FONT color="green">12587</FONT>         * For example, if the mouse is not hovering over any point before the<a name="line.12587"></a>
<FONT color="green">12588</FONT>         * update, but the update repositions one of the points so that it is now<a name="line.12588"></a>
<FONT color="green">12589</FONT>         * underneath the mouse cursor, the hover feedback for that point will be<a name="line.12589"></a>
<FONT color="green">12590</FONT>         * displayed. Similarly, if the update moves a point away from the mouse<a name="line.12590"></a>
<FONT color="green">12591</FONT>         * cursor, previously displayed hover feedback will be eliminated.<a name="line.12591"></a>
<FONT color="green">12592</FONT>         * &lt;p&gt;<a name="line.12592"></a>
<FONT color="green">12593</FONT>         * <a name="line.12593"></a>
<FONT color="green">12594</FONT>         * @see #update update<a name="line.12594"></a>
<FONT color="green">12595</FONT>         * @see #TOUCHED_POINT_CLEARED TOUCHED_POINT_CLEARED<a name="line.12595"></a>
<FONT color="green">12596</FONT>         * @see #TOUCHED_POINT_LOCKED TOUCHED_POINT_LOCKED<a name="line.12596"></a>
<FONT color="green">12597</FONT>         * <a name="line.12597"></a>
<FONT color="green">12598</FONT>         */<a name="line.12598"></a>
<FONT color="green">12599</FONT>        public static final TouchedPointUpdateOption TOUCHED_POINT_UPDATED = new TouchedPointUpdateOption();<a name="line.12599"></a>
<FONT color="green">12600</FONT>      }<a name="line.12600"></a>
<FONT color="green">12601</FONT>    <a name="line.12601"></a>
<FONT color="green">12602</FONT>      /**<a name="line.12602"></a>
<FONT color="green">12603</FONT>       * The x-axis of a GChart.<a name="line.12603"></a>
<FONT color="green">12604</FONT>       * <a name="line.12604"></a>
<FONT color="green">12605</FONT>       * @see GChart#getXAxis getXAxis<a name="line.12605"></a>
<FONT color="green">12606</FONT>       */<a name="line.12606"></a>
<FONT color="green">12607</FONT>    <a name="line.12607"></a>
<FONT color="green">12608</FONT>      public class XAxis extends Axis {<a name="line.12608"></a>
<FONT color="green">12609</FONT>        XAxis() {<a name="line.12609"></a>
<FONT color="green">12610</FONT>          super();<a name="line.12610"></a>
<FONT color="green">12611</FONT>          isHorizontalAxis = true;<a name="line.12611"></a>
<FONT color="green">12612</FONT>          ticksId = XTICKS_ID;<a name="line.12612"></a>
<FONT color="green">12613</FONT>          gridlinesId = XGRIDLINES_ID;<a name="line.12613"></a>
<FONT color="green">12614</FONT>          axisId = XAXIS_ID;<a name="line.12614"></a>
<FONT color="green">12615</FONT>          axisPosition = -1;<a name="line.12615"></a>
<FONT color="green">12616</FONT>          setTickLocation(DEFAULT_TICK_LOCATION);<a name="line.12616"></a>
<FONT color="green">12617</FONT>          setTickThickness(DEFAULT_TICK_THICKNESS);<a name="line.12617"></a>
<FONT color="green">12618</FONT>          setTickLength(DEFAULT_TICK_LENGTH);<a name="line.12618"></a>
<FONT color="green">12619</FONT>        }<a name="line.12619"></a>
<FONT color="green">12620</FONT>    <a name="line.12620"></a>
<FONT color="green">12621</FONT>        public double clientToModel(int clientCoordinate) {<a name="line.12621"></a>
<FONT color="green">12622</FONT>          int xPixel = Window.getScrollLeft() + clientCoordinate<a name="line.12622"></a>
<FONT color="green">12623</FONT>              - plotPanel.getAbsoluteLeft();<a name="line.12623"></a>
<FONT color="green">12624</FONT>          double result = plotPanel.xChartPixelToX(xPixel);<a name="line.12624"></a>
<FONT color="green">12625</FONT>          return result;<a name="line.12625"></a>
<FONT color="green">12626</FONT>        }<a name="line.12626"></a>
<FONT color="green">12627</FONT>    <a name="line.12627"></a>
<FONT color="green">12628</FONT>        public int getAxisLabelThickness() {<a name="line.12628"></a>
<FONT color="green">12629</FONT>          final int EXTRA_CHARHEIGHT = 2; // 1-char space above &amp; below<a name="line.12629"></a>
<FONT color="green">12630</FONT>          final int DEF_CHARHEIGHT = 1;<a name="line.12630"></a>
<FONT color="green">12631</FONT>          int result = 0;<a name="line.12631"></a>
<FONT color="green">12632</FONT>          if (GChart.NAI != axisLabelThickness)<a name="line.12632"></a>
<FONT color="green">12633</FONT>            result = axisLabelThickness;<a name="line.12633"></a>
<FONT color="green">12634</FONT>          else if (null == getAxisLabel())<a name="line.12634"></a>
<FONT color="green">12635</FONT>            result = 0;<a name="line.12635"></a>
<FONT color="green">12636</FONT>          else if (getAxisLabel() instanceof HasHTML) {<a name="line.12636"></a>
<FONT color="green">12637</FONT>            int charHeight = htmlHeight(((HasHTML) (getAxisLabel()))<a name="line.12637"></a>
<FONT color="green">12638</FONT>                .getHTML());<a name="line.12638"></a>
<FONT color="green">12639</FONT>            result = (int) Math.round((EXTRA_CHARHEIGHT + charHeight)<a name="line.12639"></a>
<FONT color="green">12640</FONT>                * getTickLabelFontSize()<a name="line.12640"></a>
<FONT color="green">12641</FONT>                * TICK_CHARHEIGHT_TO_FONTSIZE_LOWERBOUND);<a name="line.12641"></a>
<FONT color="green">12642</FONT>          } else<a name="line.12642"></a>
<FONT color="green">12643</FONT>            result = (int) Math.round((EXTRA_CHARHEIGHT + DEF_CHARHEIGHT)<a name="line.12643"></a>
<FONT color="green">12644</FONT>                * getTickLabelFontSize()<a name="line.12644"></a>
<FONT color="green">12645</FONT>                * TICK_CHARWIDTH_TO_FONTSIZE_LOWERBOUND);<a name="line.12645"></a>
<FONT color="green">12646</FONT>          return result;<a name="line.12646"></a>
<FONT color="green">12647</FONT>        }<a name="line.12647"></a>
<FONT color="green">12648</FONT>    <a name="line.12648"></a>
<FONT color="green">12649</FONT>        public double getDataMax() {<a name="line.12649"></a>
<FONT color="green">12650</FONT>          double result = -Double.MAX_VALUE;<a name="line.12650"></a>
<FONT color="green">12651</FONT>          int nCurves = getNCurves();<a name="line.12651"></a>
<FONT color="green">12652</FONT>          for (int i = 0; i &lt; nCurves; i++) {<a name="line.12652"></a>
<FONT color="green">12653</FONT>            Curve c = getSystemCurve(i);<a name="line.12653"></a>
<FONT color="green">12654</FONT>            if (!c.isVisible())<a name="line.12654"></a>
<FONT color="green">12655</FONT>              continue;<a name="line.12655"></a>
<FONT color="green">12656</FONT>            int nPoints = c.getNPoints();<a name="line.12656"></a>
<FONT color="green">12657</FONT>            for (int j = 0; j &lt; nPoints; j++) {<a name="line.12657"></a>
<FONT color="green">12658</FONT>              result = maxIgnoreNaNAndMaxValue(result, c.getPoint(j)<a name="line.12658"></a>
<FONT color="green">12659</FONT>                  .getX());<a name="line.12659"></a>
<FONT color="green">12660</FONT>            }<a name="line.12660"></a>
<FONT color="green">12661</FONT>          }<a name="line.12661"></a>
<FONT color="green">12662</FONT>          return result == -Double.MAX_VALUE ? Double.NaN : result;<a name="line.12662"></a>
<FONT color="green">12663</FONT>        }<a name="line.12663"></a>
<FONT color="green">12664</FONT>    <a name="line.12664"></a>
<FONT color="green">12665</FONT>        public double getDataMin() {<a name="line.12665"></a>
<FONT color="green">12666</FONT>          double result = Double.MAX_VALUE;<a name="line.12666"></a>
<FONT color="green">12667</FONT>          int nCurves = getNCurves();<a name="line.12667"></a>
<FONT color="green">12668</FONT>          for (int i = 0; i &lt; nCurves; i++) {<a name="line.12668"></a>
<FONT color="green">12669</FONT>            Curve c = getSystemCurve(i);<a name="line.12669"></a>
<FONT color="green">12670</FONT>            if (!c.isVisible())<a name="line.12670"></a>
<FONT color="green">12671</FONT>              continue;<a name="line.12671"></a>
<FONT color="green">12672</FONT>            int nPoints = c.getNPoints();<a name="line.12672"></a>
<FONT color="green">12673</FONT>            for (int j = 0; j &lt; nPoints; j++) {<a name="line.12673"></a>
<FONT color="green">12674</FONT>              result = minIgnoreNaNAndMaxValue(result, c.getPoint(j)<a name="line.12674"></a>
<FONT color="green">12675</FONT>                  .getX());<a name="line.12675"></a>
<FONT color="green">12676</FONT>            }<a name="line.12676"></a>
<FONT color="green">12677</FONT>          }<a name="line.12677"></a>
<FONT color="green">12678</FONT>          return result == Double.MAX_VALUE ? Double.NaN : result;<a name="line.12678"></a>
<FONT color="green">12679</FONT>        }<a name="line.12679"></a>
<FONT color="green">12680</FONT>    <a name="line.12680"></a>
<FONT color="green">12681</FONT>        public double getMouseCoordinate() {<a name="line.12681"></a>
<FONT color="green">12682</FONT>          double result = plotPanel.xChartPixelToX(plotPanel.getXMouse());<a name="line.12682"></a>
<FONT color="green">12683</FONT>          return result;<a name="line.12683"></a>
<FONT color="green">12684</FONT>        }<a name="line.12684"></a>
<FONT color="green">12685</FONT>    <a name="line.12685"></a>
<FONT color="green">12686</FONT>        @Override<a name="line.12686"></a>
<FONT color="green">12687</FONT>        public int getTickLabelThickness(boolean needsPopulation) {<a name="line.12687"></a>
<FONT color="green">12688</FONT>          int result;<a name="line.12688"></a>
<FONT color="green">12689</FONT>          if (tickLabelThickness != GChart.NAI)<a name="line.12689"></a>
<FONT color="green">12690</FONT>            result = tickLabelThickness;<a name="line.12690"></a>
<FONT color="green">12691</FONT>          else if (getTickCount() == 0)<a name="line.12691"></a>
<FONT color="green">12692</FONT>            result = 0;<a name="line.12692"></a>
<FONT color="green">12693</FONT>          else {<a name="line.12693"></a>
<FONT color="green">12694</FONT>            // XXX: single line labels assumed; these have height<a name="line.12694"></a>
<FONT color="green">12695</FONT>            // almost equal to the fontSize in pixels. Not really<a name="line.12695"></a>
<FONT color="green">12696</FONT>            // right, since multi-line HTML can now be used, but user<a name="line.12696"></a>
<FONT color="green">12697</FONT>            // can explicitly change tick label thickness with<a name="line.12697"></a>
<FONT color="green">12698</FONT>            // multi-line, HTML based, ticks, so OK for now.<a name="line.12698"></a>
<FONT color="green">12699</FONT>            result = (int) Math.round(TICK_CHARHEIGHT_TO_FONTSIZE_LOWERBOUND<a name="line.12699"></a>
<FONT color="green">12700</FONT>                * tickLabelFontSize);<a name="line.12700"></a>
<FONT color="green">12701</FONT>          }<a name="line.12701"></a>
<FONT color="green">12702</FONT>          return result;<a name="line.12702"></a>
<FONT color="green">12703</FONT>        }<a name="line.12703"></a>
<FONT color="green">12704</FONT>    <a name="line.12704"></a>
<FONT color="green">12705</FONT>        public double modelToClient(double modelCoordinate) {<a name="line.12705"></a>
<FONT color="green">12706</FONT>          double xPixel = plotPanel.xToChartPixel(modelCoordinate);<a name="line.12706"></a>
<FONT color="green">12707</FONT>          double result = plotPanel.getAbsoluteLeft()<a name="line.12707"></a>
<FONT color="green">12708</FONT>              - Window.getScrollLeft() + xPixel;<a name="line.12708"></a>
<FONT color="green">12709</FONT>          return result;<a name="line.12709"></a>
<FONT color="green">12710</FONT>        }<a name="line.12710"></a>
<FONT color="green">12711</FONT>    <a name="line.12711"></a>
<FONT color="green">12712</FONT>        public double modelToPixel(double modelCoordinate) {<a name="line.12712"></a>
<FONT color="green">12713</FONT>          double result = plotPanel.xToChartPixel(modelCoordinate);<a name="line.12713"></a>
<FONT color="green">12714</FONT>          return result;<a name="line.12714"></a>
<FONT color="green">12715</FONT>        }<a name="line.12715"></a>
<FONT color="green">12716</FONT>    <a name="line.12716"></a>
<FONT color="green">12717</FONT>        public double modelToPlotAreaPixel(double modelCoordinate) {<a name="line.12717"></a>
<FONT color="green">12718</FONT>          double result = plotPanel.xToPixel(modelCoordinate);<a name="line.12718"></a>
<FONT color="green">12719</FONT>          return result;<a name="line.12719"></a>
<FONT color="green">12720</FONT>        }<a name="line.12720"></a>
<FONT color="green">12721</FONT>    <a name="line.12721"></a>
<FONT color="green">12722</FONT>        public double pixelToModel(int pixelCoordinate) {<a name="line.12722"></a>
<FONT color="green">12723</FONT>          double result = plotPanel.xChartPixelToX(pixelCoordinate);<a name="line.12723"></a>
<FONT color="green">12724</FONT>          return result;<a name="line.12724"></a>
<FONT color="green">12725</FONT>        }<a name="line.12725"></a>
<FONT color="green">12726</FONT>    <a name="line.12726"></a>
<FONT color="green">12727</FONT>        public double plotAreaPixelToModel(int pixelCoordinate) {<a name="line.12727"></a>
<FONT color="green">12728</FONT>          double result = plotPanel.xPixelToX(pixelCoordinate);<a name="line.12728"></a>
<FONT color="green">12729</FONT>          return result;<a name="line.12729"></a>
<FONT color="green">12730</FONT>        }<a name="line.12730"></a>
<FONT color="green">12731</FONT>    <a name="line.12731"></a>
<FONT color="green">12732</FONT>        public void setTickLength(int tickLength) {<a name="line.12732"></a>
<FONT color="green">12733</FONT>          chartDecorationsChanged = true;<a name="line.12733"></a>
<FONT color="green">12734</FONT>          this.tickLength = tickLength;<a name="line.12734"></a>
<FONT color="green">12735</FONT>          getSystemCurve(ticksId).getSymbol()<a name="line.12735"></a>
<FONT color="green">12736</FONT>              .setHeight(getActualTickLength());<a name="line.12736"></a>
<FONT color="green">12737</FONT>        }<a name="line.12737"></a>
<FONT color="green">12738</FONT>    <a name="line.12738"></a>
<FONT color="green">12739</FONT>        public void setTickThickness(int tickThickness) {<a name="line.12739"></a>
<FONT color="green">12740</FONT>          this.tickThickness = tickThickness;<a name="line.12740"></a>
<FONT color="green">12741</FONT>          getSystemCurve(ticksId).getSymbol().setWidth(tickThickness);<a name="line.12741"></a>
<FONT color="green">12742</FONT>        }<a name="line.12742"></a>
<FONT color="green">12743</FONT>    <a name="line.12743"></a>
<FONT color="green">12744</FONT>      } // end of class XAxis<a name="line.12744"></a>
<FONT color="green">12745</FONT>    <a name="line.12745"></a>
<FONT color="green">12746</FONT>      /**<a name="line.12746"></a>
<FONT color="green">12747</FONT>       * The right, or "y2", axis of a GChart.<a name="line.12747"></a>
<FONT color="green">12748</FONT>       * <a name="line.12748"></a>
<FONT color="green">12749</FONT>       * @see GChart#getY2Axis getY2Axis<a name="line.12749"></a>
<FONT color="green">12750</FONT>       */<a name="line.12750"></a>
<FONT color="green">12751</FONT>    <a name="line.12751"></a>
<FONT color="green">12752</FONT>      public class Y2Axis extends Axis {<a name="line.12752"></a>
<FONT color="green">12753</FONT>        Y2Axis() {<a name="line.12753"></a>
<FONT color="green">12754</FONT>          super();<a name="line.12754"></a>
<FONT color="green">12755</FONT>          isHorizontalAxis = false;<a name="line.12755"></a>
<FONT color="green">12756</FONT>          ticksId = Y2TICKS_ID;<a name="line.12756"></a>
<FONT color="green">12757</FONT>          gridlinesId = Y2GRIDLINES_ID;<a name="line.12757"></a>
<FONT color="green">12758</FONT>          axisId = Y2AXIS_ID;<a name="line.12758"></a>
<FONT color="green">12759</FONT>          axisPosition = 1;<a name="line.12759"></a>
<FONT color="green">12760</FONT>          setTickLocation(DEFAULT_TICK_LOCATION);<a name="line.12760"></a>
<FONT color="green">12761</FONT>          setTickThickness(DEFAULT_TICK_THICKNESS);<a name="line.12761"></a>
<FONT color="green">12762</FONT>          setTickLength(DEFAULT_TICK_LENGTH);<a name="line.12762"></a>
<FONT color="green">12763</FONT>        }<a name="line.12763"></a>
<FONT color="green">12764</FONT>    <a name="line.12764"></a>
<FONT color="green">12765</FONT>        public double clientToModel(int clientCoordinate) {<a name="line.12765"></a>
<FONT color="green">12766</FONT>          int yPixel = Window.getScrollTop() + clientCoordinate<a name="line.12766"></a>
<FONT color="green">12767</FONT>              - plotPanel.getAbsoluteTop();<a name="line.12767"></a>
<FONT color="green">12768</FONT>          double result = plotPanel.yChartPixelToY2(yPixel);<a name="line.12768"></a>
<FONT color="green">12769</FONT>          return result;<a name="line.12769"></a>
<FONT color="green">12770</FONT>        }<a name="line.12770"></a>
<FONT color="green">12771</FONT>    <a name="line.12771"></a>
<FONT color="green">12772</FONT>        public double getDataMax() {<a name="line.12772"></a>
<FONT color="green">12773</FONT>          double result = -Double.MAX_VALUE;<a name="line.12773"></a>
<FONT color="green">12774</FONT>          int nCurves = getNCurves();<a name="line.12774"></a>
<FONT color="green">12775</FONT>          for (int i = 0; i &lt; nCurves; i++) {<a name="line.12775"></a>
<FONT color="green">12776</FONT>            Curve c = getSystemCurve(i);<a name="line.12776"></a>
<FONT color="green">12777</FONT>            if (!c.isVisible())<a name="line.12777"></a>
<FONT color="green">12778</FONT>              continue;<a name="line.12778"></a>
<FONT color="green">12779</FONT>            if (c.getYAxis() == Y2_AXIS) {<a name="line.12779"></a>
<FONT color="green">12780</FONT>              int nPoints = c.getNPoints();<a name="line.12780"></a>
<FONT color="green">12781</FONT>              for (int j = 0; j &lt; nPoints; j++) {<a name="line.12781"></a>
<FONT color="green">12782</FONT>                result = maxIgnoreNaNAndMaxValue(result, c.getPoint(j)<a name="line.12782"></a>
<FONT color="green">12783</FONT>                    .getY());<a name="line.12783"></a>
<FONT color="green">12784</FONT>              }<a name="line.12784"></a>
<FONT color="green">12785</FONT>            }<a name="line.12785"></a>
<FONT color="green">12786</FONT>          }<a name="line.12786"></a>
<FONT color="green">12787</FONT>          return result == -Double.MAX_VALUE ? Double.NaN : result;<a name="line.12787"></a>
<FONT color="green">12788</FONT>        }<a name="line.12788"></a>
<FONT color="green">12789</FONT>    <a name="line.12789"></a>
<FONT color="green">12790</FONT>        public double getDataMin() {<a name="line.12790"></a>
<FONT color="green">12791</FONT>          double result = Double.MAX_VALUE;<a name="line.12791"></a>
<FONT color="green">12792</FONT>          int nCurves = getNCurves();<a name="line.12792"></a>
<FONT color="green">12793</FONT>          for (int i = 0; i &lt; nCurves; i++) {<a name="line.12793"></a>
<FONT color="green">12794</FONT>            Curve c = getSystemCurve(i);<a name="line.12794"></a>
<FONT color="green">12795</FONT>            if (!c.isVisible())<a name="line.12795"></a>
<FONT color="green">12796</FONT>              continue;<a name="line.12796"></a>
<FONT color="green">12797</FONT>            if (c.getYAxis() == Y2_AXIS) {<a name="line.12797"></a>
<FONT color="green">12798</FONT>              int nPoints = c.getNPoints();<a name="line.12798"></a>
<FONT color="green">12799</FONT>              for (int j = 0; j &lt; nPoints; j++) {<a name="line.12799"></a>
<FONT color="green">12800</FONT>                result = minIgnoreNaNAndMaxValue(result, c.getPoint(j)<a name="line.12800"></a>
<FONT color="green">12801</FONT>                    .getY());<a name="line.12801"></a>
<FONT color="green">12802</FONT>              }<a name="line.12802"></a>
<FONT color="green">12803</FONT>            }<a name="line.12803"></a>
<FONT color="green">12804</FONT>          }<a name="line.12804"></a>
<FONT color="green">12805</FONT>          return result == Double.MAX_VALUE ? Double.NaN : result;<a name="line.12805"></a>
<FONT color="green">12806</FONT>        }<a name="line.12806"></a>
<FONT color="green">12807</FONT>    <a name="line.12807"></a>
<FONT color="green">12808</FONT>        public double getMouseCoordinate() {<a name="line.12808"></a>
<FONT color="green">12809</FONT>          double result = plotPanel.yChartPixelToY2(plotPanel.getYMouse());<a name="line.12809"></a>
<FONT color="green">12810</FONT>          return result;<a name="line.12810"></a>
<FONT color="green">12811</FONT>        }<a name="line.12811"></a>
<FONT color="green">12812</FONT>    <a name="line.12812"></a>
<FONT color="green">12813</FONT>        public double modelToClient(double modelCoordinate) {<a name="line.12813"></a>
<FONT color="green">12814</FONT>          double yPixel = plotPanel.yToChartPixel(modelCoordinate, true);<a name="line.12814"></a>
<FONT color="green">12815</FONT>          double result = plotPanel.getAbsoluteTop() - Window.getScrollTop()<a name="line.12815"></a>
<FONT color="green">12816</FONT>              + yPixel;<a name="line.12816"></a>
<FONT color="green">12817</FONT>          return result;<a name="line.12817"></a>
<FONT color="green">12818</FONT>        }<a name="line.12818"></a>
<FONT color="green">12819</FONT>    <a name="line.12819"></a>
<FONT color="green">12820</FONT>        public double modelToPixel(double modelCoordinate) {<a name="line.12820"></a>
<FONT color="green">12821</FONT>          double result = plotPanel.yToChartPixel(modelCoordinate, true);<a name="line.12821"></a>
<FONT color="green">12822</FONT>          return result;<a name="line.12822"></a>
<FONT color="green">12823</FONT>        }<a name="line.12823"></a>
<FONT color="green">12824</FONT>    <a name="line.12824"></a>
<FONT color="green">12825</FONT>        public double modelToPlotAreaPixel(double modelCoordinate) {<a name="line.12825"></a>
<FONT color="green">12826</FONT>          double result = plotPanel.yToPixel(modelCoordinate, true);<a name="line.12826"></a>
<FONT color="green">12827</FONT>          return result;<a name="line.12827"></a>
<FONT color="green">12828</FONT>        }<a name="line.12828"></a>
<FONT color="green">12829</FONT>    <a name="line.12829"></a>
<FONT color="green">12830</FONT>        public double pixelToModel(int pixelCoordinate) {<a name="line.12830"></a>
<FONT color="green">12831</FONT>          double result = plotPanel.yChartPixelToY2(pixelCoordinate);<a name="line.12831"></a>
<FONT color="green">12832</FONT>          return result;<a name="line.12832"></a>
<FONT color="green">12833</FONT>        }<a name="line.12833"></a>
<FONT color="green">12834</FONT>    <a name="line.12834"></a>
<FONT color="green">12835</FONT>        public double plotAreaPixelToModel(int pixelCoordinate) {<a name="line.12835"></a>
<FONT color="green">12836</FONT>          double result = plotPanel.yPixelToY2(pixelCoordinate);<a name="line.12836"></a>
<FONT color="green">12837</FONT>          return result;<a name="line.12837"></a>
<FONT color="green">12838</FONT>        }<a name="line.12838"></a>
<FONT color="green">12839</FONT>    <a name="line.12839"></a>
<FONT color="green">12840</FONT>        public void setTickLength(int tickLength) {<a name="line.12840"></a>
<FONT color="green">12841</FONT>          chartDecorationsChanged = true;<a name="line.12841"></a>
<FONT color="green">12842</FONT>          this.tickLength = tickLength;<a name="line.12842"></a>
<FONT color="green">12843</FONT>          getSystemCurve(ticksId).getSymbol().setWidth(getActualTickLength());<a name="line.12843"></a>
<FONT color="green">12844</FONT>        }<a name="line.12844"></a>
<FONT color="green">12845</FONT>    <a name="line.12845"></a>
<FONT color="green">12846</FONT>        public void setTickThickness(int tickThickness) {<a name="line.12846"></a>
<FONT color="green">12847</FONT>          this.tickThickness = tickThickness;<a name="line.12847"></a>
<FONT color="green">12848</FONT>          getSystemCurve(ticksId).getSymbol().setHeight(tickThickness);<a name="line.12848"></a>
<FONT color="green">12849</FONT>        }<a name="line.12849"></a>
<FONT color="green">12850</FONT>    <a name="line.12850"></a>
<FONT color="green">12851</FONT>      } // end of class Y2Axis<a name="line.12851"></a>
<FONT color="green">12852</FONT>    <a name="line.12852"></a>
<FONT color="green">12853</FONT>      /**<a name="line.12853"></a>
<FONT color="green">12854</FONT>       * The left y-axis of a GChart.<a name="line.12854"></a>
<FONT color="green">12855</FONT>       * <a name="line.12855"></a>
<FONT color="green">12856</FONT>       * @see GChart#getYAxis getYAxis<a name="line.12856"></a>
<FONT color="green">12857</FONT>       * <a name="line.12857"></a>
<FONT color="green">12858</FONT>       */<a name="line.12858"></a>
<FONT color="green">12859</FONT>    <a name="line.12859"></a>
<FONT color="green">12860</FONT>      public class YAxis extends Axis {<a name="line.12860"></a>
<FONT color="green">12861</FONT>        YAxis() {<a name="line.12861"></a>
<FONT color="green">12862</FONT>          super();<a name="line.12862"></a>
<FONT color="green">12863</FONT>          isHorizontalAxis = false;<a name="line.12863"></a>
<FONT color="green">12864</FONT>          ticksId = YTICKS_ID;<a name="line.12864"></a>
<FONT color="green">12865</FONT>          gridlinesId = YGRIDLINES_ID;<a name="line.12865"></a>
<FONT color="green">12866</FONT>          axisId = YAXIS_ID;<a name="line.12866"></a>
<FONT color="green">12867</FONT>          axisPosition = -1;<a name="line.12867"></a>
<FONT color="green">12868</FONT>          setTickLocation(DEFAULT_TICK_LOCATION);<a name="line.12868"></a>
<FONT color="green">12869</FONT>          setTickThickness(DEFAULT_TICK_THICKNESS);<a name="line.12869"></a>
<FONT color="green">12870</FONT>          setTickLength(DEFAULT_TICK_LENGTH);<a name="line.12870"></a>
<FONT color="green">12871</FONT>        }<a name="line.12871"></a>
<FONT color="green">12872</FONT>    <a name="line.12872"></a>
<FONT color="green">12873</FONT>        public double clientToModel(int clientCoordinate) {<a name="line.12873"></a>
<FONT color="green">12874</FONT>          int yPixel = Window.getScrollTop() + clientCoordinate<a name="line.12874"></a>
<FONT color="green">12875</FONT>              - plotPanel.getAbsoluteTop();<a name="line.12875"></a>
<FONT color="green">12876</FONT>          double result = plotPanel.yChartPixelToY(yPixel);<a name="line.12876"></a>
<FONT color="green">12877</FONT>          return result;<a name="line.12877"></a>
<FONT color="green">12878</FONT>        }<a name="line.12878"></a>
<FONT color="green">12879</FONT>    <a name="line.12879"></a>
<FONT color="green">12880</FONT>        public double getDataMax() {<a name="line.12880"></a>
<FONT color="green">12881</FONT>          double result = -Double.MAX_VALUE;<a name="line.12881"></a>
<FONT color="green">12882</FONT>          int nCurves = getNCurves();<a name="line.12882"></a>
<FONT color="green">12883</FONT>          for (int i = 0; i &lt; nCurves; i++) {<a name="line.12883"></a>
<FONT color="green">12884</FONT>            Curve c = getSystemCurve(i);<a name="line.12884"></a>
<FONT color="green">12885</FONT>            if (!c.isVisible())<a name="line.12885"></a>
<FONT color="green">12886</FONT>              continue;<a name="line.12886"></a>
<FONT color="green">12887</FONT>            if (c.getYAxis() == Y_AXIS) {<a name="line.12887"></a>
<FONT color="green">12888</FONT>              int nPoints = c.getNPoints();<a name="line.12888"></a>
<FONT color="green">12889</FONT>              for (int j = 0; j &lt; nPoints; j++) {<a name="line.12889"></a>
<FONT color="green">12890</FONT>                result = maxIgnoreNaNAndMaxValue(result, c.getPoint(j)<a name="line.12890"></a>
<FONT color="green">12891</FONT>                    .getY());<a name="line.12891"></a>
<FONT color="green">12892</FONT>              }<a name="line.12892"></a>
<FONT color="green">12893</FONT>            }<a name="line.12893"></a>
<FONT color="green">12894</FONT>          }<a name="line.12894"></a>
<FONT color="green">12895</FONT>          return result == -Double.MAX_VALUE ? Double.NaN : result;<a name="line.12895"></a>
<FONT color="green">12896</FONT>        }<a name="line.12896"></a>
<FONT color="green">12897</FONT>    <a name="line.12897"></a>
<FONT color="green">12898</FONT>        public double getDataMin() {<a name="line.12898"></a>
<FONT color="green">12899</FONT>          double result = Double.MAX_VALUE;<a name="line.12899"></a>
<FONT color="green">12900</FONT>          int nCurves = getNCurves();<a name="line.12900"></a>
<FONT color="green">12901</FONT>          for (int i = 0; i &lt; nCurves; i++) {<a name="line.12901"></a>
<FONT color="green">12902</FONT>            Curve c = getSystemCurve(i);<a name="line.12902"></a>
<FONT color="green">12903</FONT>            if (!c.isVisible())<a name="line.12903"></a>
<FONT color="green">12904</FONT>              continue;<a name="line.12904"></a>
<FONT color="green">12905</FONT>            if (c.getYAxis() == Y_AXIS) {<a name="line.12905"></a>
<FONT color="green">12906</FONT>              int nPoints = c.getNPoints();<a name="line.12906"></a>
<FONT color="green">12907</FONT>              for (int j = 0; j &lt; nPoints; j++) {<a name="line.12907"></a>
<FONT color="green">12908</FONT>                result = minIgnoreNaNAndMaxValue(result, c.getPoint(j)<a name="line.12908"></a>
<FONT color="green">12909</FONT>                    .getY());<a name="line.12909"></a>
<FONT color="green">12910</FONT>              }<a name="line.12910"></a>
<FONT color="green">12911</FONT>            }<a name="line.12911"></a>
<FONT color="green">12912</FONT>          }<a name="line.12912"></a>
<FONT color="green">12913</FONT>          return result == Double.MAX_VALUE ? Double.NaN : result;<a name="line.12913"></a>
<FONT color="green">12914</FONT>        }<a name="line.12914"></a>
<FONT color="green">12915</FONT>    <a name="line.12915"></a>
<FONT color="green">12916</FONT>        public double getMouseCoordinate() {<a name="line.12916"></a>
<FONT color="green">12917</FONT>          double result = plotPanel.yChartPixelToY(plotPanel.getYMouse());<a name="line.12917"></a>
<FONT color="green">12918</FONT>          return result;<a name="line.12918"></a>
<FONT color="green">12919</FONT>        }<a name="line.12919"></a>
<FONT color="green">12920</FONT>    <a name="line.12920"></a>
<FONT color="green">12921</FONT>        public double modelToClient(double modelCoordinate) {<a name="line.12921"></a>
<FONT color="green">12922</FONT>          double yPixel = plotPanel.yToChartPixel(modelCoordinate, false);<a name="line.12922"></a>
<FONT color="green">12923</FONT>          double result = plotPanel.getAbsoluteTop() - Window.getScrollTop()<a name="line.12923"></a>
<FONT color="green">12924</FONT>              + yPixel;<a name="line.12924"></a>
<FONT color="green">12925</FONT>          return result;<a name="line.12925"></a>
<FONT color="green">12926</FONT>        }<a name="line.12926"></a>
<FONT color="green">12927</FONT>    <a name="line.12927"></a>
<FONT color="green">12928</FONT>        public double modelToPixel(double modelCoordinate) {<a name="line.12928"></a>
<FONT color="green">12929</FONT>          double result = plotPanel.yToChartPixel(modelCoordinate, false);<a name="line.12929"></a>
<FONT color="green">12930</FONT>          return result;<a name="line.12930"></a>
<FONT color="green">12931</FONT>        }<a name="line.12931"></a>
<FONT color="green">12932</FONT>    <a name="line.12932"></a>
<FONT color="green">12933</FONT>        public double modelToPlotAreaPixel(double modelCoordinate) {<a name="line.12933"></a>
<FONT color="green">12934</FONT>          double result = plotPanel.yToPixel(modelCoordinate, false);<a name="line.12934"></a>
<FONT color="green">12935</FONT>          return result;<a name="line.12935"></a>
<FONT color="green">12936</FONT>        }<a name="line.12936"></a>
<FONT color="green">12937</FONT>    <a name="line.12937"></a>
<FONT color="green">12938</FONT>        public double pixelToModel(int pixelCoordinate) {<a name="line.12938"></a>
<FONT color="green">12939</FONT>          double result = plotPanel.yChartPixelToY(pixelCoordinate);<a name="line.12939"></a>
<FONT color="green">12940</FONT>          return result;<a name="line.12940"></a>
<FONT color="green">12941</FONT>        }<a name="line.12941"></a>
<FONT color="green">12942</FONT>    <a name="line.12942"></a>
<FONT color="green">12943</FONT>        public double plotAreaPixelToModel(int pixelCoordinate) {<a name="line.12943"></a>
<FONT color="green">12944</FONT>          double result = plotPanel.yPixelToY(pixelCoordinate);<a name="line.12944"></a>
<FONT color="green">12945</FONT>          return result;<a name="line.12945"></a>
<FONT color="green">12946</FONT>        }<a name="line.12946"></a>
<FONT color="green">12947</FONT>    <a name="line.12947"></a>
<FONT color="green">12948</FONT>        public void setTickLength(int tickLength) {<a name="line.12948"></a>
<FONT color="green">12949</FONT>          chartDecorationsChanged = true;<a name="line.12949"></a>
<FONT color="green">12950</FONT>          this.tickLength = tickLength;<a name="line.12950"></a>
<FONT color="green">12951</FONT>          getSystemCurve(ticksId).getSymbol().setWidth(getActualTickLength());<a name="line.12951"></a>
<FONT color="green">12952</FONT>        }<a name="line.12952"></a>
<FONT color="green">12953</FONT>    <a name="line.12953"></a>
<FONT color="green">12954</FONT>        public void setTickThickness(int tickThickness) {<a name="line.12954"></a>
<FONT color="green">12955</FONT>          this.tickThickness = tickThickness;<a name="line.12955"></a>
<FONT color="green">12956</FONT>          getSystemCurve(ticksId).getSymbol().setHeight(tickThickness);<a name="line.12956"></a>
<FONT color="green">12957</FONT>        }<a name="line.12957"></a>
<FONT color="green">12958</FONT>    <a name="line.12958"></a>
<FONT color="green">12959</FONT>      } // end of class YAxis<a name="line.12959"></a>
<FONT color="green">12960</FONT>    <a name="line.12960"></a>
<FONT color="green">12961</FONT>      /*<a name="line.12961"></a>
<FONT color="green">12962</FONT>       * Allows precise alignment of a text label before the exact size of that<a name="line.12962"></a>
<FONT color="green">12963</FONT>       * label is known, by enclosing it within a 1x1 grid. &lt;p&gt;<a name="line.12963"></a>
<FONT color="green">12964</FONT>       * <a name="line.12964"></a>
<FONT color="green">12965</FONT>       * The external grid must be larger than the label or requested grid alignment<a name="line.12965"></a>
<FONT color="green">12966</FONT>       * won't be realized. But larger than required containing grids occlude mouse<a name="line.12966"></a>
<FONT color="green">12967</FONT>       * events from nearby elements. The NonoccludingReusableAlignedLabel<a name="line.12967"></a>
<FONT color="green">12968</FONT>       * subclasses this class to solve this problem.<a name="line.12968"></a>
<FONT color="green">12969</FONT>       */<a name="line.12969"></a>
<FONT color="green">12970</FONT>    <a name="line.12970"></a>
<FONT color="green">12971</FONT>      private static class AlignedLabel extends Grid {<a name="line.12971"></a>
<FONT color="green">12972</FONT>        AlignedLabel() {<a name="line.12972"></a>
<FONT color="green">12973</FONT>          super(1, 1);<a name="line.12973"></a>
<FONT color="green">12974</FONT>          getCellFormatter().setWordWrap(0, 0, false);<a name="line.12974"></a>
<FONT color="green">12975</FONT>          setCellPadding(0);<a name="line.12975"></a>
<FONT color="green">12976</FONT>          setCellSpacing(0);<a name="line.12976"></a>
<FONT color="green">12977</FONT>          setBorderWidth(0);<a name="line.12977"></a>
<FONT color="green">12978</FONT>        }<a name="line.12978"></a>
<FONT color="green">12979</FONT>      }<a name="line.12979"></a>
<FONT color="green">12980</FONT>    <a name="line.12980"></a>
<FONT color="green">12981</FONT>      /*<a name="line.12981"></a>
<FONT color="green">12982</FONT>       * This class' sole purpose is to work around a FF 2 performance limitation:<a name="line.12982"></a>
<FONT color="green">12983</FONT>       * chart update times increase as O(N^2) after the number of direct ancestor<a name="line.12983"></a>
<FONT color="green">12984</FONT>       * child widgets in a single AbsolutePanel exceeds around 500-1000, AND the<a name="line.12984"></a>
<FONT color="green">12985</FONT>       * chart is updated in more than one browser-displayed stage (e.g, via a<a name="line.12985"></a>
<FONT color="green">12986</FONT>       * series of incremental updates that successively add more curve data, for<a name="line.12986"></a>
<FONT color="green">12987</FONT>       * purposes of user feedback). By contrast, IE7 times grow as O(N) even if<a name="line.12987"></a>
<FONT color="green">12988</FONT>       * 3,000 child widgets are added to a previously displayed chart (e.g. by<a name="line.12988"></a>
<FONT color="green">12989</FONT>       * adding a bar curve with 3,000 bars on it).<a name="line.12989"></a>
<FONT color="green">12990</FONT>       * <a name="line.12990"></a>
<FONT color="green">12991</FONT>       * &lt;p&gt;<a name="line.12991"></a>
<FONT color="green">12992</FONT>       * <a name="line.12992"></a>
<FONT color="green">12993</FONT>       * For solid-fill line chart support (LINE SymbolType introduced in 2.2),<a name="line.12993"></a>
<FONT color="green">12994</FONT>       * thousands of widgets are often needed and so these O(N^2) FF 2 times were<a name="line.12994"></a>
<FONT color="green">12995</FONT>       * just too slow.<a name="line.12995"></a>
<FONT color="green">12996</FONT>       * <a name="line.12996"></a>
<FONT color="green">12997</FONT>       * &lt;p&gt;<a name="line.12997"></a>
<FONT color="green">12998</FONT>       * <a name="line.12998"></a>
<FONT color="green">12999</FONT>       * Some kind of fixed hash table inside of FF 2 divs could explain this switch<a name="line.12999"></a>
<FONT color="green">13000</FONT>       * from O(N) to O(N^2) performance. &lt;p&gt;<a name="line.13000"></a>
<FONT color="green">13001</FONT>       * <a name="line.13001"></a>
<FONT color="green">13002</FONT>       * Approach is to split up the large AbsolutePanel into a series of child<a name="line.13002"></a>
<FONT color="green">13003</FONT>       * panels, each of which contains a number of elements within the range where<a name="line.13003"></a>
<FONT color="green">13004</FONT>       * FF 2 updates are O(N). &lt;p&gt;<a name="line.13004"></a>
<FONT color="green">13005</FONT>       * <a name="line.13005"></a>
<FONT color="green">13006</FONT>       * Tried to keep it light-weight so IE7 isn't penalized too much for having to<a name="line.13006"></a>
<FONT color="green">13007</FONT>       * workaround this FF 2 limitation.<a name="line.13007"></a>
<FONT color="green">13008</FONT>       */<a name="line.13008"></a>
<FONT color="green">13009</FONT>    <a name="line.13009"></a>
<FONT color="green">13010</FONT>      static class PartitionedAbsolutePanel extends Composite {<a name="line.13010"></a>
<FONT color="green">13011</FONT>        /*<a name="line.13011"></a>
<FONT color="green">13012</FONT>         * Max number of widgets in each panel; chose a value as large as possible<a name="line.13012"></a>
<FONT color="green">13013</FONT>         * while remaining within the empirically determined FF 2 O(N) range. Here's<a name="line.13013"></a>
<FONT color="green">13014</FONT>         * the data (from a 3,000 element test based on the sin curve of the 2.1<a name="line.13014"></a>
<FONT color="green">13015</FONT>         * live demo called GChartExample15c.java) upon which this choice was based:<a name="line.13015"></a>
<FONT color="green">13016</FONT>         * &lt;p&gt;<a name="line.13016"></a>
<FONT color="green">13017</FONT>         * <a name="line.13017"></a>
<FONT color="green">13018</FONT>         * &lt;pre&gt;<a name="line.13018"></a>
<FONT color="green">13019</FONT>         * <a name="line.13019"></a>
<FONT color="green">13020</FONT>         * Size FF2 IE7<a name="line.13020"></a>
<FONT color="green">13021</FONT>         *     (sec) (sec)<a name="line.13021"></a>
<FONT color="green">13022</FONT>         *  1    ~14 16<a name="line.13022"></a>
<FONT color="green">13023</FONT>         *  2     11 13<a name="line.13023"></a>
<FONT color="green">13024</FONT>         *  32     9 11<a name="line.13024"></a>
<FONT color="green">13025</FONT>         *  64     9 12<a name="line.13025"></a>
<FONT color="green">13026</FONT>         *  128    9 11<a name="line.13026"></a>
<FONT color="green">13027</FONT>         *  256    9 11<a name="line.13027"></a>
<FONT color="green">13028</FONT>         *  512   10 11<a name="line.13028"></a>
<FONT color="green">13029</FONT>         *  1024  15 11<a name="line.13029"></a>
<FONT color="green">13030</FONT>         *  2048  27 11<a name="line.13030"></a>
<FONT color="green">13031</FONT>         *  4096* 61 12<a name="line.13031"></a>
<FONT color="green">13032</FONT>         * <a name="line.13032"></a>
<FONT color="green">13033</FONT>         * &lt;/pre&gt; &lt;p&gt;<a name="line.13033"></a>
<FONT color="green">13034</FONT>         * <a name="line.13034"></a>
<FONT color="green">13035</FONT>         * The two largest sizes are good approximations of FF2 times we got<a name="line.13035"></a>
<FONT color="green">13036</FONT>         * informally before the switch to partitioned AbsolutePanels with charts<a name="line.13036"></a>
<FONT color="green">13037</FONT>         * with the corresponding number of elements (2000 or 3000). The overhead of<a name="line.13037"></a>
<FONT color="green">13038</FONT>         * the partitioning itself is very low, as shown by the modest time increase<a name="line.13038"></a>
<FONT color="green">13039</FONT>         * even when each element is placed into its own sub-panel. Tests with a &lt;<a name="line.13039"></a>
<FONT color="green">13040</FONT>         * 256 element chart suggested at most a couple of ms of time increases due<a name="line.13040"></a>
<FONT color="green">13041</FONT>         * to the introduction of partitioning.<a name="line.13041"></a>
<FONT color="green">13042</FONT>         * <a name="line.13042"></a>
<FONT color="green">13043</FONT>         * &lt;p&gt;<a name="line.13043"></a>
<FONT color="green">13044</FONT>         * <a name="line.13044"></a>
<FONT color="green">13045</FONT>         * I kind of expected to see &gt;61 second times with a sub-panel size of 1,<a name="line.13045"></a>
<FONT color="green">13046</FONT>         * since the parent panel still has &gt;3,000 elements in this case. Whatever<a name="line.13046"></a>
<FONT color="green">13047</FONT>         * the cause of the performance logjam (presumably in the FF2 heap<a name="line.13047"></a>
<FONT color="green">13048</FONT>         * somewhere?) simply the fact that you introduce a parent AbsolutePanel<a name="line.13048"></a>
<FONT color="green">13049</FONT>         * that holds various child AbslolutePanels that hold the actual image<a name="line.13049"></a>
<FONT color="green">13050</FONT>         * widgets appears to work around most of the problem. If such a useless<a name="line.13050"></a>
<FONT color="green">13051</FONT>         * change makes FF2 materially faster, that seems like a performance bug in<a name="line.13051"></a>
<FONT color="green">13052</FONT>         * FF2 to me.&lt;p&gt;<a name="line.13052"></a>
<FONT color="green">13053</FONT>         * <a name="line.13053"></a>
<FONT color="green">13054</FONT>         * The root FF cause is apparently NOT image cache related, though, since<a name="line.13054"></a>
<FONT color="green">13055</FONT>         * turning off the image cache via about:config didn't change times for the<a name="line.13055"></a>
<FONT color="green">13056</FONT>         * last row of the table above.<a name="line.13056"></a>
<FONT color="green">13057</FONT>         */<a name="line.13057"></a>
<FONT color="green">13058</FONT>    <a name="line.13058"></a>
<FONT color="green">13059</FONT>        /*<a name="line.13059"></a>
<FONT color="green">13060</FONT>         * Strange, reorganized DOM layout in GChart v2.5 and now cannot reproduce<a name="line.13060"></a>
<FONT color="green">13061</FONT>         * these results in FF2 (partitioning gave just a modest 1 second boost in a<a name="line.13061"></a>
<FONT color="green">13062</FONT>         * 15 second, 4,000 point test). So, I was about to drop back to a simple<a name="line.13062"></a>
<FONT color="green">13063</FONT>         * AbsolutePanel. BUT, in FF3, now, the 4,000 point test crashes unless I<a name="line.13063"></a>
<FONT color="green">13064</FONT>         * use PartitionedAbsolutePanel! I guess Firefox 3 has problems with divs<a name="line.13064"></a>
<FONT color="green">13065</FONT>         * that have 4,000 elements, or at least 4,000 image elements, on them,<a name="line.13065"></a>
<FONT color="green">13066</FONT>         * which the partioning fixes.<a name="line.13066"></a>
<FONT color="green">13067</FONT>         */<a name="line.13067"></a>
<FONT color="green">13068</FONT>    <a name="line.13068"></a>
<FONT color="green">13069</FONT>        final int WIDGETS_PER_PANEL = 256;<a name="line.13069"></a>
<FONT color="green">13070</FONT>        private AbsolutePanel root = new AbsolutePanel();<a name="line.13070"></a>
<FONT color="green">13071</FONT>        private AbsolutePanel subPanel = null; // "selected" subPanel<a name="line.13071"></a>
<FONT color="green">13072</FONT>        private int iSubPanel = -1; // index of "selected" subPanel<a name="line.13072"></a>
<FONT color="green">13073</FONT>        private int nWidgets = 0; // total # over all subPanels<a name="line.13073"></a>
<FONT color="green">13074</FONT>    <a name="line.13074"></a>
<FONT color="green">13075</FONT>        PartitionedAbsolutePanel() {<a name="line.13075"></a>
<FONT color="green">13076</FONT>          super();<a name="line.13076"></a>
<FONT color="green">13077</FONT>          initWidget(root);<a name="line.13077"></a>
<FONT color="green">13078</FONT>        }<a name="line.13078"></a>
<FONT color="green">13079</FONT>    <a name="line.13079"></a>
<FONT color="green">13080</FONT>        /* resets the partitioned panel to it's initial state */<a name="line.13080"></a>
<FONT color="green">13081</FONT>        public void clear() {<a name="line.13081"></a>
<FONT color="green">13082</FONT>          root.clear();<a name="line.13082"></a>
<FONT color="green">13083</FONT>          subPanel = null;<a name="line.13083"></a>
<FONT color="green">13084</FONT>          iSubPanel = -1;<a name="line.13084"></a>
<FONT color="green">13085</FONT>          nWidgets = 0;<a name="line.13085"></a>
<FONT color="green">13086</FONT>        }<a name="line.13086"></a>
<FONT color="green">13087</FONT>    <a name="line.13087"></a>
<FONT color="green">13088</FONT>        public int getWidgetCount() {<a name="line.13088"></a>
<FONT color="green">13089</FONT>          return nWidgets;<a name="line.13089"></a>
<FONT color="green">13090</FONT>        }<a name="line.13090"></a>
<FONT color="green">13091</FONT>    <a name="line.13091"></a>
<FONT color="green">13092</FONT>        // makes the subpanel containing the widget the selected one.<a name="line.13092"></a>
<FONT color="green">13093</FONT>        private void selectSubPanel(int iWidget) {<a name="line.13093"></a>
<FONT color="green">13094</FONT>          if (iSubPanel != iWidget / WIDGETS_PER_PANEL) {<a name="line.13094"></a>
<FONT color="green">13095</FONT>            iSubPanel = iWidget / WIDGETS_PER_PANEL;<a name="line.13095"></a>
<FONT color="green">13096</FONT>            subPanel = (AbsolutePanel) root.getWidget(iSubPanel);<a name="line.13096"></a>
<FONT color="green">13097</FONT>          }<a name="line.13097"></a>
<FONT color="green">13098</FONT>        }<a name="line.13098"></a>
<FONT color="green">13099</FONT>    <a name="line.13099"></a>
<FONT color="green">13100</FONT>        // adds a widget to end of this partioned absolute panel<a name="line.13100"></a>
<FONT color="green">13101</FONT>        public void add(Widget w) {<a name="line.13101"></a>
<FONT color="green">13102</FONT>          if (nWidgets % WIDGETS_PER_PANEL == 0) {<a name="line.13102"></a>
<FONT color="green">13103</FONT>            // last panel is full, time to add a new one<a name="line.13103"></a>
<FONT color="green">13104</FONT>            subPanel = new AbsolutePanel();<a name="line.13104"></a>
<FONT color="green">13105</FONT>            // Panel sits in upper left corner. Does nothing, can't<a name="line.13105"></a>
<FONT color="green">13106</FONT>            // be seen. It's just a holder for other widgets.<a name="line.13106"></a>
<FONT color="green">13107</FONT>            GChart.setOverflow(subPanel, "visible");<a name="line.13107"></a>
<FONT color="green">13108</FONT>            subPanel.setPixelSize(0, 0);<a name="line.13108"></a>
<FONT color="green">13109</FONT>            root.add(subPanel, 0, 0);<a name="line.13109"></a>
<FONT color="green">13110</FONT>          }<a name="line.13110"></a>
<FONT color="green">13111</FONT>          selectSubPanel(nWidgets);<a name="line.13111"></a>
<FONT color="green">13112</FONT>          subPanel.add(w);<a name="line.13112"></a>
<FONT color="green">13113</FONT>          nWidgets++;<a name="line.13113"></a>
<FONT color="green">13114</FONT>        }<a name="line.13114"></a>
<FONT color="green">13115</FONT>    <a name="line.13115"></a>
<FONT color="green">13116</FONT>        // returns widget at given index<a name="line.13116"></a>
<FONT color="green">13117</FONT>        public Widget getWidget(int iWidget) {<a name="line.13117"></a>
<FONT color="green">13118</FONT>          if (iWidget &lt; 0 || iWidget &gt;= nWidgets)<a name="line.13118"></a>
<FONT color="green">13119</FONT>            throw new IllegalArgumentException("Invalid widget index: "<a name="line.13119"></a>
<FONT color="green">13120</FONT>                + iWidget + ". Valid range is: 0..." + (nWidgets - 1));<a name="line.13120"></a>
<FONT color="green">13121</FONT>    <a name="line.13121"></a>
<FONT color="green">13122</FONT>          selectSubPanel(iWidget);<a name="line.13122"></a>
<FONT color="green">13123</FONT>          Widget result = subPanel.getWidget(iWidget % WIDGETS_PER_PANEL);<a name="line.13123"></a>
<FONT color="green">13124</FONT>          return result;<a name="line.13124"></a>
<FONT color="green">13125</FONT>        }<a name="line.13125"></a>
<FONT color="green">13126</FONT>    <a name="line.13126"></a>
<FONT color="green">13127</FONT>        // Remove very last widget from panel.<a name="line.13127"></a>
<FONT color="green">13128</FONT>        public boolean remove(int iWidget) {<a name="line.13128"></a>
<FONT color="green">13129</FONT>          if (iWidget != nWidgets - 1)<a name="line.13129"></a>
<FONT color="green">13130</FONT>            throw new IllegalArgumentException("iWidgets arg = " + iWidget<a name="line.13130"></a>
<FONT color="green">13131</FONT>                + " nWidgets-1 (" + (nWidgets - 1) + ") is required.");<a name="line.13131"></a>
<FONT color="green">13132</FONT>    <a name="line.13132"></a>
<FONT color="green">13133</FONT>          selectSubPanel(iWidget);<a name="line.13133"></a>
<FONT color="green">13134</FONT>          boolean result = subPanel.remove(iWidget % WIDGETS_PER_PANEL);<a name="line.13134"></a>
<FONT color="green">13135</FONT>          if (iWidget % WIDGETS_PER_PANEL == 0) {<a name="line.13135"></a>
<FONT color="green">13136</FONT>            // if deleted widget is last widget overall, and first on<a name="line.13136"></a>
<FONT color="green">13137</FONT>            // the selected panel, selected panel will now be empty.<a name="line.13137"></a>
<FONT color="green">13138</FONT>            root.remove(subPanel);<a name="line.13138"></a>
<FONT color="green">13139</FONT>            iSubPanel = -1; // next selectSubPanel will reset these<a name="line.13139"></a>
<FONT color="green">13140</FONT>            subPanel = null;<a name="line.13140"></a>
<FONT color="green">13141</FONT>          }<a name="line.13141"></a>
<FONT color="green">13142</FONT>          nWidgets--;<a name="line.13142"></a>
<FONT color="green">13143</FONT>          return result;<a name="line.13143"></a>
<FONT color="green">13144</FONT>        }<a name="line.13144"></a>
<FONT color="green">13145</FONT>    <a name="line.13145"></a>
<FONT color="green">13146</FONT>        // To assure that w is on the selected subPanel, this method<a name="line.13146"></a>
<FONT color="green">13147</FONT>        // must only be passed a widget that is in the currently<a name="line.13147"></a>
<FONT color="green">13148</FONT>        // selected subPanel. This can be assured by passing in a<a name="line.13148"></a>
<FONT color="green">13149</FONT>        // widget that was just added via add(), or just retrieved<a name="line.13149"></a>
<FONT color="green">13150</FONT>        // via getWidget (otherwise, an exception will be thrown).<a name="line.13150"></a>
<FONT color="green">13151</FONT>    <a name="line.13151"></a>
<FONT color="green">13152</FONT>        public void setWidgetPosition(Widget w, int left, int top) {<a name="line.13152"></a>
<FONT color="green">13153</FONT>          subPanel.setWidgetPosition(w, left, top);<a name="line.13153"></a>
<FONT color="green">13154</FONT>        }<a name="line.13154"></a>
<FONT color="green">13155</FONT>    <a name="line.13155"></a>
<FONT color="green">13156</FONT>      } // end of class PartitionedAbsolutePanel<a name="line.13156"></a>
<FONT color="green">13157</FONT>    <a name="line.13157"></a>
<FONT color="green">13158</FONT>      static class Rectangle { // a (pixel graphics coords) rectangle<a name="line.13158"></a>
<FONT color="green">13159</FONT>        double x; // x, y at upper left corner of rectangle<a name="line.13159"></a>
<FONT color="green">13160</FONT>        double y;<a name="line.13160"></a>
<FONT color="green">13161</FONT>        double width; // distance from x to right edge<a name="line.13161"></a>
<FONT color="green">13162</FONT>        double height; // distance from y to bottom edge<a name="line.13162"></a>
<FONT color="green">13163</FONT>      }<a name="line.13163"></a>
<FONT color="green">13164</FONT>    <a name="line.13164"></a>
<FONT color="green">13165</FONT>      /*<a name="line.13165"></a>
<FONT color="green">13166</FONT>       * AbsolutePanel that allows annotations it contains to be easily reused, for<a name="line.13166"></a>
<FONT color="green">13167</FONT>       * increased efficiency.<a name="line.13167"></a>
<FONT color="green">13168</FONT>       */<a name="line.13168"></a>
<FONT color="green">13169</FONT>      class AnnotationRenderingPanel extends PartitionedAbsolutePanel {<a name="line.13169"></a>
<FONT color="green">13170</FONT>        int labelIndex = 0; // to-be-added-next label index<a name="line.13170"></a>
<FONT color="green">13171</FONT>        private int lastVisibleLabel = -1; // just before 1st valid index<a name="line.13171"></a>
<FONT color="green">13172</FONT>    <a name="line.13172"></a>
<FONT color="green">13173</FONT>        /*<a name="line.13173"></a>
<FONT color="green">13174</FONT>         * Returns the inner grid of the first reusuable, non-occluding aligned<a name="line.13174"></a>
<FONT color="green">13175</FONT>         * label in this rendering panel.<a name="line.13175"></a>
<FONT color="green">13176</FONT>         */<a name="line.13176"></a>
<FONT color="green">13177</FONT>        AlignedLabel getFirstInnerAlignedLabel() {<a name="line.13177"></a>
<FONT color="green">13178</FONT>          AlignedLabel result = null;<a name="line.13178"></a>
<FONT color="green">13179</FONT>          if (labelIndex &gt; 0) {<a name="line.13179"></a>
<FONT color="green">13180</FONT>            NonoccludingReusuableAlignedLabel parent = (NonoccludingReusuableAlignedLabel) getWidget(0);<a name="line.13180"></a>
<FONT color="green">13181</FONT>            result = parent.getInnerGrid();<a name="line.13181"></a>
<FONT color="green">13182</FONT>          }<a name="line.13182"></a>
<FONT color="green">13183</FONT>          return result;<a name="line.13183"></a>
<FONT color="green">13184</FONT>        }<a name="line.13184"></a>
<FONT color="green">13185</FONT>    <a name="line.13185"></a>
<FONT color="green">13186</FONT>        /**<a name="line.13186"></a>
<FONT color="green">13187</FONT>         * Provides support for reusing certain property specifications that are<a name="line.13187"></a>
<FONT color="green">13188</FONT>         * likely to be the same, given how aligned labels in a GChart get reused,<a name="line.13188"></a>
<FONT color="green">13189</FONT>         * and given certain assumptions about which properties of the labels are<a name="line.13189"></a>
<FONT color="green">13190</FONT>         * most likely to remain unchanged between updates.<a name="line.13190"></a>
<FONT color="green">13191</FONT>         * &lt;p&gt;<a name="line.13191"></a>
<FONT color="green">13192</FONT>         * <a name="line.13192"></a>
<FONT color="green">13193</FONT>         * Also applies a hidden outter grid technique to allow proper alignment<a name="line.13193"></a>
<FONT color="green">13194</FONT>         * with labels of unknown size without occluding mouse events of nearby<a name="line.13194"></a>
<FONT color="green">13195</FONT>         * elements.<a name="line.13195"></a>
<FONT color="green">13196</FONT>         * &lt;p&gt;<a name="line.13196"></a>
<FONT color="green">13197</FONT>         * <a name="line.13197"></a>
<FONT color="green">13198</FONT>         * Very similar in intent to the ReusableImage, see that class' header<a name="line.13198"></a>
<FONT color="green">13199</FONT>         * comment for more info.<a name="line.13199"></a>
<FONT color="green">13200</FONT>         * <a name="line.13200"></a>
<FONT color="green">13201</FONT>         */<a name="line.13201"></a>
<FONT color="green">13202</FONT>        class NonoccludingReusuableAlignedLabel extends AlignedLabel {<a name="line.13202"></a>
<FONT color="green">13203</FONT>          int fontSize = GChart.NAI;<a name="line.13203"></a>
<FONT color="green">13204</FONT>          String fontFamily = USE_CSS;<a name="line.13204"></a>
<FONT color="green">13205</FONT>          String fontStyle = USE_CSS;<a name="line.13205"></a>
<FONT color="green">13206</FONT>          String fontWeight = USE_CSS;<a name="line.13206"></a>
<FONT color="green">13207</FONT>          String fontColor = USE_CSS;<a name="line.13207"></a>
<FONT color="green">13208</FONT>          HasHorizontalAlignment.HorizontalAlignmentConstant hAlign;<a name="line.13208"></a>
<FONT color="green">13209</FONT>          HasVerticalAlignment.VerticalAlignmentConstant vAlign;<a name="line.13209"></a>
<FONT color="green">13210</FONT>          String labelText = null;<a name="line.13210"></a>
<FONT color="green">13211</FONT>          boolean isHTML = false;<a name="line.13211"></a>
<FONT color="green">13212</FONT>          Widget labelWidget = null;<a name="line.13212"></a>
<FONT color="green">13213</FONT>          final AlignedLabel innerGrid = new AlignedLabel();<a name="line.13213"></a>
<FONT color="green">13214</FONT>    <a name="line.13214"></a>
<FONT color="green">13215</FONT>          AlignedLabel getInnerGrid() {<a name="line.13215"></a>
<FONT color="green">13216</FONT>            return innerGrid;<a name="line.13216"></a>
<FONT color="green">13217</FONT>          }<a name="line.13217"></a>
<FONT color="green">13218</FONT>    <a name="line.13218"></a>
<FONT color="green">13219</FONT>          NonoccludingReusuableAlignedLabel() {<a name="line.13219"></a>
<FONT color="green">13220</FONT>            super();<a name="line.13220"></a>
<FONT color="green">13221</FONT>            setWidget(0, 0, innerGrid);<a name="line.13221"></a>
<FONT color="green">13222</FONT>            /*<a name="line.13222"></a>
<FONT color="green">13223</FONT>             * The basic technique being used in the lines below is illustrated by<a name="line.13223"></a>
<FONT color="green">13224</FONT>             * this excerpt from p 317 of "CSS, The Definitive Guide" by Eric A.<a name="line.13224"></a>
<FONT color="green">13225</FONT>             * Meyer: &lt;p&gt;<a name="line.13225"></a>
<FONT color="green">13226</FONT>             * <a name="line.13226"></a>
<FONT color="green">13227</FONT>             * &lt;pre&gt; p.clear {visibility: hidden;} p.clear em {visibility: visible;}<a name="line.13227"></a>
<FONT color="green">13228</FONT>             * &lt;/pre&gt; &lt;p&gt;<a name="line.13228"></a>
<FONT color="green">13229</FONT>             * <a name="line.13229"></a>
<FONT color="green">13230</FONT>             * In the above example, emphasized (italic) text is positioned exactly<a name="line.13230"></a>
<FONT color="green">13231</FONT>             * as it would have been in the paragraph had the normal text been<a name="line.13231"></a>
<FONT color="green">13232</FONT>             * visible, except that the normal text &lt;i&gt;isn't&lt;/i&gt; visible. And,<a name="line.13232"></a>
<FONT color="green">13233</FONT>             * unlike transparent text, the invisible text also won't capture mouse<a name="line.13233"></a>
<FONT color="green">13234</FONT>             * events (essential for our aligned labels)<a name="line.13234"></a>
<FONT color="green">13235</FONT>             * <a name="line.13235"></a>
<FONT color="green">13236</FONT>             * &lt;p&gt;<a name="line.13236"></a>
<FONT color="green">13237</FONT>             * <a name="line.13237"></a>
<FONT color="green">13238</FONT>             * With GChart's aligned label, we want the outter Grid (HTML table) to<a name="line.13238"></a>
<FONT color="green">13239</FONT>             * be "not there" as far as visibility and mouseovers, but still impact<a name="line.13239"></a>
<FONT color="green">13240</FONT>             * centering and other alignment of the stuff in the visible, inner<a name="line.13240"></a>
<FONT color="green">13241</FONT>             * Grid.<a name="line.13241"></a>
<FONT color="green">13242</FONT>             * <a name="line.13242"></a>
<FONT color="green">13243</FONT>             * &lt;p&gt;<a name="line.13243"></a>
<FONT color="green">13244</FONT>             * <a name="line.13244"></a>
<FONT color="green">13245</FONT>             * Note that we cannot just make the Grid color transparent (tried that<a name="line.13245"></a>
<FONT color="green">13246</FONT>             * first) because in that case the oversized outter Grid required for<a name="line.13246"></a>
<FONT color="green">13247</FONT>             * alignment will still grab the mouseover events inappropriately (wrong<a name="line.13247"></a>
<FONT color="green">13248</FONT>             * hovertext problem).<a name="line.13248"></a>
<FONT color="green">13249</FONT>             * <a name="line.13249"></a>
<FONT color="green">13250</FONT>             * &lt;p&gt;<a name="line.13250"></a>
<FONT color="green">13251</FONT>             * <a name="line.13251"></a>
<FONT color="green">13252</FONT>             * Not certain but, apparently, IE6 requires that, if you want to apply<a name="line.13252"></a>
<FONT color="green">13253</FONT>             * this trick when the outer element is a table you must use another<a name="line.13253"></a>
<FONT color="green">13254</FONT>             * table as the inner element. At least, the div inner element approach<a name="line.13254"></a>
<FONT color="green">13255</FONT>             * I used at first (that basically worked in Firefox), made both parent<a name="line.13255"></a>
<FONT color="green">13256</FONT>             * and child invisible in IE6. &lt;p&gt;<a name="line.13256"></a>
<FONT color="green">13257</FONT>             * <a name="line.13257"></a>
<FONT color="green">13258</FONT>             * In summary:<a name="line.13258"></a>
<FONT color="green">13259</FONT>             * <a name="line.13259"></a>
<FONT color="green">13260</FONT>             * The upside: alignment without inappropriate event occlusion The<a name="line.13260"></a>
<FONT color="green">13261</FONT>             * downside: the extra Grid element saps performance<a name="line.13261"></a>
<FONT color="green">13262</FONT>             */<a name="line.13262"></a>
<FONT color="green">13263</FONT>    <a name="line.13263"></a>
<FONT color="green">13264</FONT>            DOM.setStyleAttribute(getElement(), "visibility", "hidden");<a name="line.13264"></a>
<FONT color="green">13265</FONT>            DOM.setStyleAttribute(innerGrid.getElement(), "visibility",<a name="line.13265"></a>
<FONT color="green">13266</FONT>                "visible");<a name="line.13266"></a>
<FONT color="green">13267</FONT>          }<a name="line.13267"></a>
<FONT color="green">13268</FONT>    <a name="line.13268"></a>
<FONT color="green">13269</FONT>          /*<a name="line.13269"></a>
<FONT color="green">13270</FONT>           * Sets properties only if they have changed; to replace expensive DOM<a name="line.13270"></a>
<FONT color="green">13271</FONT>           * calls with cheap inequality tests.<a name="line.13271"></a>
<FONT color="green">13272</FONT>           * <a name="line.13272"></a>
<FONT color="green">13273</FONT>           * TODO: Investigate moving properties that are guaranteed to be the same<a name="line.13273"></a>
<FONT color="green">13274</FONT>           * across all elements in the image panel (backgroundColor, borderColor,<a name="line.13274"></a>
<FONT color="green">13275</FONT>           * borderWidth, borderStyle, image url, possibly more) into a single style<a name="line.13275"></a>
<FONT color="green">13276</FONT>           * for the image panel as a whole, and just add that styleName to each<a name="line.13276"></a>
<FONT color="green">13277</FONT>           * image, and set the properties once, in the style. If this worked, it<a name="line.13277"></a>
<FONT color="green">13278</FONT>           * would save both time and space (style would be internal and not<a name="line.13278"></a>
<FONT color="green">13279</FONT>           * intended for direct developer access, since in some charts canvas, not<a name="line.13279"></a>
<FONT color="green">13280</FONT>           * styles, would be responsible for these curve properties), and the same<a name="line.13280"></a>
<FONT color="green">13281</FONT>           * approach could be applied to the labelPanel.<a name="line.13281"></a>
<FONT color="green">13282</FONT>           */<a name="line.13282"></a>
<FONT color="green">13283</FONT>    <a name="line.13283"></a>
<FONT color="green">13284</FONT>          void setReusableProperties(int fontSize, String fontFamily,<a name="line.13284"></a>
<FONT color="green">13285</FONT>              String fontStyle, String fontWeight, String fontColor,<a name="line.13285"></a>
<FONT color="green">13286</FONT>              HasHorizontalAlignment.HorizontalAlignmentConstant hAlign,<a name="line.13286"></a>
<FONT color="green">13287</FONT>              HasVerticalAlignment.VerticalAlignmentConstant vAlign,<a name="line.13287"></a>
<FONT color="green">13288</FONT>              String labelText, boolean isHTML, Widget labelWidget) {<a name="line.13288"></a>
<FONT color="green">13289</FONT>    <a name="line.13289"></a>
<FONT color="green">13290</FONT>            if (this.fontSize != fontSize) {<a name="line.13290"></a>
<FONT color="green">13291</FONT>              DOM.setIntStyleAttribute(innerGrid.getCellFormatter()<a name="line.13291"></a>
<FONT color="green">13292</FONT>                  .getElement(0, 0), "fontSize", fontSize);<a name="line.13292"></a>
<FONT color="green">13293</FONT>              this.fontSize = fontSize;<a name="line.13293"></a>
<FONT color="green">13294</FONT>            }<a name="line.13294"></a>
<FONT color="green">13295</FONT>            if (this.fontFamily != fontFamily) {<a name="line.13295"></a>
<FONT color="green">13296</FONT>              DOM.setStyleAttribute(innerGrid.getCellFormatter()<a name="line.13296"></a>
<FONT color="green">13297</FONT>                  .getElement(0, 0), "fontFamily", fontFamily);<a name="line.13297"></a>
<FONT color="green">13298</FONT>              this.fontFamily = fontFamily;<a name="line.13298"></a>
<FONT color="green">13299</FONT>            }<a name="line.13299"></a>
<FONT color="green">13300</FONT>            if (this.fontStyle != fontStyle) {<a name="line.13300"></a>
<FONT color="green">13301</FONT>              DOM.setStyleAttribute(innerGrid.getCellFormatter()<a name="line.13301"></a>
<FONT color="green">13302</FONT>                  .getElement(0, 0), "fontStyle", fontStyle);<a name="line.13302"></a>
<FONT color="green">13303</FONT>              this.fontStyle = fontStyle;<a name="line.13303"></a>
<FONT color="green">13304</FONT>            }<a name="line.13304"></a>
<FONT color="green">13305</FONT>            if (this.fontWeight != fontWeight) {<a name="line.13305"></a>
<FONT color="green">13306</FONT>              DOM.setStyleAttribute(innerGrid.getCellFormatter()<a name="line.13306"></a>
<FONT color="green">13307</FONT>                  .getElement(0, 0), "fontWeight", fontWeight);<a name="line.13307"></a>
<FONT color="green">13308</FONT>              this.fontWeight = fontWeight;<a name="line.13308"></a>
<FONT color="green">13309</FONT>            }<a name="line.13309"></a>
<FONT color="green">13310</FONT>            if (this.fontColor != fontColor) {<a name="line.13310"></a>
<FONT color="green">13311</FONT>              DOM.setStyleAttribute(innerGrid.getCellFormatter()<a name="line.13311"></a>
<FONT color="green">13312</FONT>                  .getElement(0, 0), "color", fontColor);<a name="line.13312"></a>
<FONT color="green">13313</FONT>              this.fontColor = fontColor;<a name="line.13313"></a>
<FONT color="green">13314</FONT>            }<a name="line.13314"></a>
<FONT color="green">13315</FONT>            if (this.hAlign != hAlign) {<a name="line.13315"></a>
<FONT color="green">13316</FONT>              getCellFormatter().setHorizontalAlignment(0, 0, hAlign);<a name="line.13316"></a>
<FONT color="green">13317</FONT>              // without this, only IE6-quirks doesn't quite align right:<a name="line.13317"></a>
<FONT color="green">13318</FONT>              innerGrid.getCellFormatter().setHorizontalAlignment(0, 0,<a name="line.13318"></a>
<FONT color="green">13319</FONT>                  hAlign);<a name="line.13319"></a>
<FONT color="green">13320</FONT>              this.hAlign = hAlign;<a name="line.13320"></a>
<FONT color="green">13321</FONT>            }<a name="line.13321"></a>
<FONT color="green">13322</FONT>            if (this.vAlign != vAlign) {<a name="line.13322"></a>
<FONT color="green">13323</FONT>              getCellFormatter().setVerticalAlignment(0, 0, vAlign);<a name="line.13323"></a>
<FONT color="green">13324</FONT>              // without this, only IE6-quirks doesn't quite align right:<a name="line.13324"></a>
<FONT color="green">13325</FONT>              innerGrid.getCellFormatter().setVerticalAlignment(0, 0,<a name="line.13325"></a>
<FONT color="green">13326</FONT>                  vAlign);<a name="line.13326"></a>
<FONT color="green">13327</FONT>              this.vAlign = vAlign;<a name="line.13327"></a>
<FONT color="green">13328</FONT>            }<a name="line.13328"></a>
<FONT color="green">13329</FONT>    <a name="line.13329"></a>
<FONT color="green">13330</FONT>            if (null != labelWidget) {<a name="line.13330"></a>
<FONT color="green">13331</FONT>              if (this.labelWidget != labelWidget) {<a name="line.13331"></a>
<FONT color="green">13332</FONT>                innerGrid.setWidget(0, 0, labelWidget);<a name="line.13332"></a>
<FONT color="green">13333</FONT>                this.labelWidget = labelWidget;<a name="line.13333"></a>
<FONT color="green">13334</FONT>                this.labelText = null;<a name="line.13334"></a>
<FONT color="green">13335</FONT>              }<a name="line.13335"></a>
<FONT color="green">13336</FONT>            } else if (this.labelText != labelText || this.isHTML != isHTML) {<a name="line.13336"></a>
<FONT color="green">13337</FONT>              if (null == labelText || "" == labelText)<a name="line.13337"></a>
<FONT color="green">13338</FONT>                innerGrid.setText(0, 0, "");<a name="line.13338"></a>
<FONT color="green">13339</FONT>              else if (!isHTML) {<a name="line.13339"></a>
<FONT color="green">13340</FONT>                innerGrid.setText(0, 0, labelText);<a name="line.13340"></a>
<FONT color="green">13341</FONT>              } else {<a name="line.13341"></a>
<FONT color="green">13342</FONT>                innerGrid.setHTML(0, 0, labelText);<a name="line.13342"></a>
<FONT color="green">13343</FONT>              }<a name="line.13343"></a>
<FONT color="green">13344</FONT>              this.isHTML = isHTML;<a name="line.13344"></a>
<FONT color="green">13345</FONT>              this.labelText = labelText;<a name="line.13345"></a>
<FONT color="green">13346</FONT>              this.labelWidget = null;<a name="line.13346"></a>
<FONT color="green">13347</FONT>            }<a name="line.13347"></a>
<FONT color="green">13348</FONT>          }<a name="line.13348"></a>
<FONT color="green">13349</FONT>        } // end of class NonoccludingReusuableAlignedLabel<a name="line.13349"></a>
<FONT color="green">13350</FONT>    <a name="line.13350"></a>
<FONT color="green">13351</FONT>        AnnotationRenderingPanel() {<a name="line.13351"></a>
<FONT color="green">13352</FONT>          super();<a name="line.13352"></a>
<FONT color="green">13353</FONT>          /*<a name="line.13353"></a>
<FONT color="green">13354</FONT>           * Because of event-occlusion that can occur on all browsers but IE,<a name="line.13354"></a>
<FONT color="green">13355</FONT>           * annotation panels MUST by 0-sized/overflow:visible otherwise they will<a name="line.13355"></a>
<FONT color="green">13356</FONT>           * short-circuit event processing needed for widget annotations added by<a name="line.13356"></a>
<FONT color="green">13357</FONT>           * developer. Graphics rendering panels don't have this constraint and<a name="line.13357"></a>
<FONT color="green">13358</FONT>           * thus can be clipped to the plot area.<a name="line.13358"></a>
<FONT color="green">13359</FONT>           */<a name="line.13359"></a>
<FONT color="green">13360</FONT>          GChart.setOverflow(this, "visible");<a name="line.13360"></a>
<FONT color="green">13361</FONT>          this.setPixelSize(0, 0);<a name="line.13361"></a>
<FONT color="green">13362</FONT>        }<a name="line.13362"></a>
<FONT color="green">13363</FONT>    <a name="line.13363"></a>
<FONT color="green">13364</FONT>        void setLabelPosition(NonoccludingReusuableAlignedLabel lbl, int x,<a name="line.13364"></a>
<FONT color="green">13365</FONT>            int y) {<a name="line.13365"></a>
<FONT color="green">13366</FONT>          // workaround problem with special meaning of (-1,-1) to<a name="line.13366"></a>
<FONT color="green">13367</FONT>          // setWidgetPosition (makes position off by one pixel).<a name="line.13367"></a>
<FONT color="green">13368</FONT>          if (x == -1 &amp;&amp; y == -1)<a name="line.13368"></a>
<FONT color="green">13369</FONT>            x = 0;<a name="line.13369"></a>
<FONT color="green">13370</FONT>          setWidgetPosition(lbl, x, y);<a name="line.13370"></a>
<FONT color="green">13371</FONT>        }<a name="line.13371"></a>
<FONT color="green">13372</FONT>    <a name="line.13372"></a>
<FONT color="green">13373</FONT>        void beginRendering() {<a name="line.13373"></a>
<FONT color="green">13374</FONT>          labelIndex = 0;<a name="line.13374"></a>
<FONT color="green">13375</FONT>        }<a name="line.13375"></a>
<FONT color="green">13376</FONT>    <a name="line.13376"></a>
<FONT color="green">13377</FONT>        void endRendering() {<a name="line.13377"></a>
<FONT color="green">13378</FONT>          // hide or remove labels no longer being used<a name="line.13378"></a>
<FONT color="green">13379</FONT>          for (int iLabel = optimizeForMemory ? (getWidgetCount() - 1)<a name="line.13379"></a>
<FONT color="green">13380</FONT>              : lastVisibleLabel; iLabel &gt;= labelIndex; iLabel--) {<a name="line.13380"></a>
<FONT color="green">13381</FONT>            Widget w = getWidget(iLabel);<a name="line.13381"></a>
<FONT color="green">13382</FONT>            if (optimizeForMemory)<a name="line.13382"></a>
<FONT color="green">13383</FONT>              remove(iLabel);<a name="line.13383"></a>
<FONT color="green">13384</FONT>            else<a name="line.13384"></a>
<FONT color="green">13385</FONT>              w.setVisible(false);<a name="line.13385"></a>
<FONT color="green">13386</FONT>          }<a name="line.13386"></a>
<FONT color="green">13387</FONT>          lastVisibleLabel = labelIndex - 1;<a name="line.13387"></a>
<FONT color="green">13388</FONT>        }<a name="line.13388"></a>
<FONT color="green">13389</FONT>    <a name="line.13389"></a>
<FONT color="green">13390</FONT>        /*<a name="line.13390"></a>
<FONT color="green">13391</FONT>         * Creates (or reveals), and configures, an aligned label. Works very<a name="line.13391"></a>
<FONT color="green">13392</FONT>         * similarly to addOrRevealImage.<a name="line.13392"></a>
<FONT color="green">13393</FONT>         */<a name="line.13393"></a>
<FONT color="green">13394</FONT>        NonoccludingReusuableAlignedLabel getNextOrNewAlignedLabel(<a name="line.13394"></a>
<FONT color="green">13395</FONT>            int fontSize, String fontFamily, String fontStyle,<a name="line.13395"></a>
<FONT color="green">13396</FONT>            String fontWeight, String fontColor,<a name="line.13396"></a>
<FONT color="green">13397</FONT>            HasHorizontalAlignment.HorizontalAlignmentConstant hAlign,<a name="line.13397"></a>
<FONT color="green">13398</FONT>            HasVerticalAlignment.VerticalAlignmentConstant vAlign,<a name="line.13398"></a>
<FONT color="green">13399</FONT>            String labelText, boolean isHTML, Widget labelWidget) {<a name="line.13399"></a>
<FONT color="green">13400</FONT>          NonoccludingReusuableAlignedLabel result;<a name="line.13400"></a>
<FONT color="green">13401</FONT>          if (labelIndex &lt; getWidgetCount()) {<a name="line.13401"></a>
<FONT color="green">13402</FONT>            result = (NonoccludingReusuableAlignedLabel) getWidget(labelIndex);<a name="line.13402"></a>
<FONT color="green">13403</FONT>            if (null != result.labelWidget<a name="line.13403"></a>
<FONT color="green">13404</FONT>                &amp;&amp; labelWidget == result.labelWidget) {<a name="line.13404"></a>
<FONT color="green">13405</FONT>              /*<a name="line.13405"></a>
<FONT color="green">13406</FONT>               * DOM element actually stored in the label's Grid-cell, and what the<a name="line.13406"></a>
<FONT color="green">13407</FONT>               * label "thinks" is stored there, could be inconsistent if, for<a name="line.13407"></a>
<FONT color="green">13408</FONT>               * example, the same label widget reference was used to define two<a name="line.13408"></a>
<FONT color="green">13409</FONT>               * different points' annotations. In that case, we need to clear the<a name="line.13409"></a>
<FONT color="green">13410</FONT>               * widget reference that the label stores thus making it consistent<a name="line.13410"></a>
<FONT color="green">13411</FONT>               * with what is really in the DOM. &lt;p&gt;<a name="line.13411"></a>
<FONT color="green">13412</FONT>               * <a name="line.13412"></a>
<FONT color="green">13413</FONT>               * This code was added to fix the bug reproduced by TestGChart53.java.<a name="line.13413"></a>
<FONT color="green">13414</FONT>               * See that test for more info.<a name="line.13414"></a>
<FONT color="green">13415</FONT>               */<a name="line.13415"></a>
<FONT color="green">13416</FONT>              Element e = labelWidget.getElement();<a name="line.13416"></a>
<FONT color="green">13417</FONT>              if (null == e<a name="line.13417"></a>
<FONT color="green">13418</FONT>                  || (e.getParentElement() != result.innerGrid<a name="line.13418"></a>
<FONT color="green">13419</FONT>                  .getCellFormatter().getElement(0, 0)))<a name="line.13419"></a>
<FONT color="green">13420</FONT>                // the widget' DOM parent isn't label's grid-cell (it<a name="line.13420"></a>
<FONT color="green">13421</FONT>                // was moved)<a name="line.13421"></a>
<FONT color="green">13422</FONT>                result.labelWidget = null;<a name="line.13422"></a>
<FONT color="green">13423</FONT>            }<a name="line.13423"></a>
<FONT color="green">13424</FONT>    <a name="line.13424"></a>
<FONT color="green">13425</FONT>            if (labelIndex &gt; lastVisibleLabel)<a name="line.13425"></a>
<FONT color="green">13426</FONT>              result.setVisible(true);<a name="line.13426"></a>
<FONT color="green">13427</FONT>          } else {<a name="line.13427"></a>
<FONT color="green">13428</FONT>            result = new NonoccludingReusuableAlignedLabel();<a name="line.13428"></a>
<FONT color="green">13429</FONT>            add(result);<a name="line.13429"></a>
<FONT color="green">13430</FONT>          }<a name="line.13430"></a>
<FONT color="green">13431</FONT>          result.setReusableProperties(fontSize, fontFamily, fontStyle,<a name="line.13431"></a>
<FONT color="green">13432</FONT>              fontWeight, fontColor, hAlign, vAlign, labelText, isHTML,<a name="line.13432"></a>
<FONT color="green">13433</FONT>              labelWidget);<a name="line.13433"></a>
<FONT color="green">13434</FONT>    <a name="line.13434"></a>
<FONT color="green">13435</FONT>          if (lastVisibleLabel &lt; labelIndex)<a name="line.13435"></a>
<FONT color="green">13436</FONT>            lastVisibleLabel = labelIndex;<a name="line.13436"></a>
<FONT color="green">13437</FONT>          labelIndex++;<a name="line.13437"></a>
<FONT color="green">13438</FONT>          return result;<a name="line.13438"></a>
<FONT color="green">13439</FONT>        }<a name="line.13439"></a>
<FONT color="green">13440</FONT>    <a name="line.13440"></a>
<FONT color="green">13441</FONT>        protected void renderAnnotation(Annotation annotation,<a name="line.13441"></a>
<FONT color="green">13442</FONT>            AnnotationLocation loc, double xCenter, double yCenter,<a name="line.13442"></a>
<FONT color="green">13443</FONT>            double symWidth, double symHeight, Symbol symbol) {<a name="line.13443"></a>
<FONT color="green">13444</FONT>    <a name="line.13444"></a>
<FONT color="green">13445</FONT>          int widthUpperBound = annotation.getWidthUpperBound();<a name="line.13445"></a>
<FONT color="green">13446</FONT>          int upLeftX = loc.getUpperLeftX(xCenter, widthUpperBound, Math<a name="line.13446"></a>
<FONT color="green">13447</FONT>              .abs(symWidth));<a name="line.13447"></a>
<FONT color="green">13448</FONT>          int heightUpperBound = annotation.getHeightUpperBound();<a name="line.13448"></a>
<FONT color="green">13449</FONT>          int upLeftY = loc.getUpperLeftY(yCenter, heightUpperBound, Math<a name="line.13449"></a>
<FONT color="green">13450</FONT>              .abs(symHeight));<a name="line.13450"></a>
<FONT color="green">13451</FONT>    <a name="line.13451"></a>
<FONT color="green">13452</FONT>          NonoccludingReusuableAlignedLabel alignedLabel = getNextOrNewAlignedLabel(<a name="line.13452"></a>
<FONT color="green">13453</FONT>              annotation.getFontSize(), <a name="line.13453"></a>
<FONT color="green">13454</FONT>              annotation.getFontFamilyExpanded(getFontFamily()),<a name="line.13454"></a>
<FONT color="green">13455</FONT>              annotation.getFontStyle(), annotation.getFontWeight(),<a name="line.13455"></a>
<FONT color="green">13456</FONT>              annotation.getFontColor(), loc.getHorizontalAlignment(),<a name="line.13456"></a>
<FONT color="green">13457</FONT>              loc.getVerticalAlignment(), annotation.getText(),<a name="line.13457"></a>
<FONT color="green">13458</FONT>              annotation.isHTML(), annotation.getWidget());<a name="line.13458"></a>
<FONT color="green">13459</FONT>          // If positioning by top or left edges, explicit sizing isn't<a name="line.13459"></a>
<FONT color="green">13460</FONT>          // needed (makes the bounding box tighter, which, for reasons<a name="line.13460"></a>
<FONT color="green">13461</FONT>          // unknown, makes rendering around 10% faster on some browsers and<a name="line.13461"></a>
<FONT color="green">13462</FONT>          // usage scenarios).<a name="line.13462"></a>
<FONT color="green">13463</FONT>          if (loc.getHorizontalAlignment() != HasHorizontalAlignment.ALIGN_LEFT)<a name="line.13463"></a>
<FONT color="green">13464</FONT>            alignedLabel.setWidth(widthUpperBound + "px");<a name="line.13464"></a>
<FONT color="green">13465</FONT>          else<a name="line.13465"></a>
<FONT color="green">13466</FONT>            alignedLabel.setWidth("");<a name="line.13466"></a>
<FONT color="green">13467</FONT>    <a name="line.13467"></a>
<FONT color="green">13468</FONT>          if (loc.getVerticalAlignment() != HasVerticalAlignment.ALIGN_TOP)<a name="line.13468"></a>
<FONT color="green">13469</FONT>            alignedLabel.setHeight(heightUpperBound + "px");<a name="line.13469"></a>
<FONT color="green">13470</FONT>          else<a name="line.13470"></a>
<FONT color="green">13471</FONT>            alignedLabel.setHeight("");<a name="line.13471"></a>
<FONT color="green">13472</FONT>    <a name="line.13472"></a>
<FONT color="green">13473</FONT>          setLabelPosition(alignedLabel, upLeftX, upLeftY);<a name="line.13473"></a>
<FONT color="green">13474</FONT>        }<a name="line.13474"></a>
<FONT color="green">13475</FONT>    <a name="line.13475"></a>
<FONT color="green">13476</FONT>      } // end of class AnnotationRenderingPanel<a name="line.13476"></a>
<FONT color="green">13477</FONT>    <a name="line.13477"></a>
<FONT color="green">13478</FONT>      /*<a name="line.13478"></a>
<FONT color="green">13479</FONT>       * A rendering panel contains subpanels for Image-element based graphics<a name="line.13479"></a>
<FONT color="green">13480</FONT>       * rendering, canvas-based graphics rendering, and Grid-based compass-aligned<a name="line.13480"></a>
<FONT color="green">13481</FONT>       * label rendering. &lt;p&gt;<a name="line.13481"></a>
<FONT color="green">13482</FONT>       * <a name="line.13482"></a>
<FONT color="green">13483</FONT>       * Each rendering panel is joined-at-the-hip with, and provides the<a name="line.13483"></a>
<FONT color="green">13484</FONT>       * in-the-browser-realization of, a single corresponding GChart curve. The one<a name="line.13484"></a>
<FONT color="green">13485</FONT>       * exception to this rule are the system curves used internally for rendering<a name="line.13485"></a>
<FONT color="green">13486</FONT>       * chart decorations, which, for reasons of efficiency, all share the same<a name="line.13486"></a>
<FONT color="green">13487</FONT>       * rendering panel. &lt;p&gt;<a name="line.13487"></a>
<FONT color="green">13488</FONT>       * <a name="line.13488"></a>
<FONT color="green">13489</FONT>       * Rather than clearing the widgets contained in the rendering panel and<a name="line.13489"></a>
<FONT color="green">13490</FONT>       * recreating and adding them back as needed (which is expensive) the<a name="line.13490"></a>
<FONT color="green">13491</FONT>       * rendering panel can make widgets it employs for these purposes invisible<a name="line.13491"></a>
<FONT color="green">13492</FONT>       * when not in use and visible again when they are needed (which is usually at<a name="line.13492"></a>
<FONT color="green">13493</FONT>       * least twice as fast). &lt;p&gt;<a name="line.13493"></a>
<FONT color="green">13494</FONT>       * <a name="line.13494"></a>
<FONT color="green">13495</FONT>       * &lt;p&gt; In principle, this is less memory efficient, but in practice, due to<a name="line.13495"></a>
<FONT color="green">13496</FONT>       * the fact that there is less likelyhood of fragmentation with reuse than<a name="line.13496"></a>
<FONT color="green">13497</FONT>       * with relying of the garbage collector, it could even be more memory<a name="line.13497"></a>
<FONT color="green">13498</FONT>       * efficient.<a name="line.13498"></a>
<FONT color="green">13499</FONT>       * <a name="line.13499"></a>
<FONT color="green">13500</FONT>       * &lt;p&gt;<a name="line.13500"></a>
<FONT color="green">13501</FONT>       * <a name="line.13501"></a>
<FONT color="green">13502</FONT>       * When a canvas factory is specified by the developer, the panel will include<a name="line.13502"></a>
<FONT color="green">13503</FONT>       * a single canvas widget, where most of the graphical elements associated<a name="line.13503"></a>
<FONT color="green">13504</FONT>       * with the curve that uses this rendering panel will be drawn. GChart's<a name="line.13504"></a>
<FONT color="green">13505</FONT>       * canvas support is not yet up to the task of rendering everything--it<a name="line.13505"></a>
<FONT color="green">13506</FONT>       * renders only those aspects of the chart where canvas rendering provides the<a name="line.13506"></a>
<FONT color="green">13507</FONT>       * biggest quality/speed advantages. So, even if a canvas factory has been<a name="line.13507"></a>
<FONT color="green">13508</FONT>       * provided, many aspects of a curve (e.g. the rectangles in bar charts) will<a name="line.13508"></a>
<FONT color="green">13509</FONT>       * still be rendered with Image elements.<a name="line.13509"></a>
<FONT color="green">13510</FONT>       */<a name="line.13510"></a>
<FONT color="green">13511</FONT>      class GraphicsRenderingPanel extends AbsolutePanel {<a name="line.13511"></a>
<FONT color="green">13512</FONT>        private GChartCanvasLite canvas = null;<a name="line.13512"></a>
<FONT color="green">13513</FONT>        int x0 = 0; // origin, in pixel coords, of upper left..<a name="line.13513"></a>
<FONT color="green">13514</FONT>        int y0 = 0; // corner of rendering canvas widget<a name="line.13514"></a>
<FONT color="green">13515</FONT>        int canvasWidth = 0; // width of last used rendering canvas<a name="line.13515"></a>
<FONT color="green">13516</FONT>        int canvasHeight = 0; // height of last used rendering canvas<a name="line.13516"></a>
<FONT color="green">13517</FONT>        private AbsolutePanel canvasPanel = new AbsolutePanel();<a name="line.13517"></a>
<FONT color="green">13518</FONT>        private PartitionedAbsolutePanel imagePanel = new PartitionedAbsolutePanel();<a name="line.13518"></a>
<FONT color="green">13519</FONT>        int imageIndex = 0;<a name="line.13519"></a>
<FONT color="green">13520</FONT>        // helps minimize calls to setVisible (which can be expensive)<a name="line.13520"></a>
<FONT color="green">13521</FONT>        private int lastVisibleImage = -1;<a name="line.13521"></a>
<FONT color="green">13522</FONT>    <a name="line.13522"></a>
<FONT color="green">13523</FONT>        void setRenderingPosition(int xShift, int yShift) {<a name="line.13523"></a>
<FONT color="green">13524</FONT>          setWidgetPosition(canvasPanel, xShift, -yShift);<a name="line.13524"></a>
<FONT color="green">13525</FONT>          setWidgetPosition(imagePanel, xShift, -yShift);<a name="line.13525"></a>
<FONT color="green">13526</FONT>        }<a name="line.13526"></a>
<FONT color="green">13527</FONT>    <a name="line.13527"></a>
<FONT color="green">13528</FONT>        // Add a canvas, if needed<a name="line.13528"></a>
<FONT color="green">13529</FONT>        void maybeAddCanvas() {<a name="line.13529"></a>
<FONT color="green">13530</FONT>          if (null != canvasFactory &amp;&amp; null == canvas) {<a name="line.13530"></a>
<FONT color="green">13531</FONT>            canvas = canvasFactory.create();<a name="line.13531"></a>
<FONT color="green">13532</FONT>            if (null != canvas) {<a name="line.13532"></a>
<FONT color="green">13533</FONT>              if (canvas instanceof Widget) {<a name="line.13533"></a>
<FONT color="green">13534</FONT>                /*<a name="line.13534"></a>
<FONT color="green">13535</FONT>                 * The next line is only needed for IE; it is needed to work-around<a name="line.13535"></a>
<FONT color="green">13536</FONT>                 * a GWTCanvas bug that improperly shifts the x-placement of<a name="line.13536"></a>
<FONT color="green">13537</FONT>                 * rendered graphics when a GChart is placed into a non-left-aligned<a name="line.13537"></a>
<FONT color="green">13538</FONT>                 * Grid cell (GChart uses Grid Widgets to implement its annotations<a name="line.13538"></a>
<FONT color="green">13539</FONT>                 * feature, so a GChart placed as an annotation on another GChart,<a name="line.13539"></a>
<FONT color="green">13540</FONT>                 * as would occur with an inset or popup chart, will end up within<a name="line.13540"></a>
<FONT color="green">13541</FONT>                 * an aligned Grid). &lt;p&gt;<a name="line.13541"></a>
<FONT color="green">13542</FONT>                 * <a name="line.13542"></a>
<FONT color="green">13543</FONT>                 * See also TestGChart46.java, which reproduces the GWTCanvas bug.<a name="line.13543"></a>
<FONT color="green">13544</FONT>                 */<a name="line.13544"></a>
<FONT color="green">13545</FONT>                DOM.setElementAttribute(((Widget) canvas).getElement(),<a name="line.13545"></a>
<FONT color="green">13546</FONT>                    "align", "left");<a name="line.13546"></a>
<FONT color="green">13547</FONT>                canvasPanel.add((Widget) canvas, 0, 0);<a name="line.13547"></a>
<FONT color="green">13548</FONT>              } else<a name="line.13548"></a>
<FONT color="green">13549</FONT>                throw new IllegalStateException(<a name="line.13549"></a>
<FONT color="green">13550</FONT>                    "Your canvas factory's create method did not return "<a name="line.13550"></a>
<FONT color="green">13551</FONT>                    + "either null or a GWT Widget, as required. See the "<a name="line.13551"></a>
<FONT color="green">13552</FONT>                    + "GChart.setCanvasFactory method javadocs for details.");<a name="line.13552"></a>
<FONT color="green">13553</FONT>            }<a name="line.13553"></a>
<FONT color="green">13554</FONT>          }<a name="line.13554"></a>
<FONT color="green">13555</FONT>        }<a name="line.13555"></a>
<FONT color="green">13556</FONT>    <a name="line.13556"></a>
<FONT color="green">13557</FONT>        /**<a name="line.13557"></a>
<FONT color="green">13558</FONT>         * Provides support for reusing certain property specifications that are<a name="line.13558"></a>
<FONT color="green">13559</FONT>         * likely to be the same, given how images in a GChart get reused, and given<a name="line.13559"></a>
<FONT color="green">13560</FONT>         * certain assumptions about which properties of the image are most likely<a name="line.13560"></a>
<FONT color="green">13561</FONT>         * to remain unchanged between updates. For the most common scenarios, chart<a name="line.13561"></a>
<FONT color="green">13562</FONT>         * updates are significantly faster due to replacing (relatively expensive)<a name="line.13562"></a>
<FONT color="green">13563</FONT>         * DOM style attribute setting with (relatively cheap) String reference or<a name="line.13563"></a>
<FONT color="green">13564</FONT>         * integer equality tests.<a name="line.13564"></a>
<FONT color="green">13565</FONT>         * &lt;p&gt;<a name="line.13565"></a>
<FONT color="green">13566</FONT>         * <a name="line.13566"></a>
<FONT color="green">13567</FONT>         * For hovertext, the class also lets us defer actual generation of the<a name="line.13567"></a>
<FONT color="green">13568</FONT>         * hovertext until they actually mouse over the image, saving further time<a name="line.13568"></a>
<FONT color="green">13569</FONT>         * (it's surprisingly expensive just to format the numbers and such used in<a name="line.13569"></a>
<FONT color="green">13570</FONT>         * hovertexts).<a name="line.13570"></a>
<FONT color="green">13571</FONT>         * &lt;p&gt;<a name="line.13571"></a>
<FONT color="green">13572</FONT>         * <a name="line.13572"></a>
<FONT color="green">13573</FONT>         * TODO: Since we no longer use events on Image widgets, see if we can<a name="line.13573"></a>
<FONT color="green">13574</FONT>         * switch to just using simpler HTML elements, if that reduces the overhead<a name="line.13574"></a>
<FONT color="green">13575</FONT>         * associated with a Widget?<a name="line.13575"></a>
<FONT color="green">13576</FONT>         * <a name="line.13576"></a>
<FONT color="green">13577</FONT>         * <a name="line.13577"></a>
<FONT color="green">13578</FONT>         */<a name="line.13578"></a>
<FONT color="green">13579</FONT>        class ReusableImage extends Image {<a name="line.13579"></a>
<FONT color="green">13580</FONT>          private String backgroundColor = USE_CSS;<a name="line.13580"></a>
<FONT color="green">13581</FONT>          private String borderColor = USE_CSS;<a name="line.13581"></a>
<FONT color="green">13582</FONT>          private String borderStyle = USE_CSS;<a name="line.13582"></a>
<FONT color="green">13583</FONT>          // the capped border width, times two (to allow half-pixel widths)<a name="line.13583"></a>
<FONT color="green">13584</FONT>          private int cappedBorderWidthX2 = GChart.NAI;<a name="line.13584"></a>
<FONT color="green">13585</FONT>          private int width = GChart.NAI;<a name="line.13585"></a>
<FONT color="green">13586</FONT>          private int height = GChart.NAI;<a name="line.13586"></a>
<FONT color="green">13587</FONT>          int x = GChart.NAI;<a name="line.13587"></a>
<FONT color="green">13588</FONT>          int y = GChart.NAI;<a name="line.13588"></a>
<FONT color="green">13589</FONT>          String url = null;<a name="line.13589"></a>
<FONT color="green">13590</FONT>    <a name="line.13590"></a>
<FONT color="green">13591</FONT>          ReusableImage() {<a name="line.13591"></a>
<FONT color="green">13592</FONT>            super();<a name="line.13592"></a>
<FONT color="green">13593</FONT>            this.url = null;<a name="line.13593"></a>
<FONT color="green">13594</FONT>          }<a name="line.13594"></a>
<FONT color="green">13595</FONT>    <a name="line.13595"></a>
<FONT color="green">13596</FONT>          void setReusableProperties(String backgroundColor,<a name="line.13596"></a>
<FONT color="green">13597</FONT>              String borderColor, String borderStyle, int borderWidth,<a name="line.13597"></a>
<FONT color="green">13598</FONT>              double dWidth, double dHeight, double xD, double yD,<a name="line.13598"></a>
<FONT color="green">13599</FONT>              String url) {<a name="line.13599"></a>
<FONT color="green">13600</FONT>    <a name="line.13600"></a>
<FONT color="green">13601</FONT>            // Round two edges, and define width to be their difference.<a name="line.13601"></a>
<FONT color="green">13602</FONT>            // (rounding this way assures bars align with gridlines, etc.)<a name="line.13602"></a>
<FONT color="green">13603</FONT>            int newX = (int) Math.round(xD);<a name="line.13603"></a>
<FONT color="green">13604</FONT>            int newW = (int) Math.round(xD + dWidth) - newX;<a name="line.13604"></a>
<FONT color="green">13605</FONT>            int newY = (int) Math.round(yD);<a name="line.13605"></a>
<FONT color="green">13606</FONT>            int newH = (int) Math.round(yD + dHeight) - newY;<a name="line.13606"></a>
<FONT color="green">13607</FONT>            int thickness = (newW &lt; newH) ? newW : newH;<a name="line.13607"></a>
<FONT color="green">13608</FONT>            // Don't allow borders that would exceed specified width or<a name="line.13608"></a>
<FONT color="green">13609</FONT>            // height. So, if smaller of width, height is at least twice the<a name="line.13609"></a>
<FONT color="green">13610</FONT>            // border width, border width is used as is, otherwise,<a name="line.13610"></a>
<FONT color="green">13611</FONT>            // it's replaced with half the smaller of width, height:<a name="line.13611"></a>
<FONT color="green">13612</FONT>            int newCappedBorderWidthX2 = (2 * borderWidth &lt; thickness) ? 2 * borderWidth<a name="line.13612"></a>
<FONT color="green">13613</FONT>                : thickness;<a name="line.13613"></a>
<FONT color="green">13614</FONT>            /*<a name="line.13614"></a>
<FONT color="green">13615</FONT>             * Note: on a GWT absolute panel, the x,y position of the widget is the<a name="line.13615"></a>
<FONT color="green">13616</FONT>             * upper left corner of the widget's border, so x, y need no adjustment<a name="line.13616"></a>
<FONT color="green">13617</FONT>             * to account for an internal (positive) border. Negative (external)<a name="line.13617"></a>
<FONT color="green">13618</FONT>             * borders expand rectangle equally in all directions, so x,y need to<a name="line.13618"></a>
<FONT color="green">13619</FONT>             * shift back to the new upper left corner. Transparent border emulation<a name="line.13619"></a>
<FONT color="green">13620</FONT>             * sets border width to 0, and adjusts element size and position to<a name="line.13620"></a>
<FONT color="green">13621</FONT>             * mimic border transparency (this rather odd feature is required to<a name="line.13621"></a>
<FONT color="green">13622</FONT>             * workaround the IE6 "transparent border" bug)<a name="line.13622"></a>
<FONT color="green">13623</FONT>             */<a name="line.13623"></a>
<FONT color="green">13624</FONT>            if (TRANSPARENT_BORDER_COLOR == borderColor) {// transparency<a name="line.13624"></a>
<FONT color="green">13625</FONT>              // emulation<a name="line.13625"></a>
<FONT color="green">13626</FONT>              if (newCappedBorderWidthX2 &gt; 0) {<a name="line.13626"></a>
<FONT color="green">13627</FONT>                // to emulate an internal transparent border using a 0 width<a name="line.13627"></a>
<FONT color="green">13628</FONT>                // border, we need to shift the upper left corner by the<a name="line.13628"></a>
<FONT color="green">13629</FONT>                // amount of border, and shrink the size by twice the amount<a name="line.13629"></a>
<FONT color="green">13630</FONT>                // of the border.<a name="line.13630"></a>
<FONT color="green">13631</FONT>                newX += newCappedBorderWidthX2 / 2; // shift upper left<a name="line.13631"></a>
<FONT color="green">13632</FONT>                // corner<a name="line.13632"></a>
<FONT color="green">13633</FONT>                newY += newCappedBorderWidthX2 / 2;<a name="line.13633"></a>
<FONT color="green">13634</FONT>                newH -= newCappedBorderWidthX2; // shrink size<a name="line.13634"></a>
<FONT color="green">13635</FONT>                newW -= newCappedBorderWidthX2;<a name="line.13635"></a>
<FONT color="green">13636</FONT>              }<a name="line.13636"></a>
<FONT color="green">13637</FONT>              // else, external border is just eliminated, no adjustment<a name="line.13637"></a>
<FONT color="green">13638</FONT>              // needed<a name="line.13638"></a>
<FONT color="green">13639</FONT>              newCappedBorderWidthX2 = 0;<a name="line.13639"></a>
<FONT color="green">13640</FONT>              borderColor = "transparent"; // because DOM won't accept null<a name="line.13640"></a>
<FONT color="green">13641</FONT>              if (backgroundColor == TRANSPARENT_BORDER_COLOR)<a name="line.13641"></a>
<FONT color="green">13642</FONT>                backgroundColor = "transparent";<a name="line.13642"></a>
<FONT color="green">13643</FONT>            } else if (newCappedBorderWidthX2 &lt; 0) {<a name="line.13643"></a>
<FONT color="green">13644</FONT>              newX += newCappedBorderWidthX2 / 2; // shift upper left corner back<a name="line.13644"></a>
<FONT color="green">13645</FONT>              newY += newCappedBorderWidthX2 / 2; // to incorporate external border.<a name="line.13645"></a>
<FONT color="green">13646</FONT>            } else {<a name="line.13646"></a>
<FONT color="green">13647</FONT>              newH -= newCappedBorderWidthX2; // shrink size to incorporate<a name="line.13647"></a>
<FONT color="green">13648</FONT>              newW -= newCappedBorderWidthX2; // impact of internal border.<a name="line.13648"></a>
<FONT color="green">13649</FONT>            }<a name="line.13649"></a>
<FONT color="green">13650</FONT>    <a name="line.13650"></a>
<FONT color="green">13651</FONT>            if (cappedBorderWidthX2 != newCappedBorderWidthX2) {<a name="line.13651"></a>
<FONT color="green">13652</FONT>              if (1 == (newCappedBorderWidthX2 % 2)) {<a name="line.13652"></a>
<FONT color="green">13653</FONT>                // odd pixel 2 x borderWidth needs asymetical borders to<a name="line.13653"></a>
<FONT color="green">13654</FONT>                // fill rect (only positive (internal) borders can have<a name="line.13654"></a>
<FONT color="green">13655</FONT>                // half-pixel widths)<a name="line.13655"></a>
<FONT color="green">13656</FONT>                int floorBW = newCappedBorderWidthX2 / 2;<a name="line.13656"></a>
<FONT color="green">13657</FONT>                int ceilBW = floorBW + 1;<a name="line.13657"></a>
<FONT color="green">13658</FONT>                // (top, right, bottom, left) == (floor, floor, ceil, ceil)<a name="line.13658"></a>
<FONT color="green">13659</FONT>                // assures symbol is odd-pixel border-filled in all cases<a name="line.13659"></a>
<FONT color="green">13660</FONT>                DOM.setStyleAttribute(getElement(), "borderWidth",<a name="line.13660"></a>
<FONT color="green">13661</FONT>                    floorBW + "px " + floorBW + "px " + ceilBW<a name="line.13661"></a>
<FONT color="green">13662</FONT>                    + "px " + ceilBW + "px ");<a name="line.13662"></a>
<FONT color="green">13663</FONT>              } else {<a name="line.13663"></a>
<FONT color="green">13664</FONT>                DOM.setStyleAttribute(getElement(), "borderWidth", Math<a name="line.13664"></a>
<FONT color="green">13665</FONT>                    .abs(newCappedBorderWidthX2 / 2)<a name="line.13665"></a>
<FONT color="green">13666</FONT>                    + "px");<a name="line.13666"></a>
<FONT color="green">13667</FONT>              }<a name="line.13667"></a>
<FONT color="green">13668</FONT>              cappedBorderWidthX2 = newCappedBorderWidthX2;<a name="line.13668"></a>
<FONT color="green">13669</FONT>            }<a name="line.13669"></a>
<FONT color="green">13670</FONT>    <a name="line.13670"></a>
<FONT color="green">13671</FONT>            if (GChart.NAI == this.x) {<a name="line.13671"></a>
<FONT color="green">13672</FONT>              // At first, use AbsolutePanel's official API (to insulate us<a name="line.13672"></a>
<FONT color="green">13673</FONT>              // from any future AbsolutePanel changes)<a name="line.13673"></a>
<FONT color="green">13674</FONT>              setImagePosition(this, newX, newY);<a name="line.13674"></a>
<FONT color="green">13675</FONT>              this.x = newX;<a name="line.13675"></a>
<FONT color="green">13676</FONT>              this.y = newY;<a name="line.13676"></a>
<FONT color="green">13677</FONT>            } else { // for speed, just set the edge positions that changed<a name="line.13677"></a>
<FONT color="green">13678</FONT>              // (works, but bypasses AbsolutePanel's official API)<a name="line.13678"></a>
<FONT color="green">13679</FONT>              if (this.x != newX) {<a name="line.13679"></a>
<FONT color="green">13680</FONT>                DOM.setStyleAttribute(getElement(), "left", newX + "px");<a name="line.13680"></a>
<FONT color="green">13681</FONT>                this.x = newX;<a name="line.13681"></a>
<FONT color="green">13682</FONT>              }<a name="line.13682"></a>
<FONT color="green">13683</FONT>              if (this.y != newY) {<a name="line.13683"></a>
<FONT color="green">13684</FONT>                DOM.setStyleAttribute(getElement(), "top", newY + "px");<a name="line.13684"></a>
<FONT color="green">13685</FONT>                this.y = newY;<a name="line.13685"></a>
<FONT color="green">13686</FONT>              }<a name="line.13686"></a>
<FONT color="green">13687</FONT>            }<a name="line.13687"></a>
<FONT color="green">13688</FONT>    <a name="line.13688"></a>
<FONT color="green">13689</FONT>            if (this.width != newW) {<a name="line.13689"></a>
<FONT color="green">13690</FONT>              setWidth(newW + "px");<a name="line.13690"></a>
<FONT color="green">13691</FONT>              this.width = newW;<a name="line.13691"></a>
<FONT color="green">13692</FONT>            }<a name="line.13692"></a>
<FONT color="green">13693</FONT>            if (this.height != newH) {<a name="line.13693"></a>
<FONT color="green">13694</FONT>              setHeight(newH + "px");<a name="line.13694"></a>
<FONT color="green">13695</FONT>              this.height = newH;<a name="line.13695"></a>
<FONT color="green">13696</FONT>            }<a name="line.13696"></a>
<FONT color="green">13697</FONT>    <a name="line.13697"></a>
<FONT color="green">13698</FONT>            if (this.backgroundColor != backgroundColor) {<a name="line.13698"></a>
<FONT color="green">13699</FONT>              DOM.setStyleAttribute(getElement(), "backgroundColor",<a name="line.13699"></a>
<FONT color="green">13700</FONT>                  backgroundColor);<a name="line.13700"></a>
<FONT color="green">13701</FONT>              this.backgroundColor = backgroundColor;<a name="line.13701"></a>
<FONT color="green">13702</FONT>            }<a name="line.13702"></a>
<FONT color="green">13703</FONT>            if (this.borderColor != borderColor) {<a name="line.13703"></a>
<FONT color="green">13704</FONT>              DOM.setStyleAttribute(getElement(), "borderColor",<a name="line.13704"></a>
<FONT color="green">13705</FONT>                  borderColor);<a name="line.13705"></a>
<FONT color="green">13706</FONT>              this.borderColor = borderColor;<a name="line.13706"></a>
<FONT color="green">13707</FONT>            }<a name="line.13707"></a>
<FONT color="green">13708</FONT>            if (this.borderStyle != borderStyle) {<a name="line.13708"></a>
<FONT color="green">13709</FONT>              DOM.setStyleAttribute(getElement(), "borderStyle",<a name="line.13709"></a>
<FONT color="green">13710</FONT>                  borderStyle);<a name="line.13710"></a>
<FONT color="green">13711</FONT>              this.borderStyle = borderStyle;<a name="line.13711"></a>
<FONT color="green">13712</FONT>            }<a name="line.13712"></a>
<FONT color="green">13713</FONT>    <a name="line.13713"></a>
<FONT color="green">13714</FONT>            if (this.url != url) {<a name="line.13714"></a>
<FONT color="green">13715</FONT>              /*<a name="line.13715"></a>
<FONT color="green">13716</FONT>               * WARNING: Redundant setUrls cause leaks in FF 2.0.0.16. So, be<a name="line.13716"></a>
<FONT color="green">13717</FONT>               * particularly careful not to accidentally "double set" a URL to the<a name="line.13717"></a>
<FONT color="green">13718</FONT>               * exact same URL (I did this with a slightly less efficient<a name="line.13718"></a>
<FONT color="green">13719</FONT>               * initialization of my images, and this caused a huge memory leak<a name="line.13719"></a>
<FONT color="green">13720</FONT>               * that I hope to memorialize, and lay to rest forever, here.)<a name="line.13720"></a>
<FONT color="green">13721</FONT>               * <a name="line.13721"></a>
<FONT color="green">13722</FONT>               * Symptoms, in FF 2 only, are those that would occur AS IF the extra<a name="line.13722"></a>
<FONT color="green">13723</FONT>               * setUrl increased the reference count on the (browser cached) image<a name="line.13723"></a>
<FONT color="green">13724</FONT>               * file so that Firefox can't release either it, or any of the img<a name="line.13724"></a>
<FONT color="green">13725</FONT>               * elements that reference it. A very big leak for GChart, since just<a name="line.13725"></a>
<FONT color="green">13726</FONT>               * about everything in a GChart references the exact same blank gif<a name="line.13726"></a>
<FONT color="green">13727</FONT>               * URL.<a name="line.13727"></a>
<FONT color="green">13728</FONT>               * <a name="line.13728"></a>
<FONT color="green">13729</FONT>               * Such symptoms did not occur in IE7, or in FF 2 if the cache has<a name="line.13729"></a>
<FONT color="green">13730</FONT>               * been disabled via "about:config".<a name="line.13730"></a>
<FONT color="green">13731</FONT>               * <a name="line.13731"></a>
<FONT color="green">13732</FONT>               */<a name="line.13732"></a>
<FONT color="green">13733</FONT>              setUrl(url);<a name="line.13733"></a>
<FONT color="green">13734</FONT>              this.url = url;<a name="line.13734"></a>
<FONT color="green">13735</FONT>            }<a name="line.13735"></a>
<FONT color="green">13736</FONT>          }<a name="line.13736"></a>
<FONT color="green">13737</FONT>        } // end of class ReusableImage<a name="line.13737"></a>
<FONT color="green">13738</FONT>    <a name="line.13738"></a>
<FONT color="green">13739</FONT>        GraphicsRenderingPanel() {<a name="line.13739"></a>
<FONT color="green">13740</FONT>          super();<a name="line.13740"></a>
<FONT color="green">13741</FONT>          // Overflow of this panel is controlled when it is added<a name="line.13741"></a>
<FONT color="green">13742</FONT>          // GChart.setOverflow(this, "visible");<a name="line.13742"></a>
<FONT color="green">13743</FONT>          GChart.setOverflow(canvasPanel, "visible");<a name="line.13743"></a>
<FONT color="green">13744</FONT>          GChart.setOverflow(imagePanel, "visible");<a name="line.13744"></a>
<FONT color="green">13745</FONT>          // these sub-panels have no size themselves, they are merely<a name="line.13745"></a>
<FONT color="green">13746</FONT>          // there to segregate canvas and HTML rendered parts of curve<a name="line.13746"></a>
<FONT color="green">13747</FONT>          canvasPanel.setPixelSize(0, 0);<a name="line.13747"></a>
<FONT color="green">13748</FONT>          imagePanel.setPixelSize(0, 0);<a name="line.13748"></a>
<FONT color="green">13749</FONT>          this.add(canvasPanel, 0, 0);<a name="line.13749"></a>
<FONT color="green">13750</FONT>          this.add(imagePanel, 0, 0);<a name="line.13750"></a>
<FONT color="green">13751</FONT>        }<a name="line.13751"></a>
<FONT color="green">13752</FONT>    <a name="line.13752"></a>
<FONT color="green">13753</FONT>        GChartCanvasLite getCanvas() {<a name="line.13753"></a>
<FONT color="green">13754</FONT>          return canvas;<a name="line.13754"></a>
<FONT color="green">13755</FONT>        }<a name="line.13755"></a>
<FONT color="green">13756</FONT>    <a name="line.13756"></a>
<FONT color="green">13757</FONT>        void setImagePosition(ReusableImage img, int x, int y) {<a name="line.13757"></a>
<FONT color="green">13758</FONT>          // workaround problem of special meaning of (-1,-1) to<a name="line.13758"></a>
<FONT color="green">13759</FONT>          // setWidgetPosition (makes position off by one pixel, though).<a name="line.13759"></a>
<FONT color="green">13760</FONT>          if (x == -1 &amp;&amp; y == -1)<a name="line.13760"></a>
<FONT color="green">13761</FONT>            x = 0;<a name="line.13761"></a>
<FONT color="green">13762</FONT>          imagePanel.setWidgetPosition(img, x, y);<a name="line.13762"></a>
<FONT color="green">13763</FONT>        }<a name="line.13763"></a>
<FONT color="green">13764</FONT>    <a name="line.13764"></a>
<FONT color="green">13765</FONT>        // Tells panel you are ready to start drawing the curve on it<a name="line.13765"></a>
<FONT color="green">13766</FONT>        void beginRendering(Rectangle canvasRegion) {<a name="line.13766"></a>
<FONT color="green">13767</FONT>          if (null != canvas) {<a name="line.13767"></a>
<FONT color="green">13768</FONT>            if (null == canvasRegion) {<a name="line.13768"></a>
<FONT color="green">13769</FONT>              // hold onto empty canvas for simplicity<a name="line.13769"></a>
<FONT color="green">13770</FONT>              canvas.resize(0, 0);<a name="line.13770"></a>
<FONT color="green">13771</FONT>              canvasWidth = canvasHeight = 0;<a name="line.13771"></a>
<FONT color="green">13772</FONT>            } else {<a name="line.13772"></a>
<FONT color="green">13773</FONT>              int width = (int) Math.round(canvasRegion.width);<a name="line.13773"></a>
<FONT color="green">13774</FONT>              int height = (int) Math.round(canvasRegion.height);<a name="line.13774"></a>
<FONT color="green">13775</FONT>              // if exactly same size, just clear...seems to save a little<a name="line.13775"></a>
<FONT color="green">13776</FONT>              // time<a name="line.13776"></a>
<FONT color="green">13777</FONT>              if (width == canvasWidth &amp;&amp; height == canvasHeight)<a name="line.13777"></a>
<FONT color="green">13778</FONT>                canvas.clear(); // reuse same canvas<a name="line.13778"></a>
<FONT color="green">13779</FONT>              else { // size changed<a name="line.13779"></a>
<FONT color="green">13780</FONT>                canvas.resize(width, height);<a name="line.13780"></a>
<FONT color="green">13781</FONT>                canvasWidth = width;<a name="line.13781"></a>
<FONT color="green">13782</FONT>                canvasHeight = height;<a name="line.13782"></a>
<FONT color="green">13783</FONT>              }<a name="line.13783"></a>
<FONT color="green">13784</FONT>              x0 = (int) Math.round(canvasRegion.x);<a name="line.13784"></a>
<FONT color="green">13785</FONT>              y0 = (int) Math.round(canvasRegion.y);<a name="line.13785"></a>
<FONT color="green">13786</FONT>              // workaround problem with special meaning of (-1,-1) to<a name="line.13786"></a>
<FONT color="green">13787</FONT>              // setWidgetPosition (makes position off by one pixel).<a name="line.13787"></a>
<FONT color="green">13788</FONT>              if (x0 == -1 &amp;&amp; y0 == -1)<a name="line.13788"></a>
<FONT color="green">13789</FONT>                x0 = 0;<a name="line.13789"></a>
<FONT color="green">13790</FONT>              canvasPanel.setWidgetPosition((Widget) canvas, x0, y0);<a name="line.13790"></a>
<FONT color="green">13791</FONT>            }<a name="line.13791"></a>
<FONT color="green">13792</FONT>          }<a name="line.13792"></a>
<FONT color="green">13793</FONT>          imageIndex = 0;<a name="line.13793"></a>
<FONT color="green">13794</FONT>        }<a name="line.13794"></a>
<FONT color="green">13795</FONT>    <a name="line.13795"></a>
<FONT color="green">13796</FONT>        // Tells panel you are done drawing on it, and<a name="line.13796"></a>
<FONT color="green">13797</FONT>        // it's OK to do any final cleanup/bookkeeping needed.<a name="line.13797"></a>
<FONT color="green">13798</FONT>        void endRendering() {<a name="line.13798"></a>
<FONT color="green">13799</FONT>          // hide or remove images no longer being used<a name="line.13799"></a>
<FONT color="green">13800</FONT>          for (int iImage = optimizeForMemory ? (imagePanel.getWidgetCount() - 1)<a name="line.13800"></a>
<FONT color="green">13801</FONT>              : lastVisibleImage; iImage &gt;= imageIndex; iImage--) {<a name="line.13801"></a>
<FONT color="green">13802</FONT>            Widget w = imagePanel.getWidget(iImage);<a name="line.13802"></a>
<FONT color="green">13803</FONT>            if (optimizeForMemory)<a name="line.13803"></a>
<FONT color="green">13804</FONT>              imagePanel.remove(iImage);<a name="line.13804"></a>
<FONT color="green">13805</FONT>            else<a name="line.13805"></a>
<FONT color="green">13806</FONT>              DOM.setStyleAttribute(w.getElement(), "visibility",<a name="line.13806"></a>
<FONT color="green">13807</FONT>                  "hidden");<a name="line.13807"></a>
<FONT color="green">13808</FONT>            // setVisible unreliable w Images in IE as shown in<a name="line.13808"></a>
<FONT color="green">13809</FONT>            // TestGChart41a.java<a name="line.13809"></a>
<FONT color="green">13810</FONT>            // w.setVisible(false);<a name="line.13810"></a>
<FONT color="green">13811</FONT>          }<a name="line.13811"></a>
<FONT color="green">13812</FONT>          lastVisibleImage = imageIndex - 1;<a name="line.13812"></a>
<FONT color="green">13813</FONT>        }<a name="line.13813"></a>
<FONT color="green">13814</FONT>    <a name="line.13814"></a>
<FONT color="green">13815</FONT>        /*<a name="line.13815"></a>
<FONT color="green">13816</FONT>         * Speedier, reusable, rendering-panel-managed images. In effect, turns<a name="line.13816"></a>
<FONT color="green">13817</FONT>         * image panel into a specialized memory manager.<a name="line.13817"></a>
<FONT color="green">13818</FONT>         */<a name="line.13818"></a>
<FONT color="green">13819</FONT>        void addOrRevealImage(String backgroundColor, String borderColor,<a name="line.13819"></a>
<FONT color="green">13820</FONT>            String borderStyle, int borderWidth, double width,<a name="line.13820"></a>
<FONT color="green">13821</FONT>            double height, double x, double y, String url) {<a name="line.13821"></a>
<FONT color="green">13822</FONT>          ReusableImage img;<a name="line.13822"></a>
<FONT color="green">13823</FONT>          if (imageIndex &lt; imagePanel.getWidgetCount()) { // reuse an old image<a name="line.13823"></a>
<FONT color="green">13824</FONT>            img = (ReusableImage) imagePanel.getWidget(imageIndex);<a name="line.13824"></a>
<FONT color="green">13825</FONT>            if (imageIndex &gt; lastVisibleImage)<a name="line.13825"></a>
<FONT color="green">13826</FONT>              // "" visibility means<a name="line.13826"></a>
<FONT color="green">13827</FONT>              // "visible whenever the parent is visible"<a name="line.13827"></a>
<FONT color="green">13828</FONT>              DOM.setStyleAttribute(img.getElement(), "visibility", "");<a name="line.13828"></a>
<FONT color="green">13829</FONT>            // setVisible unreliable for Images in IE as shown in<a name="line.13829"></a>
<FONT color="green">13830</FONT>            // TestGChart41a.java<a name="line.13830"></a>
<FONT color="green">13831</FONT>            // img.setVisible(true);<a name="line.13831"></a>
<FONT color="green">13832</FONT>          } else { // add a new image<a name="line.13832"></a>
<FONT color="green">13833</FONT>            img = new ReusableImage();<a name="line.13833"></a>
<FONT color="green">13834</FONT>            imagePanel.add(img);<a name="line.13834"></a>
<FONT color="green">13835</FONT>          }<a name="line.13835"></a>
<FONT color="green">13836</FONT>    <a name="line.13836"></a>
<FONT color="green">13837</FONT>          img.setReusableProperties(backgroundColor, borderColor,<a name="line.13837"></a>
<FONT color="green">13838</FONT>              borderStyle, borderWidth, width, height, x, y, url);<a name="line.13838"></a>
<FONT color="green">13839</FONT>    <a name="line.13839"></a>
<FONT color="green">13840</FONT>          if (lastVisibleImage &lt; imageIndex)<a name="line.13840"></a>
<FONT color="green">13841</FONT>            lastVisibleImage = imageIndex;<a name="line.13841"></a>
<FONT color="green">13842</FONT>          imageIndex++;<a name="line.13842"></a>
<FONT color="green">13843</FONT>    <a name="line.13843"></a>
<FONT color="green">13844</FONT>        }<a name="line.13844"></a>
<FONT color="green">13845</FONT>    <a name="line.13845"></a>
<FONT color="green">13846</FONT>        // Decided, for simplicitly, to just use HTML for rectanglular symbols.<a name="line.13846"></a>
<FONT color="green">13847</FONT>        // May change my mind again, so leaving code below in comments<a name="line.13847"></a>
<FONT color="green">13848</FONT>        /*<a name="line.13848"></a>
<FONT color="green">13849</FONT>         * Fills a rectangle. &lt;p&gt;<a name="line.13849"></a>
<FONT color="green">13850</FONT>         * <a name="line.13850"></a>
<FONT color="green">13851</FONT>         * Needed because GChartCanvasLite does not include fillRect &lt;p&gt;<a name="line.13851"></a>
<FONT color="green">13852</FONT>         * <a name="line.13852"></a>
<FONT color="green">13853</FONT>         * TODO: Check if this slows us much compared to using canvas' fillRect. We<a name="line.13853"></a>
<FONT color="green">13854</FONT>         * may also later need to use other canvas features not in GChartCanvasLite<a name="line.13854"></a>
<FONT color="green">13855</FONT>         * (gradients? drawImage?) so should bundle all such changes together, in<a name="line.13855"></a>
<FONT color="green">13856</FONT>         * one, final, GChart canvas interface-related change to minimize<a name="line.13856"></a>
<FONT color="green">13857</FONT>         * interface-changing aggravations for developers.<a name="line.13857"></a>
<FONT color="green">13858</FONT>         */<a name="line.13858"></a>
<FONT color="green">13859</FONT>        // private void fillRect(GChartCanvasLite canvas, double x, double y,<a name="line.13859"></a>
<FONT color="green">13860</FONT>        // double width, double height) {<a name="line.13860"></a>
<FONT color="green">13861</FONT>        // canvas.beginPath();<a name="line.13861"></a>
<FONT color="green">13862</FONT>        // canvas.moveTo(x - rp.x0,y - rp.y0);<a name="line.13862"></a>
<FONT color="green">13863</FONT>        // canvas.lineTo(x+width - rp.x0, y - rp.y0);<a name="line.13863"></a>
<FONT color="green">13864</FONT>        // canvas.lineTo(x+width - rp.x0,<a name="line.13864"></a>
<FONT color="green">13865</FONT>        // y+height - rp.y0);<a name="line.13865"></a>
<FONT color="green">13866</FONT>        // canvas.lineTo(x - rp.x0,<a name="line.13866"></a>
<FONT color="green">13867</FONT>        // y+height - rp.y0);<a name="line.13867"></a>
<FONT color="green">13868</FONT>        // canvas.closePath();<a name="line.13868"></a>
<FONT color="green">13869</FONT>        // canvas.fill();<a name="line.13869"></a>
<FONT color="green">13870</FONT>        // }<a name="line.13870"></a>
<FONT color="green">13871</FONT>        /*<a name="line.13871"></a>
<FONT color="green">13872</FONT>         * Uses canvas to emulate a single Image-based rectangle, assuming that the<a name="line.13872"></a>
<FONT color="green">13873</FONT>         * image URL points to a transparent GIF<a name="line.13873"></a>
<FONT color="green">13874</FONT>         */<a name="line.13874"></a>
<FONT color="green">13875</FONT>        // void drawBorderedImage(String backgroundColor,<a name="line.13875"></a>
<FONT color="green">13876</FONT>        // String borderColor,<a name="line.13876"></a>
<FONT color="green">13877</FONT>        // String borderStyle,<a name="line.13877"></a>
<FONT color="green">13878</FONT>        // int borderWidth,<a name="line.13878"></a>
<FONT color="green">13879</FONT>        // double width,<a name="line.13879"></a>
<FONT color="green">13880</FONT>        // double height,<a name="line.13880"></a>
<FONT color="green">13881</FONT>        // double x, double y) {<a name="line.13881"></a>
<FONT color="green">13882</FONT>        // double xOut = x + ((borderWidth &lt; 0) ? borderWidth : 0);<a name="line.13882"></a>
<FONT color="green">13883</FONT>        // double yOut = y + ((borderWidth &lt; 0) ? borderWidth : 0);<a name="line.13883"></a>
<FONT color="green">13884</FONT>        // double xIn = x + ((borderWidth &gt; 0) ? borderWidth : 0);<a name="line.13884"></a>
<FONT color="green">13885</FONT>        // double yIn = y + ((borderWidth &gt; 0) ? borderWidth : 0);<a name="line.13885"></a>
<FONT color="green">13886</FONT>        // double wOut = width + ((borderWidth &lt; 0) ? (-2*borderWidth) : 0);<a name="line.13886"></a>
<FONT color="green">13887</FONT>        // double hOut = height + ((borderWidth &lt; 0) ? (-2*borderWidth) : 0);<a name="line.13887"></a>
<FONT color="green">13888</FONT>        // double wIn = width + ((borderWidth &gt; 0) ? (-2*borderWidth) : 0);<a name="line.13888"></a>
<FONT color="green">13889</FONT>        // double hIn = height + ((borderWidth &gt; 0) ? (-2*borderWidth) : 0);<a name="line.13889"></a>
<FONT color="green">13890</FONT>        // if (TRANSPARENT_BORDER_COLOR != borderColor &amp;&amp;<a name="line.13890"></a>
<FONT color="green">13891</FONT>        // "transparent" != borderColor) {<a name="line.13891"></a>
<FONT color="green">13892</FONT>        // double absBW = Math.abs(borderWidth);<a name="line.13892"></a>
<FONT color="green">13893</FONT>        // canvas.setFillStyle(borderColor);<a name="line.13893"></a>
<FONT color="green">13894</FONT>        // // draw the four rectangles forming the outer perimeter<a name="line.13894"></a>
<FONT color="green">13895</FONT>        // fillRect(canvas, xOut, yOut, absBW, hOut);<a name="line.13895"></a>
<FONT color="green">13896</FONT>        // fillRect(canvas, xOut, yOut, wOut, absBW);<a name="line.13896"></a>
<FONT color="green">13897</FONT>        // fillRect(canvas, xOut, yIn+hIn, wOut, absBW);<a name="line.13897"></a>
<FONT color="green">13898</FONT>        // fillRect(canvas, xIn+wIn, yOut, absBW, hOut);<a name="line.13898"></a>
<FONT color="green">13899</FONT>        // }<a name="line.13899"></a>
<FONT color="green">13900</FONT>        // if (TRANSPARENT_BORDER_COLOR != backgroundColor &amp;&amp;<a name="line.13900"></a>
<FONT color="green">13901</FONT>        // "transparent" != backgroundColor) {<a name="line.13901"></a>
<FONT color="green">13902</FONT>        // // draw the inside-the-border rectangle<a name="line.13902"></a>
<FONT color="green">13903</FONT>        // canvas.setFillStyle(backgroundColor);<a name="line.13903"></a>
<FONT color="green">13904</FONT>        // fillRect(canvas, xIn, yIn, wIn, hIn);<a name="line.13904"></a>
<FONT color="green">13905</FONT>        // }<a name="line.13905"></a>
<FONT color="green">13906</FONT>        // }<a name="line.13906"></a>
<FONT color="green">13907</FONT>    <a name="line.13907"></a>
<FONT color="green">13908</FONT>        public void renderBorderedImage(String backgroundColor,<a name="line.13908"></a>
<FONT color="green">13909</FONT>            String borderColor, String borderStyle, int borderWidth,<a name="line.13909"></a>
<FONT color="green">13910</FONT>            double width, double height, double x, double y, String url) {<a name="line.13910"></a>
<FONT color="green">13911</FONT>          // if (null != canvas &amp;&amp; url == getBlankImageURL() &amp;&amp;<a name="line.13911"></a>
<FONT color="green">13912</FONT>          // (borderStyle == USE_CSS || borderStyle.equals("solid")))<a name="line.13912"></a>
<FONT color="green">13913</FONT>          /*<a name="line.13913"></a>
<FONT color="green">13914</FONT>           * Use canvas to emulate a transparent, bordered image (GChart can only<a name="line.13914"></a>
<FONT color="green">13915</FONT>           * render solid borders and blank image URLS with canvas at this point)<a name="line.13915"></a>
<FONT color="green">13916</FONT>           */<a name="line.13916"></a>
<FONT color="green">13917</FONT>          // drawBorderedImage(backgroundColor,<a name="line.13917"></a>
<FONT color="green">13918</FONT>          // borderColor,<a name="line.13918"></a>
<FONT color="green">13919</FONT>          // borderStyle,<a name="line.13919"></a>
<FONT color="green">13920</FONT>          // borderWidth,<a name="line.13920"></a>
<FONT color="green">13921</FONT>          // width,<a name="line.13921"></a>
<FONT color="green">13922</FONT>          // height,<a name="line.13922"></a>
<FONT color="green">13923</FONT>          // x, y);<a name="line.13923"></a>
<FONT color="green">13924</FONT>          // else // use an actual image HTML element<a name="line.13924"></a>
<FONT color="green">13925</FONT>          addOrRevealImage(backgroundColor, borderColor, borderStyle,<a name="line.13925"></a>
<FONT color="green">13926</FONT>              borderWidth, width, height, x, y, url);<a name="line.13926"></a>
<FONT color="green">13927</FONT>    <a name="line.13927"></a>
<FONT color="green">13928</FONT>        }<a name="line.13928"></a>
<FONT color="green">13929</FONT>    <a name="line.13929"></a>
<FONT color="green">13930</FONT>      } // end of class GraphicsRenderingPanel<a name="line.13930"></a>
<FONT color="green">13931</FONT>    <a name="line.13931"></a>
<FONT color="green">13932</FONT>      // An AbsolutePanel that just turns the protected insert method public<a name="line.13932"></a>
<FONT color="green">13933</FONT>      class InsertableAbsolutePanel extends AbsolutePanel {<a name="line.13933"></a>
<FONT color="green">13934</FONT>        public void insert(Widget child,<a name="line.13934"></a>
<FONT color="green">13935</FONT>            com.google.gwt.user.client.Element container, int beforeIndex,<a name="line.13935"></a>
<FONT color="green">13936</FONT>            boolean domInsert) {<a name="line.13936"></a>
<FONT color="green">13937</FONT>          super.insert(child, container, beforeIndex, domInsert);<a name="line.13937"></a>
<FONT color="green">13938</FONT>        }<a name="line.13938"></a>
<FONT color="green">13939</FONT>      }<a name="line.13939"></a>
<FONT color="green">13940</FONT>    <a name="line.13940"></a>
<FONT color="green">13941</FONT>      class PlotPanel extends AbsolutePanel {<a name="line.13941"></a>
<FONT color="green">13942</FONT>        private int leftOfYWidth;<a name="line.13942"></a>
<FONT color="green">13943</FONT>        private int rightOfY2Width;<a name="line.13943"></a>
<FONT color="green">13944</FONT>        private int topMargin;<a name="line.13944"></a>
<FONT color="green">13945</FONT>        private int xAxisEnsembleHeight;<a name="line.13945"></a>
<FONT color="green">13946</FONT>        private int xChartSize;<a name="line.13946"></a>
<FONT color="green">13947</FONT>        private double xLB = Double.NaN; // lower bound on x<a name="line.13947"></a>
<FONT color="green">13948</FONT>        private double xUB = Double.NaN; // upper bound on x<a name="line.13948"></a>
<FONT color="green">13949</FONT>        private double xMax = Double.NaN;<a name="line.13949"></a>
<FONT color="green">13950</FONT>        private double xMin = Double.NaN;<a name="line.13950"></a>
<FONT color="green">13951</FONT>        private int y2AxisEnsembleWidth;<a name="line.13951"></a>
<FONT color="green">13952</FONT>        private double y2LB = Double.NaN;<a name="line.13952"></a>
<FONT color="green">13953</FONT>        private double y2UB = Double.NaN;<a name="line.13953"></a>
<FONT color="green">13954</FONT>        private double y2Max = Double.NaN;<a name="line.13954"></a>
<FONT color="green">13955</FONT>        private double y2Min = Double.NaN;<a name="line.13955"></a>
<FONT color="green">13956</FONT>        private int yAxisEnsembleWidth;<a name="line.13956"></a>
<FONT color="green">13957</FONT>        private int chartLegendThickness;<a name="line.13957"></a>
<FONT color="green">13958</FONT>        private int chartFootnotesThickness;<a name="line.13958"></a>
<FONT color="green">13959</FONT>        private int yChartSize;<a name="line.13959"></a>
<FONT color="green">13960</FONT>        private double yLB = Double.NaN;<a name="line.13960"></a>
<FONT color="green">13961</FONT>        private double yUB = Double.NaN;<a name="line.13961"></a>
<FONT color="green">13962</FONT>        private double yMax = Double.NaN;<a name="line.13962"></a>
<FONT color="green">13963</FONT>        private double yMin = Double.NaN;<a name="line.13963"></a>
<FONT color="green">13964</FONT>        // Retains the last moved-to (Event.ONMOUSEMOVE) client mouse position,<a name="line.13964"></a>
<FONT color="green">13965</FONT>        // or NAI if<a name="line.13965"></a>
<FONT color="green">13966</FONT>        // mouse moved away from chart entirely.<a name="line.13966"></a>
<FONT color="green">13967</FONT>        private int clientX = GChart.NAI;<a name="line.13967"></a>
<FONT color="green">13968</FONT>        private int clientY = GChart.NAI;<a name="line.13968"></a>
<FONT color="green">13969</FONT>        // Pixel coords of above mouse position, relative to top-left<a name="line.13969"></a>
<FONT color="green">13970</FONT>        // corner of the GChart (mouse position in GChart's pixel coords)<a name="line.13970"></a>
<FONT color="green">13971</FONT>        private int xMouse = GChart.NAI;<a name="line.13971"></a>
<FONT color="green">13972</FONT>        private int yMouse = GChart.NAI;<a name="line.13972"></a>
<FONT color="green">13973</FONT>        // first rendering panel is reserved for chart decorations,<a name="line.13973"></a>
<FONT color="green">13974</FONT>        // and its overflow outside of the plot panel is never hidden<a name="line.13974"></a>
<FONT color="green">13975</FONT>        final static int DECORATIVE_RENDERING_PANEL_INDEX = 0;<a name="line.13975"></a>
<FONT color="green">13976</FONT>        private InsertableAbsolutePanel graphicsPanel = new InsertableAbsolutePanel();<a name="line.13976"></a>
<FONT color="green">13977</FONT>        private InsertableAbsolutePanel annotationPanel = new InsertableAbsolutePanel();<a name="line.13977"></a>
<FONT color="green">13978</FONT>    <a name="line.13978"></a>
<FONT color="green">13979</FONT>        private boolean outOfBoundsCheckingDisabled;<a name="line.13979"></a>
<FONT color="green">13980</FONT>    <a name="line.13980"></a>
<FONT color="green">13981</FONT>        /*<a name="line.13981"></a>
<FONT color="green">13982</FONT>         * Adds a sub-panel of this plot panel that contains the widgets used to<a name="line.13982"></a>
<FONT color="green">13983</FONT>         * render the graphical parts of the given curve &lt;p&gt;<a name="line.13983"></a>
<FONT color="green">13984</FONT>         * <a name="line.13984"></a>
<FONT color="green">13985</FONT>         * This method must be called just after a new curve is added to the chart,<a name="line.13985"></a>
<FONT color="green">13986</FONT>         * to add its associated graphics rendering panel; GChart assumes each<a name="line.13986"></a>
<FONT color="green">13987</FONT>         * curve (except internal decoration rendering curves, which share a single<a name="line.13987"></a>
<FONT color="green">13988</FONT>         * rendering panel for efficiency) already has a corresponding, unique,<a name="line.13988"></a>
<FONT color="green">13989</FONT>         * rendering panel available and ready to go during updates.<a name="line.13989"></a>
<FONT color="green">13990</FONT>         */<a name="line.13990"></a>
<FONT color="green">13991</FONT>    <a name="line.13991"></a>
<FONT color="green">13992</FONT>        void addGraphicsRenderingPanel(int rpIndex) {<a name="line.13992"></a>
<FONT color="green">13993</FONT>          final boolean domInsert = true;<a name="line.13993"></a>
<FONT color="green">13994</FONT>          GraphicsRenderingPanel w = new GraphicsRenderingPanel();<a name="line.13994"></a>
<FONT color="green">13995</FONT>          if (getCurveFromRenderingPanelIndex(rpIndex).getClippedToPlotArea()) {<a name="line.13995"></a>
<FONT color="green">13996</FONT>            w.setPixelSize(getXChartSize(), getYChartSize());<a name="line.13996"></a>
<FONT color="green">13997</FONT>            GChart.setOverflow(w, "hidden");<a name="line.13997"></a>
<FONT color="green">13998</FONT>          } else {<a name="line.13998"></a>
<FONT color="green">13999</FONT>            w.setPixelSize(0, 0);<a name="line.13999"></a>
<FONT color="green">14000</FONT>            GChart.setOverflow(w, "visible");<a name="line.14000"></a>
<FONT color="green">14001</FONT>          }<a name="line.14001"></a>
<FONT color="green">14002</FONT>          graphicsPanel.insert(w, graphicsPanel.getElement(), rpIndex,<a name="line.14002"></a>
<FONT color="green">14003</FONT>              domInsert);<a name="line.14003"></a>
<FONT color="green">14004</FONT>          graphicsPanel.setWidgetPosition(w, 0, 0);<a name="line.14004"></a>
<FONT color="green">14005</FONT>        }<a name="line.14005"></a>
<FONT color="green">14006</FONT>    <a name="line.14006"></a>
<FONT color="green">14007</FONT>        /*<a name="line.14007"></a>
<FONT color="green">14008</FONT>         * Adds a sub-panel of this plot panel that contains the widgets used to<a name="line.14008"></a>
<FONT color="green">14009</FONT>         * render the annnotations of the given curve &lt;p&gt;<a name="line.14009"></a>
<FONT color="green">14010</FONT>         * <a name="line.14010"></a>
<FONT color="green">14011</FONT>         * This method must be called just after a new curve is added to the chart,<a name="line.14011"></a>
<FONT color="green">14012</FONT>         * to add its associated annotation rendering panel; GChart assumes each<a name="line.14012"></a>
<FONT color="green">14013</FONT>         * curve has a correspondingly indexed rendering panel during updates.<a name="line.14013"></a>
<FONT color="green">14014</FONT>         */<a name="line.14014"></a>
<FONT color="green">14015</FONT>    <a name="line.14015"></a>
<FONT color="green">14016</FONT>        void addAnnotationRenderingPanel(int rpIndex) {<a name="line.14016"></a>
<FONT color="green">14017</FONT>          final boolean domInsert = true;<a name="line.14017"></a>
<FONT color="green">14018</FONT>          AnnotationRenderingPanel w = new AnnotationRenderingPanel();<a name="line.14018"></a>
<FONT color="green">14019</FONT>          annotationPanel.insert(w, annotationPanel.getElement(), rpIndex,<a name="line.14019"></a>
<FONT color="green">14020</FONT>              domInsert);<a name="line.14020"></a>
<FONT color="green">14021</FONT>          annotationPanel.setWidgetPosition(w, 0, 0);<a name="line.14021"></a>
<FONT color="green">14022</FONT>        }<a name="line.14022"></a>
<FONT color="green">14023</FONT>    <a name="line.14023"></a>
<FONT color="green">14024</FONT>        /*<a name="line.14024"></a>
<FONT color="green">14025</FONT>         * Removes the rendering panel of the curve with the given internal index on<a name="line.14025"></a>
<FONT color="green">14026</FONT>         * the curves list. &lt;p&gt;<a name="line.14026"></a>
<FONT color="green">14027</FONT>         * <a name="line.14027"></a>
<FONT color="green">14028</FONT>         * This method must be called just before a curve is removed from the chart,<a name="line.14028"></a>
<FONT color="green">14029</FONT>         * to remove the widgets used to render that curve in the browser.<a name="line.14029"></a>
<FONT color="green">14030</FONT>         */<a name="line.14030"></a>
<FONT color="green">14031</FONT>        void removeGraphicsRenderingPanel(int rpIndex) {<a name="line.14031"></a>
<FONT color="green">14032</FONT>          graphicsPanel.remove(rpIndex);<a name="line.14032"></a>
<FONT color="green">14033</FONT>        }<a name="line.14033"></a>
<FONT color="green">14034</FONT>    <a name="line.14034"></a>
<FONT color="green">14035</FONT>        void removeAnnotationRenderingPanel(int rpIndex) {<a name="line.14035"></a>
<FONT color="green">14036</FONT>          annotationPanel.remove(rpIndex);<a name="line.14036"></a>
<FONT color="green">14037</FONT>        }<a name="line.14037"></a>
<FONT color="green">14038</FONT>    <a name="line.14038"></a>
<FONT color="green">14039</FONT>        /*<a name="line.14039"></a>
<FONT color="green">14040</FONT>         * Returns panel used to render the graphical elements of the curve with the<a name="line.14040"></a>
<FONT color="green">14041</FONT>         * given rendering panel index.<a name="line.14041"></a>
<FONT color="green">14042</FONT>         */<a name="line.14042"></a>
<FONT color="green">14043</FONT>        GraphicsRenderingPanel getGraphicsRenderingPanel(int rpIndex) {<a name="line.14043"></a>
<FONT color="green">14044</FONT>          if (0 == graphicsPanel.getWidgetCount()) // for lazy addition<a name="line.14044"></a>
<FONT color="green">14045</FONT>            // smaller,faster if all background curves put on single panel<a name="line.14045"></a>
<FONT color="green">14046</FONT>            for (int i = N_PRE_SYSTEM_CURVES - 1; i &lt; curves.size(); i++) {<a name="line.14046"></a>
<FONT color="green">14047</FONT>              int rpInd = getRenderingPanelIndex(i);<a name="line.14047"></a>
<FONT color="green">14048</FONT>              addGraphicsRenderingPanel(rpInd);<a name="line.14048"></a>
<FONT color="green">14049</FONT>            }<a name="line.14049"></a>
<FONT color="green">14050</FONT>          GraphicsRenderingPanel result = (GraphicsRenderingPanel) (graphicsPanel<a name="line.14050"></a>
<FONT color="green">14051</FONT>              .getWidget(rpIndex));<a name="line.14051"></a>
<FONT color="green">14052</FONT>          return result;<a name="line.14052"></a>
<FONT color="green">14053</FONT>        }<a name="line.14053"></a>
<FONT color="green">14054</FONT>    <a name="line.14054"></a>
<FONT color="green">14055</FONT>        /*<a name="line.14055"></a>
<FONT color="green">14056</FONT>         * Returns panel used to render the textual elements of the curve with the<a name="line.14056"></a>
<FONT color="green">14057</FONT>         * given rendering panel index.<a name="line.14057"></a>
<FONT color="green">14058</FONT>         */<a name="line.14058"></a>
<FONT color="green">14059</FONT>        AnnotationRenderingPanel getAnnotationRenderingPanel(int rpIndex) {<a name="line.14059"></a>
<FONT color="green">14060</FONT>          if (0 == annotationPanel.getWidgetCount()) // for lazy addition<a name="line.14060"></a>
<FONT color="green">14061</FONT>            // smaller,faster if all background curves put on single panel<a name="line.14061"></a>
<FONT color="green">14062</FONT>            for (int i = N_PRE_SYSTEM_CURVES - 1; i &lt; curves.size(); i++) {<a name="line.14062"></a>
<FONT color="green">14063</FONT>              int rpInd = getRenderingPanelIndex(i);<a name="line.14063"></a>
<FONT color="green">14064</FONT>              addAnnotationRenderingPanel(rpInd);<a name="line.14064"></a>
<FONT color="green">14065</FONT>            }<a name="line.14065"></a>
<FONT color="green">14066</FONT>          AnnotationRenderingPanel result = (AnnotationRenderingPanel) (annotationPanel<a name="line.14066"></a>
<FONT color="green">14067</FONT>              .getWidget(rpIndex));<a name="line.14067"></a>
<FONT color="green">14068</FONT>          return result;<a name="line.14068"></a>
<FONT color="green">14069</FONT>        }<a name="line.14069"></a>
<FONT color="green">14070</FONT>    <a name="line.14070"></a>
<FONT color="green">14071</FONT>        int getClientX() {<a name="line.14071"></a>
<FONT color="green">14072</FONT>          return clientX;<a name="line.14072"></a>
<FONT color="green">14073</FONT>        }<a name="line.14073"></a>
<FONT color="green">14074</FONT>    <a name="line.14074"></a>
<FONT color="green">14075</FONT>        void setClientX(int clientX, boolean isClick) {<a name="line.14075"></a>
<FONT color="green">14076</FONT>          /*<a name="line.14076"></a>
<FONT color="green">14077</FONT>           * Due to presumed bugs in FF2 and Chrome, space-bar clicking on<a name="line.14077"></a>
<FONT color="green">14078</FONT>           * TestGChart25's "rotate" button produces bogus 0 and/or (in Chrome)<a name="line.14078"></a>
<FONT color="green">14079</FONT>           * seemingly random negative return values from &lt;tt&gt;event.getClient[XY]<a name="line.14079"></a>
<FONT color="green">14080</FONT>           * with the ONCLICK event. IE7 produces correct mouse coordinates for<a name="line.14080"></a>
<FONT color="green">14081</FONT>           * Event.ONCLICK in this case. The bogus coordinates, if not corrected,<a name="line.14081"></a>
<FONT color="green">14082</FONT>           * generate bogus "mouse moved off chart"-like actions (in TestGChart25,<a name="line.14082"></a>
<FONT color="green">14083</FONT>           * Chrome produces inappropriate deselection of the hovered over point<a name="line.14083"></a>
<FONT color="green">14084</FONT>           * after a space-bar invoked update)&lt;p&gt;<a name="line.14084"></a>
<FONT color="green">14085</FONT>           * <a name="line.14085"></a>
<FONT color="green">14086</FONT>           * Workaround is to just ignore any 0 or negative coordinates--thus using<a name="line.14086"></a>
<FONT color="green">14087</FONT>           * the last valid coordinates seen by the chart's mouse tracking code in<a name="line.14087"></a>
<FONT color="green">14088</FONT>           * lieu of the bogus ones.<a name="line.14088"></a>
<FONT color="green">14089</FONT>           * <a name="line.14089"></a>
<FONT color="green">14090</FONT>           * &lt;p&gt;<a name="line.14090"></a>
<FONT color="green">14091</FONT>           * <a name="line.14091"></a>
<FONT color="green">14092</FONT>           * The resulting 1px "partly-dead" band at the top and left edges of the<a name="line.14092"></a>
<FONT color="green">14093</FONT>           * client area due to this workaround (0 is a valid client coordinate) is<a name="line.14093"></a>
<FONT color="green">14094</FONT>           * unlikely to be a significant problem, since clicked-on stuff is rarely<a name="line.14094"></a>
<FONT color="green">14095</FONT>           * clicked on right along the edges of the client area. &lt;p&gt;<a name="line.14095"></a>
<FONT color="green">14096</FONT>           */<a name="line.14096"></a>
<FONT color="green">14097</FONT>          if (clientX &lt;= 0 &amp;&amp; isClick)<a name="line.14097"></a>
<FONT color="green">14098</FONT>            return;<a name="line.14098"></a>
<FONT color="green">14099</FONT>          else if (clientX &lt; 0)<a name="line.14099"></a>
<FONT color="green">14100</FONT>            // some browsers (e.g. FF2) use -1 to indicate undefined mouse<a name="line.14100"></a>
<FONT color="green">14101</FONT>            // coords.<a name="line.14101"></a>
<FONT color="green">14102</FONT>            clientX = GChart.NAI;<a name="line.14102"></a>
<FONT color="green">14103</FONT>    <a name="line.14103"></a>
<FONT color="green">14104</FONT>          this.clientX = clientX;<a name="line.14104"></a>
<FONT color="green">14105</FONT>          // computing this on-the-fly is VERY expensive, so we retain it<a name="line.14105"></a>
<FONT color="green">14106</FONT>          // (the buffering can be wrong in unusual scrolling scenarios)<a name="line.14106"></a>
<FONT color="green">14107</FONT>          xMouse = (GChart.NAI == clientX) ? GChart.NAI : (Window<a name="line.14107"></a>
<FONT color="green">14108</FONT>              .getScrollLeft()<a name="line.14108"></a>
<FONT color="green">14109</FONT>              + clientX - getAbsoluteLeft());<a name="line.14109"></a>
<FONT color="green">14110</FONT>        }<a name="line.14110"></a>
<FONT color="green">14111</FONT>    <a name="line.14111"></a>
<FONT color="green">14112</FONT>        int getClientY() {<a name="line.14112"></a>
<FONT color="green">14113</FONT>          return clientY;<a name="line.14113"></a>
<FONT color="green">14114</FONT>        }<a name="line.14114"></a>
<FONT color="green">14115</FONT>    <a name="line.14115"></a>
<FONT color="green">14116</FONT>        // See comments on analogous lines in setClientX above<a name="line.14116"></a>
<FONT color="green">14117</FONT>        void setClientY(int clientY, boolean isClick) {<a name="line.14117"></a>
<FONT color="green">14118</FONT>          if (clientY &lt;= 0 &amp;&amp; isClick)<a name="line.14118"></a>
<FONT color="green">14119</FONT>            return;<a name="line.14119"></a>
<FONT color="green">14120</FONT>          else if (clientY &lt; 0)<a name="line.14120"></a>
<FONT color="green">14121</FONT>            clientY = GChart.NAI;<a name="line.14121"></a>
<FONT color="green">14122</FONT>    <a name="line.14122"></a>
<FONT color="green">14123</FONT>          this.clientY = clientY;<a name="line.14123"></a>
<FONT color="green">14124</FONT>          yMouse = (GChart.NAI == clientY) ? GChart.NAI : (Window<a name="line.14124"></a>
<FONT color="green">14125</FONT>              .getScrollTop()<a name="line.14125"></a>
<FONT color="green">14126</FONT>              + clientY - getAbsoluteTop());<a name="line.14126"></a>
<FONT color="green">14127</FONT>        }<a name="line.14127"></a>
<FONT color="green">14128</FONT>    <a name="line.14128"></a>
<FONT color="green">14129</FONT>        /*<a name="line.14129"></a>
<FONT color="green">14130</FONT>         * In IE drop-down list boxes, when you enter the dropdown part of the list,<a name="line.14130"></a>
<FONT color="green">14131</FONT>         * client coordinates suddenly become -1, -1 (presumably IE's way of saying<a name="line.14131"></a>
<FONT color="green">14132</FONT>         * it won't tell you what they are; apparently the dropdown part of the list<a name="line.14132"></a>
<FONT color="green">14133</FONT>         * isn't in the DOM) These repair methods replace such impossible client<a name="line.14133"></a>
<FONT color="green">14134</FONT>         * coordinates with the last valid coordinates. &lt;p&gt;<a name="line.14134"></a>
<FONT color="green">14135</FONT>         * <a name="line.14135"></a>
<FONT color="green">14136</FONT>         * Without this patch, the geometric "within the hover widget" test on<a name="line.14136"></a>
<FONT color="green">14137</FONT>         * GChartExample20a fails in IE7: as soon as user mouses into the dropdown<a name="line.14137"></a>
<FONT color="green">14138</FONT>         * list, the entire hover widget is closed. &lt;p&gt;<a name="line.14138"></a>
<FONT color="green">14139</FONT>         */<a name="line.14139"></a>
<FONT color="green">14140</FONT>        private int repairBadClientX(int x) {<a name="line.14140"></a>
<FONT color="green">14141</FONT>          if (x &lt;= 0) // 0 isn't strictly bad, but its one of the<a name="line.14141"></a>
<FONT color="green">14142</FONT>            // bad values that can pop up in some browsers.<a name="line.14142"></a>
<FONT color="green">14143</FONT>            return clientX;<a name="line.14143"></a>
<FONT color="green">14144</FONT>          else<a name="line.14144"></a>
<FONT color="green">14145</FONT>            return x;<a name="line.14145"></a>
<FONT color="green">14146</FONT>        }<a name="line.14146"></a>
<FONT color="green">14147</FONT>    <a name="line.14147"></a>
<FONT color="green">14148</FONT>        private int repairBadClientY(int y) {<a name="line.14148"></a>
<FONT color="green">14149</FONT>          if (y &lt;= 0)<a name="line.14149"></a>
<FONT color="green">14150</FONT>            return clientY;<a name="line.14150"></a>
<FONT color="green">14151</FONT>          else<a name="line.14151"></a>
<FONT color="green">14152</FONT>            return y;<a name="line.14152"></a>
<FONT color="green">14153</FONT>        }<a name="line.14153"></a>
<FONT color="green">14154</FONT>    <a name="line.14154"></a>
<FONT color="green">14155</FONT>        int getXMouse() {<a name="line.14155"></a>
<FONT color="green">14156</FONT>          return xMouse;<a name="line.14156"></a>
<FONT color="green">14157</FONT>        }<a name="line.14157"></a>
<FONT color="green">14158</FONT>    <a name="line.14158"></a>
<FONT color="green">14159</FONT>        int getYMouse() {<a name="line.14159"></a>
<FONT color="green">14160</FONT>          return yMouse;<a name="line.14160"></a>
<FONT color="green">14161</FONT>        }<a name="line.14161"></a>
<FONT color="green">14162</FONT>    <a name="line.14162"></a>
<FONT color="green">14163</FONT>        // Mouse x position relative to plot area upper left corner.<a name="line.14163"></a>
<FONT color="green">14164</FONT>        int getXMousePlotArea() {<a name="line.14164"></a>
<FONT color="green">14165</FONT>          int result = xMouse - leftOfYWidth;<a name="line.14165"></a>
<FONT color="green">14166</FONT>          return result;<a name="line.14166"></a>
<FONT color="green">14167</FONT>        }<a name="line.14167"></a>
<FONT color="green">14168</FONT>    <a name="line.14168"></a>
<FONT color="green">14169</FONT>        // Mouse y position relative to plot area upper left corner.<a name="line.14169"></a>
<FONT color="green">14170</FONT>        int getYMousePlotArea() {<a name="line.14170"></a>
<FONT color="green">14171</FONT>          int result = yMouse - topMargin;<a name="line.14171"></a>
<FONT color="green">14172</FONT>          return result;<a name="line.14172"></a>
<FONT color="green">14173</FONT>        }<a name="line.14173"></a>
<FONT color="green">14174</FONT>    <a name="line.14174"></a>
<FONT color="green">14175</FONT>        PlotPanel() {<a name="line.14175"></a>
<FONT color="green">14176</FONT>          super();<a name="line.14176"></a>
<FONT color="green">14177</FONT>          // allows labels, symbols, that extend a tad off the<a name="line.14177"></a>
<FONT color="green">14178</FONT>          // chart proper to still appear on the chart; AbsolutePanel<a name="line.14178"></a>
<FONT color="green">14179</FONT>          // default is to truncate these.<a name="line.14179"></a>
<FONT color="green">14180</FONT>          GChart.setOverflow(this, "visible");<a name="line.14180"></a>
<FONT color="green">14181</FONT>          GChart.setOverflow(graphicsPanel, "visible");<a name="line.14181"></a>
<FONT color="green">14182</FONT>          GChart.setOverflow(annotationPanel, "visible");<a name="line.14182"></a>
<FONT color="green">14183</FONT>          // these sub-panels have no size themselves, they are merely<a name="line.14183"></a>
<FONT color="green">14184</FONT>          // there to segregate the graphical and annotation parts of chart<a name="line.14184"></a>
<FONT color="green">14185</FONT>          graphicsPanel.setPixelSize(0, 0);<a name="line.14185"></a>
<FONT color="green">14186</FONT>          annotationPanel.setPixelSize(0, 0);<a name="line.14186"></a>
<FONT color="green">14187</FONT>          // this order assures all the annotations are on top of all the<a name="line.14187"></a>
<FONT color="green">14188</FONT>          // graphics<a name="line.14188"></a>
<FONT color="green">14189</FONT>          this.add(graphicsPanel, 0, 0);<a name="line.14189"></a>
<FONT color="green">14190</FONT>          this.add(annotationPanel, 0, 0);<a name="line.14190"></a>
<FONT color="green">14191</FONT>          // events for hover selection feedback, click event handling<a name="line.14191"></a>
<FONT color="green">14192</FONT>          sinkEvents(Event.ONMOUSEMOVE | Event.ONMOUSEOUT | Event.ONCLICK<a name="line.14192"></a>
<FONT color="green">14193</FONT>              | Event.ONMOUSEOVER);<a name="line.14193"></a>
<FONT color="green">14194</FONT>        }<a name="line.14194"></a>
<FONT color="green">14195</FONT>    <a name="line.14195"></a>
<FONT color="green">14196</FONT>        int getXAxisEnsembleHeight() {<a name="line.14196"></a>
<FONT color="green">14197</FONT>          return xAxisEnsembleHeight;<a name="line.14197"></a>
<FONT color="green">14198</FONT>        }<a name="line.14198"></a>
<FONT color="green">14199</FONT>    <a name="line.14199"></a>
<FONT color="green">14200</FONT>        double getXMax() {<a name="line.14200"></a>
<FONT color="green">14201</FONT>          return xMax;<a name="line.14201"></a>
<FONT color="green">14202</FONT>        }<a name="line.14202"></a>
<FONT color="green">14203</FONT>    <a name="line.14203"></a>
<FONT color="green">14204</FONT>        double getXMin() {<a name="line.14204"></a>
<FONT color="green">14205</FONT>          return xMin;<a name="line.14205"></a>
<FONT color="green">14206</FONT>        }<a name="line.14206"></a>
<FONT color="green">14207</FONT>    <a name="line.14207"></a>
<FONT color="green">14208</FONT>        int getY2AxisEnsembleWidth() {<a name="line.14208"></a>
<FONT color="green">14209</FONT>          return y2AxisEnsembleWidth;<a name="line.14209"></a>
<FONT color="green">14210</FONT>        }<a name="line.14210"></a>
<FONT color="green">14211</FONT>    <a name="line.14211"></a>
<FONT color="green">14212</FONT>        int getRightOfY2Width() {<a name="line.14212"></a>
<FONT color="green">14213</FONT>          return rightOfY2Width;<a name="line.14213"></a>
<FONT color="green">14214</FONT>        }<a name="line.14214"></a>
<FONT color="green">14215</FONT>    <a name="line.14215"></a>
<FONT color="green">14216</FONT>        double getY2Max() {<a name="line.14216"></a>
<FONT color="green">14217</FONT>          return y2Max;<a name="line.14217"></a>
<FONT color="green">14218</FONT>        }<a name="line.14218"></a>
<FONT color="green">14219</FONT>    <a name="line.14219"></a>
<FONT color="green">14220</FONT>        double getY2Min() {<a name="line.14220"></a>
<FONT color="green">14221</FONT>          return y2Min;<a name="line.14221"></a>
<FONT color="green">14222</FONT>        }<a name="line.14222"></a>
<FONT color="green">14223</FONT>    <a name="line.14223"></a>
<FONT color="green">14224</FONT>        int getYAxisEnsembleWidth() {<a name="line.14224"></a>
<FONT color="green">14225</FONT>          return yAxisEnsembleWidth;<a name="line.14225"></a>
<FONT color="green">14226</FONT>        }<a name="line.14226"></a>
<FONT color="green">14227</FONT>    <a name="line.14227"></a>
<FONT color="green">14228</FONT>        int getLeftOfYWidth() {<a name="line.14228"></a>
<FONT color="green">14229</FONT>          return leftOfYWidth;<a name="line.14229"></a>
<FONT color="green">14230</FONT>        }<a name="line.14230"></a>
<FONT color="green">14231</FONT>    <a name="line.14231"></a>
<FONT color="green">14232</FONT>        // is the given x,y point out of the plot area hard limits?<a name="line.14232"></a>
<FONT color="green">14233</FONT>        boolean isOutOfBounds(double x, double y, boolean onY2) {<a name="line.14233"></a>
<FONT color="green">14234</FONT>          // next line makes 2,000 pt sin curve of live demo 5% faster<a name="line.14234"></a>
<FONT color="green">14235</FONT>          if (outOfBoundsCheckingDisabled)<a name="line.14235"></a>
<FONT color="green">14236</FONT>            return false;<a name="line.14236"></a>
<FONT color="green">14237</FONT>          boolean result = false;<a name="line.14237"></a>
<FONT color="green">14238</FONT>          boolean xAtAxisExtrema = (Double.MAX_VALUE == x || -Double.MAX_VALUE == x);<a name="line.14238"></a>
<FONT color="green">14239</FONT>          boolean yAtAxisExtrema = (Double.MAX_VALUE == y || -Double.MAX_VALUE == y);<a name="line.14239"></a>
<FONT color="green">14240</FONT>    <a name="line.14240"></a>
<FONT color="green">14241</FONT>          if (!xAtAxisExtrema &amp;&amp; (x &lt; xLB || xUB &lt; x))<a name="line.14241"></a>
<FONT color="green">14242</FONT>            result = true;<a name="line.14242"></a>
<FONT color="green">14243</FONT>          else if (!yAtAxisExtrema &amp;&amp; !onY2 &amp;&amp; (y &lt; yLB || yUB &lt; y))<a name="line.14243"></a>
<FONT color="green">14244</FONT>            result = true;<a name="line.14244"></a>
<FONT color="green">14245</FONT>          else if (!yAtAxisExtrema &amp;&amp; onY2 &amp;&amp; (y &lt; y2LB || y2UB &lt; y))<a name="line.14245"></a>
<FONT color="green">14246</FONT>            result = true;<a name="line.14246"></a>
<FONT color="green">14247</FONT>          return result;<a name="line.14247"></a>
<FONT color="green">14248</FONT>        }<a name="line.14248"></a>
<FONT color="green">14249</FONT>    <a name="line.14249"></a>
<FONT color="green">14250</FONT>        int legendThickness() {<a name="line.14250"></a>
<FONT color="green">14251</FONT>          return chartLegendThickness;<a name="line.14251"></a>
<FONT color="green">14252</FONT>        }<a name="line.14252"></a>
<FONT color="green">14253</FONT>    <a name="line.14253"></a>
<FONT color="green">14254</FONT>        int chartFootnotesThickness() {<a name="line.14254"></a>
<FONT color="green">14255</FONT>          return chartFootnotesThickness;<a name="line.14255"></a>
<FONT color="green">14256</FONT>        }<a name="line.14256"></a>
<FONT color="green">14257</FONT>    <a name="line.14257"></a>
<FONT color="green">14258</FONT>        int chartTitleThickness() {<a name="line.14258"></a>
<FONT color="green">14259</FONT>          return topMargin;<a name="line.14259"></a>
<FONT color="green">14260</FONT>        }<a name="line.14260"></a>
<FONT color="green">14261</FONT>    <a name="line.14261"></a>
<FONT color="green">14262</FONT>        double getYMax() {<a name="line.14262"></a>
<FONT color="green">14263</FONT>          return yMax;<a name="line.14263"></a>
<FONT color="green">14264</FONT>        }<a name="line.14264"></a>
<FONT color="green">14265</FONT>    <a name="line.14265"></a>
<FONT color="green">14266</FONT>        double getYMin() {<a name="line.14266"></a>
<FONT color="green">14267</FONT>          return yMin;<a name="line.14267"></a>
<FONT color="green">14268</FONT>        }<a name="line.14268"></a>
<FONT color="green">14269</FONT>    <a name="line.14269"></a>
<FONT color="green">14270</FONT>        void reset(int xChartSize, int yChartSize, boolean hasYAxis,<a name="line.14270"></a>
<FONT color="green">14271</FONT>            boolean hasY2Axis, Axis xAxis, Axis yAxis, Axis y2Axis) {<a name="line.14271"></a>
<FONT color="green">14272</FONT>    <a name="line.14272"></a>
<FONT color="green">14273</FONT>          // these must come first (getTickLabelThickness(false) needs them)<a name="line.14273"></a>
<FONT color="green">14274</FONT>          getXAxis().maybePopulateTicks();<a name="line.14274"></a>
<FONT color="green">14275</FONT>          getYAxis().maybePopulateTicks();<a name="line.14275"></a>
<FONT color="green">14276</FONT>          getY2Axis().maybePopulateTicks();<a name="line.14276"></a>
<FONT color="green">14277</FONT>    <a name="line.14277"></a>
<FONT color="green">14278</FONT>          this.xChartSize = xChartSize;<a name="line.14278"></a>
<FONT color="green">14279</FONT>          this.yChartSize = yChartSize;<a name="line.14279"></a>
<FONT color="green">14280</FONT>    <a name="line.14280"></a>
<FONT color="green">14281</FONT>          Axis.AxisLimits axisLimits = xAxis.getAxisLimits();<a name="line.14281"></a>
<FONT color="green">14282</FONT>          xMin = axisLimits.min;<a name="line.14282"></a>
<FONT color="green">14283</FONT>          xMax = axisLimits.max;<a name="line.14283"></a>
<FONT color="green">14284</FONT>          double b0 = Math.min(xMin, xMax);<a name="line.14284"></a>
<FONT color="green">14285</FONT>          double b1 = Math.max(xMin, xMax);<a name="line.14285"></a>
<FONT color="green">14286</FONT>          double db = getXAxis().getOutOfBoundsMultiplier() * (b1 - b0);<a name="line.14286"></a>
<FONT color="green">14287</FONT>          xLB = b0 - db;<a name="line.14287"></a>
<FONT color="green">14288</FONT>          xUB = b1 + db;<a name="line.14288"></a>
<FONT color="green">14289</FONT>          axisLimits = yAxis.getAxisLimits();<a name="line.14289"></a>
<FONT color="green">14290</FONT>          yMin = axisLimits.min;<a name="line.14290"></a>
<FONT color="green">14291</FONT>          yMax = axisLimits.max;<a name="line.14291"></a>
<FONT color="green">14292</FONT>          b0 = Math.min(yMin, yMax);<a name="line.14292"></a>
<FONT color="green">14293</FONT>          b1 = Math.max(yMin, yMax);<a name="line.14293"></a>
<FONT color="green">14294</FONT>          db = getYAxis().getOutOfBoundsMultiplier() * (b1 - b0);<a name="line.14294"></a>
<FONT color="green">14295</FONT>          yLB = b0 - db;<a name="line.14295"></a>
<FONT color="green">14296</FONT>          yUB = b1 + db;<a name="line.14296"></a>
<FONT color="green">14297</FONT>          axisLimits = y2Axis.getAxisLimits();<a name="line.14297"></a>
<FONT color="green">14298</FONT>          y2Min = axisLimits.min;<a name="line.14298"></a>
<FONT color="green">14299</FONT>          y2Max = axisLimits.max;<a name="line.14299"></a>
<FONT color="green">14300</FONT>          b0 = Math.min(y2Min, y2Max);<a name="line.14300"></a>
<FONT color="green">14301</FONT>          b1 = Math.max(y2Min, y2Max);<a name="line.14301"></a>
<FONT color="green">14302</FONT>          db = getY2Axis().getOutOfBoundsMultiplier() * (b1 - b0);<a name="line.14302"></a>
<FONT color="green">14303</FONT>          y2LB = b0 - db;<a name="line.14303"></a>
<FONT color="green">14304</FONT>          y2UB = b1 + db;<a name="line.14304"></a>
<FONT color="green">14305</FONT>    <a name="line.14305"></a>
<FONT color="green">14306</FONT>          // if all bounds are undefined, checking is not needed<a name="line.14306"></a>
<FONT color="green">14307</FONT>          outOfBoundsCheckingDisabled = (xLB != xLB &amp;&amp; yLB != yLB &amp;&amp; y2LB != y2LB);<a name="line.14307"></a>
<FONT color="green">14308</FONT>    <a name="line.14308"></a>
<FONT color="green">14309</FONT>          topMargin = getChartTitleThickness();<a name="line.14309"></a>
<FONT color="green">14310</FONT>    <a name="line.14310"></a>
<FONT color="green">14311</FONT>          xAxisEnsembleHeight = xAxis.getAxisLabelThickness()<a name="line.14311"></a>
<FONT color="green">14312</FONT>              + xAxis.getTickLabelThickness(false) + xAxis.getTickSpace()<a name="line.14312"></a>
<FONT color="green">14313</FONT>              + xAxis.getTickLabelPadding();<a name="line.14313"></a>
<FONT color="green">14314</FONT>          yAxisEnsembleWidth = yAxis.getAxisLabelThickness()<a name="line.14314"></a>
<FONT color="green">14315</FONT>              + yAxis.getTickLabelThickness(false) + yAxis.getTickSpace()<a name="line.14315"></a>
<FONT color="green">14316</FONT>              + yAxis.getTickLabelPadding();<a name="line.14316"></a>
<FONT color="green">14317</FONT>          leftOfYWidth = legendLocation.getLeftThickness(GChart.this)<a name="line.14317"></a>
<FONT color="green">14318</FONT>              + yAxisEnsembleWidth;<a name="line.14318"></a>
<FONT color="green">14319</FONT>          y2AxisEnsembleWidth = y2Axis.getAxisLabelThickness()<a name="line.14319"></a>
<FONT color="green">14320</FONT>              + y2Axis.getTickLabelThickness(false)<a name="line.14320"></a>
<FONT color="green">14321</FONT>              + y2Axis.getTickSpace() + y2Axis.getTickLabelPadding();<a name="line.14321"></a>
<FONT color="green">14322</FONT>          rightOfY2Width = legendLocation.getRightThickness(GChart.this)<a name="line.14322"></a>
<FONT color="green">14323</FONT>              + y2AxisEnsembleWidth;<a name="line.14323"></a>
<FONT color="green">14324</FONT>          chartLegendThickness = getLegendThickness();<a name="line.14324"></a>
<FONT color="green">14325</FONT>          chartFootnotesThickness = getChartFootnotesThickness();<a name="line.14325"></a>
<FONT color="green">14326</FONT>    <a name="line.14326"></a>
<FONT color="green">14327</FONT>          setPixelSize(getXChartSizeDecoratedQuickly(),<a name="line.14327"></a>
<FONT color="green">14328</FONT>              getYChartSizeDecoratedQuickly());<a name="line.14328"></a>
<FONT color="green">14329</FONT>    <a name="line.14329"></a>
<FONT color="green">14330</FONT>          setWidgetPosition(graphicsPanel, leftOfYWidth, topMargin);<a name="line.14330"></a>
<FONT color="green">14331</FONT>          setWidgetPosition(annotationPanel, leftOfYWidth, topMargin);<a name="line.14331"></a>
<FONT color="green">14332</FONT>    <a name="line.14332"></a>
<FONT color="green">14333</FONT>          // if there are any existing graphical rendering panels, bring<a name="line.14333"></a>
<FONT color="green">14334</FONT>          // their clipping specs into agreement with the chartspecs<a name="line.14334"></a>
<FONT color="green">14335</FONT>          for (int i = 0; i &lt; getRenderingPanelCount(); i++) {<a name="line.14335"></a>
<FONT color="green">14336</FONT>            GraphicsRenderingPanel grp = (GraphicsRenderingPanel) graphicsPanel<a name="line.14336"></a>
<FONT color="green">14337</FONT>                .getWidget(i);<a name="line.14337"></a>
<FONT color="green">14338</FONT>            if (getCurveFromRenderingPanelIndex(i).getClippedToPlotArea()) {<a name="line.14338"></a>
<FONT color="green">14339</FONT>              grp.setPixelSize(getXChartSize(), getYChartSize());<a name="line.14339"></a>
<FONT color="green">14340</FONT>              GChart.setOverflow(grp, "hidden");<a name="line.14340"></a>
<FONT color="green">14341</FONT>            } else {<a name="line.14341"></a>
<FONT color="green">14342</FONT>              grp.setPixelSize(0, 0);<a name="line.14342"></a>
<FONT color="green">14343</FONT>              GChart.setOverflow(grp, "visible");<a name="line.14343"></a>
<FONT color="green">14344</FONT>            }<a name="line.14344"></a>
<FONT color="green">14345</FONT>          }<a name="line.14345"></a>
<FONT color="green">14346</FONT>        }<a name="line.14346"></a>
<FONT color="green">14347</FONT>    <a name="line.14347"></a>
<FONT color="green">14348</FONT>        double xToChartPixel(double x) {<a name="line.14348"></a>
<FONT color="green">14349</FONT>          double result = Double.NaN;<a name="line.14349"></a>
<FONT color="green">14350</FONT>          if (-Double.MAX_VALUE == x)<a name="line.14350"></a>
<FONT color="green">14351</FONT>            result = leftOfYWidth;<a name="line.14351"></a>
<FONT color="green">14352</FONT>          else if (Double.MAX_VALUE == x)<a name="line.14352"></a>
<FONT color="green">14353</FONT>            result = leftOfYWidth + xChartSize - 1.0;<a name="line.14353"></a>
<FONT color="green">14354</FONT>          else if (!(x != x)) { // x!=x is a faster isNaN<a name="line.14354"></a>
<FONT color="green">14355</FONT>            result = (leftOfYWidth * (xMax - x) + (leftOfYWidth<a name="line.14355"></a>
<FONT color="green">14356</FONT>                + xChartSize - 1.0)<a name="line.14356"></a>
<FONT color="green">14357</FONT>                * (x - xMin))<a name="line.14357"></a>
<FONT color="green">14358</FONT>                / (xMax - xMin);<a name="line.14358"></a>
<FONT color="green">14359</FONT>          }<a name="line.14359"></a>
<FONT color="green">14360</FONT>    <a name="line.14360"></a>
<FONT color="green">14361</FONT>          return result;<a name="line.14361"></a>
<FONT color="green">14362</FONT>        }<a name="line.14362"></a>
<FONT color="green">14363</FONT>    <a name="line.14363"></a>
<FONT color="green">14364</FONT>        double xToPixel(double x) {<a name="line.14364"></a>
<FONT color="green">14365</FONT>          double result = Double.NaN;<a name="line.14365"></a>
<FONT color="green">14366</FONT>          if (-Double.MAX_VALUE == x)<a name="line.14366"></a>
<FONT color="green">14367</FONT>            result = 0;<a name="line.14367"></a>
<FONT color="green">14368</FONT>          else if (Double.MAX_VALUE == x)<a name="line.14368"></a>
<FONT color="green">14369</FONT>            result = xChartSize - 1.0;<a name="line.14369"></a>
<FONT color="green">14370</FONT>          else if (!(x != x)) { // x!=x is a faster isNaN<a name="line.14370"></a>
<FONT color="green">14371</FONT>            result = (xChartSize - 1.0) * (x - xMin) / (xMax - xMin);<a name="line.14371"></a>
<FONT color="green">14372</FONT>          }<a name="line.14372"></a>
<FONT color="green">14373</FONT>          return result;<a name="line.14373"></a>
<FONT color="green">14374</FONT>        }<a name="line.14374"></a>
<FONT color="green">14375</FONT>    <a name="line.14375"></a>
<FONT color="green">14376</FONT>        double xChartPixelToX(int xPx) {<a name="line.14376"></a>
<FONT color="green">14377</FONT>          double result = Double.NaN;<a name="line.14377"></a>
<FONT color="green">14378</FONT>          if (GChart.NAI != xPx &amp;&amp; xChartSize &gt; 1) {<a name="line.14378"></a>
<FONT color="green">14379</FONT>            result = xMin + (xMax - xMin) * (xPx - leftOfYWidth)<a name="line.14379"></a>
<FONT color="green">14380</FONT>                / (xChartSize - 1.);<a name="line.14380"></a>
<FONT color="green">14381</FONT>          }<a name="line.14381"></a>
<FONT color="green">14382</FONT>          return result;<a name="line.14382"></a>
<FONT color="green">14383</FONT>        }<a name="line.14383"></a>
<FONT color="green">14384</FONT>    <a name="line.14384"></a>
<FONT color="green">14385</FONT>        double xPixelToX(int xPx) {<a name="line.14385"></a>
<FONT color="green">14386</FONT>          double result = Double.NaN;<a name="line.14386"></a>
<FONT color="green">14387</FONT>          if (GChart.NAI != xPx &amp;&amp; xChartSize &gt; 1) {<a name="line.14387"></a>
<FONT color="green">14388</FONT>            result = xMin + (xMax - xMin) * xPx / (xChartSize - 1.);<a name="line.14388"></a>
<FONT color="green">14389</FONT>          }<a name="line.14389"></a>
<FONT color="green">14390</FONT>          return result;<a name="line.14390"></a>
<FONT color="green">14391</FONT>        }<a name="line.14391"></a>
<FONT color="green">14392</FONT>    <a name="line.14392"></a>
<FONT color="green">14393</FONT>        double dxToPixel(double dx) {<a name="line.14393"></a>
<FONT color="green">14394</FONT>          // xMax and xMin are at centers of their pixels, hence the -1<a name="line.14394"></a>
<FONT color="green">14395</FONT>          double result = (dx * (xChartSize - 1)) / (xMax - xMin);<a name="line.14395"></a>
<FONT color="green">14396</FONT>          return result;<a name="line.14396"></a>
<FONT color="green">14397</FONT>        }<a name="line.14397"></a>
<FONT color="green">14398</FONT>    <a name="line.14398"></a>
<FONT color="green">14399</FONT>        double yToChartPixel(double y, boolean isY2) {<a name="line.14399"></a>
<FONT color="green">14400</FONT>          double minY = isY2 ? y2Min : yMin;<a name="line.14400"></a>
<FONT color="green">14401</FONT>          double maxY = isY2 ? y2Max : yMax;<a name="line.14401"></a>
<FONT color="green">14402</FONT>          double result = Double.NaN;<a name="line.14402"></a>
<FONT color="green">14403</FONT>          if (-Double.MAX_VALUE == y)<a name="line.14403"></a>
<FONT color="green">14404</FONT>            result = yChartSize + topMargin - 1.0;<a name="line.14404"></a>
<FONT color="green">14405</FONT>          else if (Double.MAX_VALUE == y)<a name="line.14405"></a>
<FONT color="green">14406</FONT>            result = topMargin;<a name="line.14406"></a>
<FONT color="green">14407</FONT>          else if (!(y != y)) // x!=x is a faster isNaN<a name="line.14407"></a>
<FONT color="green">14408</FONT>            result = (topMargin * (y - minY) + ((yChartSize + topMargin - 1.0) * (maxY - y)))<a name="line.14408"></a>
<FONT color="green">14409</FONT>                / (maxY - minY);<a name="line.14409"></a>
<FONT color="green">14410</FONT>          return result;<a name="line.14410"></a>
<FONT color="green">14411</FONT>        }<a name="line.14411"></a>
<FONT color="green">14412</FONT>    <a name="line.14412"></a>
<FONT color="green">14413</FONT>        double yToPixel(double y, boolean isY2) {<a name="line.14413"></a>
<FONT color="green">14414</FONT>          double minY = isY2 ? y2Min : yMin;<a name="line.14414"></a>
<FONT color="green">14415</FONT>          double maxY = isY2 ? y2Max : yMax;<a name="line.14415"></a>
<FONT color="green">14416</FONT>          double result = Double.NaN;<a name="line.14416"></a>
<FONT color="green">14417</FONT>          if (-Double.MAX_VALUE == y)<a name="line.14417"></a>
<FONT color="green">14418</FONT>            result = yChartSize - 1.0;<a name="line.14418"></a>
<FONT color="green">14419</FONT>          else if (Double.MAX_VALUE == y)<a name="line.14419"></a>
<FONT color="green">14420</FONT>            result = 0;<a name="line.14420"></a>
<FONT color="green">14421</FONT>          else if (!(y != y)) // x!=x is a faster isNaN<a name="line.14421"></a>
<FONT color="green">14422</FONT>            result = (yChartSize - 1.0) * (maxY - y) / (maxY - minY);<a name="line.14422"></a>
<FONT color="green">14423</FONT>          return result;<a name="line.14423"></a>
<FONT color="green">14424</FONT>        }<a name="line.14424"></a>
<FONT color="green">14425</FONT>    <a name="line.14425"></a>
<FONT color="green">14426</FONT>        double yChartPixelToY(int yPx) {<a name="line.14426"></a>
<FONT color="green">14427</FONT>          double result = Double.NaN;<a name="line.14427"></a>
<FONT color="green">14428</FONT>          if (GChart.NAI != yPx &amp;&amp; yChartSize &gt; 1) {<a name="line.14428"></a>
<FONT color="green">14429</FONT>            result = yMax + (yMin - yMax) * (yPx - topMargin)<a name="line.14429"></a>
<FONT color="green">14430</FONT>                / (yChartSize - 1.);<a name="line.14430"></a>
<FONT color="green">14431</FONT>          }<a name="line.14431"></a>
<FONT color="green">14432</FONT>          return result;<a name="line.14432"></a>
<FONT color="green">14433</FONT>        }<a name="line.14433"></a>
<FONT color="green">14434</FONT>    <a name="line.14434"></a>
<FONT color="green">14435</FONT>        double yPixelToY(int yPx) {<a name="line.14435"></a>
<FONT color="green">14436</FONT>          double result = Double.NaN;<a name="line.14436"></a>
<FONT color="green">14437</FONT>          if (GChart.NAI != yPx &amp;&amp; yChartSize &gt; 1) {<a name="line.14437"></a>
<FONT color="green">14438</FONT>            result = yMax + (yMin - yMax) * yPx / (yChartSize - 1.);<a name="line.14438"></a>
<FONT color="green">14439</FONT>          }<a name="line.14439"></a>
<FONT color="green">14440</FONT>          return result;<a name="line.14440"></a>
<FONT color="green">14441</FONT>        }<a name="line.14441"></a>
<FONT color="green">14442</FONT>    <a name="line.14442"></a>
<FONT color="green">14443</FONT>        double yChartPixelToY2(int yPx) {<a name="line.14443"></a>
<FONT color="green">14444</FONT>          double result = Double.NaN;<a name="line.14444"></a>
<FONT color="green">14445</FONT>          if (GChart.NAI != yPx &amp;&amp; yChartSize &gt; 1) {<a name="line.14445"></a>
<FONT color="green">14446</FONT>            result = y2Max + (y2Min - y2Max) * (yPx - topMargin)<a name="line.14446"></a>
<FONT color="green">14447</FONT>                / (yChartSize - 1.);<a name="line.14447"></a>
<FONT color="green">14448</FONT>          }<a name="line.14448"></a>
<FONT color="green">14449</FONT>          return result;<a name="line.14449"></a>
<FONT color="green">14450</FONT>        }<a name="line.14450"></a>
<FONT color="green">14451</FONT>    <a name="line.14451"></a>
<FONT color="green">14452</FONT>        double yPixelToY2(int yPx) {<a name="line.14452"></a>
<FONT color="green">14453</FONT>          double result = Double.NaN;<a name="line.14453"></a>
<FONT color="green">14454</FONT>          if (GChart.NAI != yPx &amp;&amp; yChartSize &gt; 1) {<a name="line.14454"></a>
<FONT color="green">14455</FONT>            result = y2Max + (y2Min - y2Max) * yPx / (yChartSize - 1.);<a name="line.14455"></a>
<FONT color="green">14456</FONT>          }<a name="line.14456"></a>
<FONT color="green">14457</FONT>          return result;<a name="line.14457"></a>
<FONT color="green">14458</FONT>        }<a name="line.14458"></a>
<FONT color="green">14459</FONT>    <a name="line.14459"></a>
<FONT color="green">14460</FONT>        double dyToPixel(double dy, boolean isY2) {<a name="line.14460"></a>
<FONT color="green">14461</FONT>          double minY = isY2 ? y2Min : yMin;<a name="line.14461"></a>
<FONT color="green">14462</FONT>          double maxY = isY2 ? y2Max : yMax;<a name="line.14462"></a>
<FONT color="green">14463</FONT>          // maxY and minY are at centers of their pixels, hence the -1<a name="line.14463"></a>
<FONT color="green">14464</FONT>          double result = (dy * (yChartSize - 1)) / (maxY - minY);<a name="line.14464"></a>
<FONT color="green">14465</FONT>          return result;<a name="line.14465"></a>
<FONT color="green">14466</FONT>        }<a name="line.14466"></a>
<FONT color="green">14467</FONT>    <a name="line.14467"></a>
<FONT color="green">14468</FONT>        // keep track of last touched point &amp; hover widget<a name="line.14468"></a>
<FONT color="green">14469</FONT>        Curve.Point touchedPoint = null;<a name="line.14469"></a>
<FONT color="green">14470</FONT>        HoverUpdateable touchedHoverWidget = null;<a name="line.14470"></a>
<FONT color="green">14471</FONT>    <a name="line.14471"></a>
<FONT color="green">14472</FONT>        // returns the inner aligned label of the opened hover annotation<a name="line.14472"></a>
<FONT color="green">14473</FONT>        // (this is the one that directly holds the popup hover annotation)<a name="line.14473"></a>
<FONT color="green">14474</FONT>        AlignedLabel getOpenedHoverContainer() {<a name="line.14474"></a>
<FONT color="green">14475</FONT>          AlignedLabel result = null;<a name="line.14475"></a>
<FONT color="green">14476</FONT>          Curve c = getSystemCurve(HOVER_ANNOTATION_ID);<a name="line.14476"></a>
<FONT color="green">14477</FONT>          if (touchedPoint != null &amp;&amp; c.isVisible()) {<a name="line.14477"></a>
<FONT color="green">14478</FONT>            int internalIndex = getInternalCurveIndex(c);<a name="line.14478"></a>
<FONT color="green">14479</FONT>            int rpIndex = getRenderingPanelIndex(internalIndex);<a name="line.14479"></a>
<FONT color="green">14480</FONT>            AnnotationRenderingPanel arp = getAnnotationRenderingPanel(rpIndex);<a name="line.14480"></a>
<FONT color="green">14481</FONT>            result = arp.getFirstInnerAlignedLabel();<a name="line.14481"></a>
<FONT color="green">14482</FONT>          }<a name="line.14482"></a>
<FONT color="green">14483</FONT>          return result;<a name="line.14483"></a>
<FONT color="green">14484</FONT>        }<a name="line.14484"></a>
<FONT color="green">14485</FONT>    <a name="line.14485"></a>
<FONT color="green">14486</FONT>        // the element associated with any opened hover container, else null<a name="line.14486"></a>
<FONT color="green">14487</FONT>        Element getOpenedHoverElement() {<a name="line.14487"></a>
<FONT color="green">14488</FONT>          AlignedLabel hoverContainer = getOpenedHoverContainer();<a name="line.14488"></a>
<FONT color="green">14489</FONT>          Element result = (null == hoverContainer) ? null : hoverContainer<a name="line.14489"></a>
<FONT color="green">14490</FONT>              .getElement();<a name="line.14490"></a>
<FONT color="green">14491</FONT>          return result;<a name="line.14491"></a>
<FONT color="green">14492</FONT>        }<a name="line.14492"></a>
<FONT color="green">14493</FONT>    <a name="line.14493"></a>
<FONT color="green">14494</FONT>        // so if user calls update inside hoverUpdate, it won't recurse<a name="line.14494"></a>
<FONT color="green">14495</FONT>        private boolean insideHoverUpdate = false;<a name="line.14495"></a>
<FONT color="green">14496</FONT>        // so if user calls update inside hoverCleanup, it won't recurse<a name="line.14496"></a>
<FONT color="green">14497</FONT>        private boolean insideHoverCleanup = false;<a name="line.14497"></a>
<FONT color="green">14498</FONT>    <a name="line.14498"></a>
<FONT color="green">14499</FONT>        /*<a name="line.14499"></a>
<FONT color="green">14500</FONT>         * Configures GChart's special selection cursor and hover annotation<a name="line.14500"></a>
<FONT color="green">14501</FONT>         * "system curves" so that they provide appropriate feedback associated with<a name="line.14501"></a>
<FONT color="green">14502</FONT>         * "touching" the given point with the mouse. When rendered, these curves<a name="line.14502"></a>
<FONT color="green">14503</FONT>         * will: &lt;p&gt;<a name="line.14503"></a>
<FONT color="green">14504</FONT>         * <a name="line.14504"></a>
<FONT color="green">14505</FONT>         * &lt;ol&gt; &lt;li&gt; Highlight the selected point in accord with specified hover<a name="line.14505"></a>
<FONT color="green">14506</FONT>         * selection options &lt;p&gt; &lt;li&gt; Display a point-specific hover annotation, in<a name="line.14506"></a>
<FONT color="green">14507</FONT>         * accord with various hover annotation related options.<a name="line.14507"></a>
<FONT color="green">14508</FONT>         * <a name="line.14508"></a>
<FONT color="green">14509</FONT>         * &lt;/ol&gt;<a name="line.14509"></a>
<FONT color="green">14510</FONT>         * <a name="line.14510"></a>
<FONT color="green">14511</FONT>         * &lt;p&gt;<a name="line.14511"></a>
<FONT color="green">14512</FONT>         * <a name="line.14512"></a>
<FONT color="green">14513</FONT>         * Also executes &lt;tt&gt;hoverCleanup&lt;/tt&gt; on any hover widget associated with<a name="line.14513"></a>
<FONT color="green">14514</FONT>         * the previously touched point, and &lt;tt&gt;hoverUpdate&lt;/tt&gt; on any hover<a name="line.14514"></a>
<FONT color="green">14515</FONT>         * widget associated with the newly touched point, and maintains up-to-date<a name="line.14515"></a>
<FONT color="green">14516</FONT>         * references to the last touched point and last touched hover widget.<a name="line.14516"></a>
<FONT color="green">14517</FONT>         */<a name="line.14517"></a>
<FONT color="green">14518</FONT>        private void touch(Curve.Point p) {<a name="line.14518"></a>
<FONT color="green">14519</FONT>          // Note: getTouchedPoint always returns NEW touched point<a name="line.14519"></a>
<FONT color="green">14520</FONT>          Curve.Point prevTouchedPoint = touchedPoint;<a name="line.14520"></a>
<FONT color="green">14521</FONT>          touchedPoint = p;<a name="line.14521"></a>
<FONT color="green">14522</FONT>          Curve cAnnotation = getSystemCurve(HOVER_ANNOTATION_ID);<a name="line.14522"></a>
<FONT color="green">14523</FONT>          Curve cCursor = getSystemCurve(HOVER_CURSOR_ID);<a name="line.14523"></a>
<FONT color="green">14524</FONT>          Curve cTouched = (null == p) ? null : p.getParent();<a name="line.14524"></a>
<FONT color="green">14525</FONT>    <a name="line.14525"></a>
<FONT color="green">14526</FONT>          if (null != touchedHoverWidget) {<a name="line.14526"></a>
<FONT color="green">14527</FONT>            // free up resources allocated to previous hover widget<a name="line.14527"></a>
<FONT color="green">14528</FONT>            if (!insideHoverCleanup) {<a name="line.14528"></a>
<FONT color="green">14529</FONT>              try {<a name="line.14529"></a>
<FONT color="green">14530</FONT>                insideHoverCleanup = true;<a name="line.14530"></a>
<FONT color="green">14531</FONT>                touchedHoverWidget.hoverCleanup(prevTouchedPoint);<a name="line.14531"></a>
<FONT color="green">14532</FONT>              } finally {<a name="line.14532"></a>
<FONT color="green">14533</FONT>                insideHoverCleanup = false;<a name="line.14533"></a>
<FONT color="green">14534</FONT>              }<a name="line.14534"></a>
<FONT color="green">14535</FONT>            }<a name="line.14535"></a>
<FONT color="green">14536</FONT>    <a name="line.14536"></a>
<FONT color="green">14537</FONT>          }<a name="line.14537"></a>
<FONT color="green">14538</FONT>    <a name="line.14538"></a>
<FONT color="green">14539</FONT>          // with hoverCleanup out of the way, switch to new hover widget<a name="line.14539"></a>
<FONT color="green">14540</FONT>          touchedHoverWidget = (null == cTouched) ? null : cTouched<a name="line.14540"></a>
<FONT color="green">14541</FONT>              .getSymbol().getHoverWidget();<a name="line.14541"></a>
<FONT color="green">14542</FONT>    <a name="line.14542"></a>
<FONT color="green">14543</FONT>          if (null == touchedHoverWidget) {<a name="line.14543"></a>
<FONT color="green">14544</FONT>            if (null != p) {<a name="line.14544"></a>
<FONT color="green">14545</FONT>              // no hover-widget, just use expanded hover-template<a name="line.14545"></a>
<FONT color="green">14546</FONT>              String hovertext = p.getHovertext();<a name="line.14546"></a>
<FONT color="green">14547</FONT>    <a name="line.14547"></a>
<FONT color="green">14548</FONT>              cAnnotation<a name="line.14548"></a>
<FONT color="green">14549</FONT>                  .getPoint(0)<a name="line.14549"></a>
<FONT color="green">14550</FONT>                  .setAnnotationText(<a name="line.14550"></a>
<FONT color="green">14551</FONT>                  hovertext,<a name="line.14551"></a>
<FONT color="green">14552</FONT>                  cTouched.getSymbol().getHoverAnnotation().widthUpperBound,<a name="line.14552"></a>
<FONT color="green">14553</FONT>                  cTouched.getSymbol().getHoverAnnotation().heightUpperBound);<a name="line.14553"></a>
<FONT color="green">14554</FONT>            }<a name="line.14554"></a>
<FONT color="green">14555</FONT>          } else {<a name="line.14555"></a>
<FONT color="green">14556</FONT>            // touched curve has custom hover widget; update it, etc.<a name="line.14556"></a>
<FONT color="green">14557</FONT>            if (!insideHoverUpdate) {<a name="line.14557"></a>
<FONT color="green">14558</FONT>              try {<a name="line.14558"></a>
<FONT color="green">14559</FONT>                insideHoverUpdate = true;<a name="line.14559"></a>
<FONT color="green">14560</FONT>                touchedHoverWidget.hoverUpdate(p);<a name="line.14560"></a>
<FONT color="green">14561</FONT>              } finally {<a name="line.14561"></a>
<FONT color="green">14562</FONT>                insideHoverUpdate = false;<a name="line.14562"></a>
<FONT color="green">14563</FONT>              }<a name="line.14563"></a>
<FONT color="green">14564</FONT>            }<a name="line.14564"></a>
<FONT color="green">14565</FONT>            cAnnotation<a name="line.14565"></a>
<FONT color="green">14566</FONT>                .getPoint(0)<a name="line.14566"></a>
<FONT color="green">14567</FONT>                .setAnnotationWidget(<a name="line.14567"></a>
<FONT color="green">14568</FONT>                (Widget) touchedHoverWidget,<a name="line.14568"></a>
<FONT color="green">14569</FONT>                cTouched.getSymbol().getHoverAnnotation().widthUpperBound,<a name="line.14569"></a>
<FONT color="green">14570</FONT>                cTouched.getSymbol().getHoverAnnotation().heightUpperBound);<a name="line.14570"></a>
<FONT color="green">14571</FONT>          }<a name="line.14571"></a>
<FONT color="green">14572</FONT>    <a name="line.14572"></a>
<FONT color="green">14573</FONT>          if (null == p) { // no longer touching anything<a name="line.14573"></a>
<FONT color="green">14574</FONT>            cAnnotation.setVisible(false);<a name="line.14574"></a>
<FONT color="green">14575</FONT>            cCursor.setVisible(false);<a name="line.14575"></a>
<FONT color="green">14576</FONT>          } else { // touching something, show that<a name="line.14576"></a>
<FONT color="green">14577</FONT>    <a name="line.14577"></a>
<FONT color="green">14578</FONT>            if (!cTouched.getSymbol().getHoverAnnotationEnabled()) {<a name="line.14578"></a>
<FONT color="green">14579</FONT>              cAnnotation.setVisible(false);<a name="line.14579"></a>
<FONT color="green">14580</FONT>            } else {<a name="line.14580"></a>
<FONT color="green">14581</FONT>              cAnnotation.setVisible(true);<a name="line.14581"></a>
<FONT color="green">14582</FONT>              cAnnotation.setXShift(cTouched.getXShift());<a name="line.14582"></a>
<FONT color="green">14583</FONT>              cAnnotation.setYShift(cTouched.getYShift());<a name="line.14583"></a>
<FONT color="green">14584</FONT>              cAnnotation.setYAxis(cTouched.getYAxis());<a name="line.14584"></a>
<FONT color="green">14585</FONT>              cAnnotation.getPoint(0).setX(p.getX());<a name="line.14585"></a>
<FONT color="green">14586</FONT>              cAnnotation.getPoint(0).setY(p.getY());<a name="line.14586"></a>
<FONT color="green">14587</FONT>              cAnnotation.getSymbol().copy(cTouched.getSymbol());<a name="line.14587"></a>
<FONT color="green">14588</FONT>              // the symbol isn't needed, so make it transparent<a name="line.14588"></a>
<FONT color="green">14589</FONT>              // and zap any images (can't make it 0-sized since<a name="line.14589"></a>
<FONT color="green">14590</FONT>              // annotation placement is size-dependent)<a name="line.14590"></a>
<FONT color="green">14591</FONT>              cAnnotation.getSymbol().setImageURL(<a name="line.14591"></a>
<FONT color="green">14592</FONT>                  GChart.DEFAULT_BLANK_IMAGE_URL_FULLPATH);<a name="line.14592"></a>
<FONT color="green">14593</FONT>              cAnnotation.getSymbol().setBackgroundColor("transparent");<a name="line.14593"></a>
<FONT color="green">14594</FONT>              cAnnotation.getSymbol().setBorderColor(<a name="line.14594"></a>
<FONT color="green">14595</FONT>                  TRANSPARENT_BORDER_COLOR);<a name="line.14595"></a>
<FONT color="green">14596</FONT>              if (null != cTouched.getSymbol()<a name="line.14596"></a>
<FONT color="green">14597</FONT>                  .getHoverAnnotationSymbolType())<a name="line.14597"></a>
<FONT color="green">14598</FONT>                cAnnotation.getSymbol().setSymbolType(<a name="line.14598"></a>
<FONT color="green">14599</FONT>                    cTouched.getSymbol()<a name="line.14599"></a>
<FONT color="green">14600</FONT>                    .getHoverAnnotationSymbolType());<a name="line.14600"></a>
<FONT color="green">14601</FONT>              // else just stick with the touched symbol's type<a name="line.14601"></a>
<FONT color="green">14602</FONT>    <a name="line.14602"></a>
<FONT color="green">14603</FONT>              // copy the hover annotations specs (including<a name="line.14603"></a>
<FONT color="green">14604</FONT>              // hover widget ref or HTML defined above)<a name="line.14604"></a>
<FONT color="green">14605</FONT>              // to the annotation curve's point<a name="line.14605"></a>
<FONT color="green">14606</FONT>              cAnnotation.getPoint(0).setAnnotationFontColor(<a name="line.14606"></a>
<FONT color="green">14607</FONT>                  cTouched.getSymbol().getHoverFontColor());<a name="line.14607"></a>
<FONT color="green">14608</FONT>              cAnnotation.getPoint(0).setAnnotationFontSize(<a name="line.14608"></a>
<FONT color="green">14609</FONT>                  cTouched.getSymbol().getHoverFontSize());<a name="line.14609"></a>
<FONT color="green">14610</FONT>              cAnnotation.getPoint(0).setAnnotationFontFamily(<a name="line.14610"></a>
<FONT color="green">14611</FONT>                  cTouched.getSymbol().getHoverFontFamily());<a name="line.14611"></a>
<FONT color="green">14612</FONT>              cAnnotation.getPoint(0).setAnnotationFontStyle(<a name="line.14612"></a>
<FONT color="green">14613</FONT>                  cTouched.getSymbol().getHoverFontStyle());<a name="line.14613"></a>
<FONT color="green">14614</FONT>              cAnnotation.getPoint(0).setAnnotationFontWeight(<a name="line.14614"></a>
<FONT color="green">14615</FONT>                  cTouched.getSymbol().getHoverFontWeight());<a name="line.14615"></a>
<FONT color="green">14616</FONT>              cAnnotation.getPoint(0).setAnnotationLocation(<a name="line.14616"></a>
<FONT color="green">14617</FONT>                  cTouched.getSymbol().getHoverLocation());<a name="line.14617"></a>
<FONT color="green">14618</FONT>              cAnnotation.getPoint(0).setAnnotationXShift(<a name="line.14618"></a>
<FONT color="green">14619</FONT>                  cTouched.getSymbol().getHoverXShift());<a name="line.14619"></a>
<FONT color="green">14620</FONT>              cAnnotation.getPoint(0).setAnnotationYShift(<a name="line.14620"></a>
<FONT color="green">14621</FONT>                  cTouched.getSymbol().getHoverYShift());<a name="line.14621"></a>
<FONT color="green">14622</FONT>            }<a name="line.14622"></a>
<FONT color="green">14623</FONT>    <a name="line.14623"></a>
<FONT color="green">14624</FONT>            if (!cTouched.getSymbol().getHoverSelectionEnabled()) {<a name="line.14624"></a>
<FONT color="green">14625</FONT>              cCursor.setVisible(false);<a name="line.14625"></a>
<FONT color="green">14626</FONT>            } else {<a name="line.14626"></a>
<FONT color="green">14627</FONT>              cCursor.setVisible(true);<a name="line.14627"></a>
<FONT color="green">14628</FONT>              cCursor.setXShift(cTouched.getXShift());<a name="line.14628"></a>
<FONT color="green">14629</FONT>              cCursor.setYShift(cTouched.getYShift());<a name="line.14629"></a>
<FONT color="green">14630</FONT>              cCursor.setYAxis(cTouched.getYAxis());<a name="line.14630"></a>
<FONT color="green">14631</FONT>              // place cursor curve's point where touched point is:<a name="line.14631"></a>
<FONT color="green">14632</FONT>              cCursor.getPoint(0).setX(p.getX());<a name="line.14632"></a>
<FONT color="green">14633</FONT>              cCursor.getPoint(0).setY(p.getY());<a name="line.14633"></a>
<FONT color="green">14634</FONT>              // cursor gets (mostly) same props as touched symbol<a name="line.14634"></a>
<FONT color="green">14635</FONT>              cCursor.getSymbol().copy(cTouched.getSymbol());<a name="line.14635"></a>
<FONT color="green">14636</FONT>              if (null != cTouched.getSymbol()<a name="line.14636"></a>
<FONT color="green">14637</FONT>                  .getHoverSelectionSymbolType())<a name="line.14637"></a>
<FONT color="green">14638</FONT>                cCursor.getSymbol().setSymbolType(<a name="line.14638"></a>
<FONT color="green">14639</FONT>                    cTouched.getSymbol()<a name="line.14639"></a>
<FONT color="green">14640</FONT>                    .getHoverSelectionSymbolType());<a name="line.14640"></a>
<FONT color="green">14641</FONT>              double fillSpacing = cTouched.getSymbol()<a name="line.14641"></a>
<FONT color="green">14642</FONT>                  .getHoverSelectionFillSpacing();<a name="line.14642"></a>
<FONT color="green">14643</FONT>              if (!(fillSpacing != fillSpacing))<a name="line.14643"></a>
<FONT color="green">14644</FONT>                cCursor.getSymbol().setFillSpacing(fillSpacing);<a name="line.14644"></a>
<FONT color="green">14645</FONT>              int fillThickness = cTouched.getSymbol()<a name="line.14645"></a>
<FONT color="green">14646</FONT>                  .getHoverSelectionFillThickness();<a name="line.14646"></a>
<FONT color="green">14647</FONT>              if (GChart.NAI != fillThickness)<a name="line.14647"></a>
<FONT color="green">14648</FONT>                cCursor.getSymbol().setFillThickness(fillThickness);<a name="line.14648"></a>
<FONT color="green">14649</FONT>              if (GChart.NAI != cTouched.getSymbol()<a name="line.14649"></a>
<FONT color="green">14650</FONT>                  .getHoverSelectionHeight())<a name="line.14650"></a>
<FONT color="green">14651</FONT>                cCursor.getSymbol().setHeight(<a name="line.14651"></a>
<FONT color="green">14652</FONT>                    cTouched.getSymbol().getHoverSelectionHeight());<a name="line.14652"></a>
<FONT color="green">14653</FONT>              if (GChart.NAI != cTouched.getSymbol()<a name="line.14653"></a>
<FONT color="green">14654</FONT>                  .getHoverSelectionWidth())<a name="line.14654"></a>
<FONT color="green">14655</FONT>                cCursor.getSymbol().setWidth(<a name="line.14655"></a>
<FONT color="green">14656</FONT>                    cTouched.getSymbol().getHoverSelectionWidth());<a name="line.14656"></a>
<FONT color="green">14657</FONT>              cCursor.getSymbol().setImageURL(<a name="line.14657"></a>
<FONT color="green">14658</FONT>                  cTouched.getSymbol().getHoverSelectionImageURL());<a name="line.14658"></a>
<FONT color="green">14659</FONT>              cCursor.getSymbol().setBackgroundColor(<a name="line.14659"></a>
<FONT color="green">14660</FONT>                  cTouched.getSymbol()<a name="line.14660"></a>
<FONT color="green">14661</FONT>                  .getHoverSelectionBackgroundColor());<a name="line.14661"></a>
<FONT color="green">14662</FONT>              cCursor.getSymbol()<a name="line.14662"></a>
<FONT color="green">14663</FONT>                  .setBorderColor(<a name="line.14663"></a>
<FONT color="green">14664</FONT>                  cTouched.getSymbol()<a name="line.14664"></a>
<FONT color="green">14665</FONT>                  .getHoverSelectionBorderColor());<a name="line.14665"></a>
<FONT color="green">14666</FONT>              cCursor.getSymbol()<a name="line.14666"></a>
<FONT color="green">14667</FONT>                  .setBorderStyle(<a name="line.14667"></a>
<FONT color="green">14668</FONT>                  cTouched.getSymbol()<a name="line.14668"></a>
<FONT color="green">14669</FONT>                  .getHoverSelectionBorderStyle());<a name="line.14669"></a>
<FONT color="green">14670</FONT>              int borderWidth = cTouched.getSymbol()<a name="line.14670"></a>
<FONT color="green">14671</FONT>                  .getHoverSelectionBorderWidth();<a name="line.14671"></a>
<FONT color="green">14672</FONT>              cCursor.getSymbol().setBorderWidth(borderWidth);<a name="line.14672"></a>
<FONT color="green">14673</FONT>            }<a name="line.14673"></a>
<FONT color="green">14674</FONT>          }<a name="line.14674"></a>
<FONT color="green">14675</FONT>        }<a name="line.14675"></a>
<FONT color="green">14676</FONT>    <a name="line.14676"></a>
<FONT color="green">14677</FONT>        /*<a name="line.14677"></a>
<FONT color="green">14678</FONT>         * Is the given target element contained within the given container? (tried<a name="line.14678"></a>
<FONT color="green">14679</FONT>         * isOrHasChild but was getting exceptions in FF2 I could not track to their<a name="line.14679"></a>
<FONT color="green">14680</FONT>         * source, so I just stuck with this)<a name="line.14680"></a>
<FONT color="green">14681</FONT>         */<a name="line.14681"></a>
<FONT color="green">14682</FONT>        private boolean isContainedIn(Element container, EventTarget et) {<a name="line.14682"></a>
<FONT color="green">14683</FONT>          Element part = (null == et || !Element.is(et)) ? null : Element<a name="line.14683"></a>
<FONT color="green">14684</FONT>              .as(et);<a name="line.14684"></a>
<FONT color="green">14685</FONT>          /*<a name="line.14685"></a>
<FONT color="green">14686</FONT>           * In Chrome and FF2, the next line makes dropdown lists inside hover<a name="line.14686"></a>
<FONT color="green">14687</FONT>           * widgets work more correctly when they click on the dropdown part of the<a name="line.14687"></a>
<FONT color="green">14688</FONT>           * list. Otherwise, hover widget can close inappropriately. As tested in<a name="line.14688"></a>
<FONT color="green">14689</FONT>           * GChartExample20a.java<a name="line.14689"></a>
<FONT color="green">14690</FONT>           */<a name="line.14690"></a>
<FONT color="green">14691</FONT>          if (null == part)<a name="line.14691"></a>
<FONT color="green">14692</FONT>            return true;<a name="line.14692"></a>
<FONT color="green">14693</FONT>          try {<a name="line.14693"></a>
<FONT color="green">14694</FONT>            for (Element ancestor = part; ancestor != null<a name="line.14694"></a>
<FONT color="green">14695</FONT>                &amp;&amp; container != null; ancestor = ancestor<a name="line.14695"></a>
<FONT color="green">14696</FONT>                .getParentElement())<a name="line.14696"></a>
<FONT color="green">14697</FONT>              if (container == ancestor)<a name="line.14697"></a>
<FONT color="green">14698</FONT>                return true;<a name="line.14698"></a>
<FONT color="green">14699</FONT>          } catch (Exception e) {<a name="line.14699"></a>
<FONT color="green">14700</FONT>            /*<a name="line.14700"></a>
<FONT color="green">14701</FONT>             * In FF2, we get the error "Error: uncaught exception: Permission<a name="line.14701"></a>
<FONT color="green">14702</FONT>             * denied to get property HTMLDivElement.parentNode" if a TextBox is<a name="line.14702"></a>
<FONT color="green">14703</FONT>             * placed into the chart x axis label and you mouse over that textbox<a name="line.14703"></a>
<FONT color="green">14704</FONT>             * (as reported by secnoc in issue #24, which has additional useful info<a name="line.14704"></a>
<FONT color="green">14705</FONT>             * about the likely cause of this problem; TestGChart44.java reproduces<a name="line.14705"></a>
<FONT color="green">14706</FONT>             * this behavior if this try/catch is removed).<a name="line.14706"></a>
<FONT color="green">14707</FONT>             * <a name="line.14707"></a>
<FONT color="green">14708</FONT>             * Returning true, which will act as if the element is contained in the<a name="line.14708"></a>
<FONT color="green">14709</FONT>             * GChart, has "cruft possibilities" as in some cases a hoverwidget may<a name="line.14709"></a>
<FONT color="green">14710</FONT>             * not get closed when user mouses completely out of the GChart, onto a<a name="line.14710"></a>
<FONT color="green">14711</FONT>             * TextBox, but should otherwise be a lesser evil than false or an<a name="line.14711"></a>
<FONT color="green">14712</FONT>             * uncaught exception.<a name="line.14712"></a>
<FONT color="green">14713</FONT>             */<a name="line.14713"></a>
<FONT color="green">14714</FONT>            return true;<a name="line.14714"></a>
<FONT color="green">14715</FONT>    <a name="line.14715"></a>
<FONT color="green">14716</FONT>          }<a name="line.14716"></a>
<FONT color="green">14717</FONT>          return false;<a name="line.14717"></a>
<FONT color="green">14718</FONT>        }<a name="line.14718"></a>
<FONT color="green">14719</FONT>    <a name="line.14719"></a>
<FONT color="green">14720</FONT>        /*<a name="line.14720"></a>
<FONT color="green">14721</FONT>         * Is given mouse client point geometrically "inside" container? &lt;p&gt;<a name="line.14721"></a>
<FONT color="green">14722</FONT>         * <a name="line.14722"></a>
<FONT color="green">14723</FONT>         * Note: Certain widgets, like drop-down lists, SuggestBox, etc. implicitly<a name="line.14723"></a>
<FONT color="green">14724</FONT>         * create popups that are not children of the chart, and thus when the user<a name="line.14724"></a>
<FONT color="green">14725</FONT>         * moves into these popups, a mouseout that looks like they are leaving the<a name="line.14725"></a>
<FONT color="green">14726</FONT>         * hover widget or chart, and thus inappropriately hides it can often make<a name="line.14726"></a>
<FONT color="green">14727</FONT>         * hover widgets involving such elements unusable.<a name="line.14727"></a>
<FONT color="green">14728</FONT>         * <a name="line.14728"></a>
<FONT color="green">14729</FONT>         * &lt;p&gt;<a name="line.14729"></a>
<FONT color="green">14730</FONT>         * <a name="line.14730"></a>
<FONT color="green">14731</FONT>         * But, by adding a geometric condition to define "being out of the chart or<a name="line.14731"></a>
<FONT color="green">14732</FONT>         * hover widget", hover widgets that use such popups can avoid such<a name="line.14732"></a>
<FONT color="green">14733</FONT>         * inappropriate hiding as long as the popups remain geometrically within<a name="line.14733"></a>
<FONT color="green">14734</FONT>         * either the chart as a whole, or the hover widget itself. For example a<a name="line.14734"></a>
<FONT color="green">14735</FONT>         * form with drop-down lists is OK as long as the drop down lists don't<a name="line.14735"></a>
<FONT color="green">14736</FONT>         * extrude off the form when they drop down.&lt;p&gt;<a name="line.14736"></a>
<FONT color="green">14737</FONT>         * <a name="line.14737"></a>
<FONT color="green">14738</FONT>         * Unfortunately, this creates another problem, in that hover widgets that<a name="line.14738"></a>
<FONT color="green">14739</FONT>         * extrude off the chart can remain open when the user mouses off the chart<a name="line.14739"></a>
<FONT color="green">14740</FONT>         * in such a way that the mouseout occurs at a point geometrically within<a name="line.14740"></a>
<FONT color="green">14741</FONT>         * the hover widget. We consider this small amount of "hover cruft" a lesser<a name="line.14741"></a>
<FONT color="green">14742</FONT>         * evil than not being able to use dropdown lists and such within hover<a name="line.14742"></a>
<FONT color="green">14743</FONT>         * widgets at all. &lt;p&gt;<a name="line.14743"></a>
<FONT color="green">14744</FONT>         * <a name="line.14744"></a>
<FONT color="green">14745</FONT>         * Often a more natural solution, rather than wrestling with such<a name="line.14745"></a>
<FONT color="green">14746</FONT>         * "geometrical popup containment", is a click-invoked modal dialog. But<a name="line.14746"></a>
<FONT color="green">14747</FONT>         * that has a distinctly different feel than the more nearly modeless hover<a name="line.14747"></a>
<FONT color="green">14748</FONT>         * widget, so I thought there was room/need for both approaches.<a name="line.14748"></a>
<FONT color="green">14749</FONT>         */<a name="line.14749"></a>
<FONT color="green">14750</FONT>        private boolean isGeometricallyContainedIn(Element container,<a name="line.14750"></a>
<FONT color="green">14751</FONT>            int clientX, int clientY) {<a name="line.14751"></a>
<FONT color="green">14752</FONT>    <a name="line.14752"></a>
<FONT color="green">14753</FONT>          if (null == container)<a name="line.14753"></a>
<FONT color="green">14754</FONT>            throw new IllegalArgumentException("Container cannot be null");<a name="line.14754"></a>
<FONT color="green">14755</FONT>          boolean result = false;<a name="line.14755"></a>
<FONT color="green">14756</FONT>    <a name="line.14756"></a>
<FONT color="green">14757</FONT>          /*<a name="line.14757"></a>
<FONT color="green">14758</FONT>           * Equations below shrink container 1px around its perimeter, to account<a name="line.14758"></a>
<FONT color="green">14759</FONT>           * for apparent roundoff errors in FF2 associated with window scrolling.<a name="line.14759"></a>
<FONT color="green">14760</FONT>           * FF2 mouseout events get dropped (about half the time, with random<a name="line.14760"></a>
<FONT color="green">14761</FONT>           * scroll position choices hence my roundoff suspicions--problem did not<a name="line.14761"></a>
<FONT color="green">14762</FONT>           * occur in Chrome or IE7) without this 1px shrinkage. End users can't<a name="line.14762"></a>
<FONT color="green">14763</FONT>           * discriminate a 1px mouse shift anyway, so there is no real downside<a name="line.14763"></a>
<FONT color="green">14764</FONT>           * (except that you had to read this comment) to using this workaround.<a name="line.14764"></a>
<FONT color="green">14765</FONT>           */<a name="line.14765"></a>
<FONT color="green">14766</FONT>          int y = Window.getScrollTop() + repairBadClientY(clientY);<a name="line.14766"></a>
<FONT color="green">14767</FONT>          int absTop = container.getAbsoluteTop();<a name="line.14767"></a>
<FONT color="green">14768</FONT>          if (absTop &lt; y &amp;&amp; y + 1 &lt; absTop + container.getOffsetHeight()) {<a name="line.14768"></a>
<FONT color="green">14769</FONT>            int x = Window.getScrollLeft() + repairBadClientX(clientX);<a name="line.14769"></a>
<FONT color="green">14770</FONT>            int absLeft = container.getAbsoluteLeft();<a name="line.14770"></a>
<FONT color="green">14771</FONT>            if (absLeft &lt; x &amp;&amp; x + 1 &lt; absLeft + container.getOffsetWidth())<a name="line.14771"></a>
<FONT color="green">14772</FONT>              result = true;<a name="line.14772"></a>
<FONT color="green">14773</FONT>          }<a name="line.14773"></a>
<FONT color="green">14774</FONT>    <a name="line.14774"></a>
<FONT color="green">14775</FONT>          return result;<a name="line.14775"></a>
<FONT color="green">14776</FONT>        }<a name="line.14776"></a>
<FONT color="green">14777</FONT>    <a name="line.14777"></a>
<FONT color="green">14778</FONT>        // Touches the underlying object at the last event's mouse<a name="line.14778"></a>
<FONT color="green">14779</FONT>        // position if it is different from the currently touched point,<a name="line.14779"></a>
<FONT color="green">14780</FONT>        // or if retouch is true. Returns true if a touch occured.<a name="line.14780"></a>
<FONT color="green">14781</FONT>        private boolean touchObjectAtMousePosition(boolean retouch) {<a name="line.14781"></a>
<FONT color="green">14782</FONT>          boolean result = false;<a name="line.14782"></a>
<FONT color="green">14783</FONT>          Curve.Point pointAtPosition = getClosestBrushTouchingPointNoCheck(<a name="line.14783"></a>
<FONT color="green">14784</FONT>              getXMousePlotArea(), getYMousePlotArea());<a name="line.14784"></a>
<FONT color="green">14785</FONT>          if ((pointAtPosition != touchedPoint) || retouch) {<a name="line.14785"></a>
<FONT color="green">14786</FONT>            touch(pointAtPosition);<a name="line.14786"></a>
<FONT color="green">14787</FONT>            result = true;<a name="line.14787"></a>
<FONT color="green">14788</FONT>          }<a name="line.14788"></a>
<FONT color="green">14789</FONT>          return result;<a name="line.14789"></a>
<FONT color="green">14790</FONT>        }<a name="line.14790"></a>
<FONT color="green">14791</FONT>    <a name="line.14791"></a>
<FONT color="green">14792</FONT>        // touch object at mouse, but only if it is a different one<a name="line.14792"></a>
<FONT color="green">14793</FONT>        boolean touchObjectAtMousePosition() {<a name="line.14793"></a>
<FONT color="green">14794</FONT>          boolean result = touchObjectAtMousePosition(false);<a name="line.14794"></a>
<FONT color="green">14795</FONT>          return result;<a name="line.14795"></a>
<FONT color="green">14796</FONT>        }<a name="line.14796"></a>
<FONT color="green">14797</FONT>    <a name="line.14797"></a>
<FONT color="green">14798</FONT>        // touch object at mouse, even if it is the same one as last time<a name="line.14798"></a>
<FONT color="green">14799</FONT>        void retouchObjectAtMousePosition() {<a name="line.14799"></a>
<FONT color="green">14800</FONT>          touchObjectAtMousePosition(true);<a name="line.14800"></a>
<FONT color="green">14801</FONT>        }<a name="line.14801"></a>
<FONT color="green">14802</FONT>    <a name="line.14802"></a>
<FONT color="green">14803</FONT>        /*<a name="line.14803"></a>
<FONT color="green">14804</FONT>         * Does the event occur over the currently opened hover annotation?<a name="line.14804"></a>
<FONT color="green">14805</FONT>         * <a name="line.14805"></a>
<FONT color="green">14806</FONT>         * This method helps us to ignore mouse clicks and moves over a<a name="line.14806"></a>
<FONT color="green">14807</FONT>         * "sticky-open" hover annotation, or one of its children. Idea is to<a name="line.14807"></a>
<FONT color="green">14808</FONT>         * prevent the hover feedback from jumping to another point while the user<a name="line.14808"></a>
<FONT color="green">14809</FONT>         * interacts with an opened hover widget. &lt;p&gt;<a name="line.14809"></a>
<FONT color="green">14810</FONT>         * <a name="line.14810"></a>
<FONT color="green">14811</FONT>         * This is not just important for hover annotations that contain buttons and<a name="line.14811"></a>
<FONT color="green">14812</FONT>         * such, but even for hover annotations based on static text, since the user<a name="line.14812"></a>
<FONT color="green">14813</FONT>         * might want to select/copy that text (involving mouse moves) for example.<a name="line.14813"></a>
<FONT color="green">14814</FONT>         */<a name="line.14814"></a>
<FONT color="green">14815</FONT>        private boolean isOverOpenedHoverAnnotation(Event event) {<a name="line.14815"></a>
<FONT color="green">14816</FONT>          boolean result = false;<a name="line.14816"></a>
<FONT color="green">14817</FONT>          Element hoverElement = getOpenedHoverElement();<a name="line.14817"></a>
<FONT color="green">14818</FONT>          if (null != hoverElement) {<a name="line.14818"></a>
<FONT color="green">14819</FONT>            if (isContainedIn(hoverElement, event.getEventTarget()))<a name="line.14819"></a>
<FONT color="green">14820</FONT>              result = true;<a name="line.14820"></a>
<FONT color="green">14821</FONT>            else if (isGeometricallyContainedIn(hoverElement, event<a name="line.14821"></a>
<FONT color="green">14822</FONT>                .getClientX(), event.getClientY()))<a name="line.14822"></a>
<FONT color="green">14823</FONT>              result = true;<a name="line.14823"></a>
<FONT color="green">14824</FONT>          }<a name="line.14824"></a>
<FONT color="green">14825</FONT>          return result;<a name="line.14825"></a>
<FONT color="green">14826</FONT>        }<a name="line.14826"></a>
<FONT color="green">14827</FONT>    <a name="line.14827"></a>
<FONT color="green">14828</FONT>        /*<a name="line.14828"></a>
<FONT color="green">14829</FONT>         * Does event (assumed a MOUSEOUT) take the mouse completely outside of the<a name="line.14829"></a>
<FONT color="green">14830</FONT>         * current chart? &lt;p&gt;<a name="line.14830"></a>
<FONT color="green">14831</FONT>         * <a name="line.14831"></a>
<FONT color="green">14832</FONT>         * To be completely outside the chart, the event must be both not associated<a name="line.14832"></a>
<FONT color="green">14833</FONT>         * with any child element of the chart (as represented in the DOM) and<a name="line.14833"></a>
<FONT color="green">14834</FONT>         * geometrically outside of the chart's "box" and the "box" of any currently<a name="line.14834"></a>
<FONT color="green">14835</FONT>         * opened hover annotation. &lt;p&gt;<a name="line.14835"></a>
<FONT color="green">14836</FONT>         * <a name="line.14836"></a>
<FONT color="green">14837</FONT>         * Because a GChart is rendered with many DOM elements, moving the mouse<a name="line.14837"></a>
<FONT color="green">14838</FONT>         * across it generates many MOUSEOUT events. This method lets us focus on<a name="line.14838"></a>
<FONT color="green">14839</FONT>         * only those that take us completely off the chart, and thus require the<a name="line.14839"></a>
<FONT color="green">14840</FONT>         * hover feedback to be turned off. &lt;p&gt;<a name="line.14840"></a>
<FONT color="green">14841</FONT>         */<a name="line.14841"></a>
<FONT color="green">14842</FONT>        private boolean takesUsCompletelyOutsideChart(Event event) {<a name="line.14842"></a>
<FONT color="green">14843</FONT>          boolean result = true;<a name="line.14843"></a>
<FONT color="green">14844</FONT>    <a name="line.14844"></a>
<FONT color="green">14845</FONT>          if (isContainedIn(getElement(), event.getRelatedEventTarget()))<a name="line.14845"></a>
<FONT color="green">14846</FONT>            /*<a name="line.14846"></a>
<FONT color="green">14847</FONT>             * hoverElement is always a descendant of the main chart element due to<a name="line.14847"></a>
<FONT color="green">14848</FONT>             * how GChart generates it, so if this branch isn't reached, toElement<a name="line.14848"></a>
<FONT color="green">14849</FONT>             * is not contained in either chart or the opened hover annotation<a name="line.14849"></a>
<FONT color="green">14850</FONT>             */<a name="line.14850"></a>
<FONT color="green">14851</FONT>            result = false;<a name="line.14851"></a>
<FONT color="green">14852</FONT>          else if (isGeometricallyContainedIn(getElement(), event<a name="line.14852"></a>
<FONT color="green">14853</FONT>              .getClientX(), event.getClientY()))<a name="line.14853"></a>
<FONT color="green">14854</FONT>            result = false;<a name="line.14854"></a>
<FONT color="green">14855</FONT>          else {<a name="line.14855"></a>
<FONT color="green">14856</FONT>            Element hoverElement = getOpenedHoverElement();<a name="line.14856"></a>
<FONT color="green">14857</FONT>            if (null != hoverElement) {<a name="line.14857"></a>
<FONT color="green">14858</FONT>              if (isGeometricallyContainedIn(hoverElement, event<a name="line.14858"></a>
<FONT color="green">14859</FONT>                  .getClientX(), event.getClientY()))<a name="line.14859"></a>
<FONT color="green">14860</FONT>                result = false;<a name="line.14860"></a>
<FONT color="green">14861</FONT>            }<a name="line.14861"></a>
<FONT color="green">14862</FONT>          }<a name="line.14862"></a>
<FONT color="green">14863</FONT>    <a name="line.14863"></a>
<FONT color="green">14864</FONT>          return result;<a name="line.14864"></a>
<FONT color="green">14865</FONT>    <a name="line.14865"></a>
<FONT color="green">14866</FONT>        }<a name="line.14866"></a>
<FONT color="green">14867</FONT>    <a name="line.14867"></a>
<FONT color="green">14868</FONT>        /**<a name="line.14868"></a>
<FONT color="green">14869</FONT>         * Fired whenever a browser event is recieved.<a name="line.14869"></a>
<FONT color="green">14870</FONT>         * &lt;p&gt;<a name="line.14870"></a>
<FONT color="green">14871</FONT>         * <a name="line.14871"></a>
<FONT color="green">14872</FONT>         * GChart keeps track of browser mouse-moves, mouse-outs, mouse-overs, and<a name="line.14872"></a>
<FONT color="green">14873</FONT>         * mouse clicks and will automatically provide appropriate hover feedback<a name="line.14873"></a>
<FONT color="green">14874</FONT>         * whenever the mouse "touches" rendered symbols on the chart. It also<a name="line.14874"></a>
<FONT color="green">14875</FONT>         * maintains a reference to the "currently touched" point which you can<a name="line.14875"></a>
<FONT color="green">14876</FONT>         * retrieve via the &lt;tt&gt;getTouchedPoint&lt;/tt&gt; method.<a name="line.14876"></a>
<FONT color="green">14877</FONT>         * &lt;p&gt;<a name="line.14877"></a>
<FONT color="green">14878</FONT>         * <a name="line.14878"></a>
<FONT color="green">14879</FONT>         * GChart never "eats" mouse events (it just watches them go by, and keeps<a name="line.14879"></a>
<FONT color="green">14880</FONT>         * track of what the mouse-anchored brush is touching) so containing Widgets<a name="line.14880"></a>
<FONT color="green">14881</FONT>         * can track and respond to the same mouse event stream after GChart does,<a name="line.14881"></a>
<FONT color="green">14882</FONT>         * if they want to.<a name="line.14882"></a>
<FONT color="green">14883</FONT>         * <a name="line.14883"></a>
<FONT color="green">14884</FONT>         * &lt;p&gt;<a name="line.14884"></a>
<FONT color="green">14885</FONT>         * <a name="line.14885"></a>
<FONT color="green">14886</FONT>         * Each curve's symbol can configure how hover feedback is displayed via the<a name="line.14886"></a>
<FONT color="green">14887</FONT>         * &lt;tt&gt;setHover*&lt;/tt&gt; family of methods and the related HoverUpdateable and<a name="line.14887"></a>
<FONT color="green">14888</FONT>         * HoverParameterInterpreter interfaces. In addition, GChart implements the<a name="line.14888"></a>
<FONT color="green">14889</FONT>         * standard GWT &lt;tt&gt;SourcesClickEvents&lt;/tt&gt; interface, so you can easily<a name="line.14889"></a>
<FONT color="green">14890</FONT>         * implement &lt;tt&gt;ClickListener.onClick&lt;/tt&gt; to be notified of user clicks on<a name="line.14890"></a>
<FONT color="green">14891</FONT>         * a GChart, using &lt;tt&gt;getTouchedPoint&lt;/tt&gt; to grab the clicked-on point.<a name="line.14891"></a>
<FONT color="green">14892</FONT>         * &lt;p&gt;<a name="line.14892"></a>
<FONT color="green">14893</FONT>         * <a name="line.14893"></a>
<FONT color="green">14894</FONT>         * This method can only properly track events when &lt;tt&gt;isUpdateNeeded&lt;/tt&gt;<a name="line.14894"></a>
<FONT color="green">14895</FONT>         * returns false (implies DOM/GChart specs are in synch) so if you want this<a name="line.14895"></a>
<FONT color="green">14896</FONT>         * tracking system to work as intended, you need to be sure to always call<a name="line.14896"></a>
<FONT color="green">14897</FONT>         * &lt;tt&gt;update&lt;/tt&gt; after making a series of chart specification changes,<a name="line.14897"></a>
<FONT color="green">14898</FONT>         * just before you give control back to the browser.<a name="line.14898"></a>
<FONT color="green">14899</FONT>         * <a name="line.14899"></a>
<FONT color="green">14900</FONT>         * <a name="line.14900"></a>
<FONT color="green">14901</FONT>         * @param event<a name="line.14901"></a>
<FONT color="green">14902</FONT>         *          the browser event that GChart will monitor so as to maintain a<a name="line.14902"></a>
<FONT color="green">14903</FONT>         *          reference to the "touched" point and provide appropriate hover<a name="line.14903"></a>
<FONT color="green">14904</FONT>         *          feedback.<a name="line.14904"></a>
<FONT color="green">14905</FONT>         * <a name="line.14905"></a>
<FONT color="green">14906</FONT>         * @see #touch touch<a name="line.14906"></a>
<FONT color="green">14907</FONT>         * @see #getTouchedPoint getTouchedPoint<a name="line.14907"></a>
<FONT color="green">14908</FONT>         * @see #setHoverWidget setHoverWidget<a name="line.14908"></a>
<FONT color="green">14909</FONT>         * @see #setHovertextTemplate setHovertextTemplate<a name="line.14909"></a>
<FONT color="green">14910</FONT>         * @see #setHoverAnnotationEnabled setHoverAnnotationEnabled<a name="line.14910"></a>
<FONT color="green">14911</FONT>         * @see #setHoverSelectionEnabled setHoverSelectionEnabled<a name="line.14911"></a>
<FONT color="green">14912</FONT>         * @see HoverUpdateable HoverUpdateable<a name="line.14912"></a>
<FONT color="green">14913</FONT>         * @see #setHoverParameterInterpreter setHoverParameterInterpreter<a name="line.14913"></a>
<FONT color="green">14914</FONT>         * @see HoverParameterInterpreter HoverParameterInterpreter<a name="line.14914"></a>
<FONT color="green">14915</FONT>         * @see #isUpdateNeeded isUpdateNeeded<a name="line.14915"></a>
<FONT color="green">14916</FONT>         * @see #update update<a name="line.14916"></a>
<FONT color="green">14917</FONT>         * <a name="line.14917"></a>
<FONT color="green">14918</FONT>         */<a name="line.14918"></a>
<FONT color="green">14919</FONT>        public void onBrowserEvent(Event event) {<a name="line.14919"></a>
<FONT color="green">14920</FONT>          // GWT docs say without this, 1.6+ event handlers won't work<a name="line.14920"></a>
<FONT color="green">14921</FONT>          super.onBrowserEvent(event);<a name="line.14921"></a>
<FONT color="green">14922</FONT>    <a name="line.14922"></a>
<FONT color="green">14923</FONT>          /*<a name="line.14923"></a>
<FONT color="green">14924</FONT>           * The tracking of the mouse position depends on if there are opened hover<a name="line.14924"></a>
<FONT color="green">14925</FONT>           * annotations or not (mouse moves over such annotations don't get<a name="line.14925"></a>
<FONT color="green">14926</FONT>           * tracked, and thus don't change the "touched" point). However, all of<a name="line.14926"></a>
<FONT color="green">14927</FONT>           * that dependency can be determined by the current DOM rendering of the<a name="line.14927"></a>
<FONT color="green">14928</FONT>           * chart--there is no need to look at actual chart specs. &lt;p&gt;<a name="line.14928"></a>
<FONT color="green">14929</FONT>           * <a name="line.14929"></a>
<FONT color="green">14930</FONT>           * So, when the DOM/chart specs are inconsistent (chart "needs update") we<a name="line.14930"></a>
<FONT color="green">14931</FONT>           * continue to perform mouse tracking based on the &lt;i&gt;last completed DOM<a name="line.14931"></a>
<FONT color="green">14932</FONT>           * rendering&lt;/i&gt; of the chart (that is, the last &lt;tt&gt;assembleChart&lt;/tt&gt;<a name="line.14932"></a>
<FONT color="green">14933</FONT>           * call). However, actual changes to the chart are "frozen" (as assured by<a name="line.14933"></a>
<FONT color="green">14934</FONT>           * the &lt;tt&gt;!isUpdateNeeded&lt;/tt&gt; test below) so no DOM changes occur<a name="line.14934"></a>
<FONT color="green">14935</FONT>           * automatically in response to mouse moves over things (e.g. no changes<a name="line.14935"></a>
<FONT color="green">14936</FONT>           * to hover feedback occur--that's frozen, too). In short, we track, but<a name="line.14936"></a>
<FONT color="green">14937</FONT>           * do not act.<a name="line.14937"></a>
<FONT color="green">14938</FONT>           * <a name="line.14938"></a>
<FONT color="green">14939</FONT>           * &lt;p&gt;<a name="line.14939"></a>
<FONT color="green">14940</FONT>           * <a name="line.14940"></a>
<FONT color="green">14941</FONT>           * We can think of it this way: mouse tracking remains consistent with the<a name="line.14941"></a>
<FONT color="green">14942</FONT>           * &lt;i&gt;last DOM rendered&lt;/i&gt; specification and then it is as if all of the<a name="line.14942"></a>
<FONT color="green">14943</FONT>           * accumulated specification changes are applied to the DOM at that point<a name="line.14943"></a>
<FONT color="green">14944</FONT>           * in time when the next (developer invoked) update occurs. That means<a name="line.14944"></a>
<FONT color="green">14945</FONT>           * there is exactly one point in time of "unpredictable change" (points<a name="line.14945"></a>
<FONT color="green">14946</FONT>           * previously hovered over can disappear from under the mouse since they<a name="line.14946"></a>
<FONT color="green">14947</FONT>           * have been deleted or moved, etc.). But that discontinuity can be<a name="line.14947"></a>
<FONT color="green">14948</FONT>           * adequately managed by the developer via the<a name="line.14948"></a>
<FONT color="green">14949</FONT>           * &lt;tt&gt;TouchedPointUpdateOption&lt;/tt&gt; argument to update. &lt;p&gt;<a name="line.14949"></a>
<FONT color="green">14950</FONT>           * <a name="line.14950"></a>
<FONT color="green">14951</FONT>           * Well, that's the theory. But GChart's mouse tracking has only been<a name="line.14951"></a>
<FONT color="green">14952</FONT>           * tested for the case where &lt;tt&gt;update&lt;/tt&gt; is always called just before<a name="line.14952"></a>
<FONT color="green">14953</FONT>           * the developer ceeds control back to the browser after making a series<a name="line.14953"></a>
<FONT color="green">14954</FONT>           * of chart spec changes. So, the public docs warn developers to be sure<a name="line.14954"></a>
<FONT color="green">14955</FONT>           * that they do that, too. But the hope is that specialized applications<a name="line.14955"></a>
<FONT color="green">14956</FONT>           * where they don't call update until the user explicitly asks for that<a name="line.14956"></a>
<FONT color="green">14957</FONT>           * (say, for a very busy chart with an editing capability and a "refresh"<a name="line.14957"></a>
<FONT color="green">14958</FONT>           * button) will also work OK.<a name="line.14958"></a>
<FONT color="green">14959</FONT>           * <a name="line.14959"></a>
<FONT color="green">14960</FONT>           * &lt;p&gt;<a name="line.14960"></a>
<FONT color="green">14961</FONT>           * <a name="line.14961"></a>
<FONT color="green">14962</FONT>           * Another important consequence of this "track but don't act" approach is<a name="line.14962"></a>
<FONT color="green">14963</FONT>           * that it assures that only cheap/quick operations can be triggered<a name="line.14963"></a>
<FONT color="green">14964</FONT>           * automatically by direct user mousing. Potentially expensive<a name="line.14964"></a>
<FONT color="green">14965</FONT>           * "full chart" updates always require a direct developer update<a name="line.14965"></a>
<FONT color="green">14966</FONT>           * invocation. So, if the system<a name="line.14966"></a>
<FONT color="green">14967</FONT>           * "locks up while it's doing a lengthly update" there will always be an<a name="line.14967"></a>
<FONT color="green">14968</FONT>           * actual developer line of code responsible for that, not some<a name="line.14968"></a>
<FONT color="green">14969</FONT>           * mysteriously event-triggered call.<a name="line.14969"></a>
<FONT color="green">14970</FONT>           */<a name="line.14970"></a>
<FONT color="green">14971</FONT>    <a name="line.14971"></a>
<FONT color="green">14972</FONT>          int eventId = DOM.eventGetType(event);<a name="line.14972"></a>
<FONT color="green">14973</FONT>          /*<a name="line.14973"></a>
<FONT color="green">14974</FONT>           * Note that a click that closes a modal DialogBox can generate a mouse<a name="line.14974"></a>
<FONT color="green">14975</FONT>           * location change without an ONMOUSEMOVE, and a point that moves under<a name="line.14975"></a>
<FONT color="green">14976</FONT>           * the mouse due to an update can generate a mouseover without a MOUSEMOVE<a name="line.14976"></a>
<FONT color="green">14977</FONT>           */<a name="line.14977"></a>
<FONT color="green">14978</FONT>          boolean isClick = (Event.ONCLICK == eventId);<a name="line.14978"></a>
<FONT color="green">14979</FONT>          if ((Event.ONMOUSEMOVE == eventId || Event.ONMOUSEOVER == eventId || isClick)<a name="line.14979"></a>
<FONT color="green">14980</FONT>              &amp;&amp; !isOverOpenedHoverAnnotation(event)) {<a name="line.14980"></a>
<FONT color="green">14981</FONT>            // remember last "tracked" mouse location<a name="line.14981"></a>
<FONT color="green">14982</FONT>            // if (Event.ONCLICK == eventId)<a name="line.14982"></a>
<FONT color="green">14983</FONT>            // Window.alert("CLICK: event.getClientX()=" +<a name="line.14983"></a>
<FONT color="green">14984</FONT>            // event.getClientX() +<a name="line.14984"></a>
<FONT color="green">14985</FONT>            // " event.getClientY()=" + event.getClientY() +<a name="line.14985"></a>
<FONT color="green">14986</FONT>            // " event.getTarget()==this.getElement() is " +<a name="line.14986"></a>
<FONT color="green">14987</FONT>            // (event.getTarget() == this.getElement()) +<a name="line.14987"></a>
<FONT color="green">14988</FONT>            // " event.getCurrentTarget()="+event.getCurrentTarget() +<a name="line.14988"></a>
<FONT color="green">14989</FONT>            // " event.getTarget()=" + event.getTarget());<a name="line.14989"></a>
<FONT color="green">14990</FONT>            // else if (Event.ONMOUSEOVER == eventId)<a name="line.14990"></a>
<FONT color="green">14991</FONT>            // Window.alert("MOUSEOVER: event.getClientX()=" +<a name="line.14991"></a>
<FONT color="green">14992</FONT>            // event.getClientX() +<a name="line.14992"></a>
<FONT color="green">14993</FONT>            // " event.getClientY()=" + event.getClientY() +<a name="line.14993"></a>
<FONT color="green">14994</FONT>            // " event.getCurrentTarget()="+event.getCurrentTarget() +<a name="line.14994"></a>
<FONT color="green">14995</FONT>            // " event.getTarget()=" + event.getTarget());<a name="line.14995"></a>
<FONT color="green">14996</FONT>            if (getHoverTouchingEnabled() || isClick) {<a name="line.14996"></a>
<FONT color="green">14997</FONT>              setClientX(event.getClientX(), isClick);<a name="line.14997"></a>
<FONT color="green">14998</FONT>              setClientY(event.getClientY(), isClick);<a name="line.14998"></a>
<FONT color="green">14999</FONT>              if (!isUpdateNeeded()<a name="line.14999"></a>
<FONT color="green">15000</FONT>                  &amp;&amp; touchObjectAtMousePosition(isClick))<a name="line.15000"></a>
<FONT color="green">15001</FONT>                assembleChart();<a name="line.15001"></a>
<FONT color="green">15002</FONT>            }<a name="line.15002"></a>
<FONT color="green">15003</FONT>          } else if (Event.ONMOUSEOUT == eventId &amp;&amp; getHoverTouchingEnabled()<a name="line.15003"></a>
<FONT color="green">15004</FONT>              &amp;&amp; takesUsCompletelyOutsideChart(event)) {<a name="line.15004"></a>
<FONT color="green">15005</FONT>            // Window.alert("MOUSEOUT: event.getClientX()=" +<a name="line.15005"></a>
<FONT color="green">15006</FONT>            // event.getClientX() +<a name="line.15006"></a>
<FONT color="green">15007</FONT>            // " event.getClientY()=" + event.getClientY() +<a name="line.15007"></a>
<FONT color="green">15008</FONT>             // " event.getCurrentTarget()="+event.getCurrentTarget() +<a name="line.15008"></a>
<FONT color="green">15009</FONT>            // " event.getTarget()=" + event.getTarget());<a name="line.15009"></a>
<FONT color="green">15010</FONT>            setClientX(GChart.NAI, false); // mouse not over chart,<a name="line.15010"></a>
<FONT color="green">15011</FONT>            setClientY(GChart.NAI, false); // so position is undefined<a name="line.15011"></a>
<FONT color="green">15012</FONT>            if (!isUpdateNeeded() &amp;&amp; touchObjectAtMousePosition())<a name="line.15012"></a>
<FONT color="green">15013</FONT>              assembleChart();<a name="line.15013"></a>
<FONT color="green">15014</FONT>          }<a name="line.15014"></a>
<FONT color="green">15015</FONT>    <a name="line.15015"></a>
<FONT color="green">15016</FONT>        }<a name="line.15016"></a>
<FONT color="green">15017</FONT>    <a name="line.15017"></a>
<FONT color="green">15018</FONT>        // Is chart's DOM rendering consistent with its specs?<a name="line.15018"></a>
<FONT color="green">15019</FONT>        boolean isValidated() {<a name="line.15019"></a>
<FONT color="green">15020</FONT>          boolean result = true;<a name="line.15020"></a>
<FONT color="green">15021</FONT>          for (int i = 0; result &amp;&amp; i &lt; curves.size(); i++)<a name="line.15021"></a>
<FONT color="green">15022</FONT>            result = curves.get(i).isValidated();<a name="line.15022"></a>
<FONT color="green">15023</FONT>          return result;<a name="line.15023"></a>
<FONT color="green">15024</FONT>        }<a name="line.15024"></a>
<FONT color="green">15025</FONT>    <a name="line.15025"></a>
<FONT color="green">15026</FONT>        /*<a name="line.15026"></a>
<FONT color="green">15027</FONT>         * Returns number of "rendering panels" that there actually are right now.<a name="line.15027"></a>
<FONT color="green">15028</FONT>         * <a name="line.15028"></a>
<FONT color="green">15029</FONT>         * GChart's implementation assures that this number is exactly the same for<a name="line.15029"></a>
<FONT color="green">15030</FONT>         * the graphics and annotation rendering panels.<a name="line.15030"></a>
<FONT color="green">15031</FONT>         */<a name="line.15031"></a>
<FONT color="green">15032</FONT>        int getRenderingPanelCount() {<a name="line.15032"></a>
<FONT color="green">15033</FONT>          int result = graphicsPanel.getWidgetCount();<a name="line.15033"></a>
<FONT color="green">15034</FONT>          return result;<a name="line.15034"></a>
<FONT color="green">15035</FONT>        }<a name="line.15035"></a>
<FONT color="green">15036</FONT>    <a name="line.15036"></a>
<FONT color="green">15037</FONT>        int getXChartSize() {<a name="line.15037"></a>
<FONT color="green">15038</FONT>          return xChartSize;<a name="line.15038"></a>
<FONT color="green">15039</FONT>        }<a name="line.15039"></a>
<FONT color="green">15040</FONT>    <a name="line.15040"></a>
<FONT color="green">15041</FONT>        int getYChartSize() {<a name="line.15041"></a>
<FONT color="green">15042</FONT>          return yChartSize;<a name="line.15042"></a>
<FONT color="green">15043</FONT>        }<a name="line.15043"></a>
<FONT color="green">15044</FONT>    <a name="line.15044"></a>
<FONT color="green">15045</FONT>        // quickly returns decorated xChartsize as of the last plotPanel.reset<a name="line.15045"></a>
<FONT color="green">15046</FONT>        int getXChartSizeDecoratedQuickly() {<a name="line.15046"></a>
<FONT color="green">15047</FONT>          int result = xChartSize + leftOfYWidth + rightOfY2Width;<a name="line.15047"></a>
<FONT color="green">15048</FONT>          return result;<a name="line.15048"></a>
<FONT color="green">15049</FONT>        }<a name="line.15049"></a>
<FONT color="green">15050</FONT>    <a name="line.15050"></a>
<FONT color="green">15051</FONT>        // quickly returns decorated yChartsize as of the last plotPanel.reset<a name="line.15051"></a>
<FONT color="green">15052</FONT>        int getYChartSizeDecoratedQuickly() {<a name="line.15052"></a>
<FONT color="green">15053</FONT>          int result = yChartSize + xAxisEnsembleHeight + topMargin<a name="line.15053"></a>
<FONT color="green">15054</FONT>              + chartFootnotesThickness;<a name="line.15054"></a>
<FONT color="green">15055</FONT>          return result;<a name="line.15055"></a>
<FONT color="green">15056</FONT>        }<a name="line.15056"></a>
<FONT color="green">15057</FONT>    <a name="line.15057"></a>
<FONT color="green">15058</FONT>        void setRenderingPosition(GraphicsRenderingPanel grp,<a name="line.15058"></a>
<FONT color="green">15059</FONT>            AnnotationRenderingPanel arp, int xShift, int yShift) {<a name="line.15059"></a>
<FONT color="green">15060</FONT>          // "-" is the cartesian to pixel transformation<a name="line.15060"></a>
<FONT color="green">15061</FONT>          grp.setRenderingPosition(xShift, yShift);<a name="line.15061"></a>
<FONT color="green">15062</FONT>          annotationPanel.setWidgetPosition(arp, xShift, -yShift);<a name="line.15062"></a>
<FONT color="green">15063</FONT>        }<a name="line.15063"></a>
<FONT color="green">15064</FONT>    <a name="line.15064"></a>
<FONT color="green">15065</FONT>      } // end of class PlotPanel<a name="line.15065"></a>
<FONT color="green">15066</FONT>    <a name="line.15066"></a>
<FONT color="green">15067</FONT>      // axis types (used to define which y-axis each curve is on)<a name="line.15067"></a>
<FONT color="green">15068</FONT>      private static class YAxisId {<a name="line.15068"></a>
<FONT color="green">15069</FONT>      }<a name="line.15069"></a>
<FONT color="green">15070</FONT>    <a name="line.15070"></a>
<FONT color="green">15071</FONT>      // case-independent index of next "break" tag in string (case of HTML<a name="line.15071"></a>
<FONT color="green">15072</FONT>      // returned from HasHTML.getHTML can change with browser)<a name="line.15072"></a>
<FONT color="green">15073</FONT>      private static int indexOfBr(String s, int iStart) {<a name="line.15073"></a>
<FONT color="green">15074</FONT>        final String BR1 = "&lt;br&gt;";<a name="line.15074"></a>
<FONT color="green">15075</FONT>        final String BR2 = "&lt;BR&gt;";<a name="line.15075"></a>
<FONT color="green">15076</FONT>        final String BR3 = "&lt;li&gt;"; // recognize &lt;li&gt; as a break.<a name="line.15076"></a>
<FONT color="green">15077</FONT>        final String BR4 = "&lt;LI&gt;";<a name="line.15077"></a>
<FONT color="green">15078</FONT>        final String BR5 = "&lt;tr&gt;"; // recognize &lt;tr&gt; as a break.<a name="line.15078"></a>
<FONT color="green">15079</FONT>        final String BR6 = "&lt;TR&gt;";<a name="line.15079"></a>
<FONT color="green">15080</FONT>        int iBr1 = s.indexOf(BR1, iStart);<a name="line.15080"></a>
<FONT color="green">15081</FONT>        int iBr2 = s.indexOf(BR2, iStart);<a name="line.15081"></a>
<FONT color="green">15082</FONT>        int iBr3 = s.indexOf(BR3, iStart);<a name="line.15082"></a>
<FONT color="green">15083</FONT>        int iBr4 = s.indexOf(BR4, iStart);<a name="line.15083"></a>
<FONT color="green">15084</FONT>        int iBr5 = s.indexOf(BR5, iStart);<a name="line.15084"></a>
<FONT color="green">15085</FONT>        int iBr6 = s.indexOf(BR6, iStart);<a name="line.15085"></a>
<FONT color="green">15086</FONT>        int result1 = 0;<a name="line.15086"></a>
<FONT color="green">15087</FONT>        int result2 = 0;<a name="line.15087"></a>
<FONT color="green">15088</FONT>        int result3 = 0;<a name="line.15088"></a>
<FONT color="green">15089</FONT>        int result = 0;<a name="line.15089"></a>
<FONT color="green">15090</FONT>    <a name="line.15090"></a>
<FONT color="green">15091</FONT>        if (-1 == iBr1)<a name="line.15091"></a>
<FONT color="green">15092</FONT>          result1 = iBr2;<a name="line.15092"></a>
<FONT color="green">15093</FONT>        else if (-1 == iBr2)<a name="line.15093"></a>
<FONT color="green">15094</FONT>          result1 = iBr1;<a name="line.15094"></a>
<FONT color="green">15095</FONT>        else<a name="line.15095"></a>
<FONT color="green">15096</FONT>          result1 = Math.min(iBr1, iBr2);<a name="line.15096"></a>
<FONT color="green">15097</FONT>    <a name="line.15097"></a>
<FONT color="green">15098</FONT>        if (-1 == iBr3)<a name="line.15098"></a>
<FONT color="green">15099</FONT>          result2 = iBr4;<a name="line.15099"></a>
<FONT color="green">15100</FONT>        else if (-1 == iBr4)<a name="line.15100"></a>
<FONT color="green">15101</FONT>          result2 = iBr3;<a name="line.15101"></a>
<FONT color="green">15102</FONT>        else<a name="line.15102"></a>
<FONT color="green">15103</FONT>          result2 = Math.min(iBr3, iBr4);<a name="line.15103"></a>
<FONT color="green">15104</FONT>    <a name="line.15104"></a>
<FONT color="green">15105</FONT>        if (-1 == iBr5)<a name="line.15105"></a>
<FONT color="green">15106</FONT>          result3 = iBr6;<a name="line.15106"></a>
<FONT color="green">15107</FONT>        else if (-1 == iBr6)<a name="line.15107"></a>
<FONT color="green">15108</FONT>          result3 = iBr5;<a name="line.15108"></a>
<FONT color="green">15109</FONT>        else<a name="line.15109"></a>
<FONT color="green">15110</FONT>          result3 = Math.min(iBr5, iBr6);<a name="line.15110"></a>
<FONT color="green">15111</FONT>    <a name="line.15111"></a>
<FONT color="green">15112</FONT>        if (-1 == result1)<a name="line.15112"></a>
<FONT color="green">15113</FONT>          result = result2;<a name="line.15113"></a>
<FONT color="green">15114</FONT>        else if (-1 == result2)<a name="line.15114"></a>
<FONT color="green">15115</FONT>          result = result1;<a name="line.15115"></a>
<FONT color="green">15116</FONT>        else<a name="line.15116"></a>
<FONT color="green">15117</FONT>          result = Math.min(result1, result2);<a name="line.15117"></a>
<FONT color="green">15118</FONT>    <a name="line.15118"></a>
<FONT color="green">15119</FONT>        if (-1 == result)<a name="line.15119"></a>
<FONT color="green">15120</FONT>          result = result3;<a name="line.15120"></a>
<FONT color="green">15121</FONT>        else if (-1 != result3)<a name="line.15121"></a>
<FONT color="green">15122</FONT>          result = Math.min(result, result3);<a name="line.15122"></a>
<FONT color="green">15123</FONT>    <a name="line.15123"></a>
<FONT color="green">15124</FONT>        return result;<a name="line.15124"></a>
<FONT color="green">15125</FONT>    <a name="line.15125"></a>
<FONT color="green">15126</FONT>      }<a name="line.15126"></a>
<FONT color="green">15127</FONT>    <a name="line.15127"></a>
<FONT color="green">15128</FONT>      private static int indexOfBr(String s) {<a name="line.15128"></a>
<FONT color="green">15129</FONT>        return indexOfBr(s, 0);<a name="line.15129"></a>
<FONT color="green">15130</FONT>      }<a name="line.15130"></a>
<FONT color="green">15131</FONT>    <a name="line.15131"></a>
<FONT color="green">15132</FONT>      // Provides a character-based width estimate when simple tags<a name="line.15132"></a>
<FONT color="green">15133</FONT>      // such as &lt;b&gt; and &lt;i&gt; are present in a multi-line,<a name="line.15133"></a>
<FONT color="green">15134</FONT>      // "break"-delimited, string. Very approximate, but a useful<a name="line.15134"></a>
<FONT color="green">15135</FONT>      // default.<a name="line.15135"></a>
<FONT color="green">15136</FONT>      private static int htmlWidth(String sIn) {<a name="line.15136"></a>
<FONT color="green">15137</FONT>        int iBr = indexOfBr(sIn);<a name="line.15137"></a>
<FONT color="green">15138</FONT>        String s = (-1 == iBr) ? sIn : sIn.substring(0, iBr);<a name="line.15138"></a>
<FONT color="green">15139</FONT>        final String LITERAL_PAT = "[&amp;][#a-zA-Z]+[;]";<a name="line.15139"></a>
<FONT color="green">15140</FONT>        s = s.replaceAll(LITERAL_PAT, "X"); // literals count as 1 char<a name="line.15140"></a>
<FONT color="green">15141</FONT>        final String TAG_PAT = "[&lt;][^&gt;]+[&gt;]";<a name="line.15141"></a>
<FONT color="green">15142</FONT>        s = s.replaceAll(TAG_PAT, ""); // tags don't count at all<a name="line.15142"></a>
<FONT color="green">15143</FONT>        return s.length();<a name="line.15143"></a>
<FONT color="green">15144</FONT>      }<a name="line.15144"></a>
<FONT color="green">15145</FONT>    <a name="line.15145"></a>
<FONT color="green">15146</FONT>      // number of &lt;br&gt; delimited lines in an HTML string<a name="line.15146"></a>
<FONT color="green">15147</FONT>      private static int htmlHeight(String s) {<a name="line.15147"></a>
<FONT color="green">15148</FONT>        final int BR_LEN = 4;<a name="line.15148"></a>
<FONT color="green">15149</FONT>        int iBr = 0;<a name="line.15149"></a>
<FONT color="green">15150</FONT>        int result = 1;<a name="line.15150"></a>
<FONT color="green">15151</FONT>        if (null != s) {<a name="line.15151"></a>
<FONT color="green">15152</FONT>          for (iBr = indexOfBr(s); iBr != -1; iBr = indexOfBr(s, iBr + BR_LEN))<a name="line.15152"></a>
<FONT color="green">15153</FONT>            result++;<a name="line.15153"></a>
<FONT color="green">15154</FONT>        }<a name="line.15154"></a>
<FONT color="green">15155</FONT>        return result;<a name="line.15155"></a>
<FONT color="green">15156</FONT>      }<a name="line.15156"></a>
<FONT color="green">15157</FONT>    <a name="line.15157"></a>
<FONT color="green">15158</FONT>      /*<a name="line.15158"></a>
<FONT color="green">15159</FONT>       * Annotates (labels) a chart symbol. Users access this class via wrapper<a name="line.15159"></a>
<FONT color="green">15160</FONT>       * methods of the Point class, and via various tick-label related methods of<a name="line.15160"></a>
<FONT color="green">15161</FONT>       * the Axis class.<a name="line.15161"></a>
<FONT color="green">15162</FONT>       */<a name="line.15162"></a>
<FONT color="green">15163</FONT>    <a name="line.15163"></a>
<FONT color="green">15164</FONT>      static class Annotation {<a name="line.15164"></a>
<FONT color="green">15165</FONT>        String fontColor = DEFAULT_FONT_COLOR;<a name="line.15165"></a>
<FONT color="green">15166</FONT>        int fontSize = DEFAULT_ANNOTATION_FONTSIZE;<a name="line.15166"></a>
<FONT color="green">15167</FONT>        String fontFamily = null; // will cause it to adapt parent GChart's<a name="line.15167"></a>
<FONT color="green">15168</FONT>        String fontStyle = "normal";<a name="line.15168"></a>
<FONT color="green">15169</FONT>        String fontWeight = "normal";<a name="line.15169"></a>
<FONT color="green">15170</FONT>        AnnotationLocation location = null;<a name="line.15170"></a>
<FONT color="green">15171</FONT>        String text = null;<a name="line.15171"></a>
<FONT color="green">15172</FONT>        Widget widget = null; // may be used in lieu of text or HTML<a name="line.15172"></a>
<FONT color="green">15173</FONT>        boolean isVisible = true;<a name="line.15173"></a>
<FONT color="green">15174</FONT>        int xShift = 0;<a name="line.15174"></a>
<FONT color="green">15175</FONT>        int yShift = 0;<a name="line.15175"></a>
<FONT color="green">15176</FONT>        // no break tags ==&gt; plain text Estimated number of lines, width in<a name="line.15176"></a>
<FONT color="green">15177</FONT>        // chars, of annotation text (not used by Widgets)<a name="line.15177"></a>
<FONT color="green">15178</FONT>        boolean isHTML = false;<a name="line.15178"></a>
<FONT color="green">15179</FONT>        int numberOfLinesHigh = 0;<a name="line.15179"></a>
<FONT color="green">15180</FONT>        int numberOfCharsWide = 0;<a name="line.15180"></a>
<FONT color="green">15181</FONT>        int widthUpperBound = GChart.NAI;<a name="line.15181"></a>
<FONT color="green">15182</FONT>        int heightUpperBound = GChart.NAI;<a name="line.15182"></a>
<FONT color="green">15183</FONT>        static final int HTML_LEN = 6; // &lt;html&gt;<a name="line.15183"></a>
<FONT color="green">15184</FONT>        static final int BR_LEN = 4;   // &lt;br&gt;<a name="line.15184"></a>
<FONT color="green">15185</FONT>    <a name="line.15185"></a>
<FONT color="green">15186</FONT>        /*<a name="line.15186"></a>
<FONT color="green">15187</FONT>         * Computes parameters used to estimate the width and height of the<a name="line.15187"></a>
<FONT color="green">15188</FONT>         * (invisible) enclosing 1x1 Grid of an annotation (used to align, center,<a name="line.15188"></a>
<FONT color="green">15189</FONT>         * etc. the annotation) &lt;p&gt;<a name="line.15189"></a>
<FONT color="green">15190</FONT>         */<a name="line.15190"></a>
<FONT color="green">15191</FONT>        private String analyzeHTML(String s) {<a name="line.15191"></a>
<FONT color="green">15192</FONT>          String result = null;<a name="line.15192"></a>
<FONT color="green">15193</FONT>          if (null == s) {<a name="line.15193"></a>
<FONT color="green">15194</FONT>            isHTML = false;<a name="line.15194"></a>
<FONT color="green">15195</FONT>            numberOfLinesHigh = 0;<a name="line.15195"></a>
<FONT color="green">15196</FONT>            numberOfCharsWide = 0;<a name="line.15196"></a>
<FONT color="green">15197</FONT>          } else if (!s.startsWith("&lt;html&gt;")) { // no html==&gt;plain text<a name="line.15197"></a>
<FONT color="green">15198</FONT>            isHTML = false;<a name="line.15198"></a>
<FONT color="green">15199</FONT>            numberOfLinesHigh = 1;<a name="line.15199"></a>
<FONT color="green">15200</FONT>            numberOfCharsWide = s.length();<a name="line.15200"></a>
<FONT color="green">15201</FONT>            result = s;<a name="line.15201"></a>
<FONT color="green">15202</FONT>          } else { // HTML<a name="line.15202"></a>
<FONT color="green">15203</FONT>            isHTML = true;<a name="line.15203"></a>
<FONT color="green">15204</FONT>            // &lt;html&gt; is just a flag, not a tag, so strip it out.<a name="line.15204"></a>
<FONT color="green">15205</FONT>            result = s.substring(HTML_LEN);<a name="line.15205"></a>
<FONT color="green">15206</FONT>            if (widthUpperBound == GChart.NAI)<a name="line.15206"></a>
<FONT color="green">15207</FONT>              numberOfCharsWide = htmlWidth(result);<a name="line.15207"></a>
<FONT color="green">15208</FONT>    <a name="line.15208"></a>
<FONT color="green">15209</FONT>            if (heightUpperBound == GChart.NAI)<a name="line.15209"></a>
<FONT color="green">15210</FONT>              numberOfLinesHigh = htmlHeight(result);<a name="line.15210"></a>
<FONT color="green">15211</FONT>    <a name="line.15211"></a>
<FONT color="green">15212</FONT>          }<a name="line.15212"></a>
<FONT color="green">15213</FONT>          return result;<a name="line.15213"></a>
<FONT color="green">15214</FONT>    <a name="line.15214"></a>
<FONT color="green">15215</FONT>        }<a name="line.15215"></a>
<FONT color="green">15216</FONT>    <a name="line.15216"></a>
<FONT color="green">15217</FONT>        // Returns number of chars in first &lt;br&gt;-delimited line of<a name="line.15217"></a>
<FONT color="green">15218</FONT>        // given string. A very crude way to estimate (especially<a name="line.15218"></a>
<FONT color="green">15219</FONT>        // HTML) width in characters, but user can give explicit<a name="line.15219"></a>
<FONT color="green">15220</FONT>        // widths when the width estimates based on this char width<a name="line.15220"></a>
<FONT color="green">15221</FONT>        // heuristic fail them.<a name="line.15221"></a>
<FONT color="green">15222</FONT>        static int getNumberOfCharsWide(String s) {<a name="line.15222"></a>
<FONT color="green">15223</FONT>          int result = 0;<a name="line.15223"></a>
<FONT color="green">15224</FONT>          if (!s.startsWith("&lt;html&gt;")) {<a name="line.15224"></a>
<FONT color="green">15225</FONT>            result = s.length();<a name="line.15225"></a>
<FONT color="green">15226</FONT>          } else {<a name="line.15226"></a>
<FONT color="green">15227</FONT>            result = htmlWidth(s);<a name="line.15227"></a>
<FONT color="green">15228</FONT>          }<a name="line.15228"></a>
<FONT color="green">15229</FONT>          return result;<a name="line.15229"></a>
<FONT color="green">15230</FONT>        }<a name="line.15230"></a>
<FONT color="green">15231</FONT>    <a name="line.15231"></a>
<FONT color="green">15232</FONT>        String getFontColor() {<a name="line.15232"></a>
<FONT color="green">15233</FONT>          return fontColor;<a name="line.15233"></a>
<FONT color="green">15234</FONT>        }<a name="line.15234"></a>
<FONT color="green">15235</FONT>    <a name="line.15235"></a>
<FONT color="green">15236</FONT>        int getFontSize() {<a name="line.15236"></a>
<FONT color="green">15237</FONT>          return fontSize;<a name="line.15237"></a>
<FONT color="green">15238</FONT>        }<a name="line.15238"></a>
<FONT color="green">15239</FONT>    <a name="line.15239"></a>
<FONT color="green">15240</FONT>        AnnotationLocation getLocation() {<a name="line.15240"></a>
<FONT color="green">15241</FONT>          return location;<a name="line.15241"></a>
<FONT color="green">15242</FONT>        }<a name="line.15242"></a>
<FONT color="green">15243</FONT>    <a name="line.15243"></a>
<FONT color="green">15244</FONT>        boolean isHTML() {<a name="line.15244"></a>
<FONT color="green">15245</FONT>          return isHTML;<a name="line.15245"></a>
<FONT color="green">15246</FONT>        }<a name="line.15246"></a>
<FONT color="green">15247</FONT>    <a name="line.15247"></a>
<FONT color="green">15248</FONT>        String getText() {<a name="line.15248"></a>
<FONT color="green">15249</FONT>          return (isHTML ? ("&lt;html&gt;" + text) : text);<a name="line.15249"></a>
<FONT color="green">15250</FONT>        }<a name="line.15250"></a>
<FONT color="green">15251</FONT>    <a name="line.15251"></a>
<FONT color="green">15252</FONT>        boolean getVisible() {<a name="line.15252"></a>
<FONT color="green">15253</FONT>          return isVisible;<a name="line.15253"></a>
<FONT color="green">15254</FONT>        }<a name="line.15254"></a>
<FONT color="green">15255</FONT>    <a name="line.15255"></a>
<FONT color="green">15256</FONT>        int getXShift() {<a name="line.15256"></a>
<FONT color="green">15257</FONT>          return xShift;<a name="line.15257"></a>
<FONT color="green">15258</FONT>        }<a name="line.15258"></a>
<FONT color="green">15259</FONT>    <a name="line.15259"></a>
<FONT color="green">15260</FONT>        int getYShift() {<a name="line.15260"></a>
<FONT color="green">15261</FONT>          return yShift;<a name="line.15261"></a>
<FONT color="green">15262</FONT>        }<a name="line.15262"></a>
<FONT color="green">15263</FONT>    <a name="line.15263"></a>
<FONT color="green">15264</FONT>        void setFontColor(String cssColor) {<a name="line.15264"></a>
<FONT color="green">15265</FONT>          this.fontColor = cssColor;<a name="line.15265"></a>
<FONT color="green">15266</FONT>        }<a name="line.15266"></a>
<FONT color="green">15267</FONT>    <a name="line.15267"></a>
<FONT color="green">15268</FONT>        void setFontSize(int fontSize) {<a name="line.15268"></a>
<FONT color="green">15269</FONT>          this.fontSize = fontSize;<a name="line.15269"></a>
<FONT color="green">15270</FONT>        }<a name="line.15270"></a>
<FONT color="green">15271</FONT>    <a name="line.15271"></a>
<FONT color="green">15272</FONT>        void setFontWeight(String cssWeight) {<a name="line.15272"></a>
<FONT color="green">15273</FONT>          this.fontWeight = cssWeight;<a name="line.15273"></a>
<FONT color="green">15274</FONT>        }<a name="line.15274"></a>
<FONT color="green">15275</FONT>    <a name="line.15275"></a>
<FONT color="green">15276</FONT>        void setFontFamily(String cssFontFamily) {<a name="line.15276"></a>
<FONT color="green">15277</FONT>          this.fontFamily = cssFontFamily;<a name="line.15277"></a>
<FONT color="green">15278</FONT>        }<a name="line.15278"></a>
<FONT color="green">15279</FONT>    <a name="line.15279"></a>
<FONT color="green">15280</FONT>        void setFontStyle(String cssStyle) {<a name="line.15280"></a>
<FONT color="green">15281</FONT>          this.fontStyle = cssStyle;<a name="line.15281"></a>
<FONT color="green">15282</FONT>        }<a name="line.15282"></a>
<FONT color="green">15283</FONT>    <a name="line.15283"></a>
<FONT color="green">15284</FONT>        String getFontWeight() {<a name="line.15284"></a>
<FONT color="green">15285</FONT>          return fontWeight;<a name="line.15285"></a>
<FONT color="green">15286</FONT>        }<a name="line.15286"></a>
<FONT color="green">15287</FONT>    <a name="line.15287"></a>
<FONT color="green">15288</FONT>        String getFontFamily() {<a name="line.15288"></a>
<FONT color="green">15289</FONT>          return fontFamily;<a name="line.15289"></a>
<FONT color="green">15290</FONT>        }<a name="line.15290"></a>
<FONT color="green">15291</FONT>        String getFontFamilyExpanded(String defFontFamily) {<a name="line.15291"></a>
<FONT color="green">15292</FONT>          String result = fontFamily;<a name="line.15292"></a>
<FONT color="green">15293</FONT>          if (null == result)<a name="line.15293"></a>
<FONT color="green">15294</FONT>            result = defFontFamily;<a name="line.15294"></a>
<FONT color="green">15295</FONT>          return result;<a name="line.15295"></a>
<FONT color="green">15296</FONT>        }<a name="line.15296"></a>
<FONT color="green">15297</FONT>        <a name="line.15297"></a>
<FONT color="green">15298</FONT>        String getFontStyle() {<a name="line.15298"></a>
<FONT color="green">15299</FONT>          return fontStyle;<a name="line.15299"></a>
<FONT color="green">15300</FONT>        }<a name="line.15300"></a>
<FONT color="green">15301</FONT>    <a name="line.15301"></a>
<FONT color="green">15302</FONT>        void setLocation(AnnotationLocation location) {<a name="line.15302"></a>
<FONT color="green">15303</FONT>          this.location = location;<a name="line.15303"></a>
<FONT color="green">15304</FONT>        }<a name="line.15304"></a>
<FONT color="green">15305</FONT>    <a name="line.15305"></a>
<FONT color="green">15306</FONT>        void setText(String text, int widthUpperBound, int heightUpperBound) {<a name="line.15306"></a>
<FONT color="green">15307</FONT>          this.widthUpperBound = widthUpperBound;<a name="line.15307"></a>
<FONT color="green">15308</FONT>          this.heightUpperBound = heightUpperBound;<a name="line.15308"></a>
<FONT color="green">15309</FONT>          this.text = analyzeHTML(text);<a name="line.15309"></a>
<FONT color="green">15310</FONT>          this.widget = null;<a name="line.15310"></a>
<FONT color="green">15311</FONT>        }<a name="line.15311"></a>
<FONT color="green">15312</FONT>    <a name="line.15312"></a>
<FONT color="green">15313</FONT>        void setText(String text) {<a name="line.15313"></a>
<FONT color="green">15314</FONT>          setText(text, GChart.NAI, GChart.NAI);<a name="line.15314"></a>
<FONT color="green">15315</FONT>        }<a name="line.15315"></a>
<FONT color="green">15316</FONT>    <a name="line.15316"></a>
<FONT color="green">15317</FONT>        void setVisible(boolean isVisible) {<a name="line.15317"></a>
<FONT color="green">15318</FONT>          this.isVisible = isVisible;<a name="line.15318"></a>
<FONT color="green">15319</FONT>        }<a name="line.15319"></a>
<FONT color="green">15320</FONT>    <a name="line.15320"></a>
<FONT color="green">15321</FONT>        void setWidget(Widget widget, int widthUpperBound, int heightUpperBound) {<a name="line.15321"></a>
<FONT color="green">15322</FONT>          this.widthUpperBound = widthUpperBound;<a name="line.15322"></a>
<FONT color="green">15323</FONT>          this.heightUpperBound = heightUpperBound;<a name="line.15323"></a>
<FONT color="green">15324</FONT>          this.text = null;<a name="line.15324"></a>
<FONT color="green">15325</FONT>          this.widget = widget;<a name="line.15325"></a>
<FONT color="green">15326</FONT>        }<a name="line.15326"></a>
<FONT color="green">15327</FONT>    <a name="line.15327"></a>
<FONT color="green">15328</FONT>        void setWidget(Widget widget) {<a name="line.15328"></a>
<FONT color="green">15329</FONT>          setWidget(widget, DEFAULT_WIDGET_WIDTH_UPPERBOUND,<a name="line.15329"></a>
<FONT color="green">15330</FONT>              DEFAULT_WIDGET_HEIGHT_UPPERBOUND);<a name="line.15330"></a>
<FONT color="green">15331</FONT>        }<a name="line.15331"></a>
<FONT color="green">15332</FONT>    <a name="line.15332"></a>
<FONT color="green">15333</FONT>        Widget getWidget() {<a name="line.15333"></a>
<FONT color="green">15334</FONT>          return widget;<a name="line.15334"></a>
<FONT color="green">15335</FONT>        }<a name="line.15335"></a>
<FONT color="green">15336</FONT>    <a name="line.15336"></a>
<FONT color="green">15337</FONT>        void setXShift(int xShift) {<a name="line.15337"></a>
<FONT color="green">15338</FONT>          this.xShift = xShift;<a name="line.15338"></a>
<FONT color="green">15339</FONT>        }<a name="line.15339"></a>
<FONT color="green">15340</FONT>    <a name="line.15340"></a>
<FONT color="green">15341</FONT>        void setYShift(int yShift) {<a name="line.15341"></a>
<FONT color="green">15342</FONT>          this.yShift = yShift;<a name="line.15342"></a>
<FONT color="green">15343</FONT>        }<a name="line.15343"></a>
<FONT color="green">15344</FONT>    <a name="line.15344"></a>
<FONT color="green">15345</FONT>        int getHeightUpperBound() {<a name="line.15345"></a>
<FONT color="green">15346</FONT>          int result = 0;<a name="line.15346"></a>
<FONT color="green">15347</FONT>          if (heightUpperBound != GChart.NAI)<a name="line.15347"></a>
<FONT color="green">15348</FONT>            result = heightUpperBound;<a name="line.15348"></a>
<FONT color="green">15349</FONT>          else {<a name="line.15349"></a>
<FONT color="green">15350</FONT>            result = (int) Math.ceil(fontSize * numberOfLinesHigh<a name="line.15350"></a>
<FONT color="green">15351</FONT>                * CHARHEIGHT_TO_FONTSIZE_UPPERBOUND);<a name="line.15351"></a>
<FONT color="green">15352</FONT>          }<a name="line.15352"></a>
<FONT color="green">15353</FONT>          return result;<a name="line.15353"></a>
<FONT color="green">15354</FONT>        }<a name="line.15354"></a>
<FONT color="green">15355</FONT>    <a name="line.15355"></a>
<FONT color="green">15356</FONT>        int getWidthUpperBound() {<a name="line.15356"></a>
<FONT color="green">15357</FONT>          int result = 0;<a name="line.15357"></a>
<FONT color="green">15358</FONT>          if (widthUpperBound != GChart.NAI)<a name="line.15358"></a>
<FONT color="green">15359</FONT>            result = widthUpperBound;<a name="line.15359"></a>
<FONT color="green">15360</FONT>          else {<a name="line.15360"></a>
<FONT color="green">15361</FONT>            result = (int) Math.ceil(fontSize * numberOfCharsWide<a name="line.15361"></a>
<FONT color="green">15362</FONT>                * CHARWIDTH_TO_FONTSIZE_UPPERBOUND);<a name="line.15362"></a>
<FONT color="green">15363</FONT>          }<a name="line.15363"></a>
<FONT color="green">15364</FONT>          return result;<a name="line.15364"></a>
<FONT color="green">15365</FONT>        }<a name="line.15365"></a>
<FONT color="green">15366</FONT>    <a name="line.15366"></a>
<FONT color="green">15367</FONT>      } // end of class Annotation<a name="line.15367"></a>
<FONT color="green">15368</FONT>    <a name="line.15368"></a>
<FONT color="green">15369</FONT>      /**<a name="line.15369"></a>
<FONT color="green">15370</FONT>       * Default size, in pixels, of text used to annotate individual plotted points<a name="line.15370"></a>
<FONT color="green">15371</FONT>       * on a curve.<a name="line.15371"></a>
<FONT color="green">15372</FONT>       * <a name="line.15372"></a>
<FONT color="green">15373</FONT>       * @see Curve.Point#setFontSize Point.setFontSize<a name="line.15373"></a>
<FONT color="green">15374</FONT>       */<a name="line.15374"></a>
<FONT color="green">15375</FONT>      public static final int DEFAULT_ANNOTATION_FONTSIZE = 12;<a name="line.15375"></a>
<FONT color="green">15376</FONT>    <a name="line.15376"></a>
<FONT color="green">15377</FONT>      /**<a name="line.15377"></a>
<FONT color="green">15378</FONT>       * Default pixel height of rectangular "brush" that defines how close the<a name="line.15378"></a>
<FONT color="green">15379</FONT>       * mouse cursor must be to a rendered symbol for it to be "touched" (which<a name="line.15379"></a>
<FONT color="green">15380</FONT>       * pops up its hover feedback).<a name="line.15380"></a>
<FONT color="green">15381</FONT>       * <a name="line.15381"></a>
<FONT color="green">15382</FONT>       * @see Symbol#setBrushHeight setBrushHeight<a name="line.15382"></a>
<FONT color="green">15383</FONT>       * @see Symbol#setBrushWidth setBrushWidth<a name="line.15383"></a>
<FONT color="green">15384</FONT>       * @see #DEFAULT_BRUSH_WIDTH DEFAULT_BRUSH_WIDTH<a name="line.15384"></a>
<FONT color="green">15385</FONT>       */<a name="line.15385"></a>
<FONT color="green">15386</FONT>      public static final int DEFAULT_BRUSH_HEIGHT = 1;<a name="line.15386"></a>
<FONT color="green">15387</FONT>      /**<a name="line.15387"></a>
<FONT color="green">15388</FONT>       * <a name="line.15388"></a>
<FONT color="green">15389</FONT>       * Default pixel width of rectangular "brush" that defines how close the mouse<a name="line.15389"></a>
<FONT color="green">15390</FONT>       * cursor must be to a rendered symbol for it to be "touched" (which pops up<a name="line.15390"></a>
<FONT color="green">15391</FONT>       * its hover feedback).<a name="line.15391"></a>
<FONT color="green">15392</FONT>       * <a name="line.15392"></a>
<FONT color="green">15393</FONT>       * @see Symbol#setBrushHeight setBrushHeight<a name="line.15393"></a>
<FONT color="green">15394</FONT>       * @see Symbol#setBrushWidth setBrushWidth<a name="line.15394"></a>
<FONT color="green">15395</FONT>       * @see #DEFAULT_BRUSH_HEIGHT DEFAULT_BRUSH_HEIGHT<a name="line.15395"></a>
<FONT color="green">15396</FONT>       */<a name="line.15396"></a>
<FONT color="green">15397</FONT>      public static final int DEFAULT_BRUSH_WIDTH = 1;<a name="line.15397"></a>
<FONT color="green">15398</FONT>    <a name="line.15398"></a>
<FONT color="green">15399</FONT>      /**<a name="line.15399"></a>
<FONT color="green">15400</FONT>       * Default color of border around the chart legend<a name="line.15400"></a>
<FONT color="green">15401</FONT>       * <a name="line.15401"></a>
<FONT color="green">15402</FONT>       * @see #setLegendBorderColor setLegendBorderColor<a name="line.15402"></a>
<FONT color="green">15403</FONT>       * <a name="line.15403"></a>
<FONT color="green">15404</FONT>       */<a name="line.15404"></a>
<FONT color="green">15405</FONT>      public static final String DEFAULT_LEGEND_BORDER_COLOR = "black";<a name="line.15405"></a>
<FONT color="green">15406</FONT>      /**<a name="line.15406"></a>
<FONT color="green">15407</FONT>       * Default width of border around the chart legend<a name="line.15407"></a>
<FONT color="green">15408</FONT>       * <a name="line.15408"></a>
<FONT color="green">15409</FONT>       * @see #setLegendBorderWidth setLegendBorderWidth<a name="line.15409"></a>
<FONT color="green">15410</FONT>       * <a name="line.15410"></a>
<FONT color="green">15411</FONT>       */<a name="line.15411"></a>
<FONT color="green">15412</FONT>      public static final int DEFAULT_LEGEND_BORDER_WIDTH = 1;<a name="line.15412"></a>
<FONT color="green">15413</FONT>      /**<a name="line.15413"></a>
<FONT color="green">15414</FONT>       * Default style of border around the chart legend<a name="line.15414"></a>
<FONT color="green">15415</FONT>       * <a name="line.15415"></a>
<FONT color="green">15416</FONT>       * @see #setLegendBorderStyle setLegendBorderStyle<a name="line.15416"></a>
<FONT color="green">15417</FONT>       * <a name="line.15417"></a>
<FONT color="green">15418</FONT>       */<a name="line.15418"></a>
<FONT color="green">15419</FONT>      public static final String DEFAULT_LEGEND_BORDER_STYLE = "solid";<a name="line.15419"></a>
<FONT color="green">15420</FONT>    <a name="line.15420"></a>
<FONT color="green">15421</FONT>      /**<a name="line.15421"></a>
<FONT color="green">15422</FONT>       * Default color of background of the chart legend<a name="line.15422"></a>
<FONT color="green">15423</FONT>       * <a name="line.15423"></a>
<FONT color="green">15424</FONT>       * @see #setLegendBackgroundColor setLegendBackgroundColor<a name="line.15424"></a>
<FONT color="green">15425</FONT>       * <a name="line.15425"></a>
<FONT color="green">15426</FONT>       */<a name="line.15426"></a>
<FONT color="green">15427</FONT>      public static final String DEFAULT_LEGEND_BACKGROUND_COLOR = "transparent";<a name="line.15427"></a>
<FONT color="green">15428</FONT>      /**<a name="line.15428"></a>
<FONT color="green">15429</FONT>       * The default color of any text appearing in a chart's legend, annotations,<a name="line.15429"></a>
<FONT color="green">15430</FONT>       * or tick labels.<a name="line.15430"></a>
<FONT color="green">15431</FONT>       * <a name="line.15431"></a>
<FONT color="green">15432</FONT>       * @see #setLegendFontColor setLegendFontColor<a name="line.15432"></a>
<FONT color="green">15433</FONT>       * @see Axis#setTickLabelFontColor setTickLabelFontColor<a name="line.15433"></a>
<FONT color="green">15434</FONT>       * @see Curve.Point#setAnnotationFontColor setAnnotationFontColor<a name="line.15434"></a>
<FONT color="green">15435</FONT>       * <a name="line.15435"></a>
<FONT color="green">15436</FONT>       */<a name="line.15436"></a>
<FONT color="green">15437</FONT>      public final static String DEFAULT_FONT_COLOR = "black";<a name="line.15437"></a>
<FONT color="green">15438</FONT>      /**<a name="line.15438"></a>
<FONT color="green">15439</FONT>       * The font-family that GChart uses by default for all textual<a name="line.15439"></a>
<FONT color="green">15440</FONT>       * annotations on a chart (tick labels, point annotation, legend key<a name="line.15440"></a>
<FONT color="green">15441</FONT>       * text, titles, and footnotes).<a name="line.15441"></a>
<FONT color="green">15442</FONT>       * &lt;p&gt;<a name="line.15442"></a>
<FONT color="green">15443</FONT>       *<a name="line.15443"></a>
<FONT color="green">15444</FONT>       * Chosen to be the same font-family as that used in GWT's standard<a name="line.15444"></a>
<FONT color="green">15445</FONT>       * CSS stylesheet ("theme"). &lt;p&gt;<a name="line.15445"></a>
<FONT color="green">15446</FONT>       * <a name="line.15446"></a>
<FONT color="green">15447</FONT>       * @see #setLegendFontFamily setLegendFontFamily<a name="line.15447"></a>
<FONT color="green">15448</FONT>       * @see Axis#setTickLabelFontFamily setTickLabelFontFamily<a name="line.15448"></a>
<FONT color="green">15449</FONT>       * @see Curve.Point#setAnnotationFontFamily setAnnotationFontFamily<a name="line.15449"></a>
<FONT color="green">15450</FONT>       * <a name="line.15450"></a>
<FONT color="green">15451</FONT>       */<a name="line.15451"></a>
<FONT color="green">15452</FONT>      public static final String DEFAULT_FONT_FAMILY = "Arial Unicode MS, Arial, sans-serif";<a name="line.15452"></a>
<FONT color="green">15453</FONT>      /**<a name="line.15453"></a>
<FONT color="green">15454</FONT>       * Default style of axis label and legend fonts.<a name="line.15454"></a>
<FONT color="green">15455</FONT>       * <a name="line.15455"></a>
<FONT color="green">15456</FONT>       * @see #setLegendFontStyle setLegendFontStyle<a name="line.15456"></a>
<FONT color="green">15457</FONT>       * @see Axis#setTickLabelFontStyle setTickLabelFontStyle<a name="line.15457"></a>
<FONT color="green">15458</FONT>       * @see Curve.Point#setAnnotationFontStyle setAnnotationFontStyle<a name="line.15458"></a>
<FONT color="green">15459</FONT>       * <a name="line.15459"></a>
<FONT color="green">15460</FONT>       */<a name="line.15460"></a>
<FONT color="green">15461</FONT>      public static final String DEFAULT_FONT_STYLE = "normal";<a name="line.15461"></a>
<FONT color="green">15462</FONT>      /**<a name="line.15462"></a>
<FONT color="green">15463</FONT>       * Default weight of axis label and legend fonts.<a name="line.15463"></a>
<FONT color="green">15464</FONT>       * <a name="line.15464"></a>
<FONT color="green">15465</FONT>       * @see #setLegendFontWeight setLegendFontWeight<a name="line.15465"></a>
<FONT color="green">15466</FONT>       * @see Axis#setTickLabelFontWeight setTickLabelFontWeight<a name="line.15466"></a>
<FONT color="green">15467</FONT>       * @see Curve.Point#setAnnotationFontWeight setAnnotationFontWeight<a name="line.15467"></a>
<FONT color="green">15468</FONT>       * <a name="line.15468"></a>
<FONT color="green">15469</FONT>       */<a name="line.15469"></a>
<FONT color="green">15470</FONT>    <a name="line.15470"></a>
<FONT color="green">15471</FONT>      public static final String DEFAULT_FONT_WEIGHT = "normal";<a name="line.15471"></a>
<FONT color="green">15472</FONT>    <a name="line.15472"></a>
<FONT color="green">15473</FONT>      /**<a name="line.15473"></a>
<FONT color="green">15474</FONT>       * The default template string used to generate the hovertext displayed when<a name="line.15474"></a>
<FONT color="green">15475</FONT>       * the user hovers their mouse above a point on a curve (pie slices have a<a name="line.15475"></a>
<FONT color="green">15476</FONT>       * different default).<a name="line.15476"></a>
<FONT color="green">15477</FONT>       * <a name="line.15477"></a>
<FONT color="green">15478</FONT>       * @see Symbol#setHovertextTemplate setHovertextTemplate<a name="line.15478"></a>
<FONT color="green">15479</FONT>       * @see #DEFAULT_PIE_SLICE_HOVERTEXT_TEMPLATE<a name="line.15479"></a>
<FONT color="green">15480</FONT>       *      DEFAULT_PIE_SLICE_HOVERTEXT_TEMPLATE<a name="line.15480"></a>
<FONT color="green">15481</FONT>       * <a name="line.15481"></a>
<FONT color="green">15482</FONT>       */<a name="line.15482"></a>
<FONT color="green">15483</FONT>      public static final String DEFAULT_HOVERTEXT_TEMPLATE = GChart<a name="line.15483"></a>
<FONT color="green">15484</FONT>          .formatAsHovertext("(${x}, ${y})");<a name="line.15484"></a>
<FONT color="green">15485</FONT>      /**<a name="line.15485"></a>
<FONT color="green">15486</FONT>       * The default hover feedback location used to position the hover feedback<a name="line.15486"></a>
<FONT color="green">15487</FONT>       * when the user hovers their mouse above a point on a curve (pie slices, and<a name="line.15487"></a>
<FONT color="green">15488</FONT>       * bar symbols have different defaults).<a name="line.15488"></a>
<FONT color="green">15489</FONT>       * <a name="line.15489"></a>
<FONT color="green">15490</FONT>       * @see Symbol#setHoverLocation setHoverLocation<a name="line.15490"></a>
<FONT color="green">15491</FONT>       * @see #DEFAULT_PIE_SLICE_HOVER_LOCATION DEFAULT_PIE_SLICE_HOVER_LOCATION<a name="line.15491"></a>
<FONT color="green">15492</FONT>       * @see #DEFAULT_VBAR_BASELINE_HOVER_LOCATION<a name="line.15492"></a>
<FONT color="green">15493</FONT>       *      DEFAULT_VBAR_BASELINE_HOVER_LOCATION<a name="line.15493"></a>
<FONT color="green">15494</FONT>       * @see #DEFAULT_VBARBOTTOM_HOVER_LOCATION DEFAULT_VBARBOTTOM_HOVER_LOCATION<a name="line.15494"></a>
<FONT color="green">15495</FONT>       * @see #DEFAULT_VBARTOP_HOVER_LOCATION DEFAULT_VBARTOP_HOVER_LOCATION<a name="line.15495"></a>
<FONT color="green">15496</FONT>       * @see #DEFAULT_HBAR_BASELINE_HOVER_LOCATION<a name="line.15496"></a>
<FONT color="green">15497</FONT>       *      DEFAULT_HBAR_BASELINE_HOVER_LOCATION<a name="line.15497"></a>
<FONT color="green">15498</FONT>       * @see #DEFAULT_HBARLEFT_HOVER_LOCATION DEFAULT_HBARLEFT_HOVER_LOCATION<a name="line.15498"></a>
<FONT color="green">15499</FONT>       * @see #DEFAULT_HBARRIGHT_HOVER_LOCATION DEFAULT_HBARRIGHT_HOVER_LOCATION<a name="line.15499"></a>
<FONT color="green">15500</FONT>       * <a name="line.15500"></a>
<FONT color="green">15501</FONT>       */<a name="line.15501"></a>
<FONT color="green">15502</FONT>      public static final AnnotationLocation DEFAULT_HOVER_LOCATION = AnnotationLocation.NORTHWEST;<a name="line.15502"></a>
<FONT color="green">15503</FONT>      /**<a name="line.15503"></a>
<FONT color="green">15504</FONT>       * The default fontsize of text that appears in the chart's legend (key).<a name="line.15504"></a>
<FONT color="green">15505</FONT>       * <a name="line.15505"></a>
<FONT color="green">15506</FONT>       * @see Axis#setTickLabelFontSize setTickLabelFontSize<a name="line.15506"></a>
<FONT color="green">15507</FONT>       * @see #getXAxis getXAxis<a name="line.15507"></a>
<FONT color="green">15508</FONT>       * @see #getYAxis getYAxis<a name="line.15508"></a>
<FONT color="green">15509</FONT>       * @see #getY2Axis getY2Axis<a name="line.15509"></a>
<FONT color="green">15510</FONT>       * <a name="line.15510"></a>
<FONT color="green">15511</FONT>       */<a name="line.15511"></a>
<FONT color="green">15512</FONT>      public final static int DEFAULT_LEGEND_FONTSIZE = 12;<a name="line.15512"></a>
<FONT color="green">15513</FONT>    <a name="line.15513"></a>
<FONT color="green">15514</FONT>      /**<a name="line.15514"></a>
<FONT color="green">15515</FONT>       * The default background color used for the chart's plot area if none is<a name="line.15515"></a>
<FONT color="green">15516</FONT>       * specified.<a name="line.15516"></a>
<FONT color="green">15517</FONT>       * <a name="line.15517"></a>
<FONT color="green">15518</FONT>       * @see #setPlotAreaBackgroundColor setPlotAreaBackgroundColor<a name="line.15518"></a>
<FONT color="green">15519</FONT>       * <a name="line.15519"></a>
<FONT color="green">15520</FONT>       */<a name="line.15520"></a>
<FONT color="green">15521</FONT>      public final static String DEFAULT_PLOTAREA_BACKGROUND_COLOR = "transparent";<a name="line.15521"></a>
<FONT color="green">15522</FONT>      /**<a name="line.15522"></a>
<FONT color="green">15523</FONT>       * The default border color used for the chart's plot area if none is<a name="line.15523"></a>
<FONT color="green">15524</FONT>       * specified.<a name="line.15524"></a>
<FONT color="green">15525</FONT>       * <a name="line.15525"></a>
<FONT color="green">15526</FONT>       * @see #setPlotAreaBorderColor setPlotAreaBorderColor<a name="line.15526"></a>
<FONT color="green">15527</FONT>       * <a name="line.15527"></a>
<FONT color="green">15528</FONT>       */<a name="line.15528"></a>
<FONT color="green">15529</FONT>      public final static String DEFAULT_PLOTAREA_BORDER_COLOR = "black";<a name="line.15529"></a>
<FONT color="green">15530</FONT>      /**<a name="line.15530"></a>
<FONT color="green">15531</FONT>       * The default style of the border around the chart's plot area if none is<a name="line.15531"></a>
<FONT color="green">15532</FONT>       * specified.<a name="line.15532"></a>
<FONT color="green">15533</FONT>       * <a name="line.15533"></a>
<FONT color="green">15534</FONT>       * @see #setPlotAreaBorderStyle setPlotAreaBorderStyle<a name="line.15534"></a>
<FONT color="green">15535</FONT>       * <a name="line.15535"></a>
<FONT color="green">15536</FONT>       */<a name="line.15536"></a>
<FONT color="green">15537</FONT>      public final static String DEFAULT_PLOTAREA_BORDER_STYLE = "solid";<a name="line.15537"></a>
<FONT color="green">15538</FONT>      /**<a name="line.15538"></a>
<FONT color="green">15539</FONT>       * The default width of the border around the chart's plot area if none is<a name="line.15539"></a>
<FONT color="green">15540</FONT>       * specified.<a name="line.15540"></a>
<FONT color="green">15541</FONT>       * <a name="line.15541"></a>
<FONT color="green">15542</FONT>       * @see #setPlotAreaBorderWidth setPlotAreaBorderWidth<a name="line.15542"></a>
<FONT color="green">15543</FONT>       * <a name="line.15543"></a>
<FONT color="green">15544</FONT>       */<a name="line.15544"></a>
<FONT color="green">15545</FONT>      public final static int DEFAULT_PLOTAREA_BORDER_WIDTH = 0;<a name="line.15545"></a>
<FONT color="green">15546</FONT>      /**<a name="line.15546"></a>
<FONT color="green">15547</FONT>       * The default CSS background color used for symbols if none is specified.<a name="line.15547"></a>
<FONT color="green">15548</FONT>       * <a name="line.15548"></a>
<FONT color="green">15549</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15549"></a>
<FONT color="green">15550</FONT>       * @see Symbol#setBackgroundColor setBackgroundColor<a name="line.15550"></a>
<FONT color="green">15551</FONT>       */<a name="line.15551"></a>
<FONT color="green">15552</FONT>      public static final String DEFAULT_SYMBOL_BACKGROUND_COLOR = "transparent";<a name="line.15552"></a>
<FONT color="green">15553</FONT>      /**<a name="line.15553"></a>
<FONT color="green">15554</FONT>       * The default CSS border colors used for symbols if none are specified. These<a name="line.15554"></a>
<FONT color="green">15555</FONT>       * defaults are, in order of the curve's integer index: red, green, blue,<a name="line.15555"></a>
<FONT color="green">15556</FONT>       * fuchsia, aqua, teal, maroon, lime, navy, silver, olive, purple. This<a name="line.15556"></a>
<FONT color="green">15557</FONT>       * sequence repeats if there are more than 12 curves.<a name="line.15557"></a>
<FONT color="green">15558</FONT>       * &lt;p&gt;<a name="line.15558"></a>
<FONT color="green">15559</FONT>       * <a name="line.15559"></a>
<FONT color="green">15560</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15560"></a>
<FONT color="green">15561</FONT>       * @see Symbol#setBorderColor setBorderColor<a name="line.15561"></a>
<FONT color="green">15562</FONT>       * <a name="line.15562"></a>
<FONT color="green">15563</FONT>       */<a name="line.15563"></a>
<FONT color="green">15564</FONT>    <a name="line.15564"></a>
<FONT color="green">15565</FONT>      public static final String[] DEFAULT_SYMBOL_BORDER_COLORS = { "red",<a name="line.15565"></a>
<FONT color="green">15566</FONT>          "green", "blue", "fuchsia", "aqua", "teal", "maroon", "lime",<a name="line.15566"></a>
<FONT color="green">15567</FONT>          "navy", "silver", "olive", "purple" };<a name="line.15567"></a>
<FONT color="green">15568</FONT>      private static String[] defaultSymbolBorderColors = DEFAULT_SYMBOL_BORDER_COLORS;<a name="line.15568"></a>
<FONT color="green">15569</FONT>    <a name="line.15569"></a>
<FONT color="green">15570</FONT>      /**<a name="line.15570"></a>
<FONT color="green">15571</FONT>       * The default CSS border style used for symbols if none is specified; this<a name="line.15571"></a>
<FONT color="green">15572</FONT>       * default is "solid".<a name="line.15572"></a>
<FONT color="green">15573</FONT>       * <a name="line.15573"></a>
<FONT color="green">15574</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15574"></a>
<FONT color="green">15575</FONT>       * @see Symbol#setBorderStyle setBorderStyle<a name="line.15575"></a>
<FONT color="green">15576</FONT>       * <a name="line.15576"></a>
<FONT color="green">15577</FONT>       */<a name="line.15577"></a>
<FONT color="green">15578</FONT>      public static final String DEFAULT_SYMBOL_BORDER_STYLE = "solid";<a name="line.15578"></a>
<FONT color="green">15579</FONT>      /**<a name="line.15579"></a>
<FONT color="green">15580</FONT>       * The default CSS border width used for symbols if none is specified; this<a name="line.15580"></a>
<FONT color="green">15581</FONT>       * default is 1 pixel.<a name="line.15581"></a>
<FONT color="green">15582</FONT>       * <a name="line.15582"></a>
<FONT color="green">15583</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15583"></a>
<FONT color="green">15584</FONT>       * @see Symbol#setBorderWidth setBorderWidth<a name="line.15584"></a>
<FONT color="green">15585</FONT>       * <a name="line.15585"></a>
<FONT color="green">15586</FONT>       */<a name="line.15586"></a>
<FONT color="green">15587</FONT>      public static final int DEFAULT_SYMBOL_BORDER_WIDTH = 1;<a name="line.15587"></a>
<FONT color="green">15588</FONT>      /**<a name="line.15588"></a>
<FONT color="green">15589</FONT>       * The default spacing between discrete, rectangular, elements used to<a name="line.15589"></a>
<FONT color="green">15590</FONT>       * simulate continuous graphical elements. This default does not apply to bar<a name="line.15590"></a>
<FONT color="green">15591</FONT>       * chart symbol types or the LINE symbol type, which have their own default<a name="line.15591"></a>
<FONT color="green">15592</FONT>       * fill spacings.<a name="line.15592"></a>
<FONT color="green">15593</FONT>       * &lt;p&gt;<a name="line.15593"></a>
<FONT color="green">15594</FONT>       * <a name="line.15594"></a>
<FONT color="green">15595</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15595"></a>
<FONT color="green">15596</FONT>       * @see Symbol#setFillSpacing setFillSpacing<a name="line.15596"></a>
<FONT color="green">15597</FONT>       * @see Symbol#setFillThickness setFillThickness<a name="line.15597"></a>
<FONT color="green">15598</FONT>       * @see #DEFAULT_BAR_FILL_SPACING DEFAULT_BAR_FILL_SPACING<a name="line.15598"></a>
<FONT color="green">15599</FONT>       * @see #DEFAULT_LINE_FILL_SPACING DEFAULT_LINE_FILL_SPACING<a name="line.15599"></a>
<FONT color="green">15600</FONT>       * <a name="line.15600"></a>
<FONT color="green">15601</FONT>       */<a name="line.15601"></a>
<FONT color="green">15602</FONT>      public static final double DEFAULT_SYMBOL_FILL_SPACING = 4;<a name="line.15602"></a>
<FONT color="green">15603</FONT>      /**<a name="line.15603"></a>
<FONT color="green">15604</FONT>       * The default "thickness" of the rectangular elements used to simulate<a name="line.15604"></a>
<FONT color="green">15605</FONT>       * continuous graphical objects, such as connecting lines in line charts. This<a name="line.15605"></a>
<FONT color="green">15606</FONT>       * default applies to all symbol types &lt;tt&gt;except&lt;/tt&gt; for those representing<a name="line.15606"></a>
<FONT color="green">15607</FONT>       * pie slices, whose default is &lt;tt&gt;DEFAULT_PIE_SLICE_FILL_THICKNESS&lt;/tt&gt;, and<a name="line.15607"></a>
<FONT color="green">15608</FONT>       * the LINE symbol type, whose default is DEFAULT_LINE_FILL_THICKNESS.<a name="line.15608"></a>
<FONT color="green">15609</FONT>       * <a name="line.15609"></a>
<FONT color="green">15610</FONT>       * &lt;p&gt;<a name="line.15610"></a>
<FONT color="green">15611</FONT>       * Since this default thickness is 0 px, this implies that, except for pie<a name="line.15611"></a>
<FONT color="green">15612</FONT>       * slices and lines, no such continuous fill elements are generated by<a name="line.15612"></a>
<FONT color="green">15613</FONT>       * default. For example, if you want to have dotted connecting lines drawn<a name="line.15613"></a>
<FONT color="green">15614</FONT>       * between individual data points represented using the &lt;tt&gt;BOX_CENTER&lt;/tt&gt;<a name="line.15614"></a>
<FONT color="green">15615</FONT>       * symbol type, you must explicitly specify a positive fill thickness (for<a name="line.15615"></a>
<FONT color="green">15616</FONT>       * solid connecting lines, the LINE symbol is usually far more efficient than<a name="line.15616"></a>
<FONT color="green">15617</FONT>       * using a fill thickness of 1px with the BOX_CENTER symbol).<a name="line.15617"></a>
<FONT color="green">15618</FONT>       * <a name="line.15618"></a>
<FONT color="green">15619</FONT>       * @see #DEFAULT_PIE_SLICE_FILL_THICKNESS DEFAULT_PIE_SLICE_FILL_THICKNESS<a name="line.15619"></a>
<FONT color="green">15620</FONT>       * @see #DEFAULT_LINE_FILL_THICKNESS DEFAULT_LINE_FILL_THICKNESS<a name="line.15620"></a>
<FONT color="green">15621</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15621"></a>
<FONT color="green">15622</FONT>       * @see Symbol#setFillSpacing setFillSpacing<a name="line.15622"></a>
<FONT color="green">15623</FONT>       * @see Symbol#setFillThickness setFillThickness<a name="line.15623"></a>
<FONT color="green">15624</FONT>       * <a name="line.15624"></a>
<FONT color="green">15625</FONT>       */<a name="line.15625"></a>
<FONT color="green">15626</FONT>      public static final int DEFAULT_SYMBOL_FILL_THICKNESS = 0;<a name="line.15626"></a>
<FONT color="green">15627</FONT>    <a name="line.15627"></a>
<FONT color="green">15628</FONT>      /**<a name="line.15628"></a>
<FONT color="green">15629</FONT>       * The default spacing between discrete, rectangular, elements used to<a name="line.15629"></a>
<FONT color="green">15630</FONT>       * simulate continuous filling of polygonal regions formed by connecting<a name="line.15630"></a>
<FONT color="green">15631</FONT>       * corresponding ends of successive bars in a bar chart.<a name="line.15631"></a>
<FONT color="green">15632</FONT>       * &lt;p&gt;<a name="line.15632"></a>
<FONT color="green">15633</FONT>       * <a name="line.15633"></a>
<FONT color="green">15634</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15634"></a>
<FONT color="green">15635</FONT>       * @see Symbol#setFillSpacing setFillSpacing<a name="line.15635"></a>
<FONT color="green">15636</FONT>       * @see Symbol#setFillThickness setFillThickness<a name="line.15636"></a>
<FONT color="green">15637</FONT>       * @see #DEFAULT_SYMBOL_FILL_SPACING DEFAULT_SYMBOL_FILL_SPACING<a name="line.15637"></a>
<FONT color="green">15638</FONT>       * <a name="line.15638"></a>
<FONT color="green">15639</FONT>       */<a name="line.15639"></a>
<FONT color="green">15640</FONT>      public static final double DEFAULT_BAR_FILL_SPACING = 0;<a name="line.15640"></a>
<FONT color="green">15641</FONT>    <a name="line.15641"></a>
<FONT color="green">15642</FONT>      /**<a name="line.15642"></a>
<FONT color="green">15643</FONT>       * The default thickness of connecting lines drawn on curves whose symbols<a name="line.15643"></a>
<FONT color="green">15644</FONT>       * have the LINE symbol type.<a name="line.15644"></a>
<FONT color="green">15645</FONT>       * <a name="line.15645"></a>
<FONT color="green">15646</FONT>       * @see #DEFAULT_SYMBOL_FILL_THICKNESS DEFAULT_SYMBOL_FILL_THICKNESS<a name="line.15646"></a>
<FONT color="green">15647</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15647"></a>
<FONT color="green">15648</FONT>       * @see Symbol#setFillSpacing setFillSpacing<a name="line.15648"></a>
<FONT color="green">15649</FONT>       * @see Symbol#setFillThickness setFillThickness<a name="line.15649"></a>
<FONT color="green">15650</FONT>       * <a name="line.15650"></a>
<FONT color="green">15651</FONT>       */<a name="line.15651"></a>
<FONT color="green">15652</FONT>      public static final int DEFAULT_LINE_FILL_THICKNESS = 1;<a name="line.15652"></a>
<FONT color="green">15653</FONT>    <a name="line.15653"></a>
<FONT color="green">15654</FONT>      /**<a name="line.15654"></a>
<FONT color="green">15655</FONT>       * The default spacing between discrete, rectangular, elements used to<a name="line.15655"></a>
<FONT color="green">15656</FONT>       * simulate continuously connected lines between successive points on a curve<a name="line.15656"></a>
<FONT color="green">15657</FONT>       * that uses the &lt;tt&gt;LINE&lt;/tt&gt; symbol type.<a name="line.15657"></a>
<FONT color="green">15658</FONT>       * &lt;p&gt;<a name="line.15658"></a>
<FONT color="green">15659</FONT>       * <a name="line.15659"></a>
<FONT color="green">15660</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15660"></a>
<FONT color="green">15661</FONT>       * @see Symbol#setFillSpacing setFillSpacing<a name="line.15661"></a>
<FONT color="green">15662</FONT>       * @see Symbol#setFillThickness setFillThickness<a name="line.15662"></a>
<FONT color="green">15663</FONT>       * @see #DEFAULT_SYMBOL_FILL_SPACING DEFAULT_SYMBOL_FILL_SPACING<a name="line.15663"></a>
<FONT color="green">15664</FONT>       * <a name="line.15664"></a>
<FONT color="green">15665</FONT>       */<a name="line.15665"></a>
<FONT color="green">15666</FONT>      public static final int DEFAULT_LINE_FILL_SPACING = 0;<a name="line.15666"></a>
<FONT color="green">15667</FONT>    <a name="line.15667"></a>
<FONT color="green">15668</FONT>      /**<a name="line.15668"></a>
<FONT color="green">15669</FONT>       * The default "spacing" between corresponding edges of the rectangular<a name="line.15669"></a>
<FONT color="green">15670</FONT>       * elements used to simulate continuous fill of pie slices.<a name="line.15670"></a>
<FONT color="green">15671</FONT>       * &lt;p&gt;<a name="line.15671"></a>
<FONT color="green">15672</FONT>       * <a name="line.15672"></a>
<FONT color="green">15673</FONT>       * @see #DEFAULT_SYMBOL_FILL_SPACING DEFAULT_SYMBOL_FILL_SPACING<a name="line.15673"></a>
<FONT color="green">15674</FONT>       * @see #DEFAULT_PIE_SLICE_FILL_THICKNESS DEFAULT_PIE_SLICE_FILL_THICKNESS<a name="line.15674"></a>
<FONT color="green">15675</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15675"></a>
<FONT color="green">15676</FONT>       * @see Symbol#setFillSpacing setFillSpacing<a name="line.15676"></a>
<FONT color="green">15677</FONT>       * @see Symbol#setFillThickness setFillThickness<a name="line.15677"></a>
<FONT color="green">15678</FONT>       * <a name="line.15678"></a>
<FONT color="green">15679</FONT>       */<a name="line.15679"></a>
<FONT color="green">15680</FONT>      public static final double DEFAULT_PIE_SLICE_FILL_SPACING = 4;<a name="line.15680"></a>
<FONT color="green">15681</FONT>      /**<a name="line.15681"></a>
<FONT color="green">15682</FONT>       * The default "thickness" of the rectangular elements used to simulate<a name="line.15682"></a>
<FONT color="green">15683</FONT>       * continuous fill of pie slices. This thickness defines the height of<a name="line.15683"></a>
<FONT color="green">15684</FONT>       * horizontal pie slice shading bars, and the width of vertical shading bars.<a name="line.15684"></a>
<FONT color="green">15685</FONT>       * &lt;p&gt;<a name="line.15685"></a>
<FONT color="green">15686</FONT>       * <a name="line.15686"></a>
<FONT color="green">15687</FONT>       * @see #DEFAULT_SYMBOL_FILL_THICKNESS DEFAULT_SYMBOL_FILL_THICKNESS<a name="line.15687"></a>
<FONT color="green">15688</FONT>       * @see #DEFAULT_LINE_FILL_THICKNESS DEFAULT_LINE_FILL_THICKNESS<a name="line.15688"></a>
<FONT color="green">15689</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15689"></a>
<FONT color="green">15690</FONT>       * @see Symbol#setFillSpacing setFillSpacing<a name="line.15690"></a>
<FONT color="green">15691</FONT>       * @see Symbol#setFillThickness setFillThickness<a name="line.15691"></a>
<FONT color="green">15692</FONT>       * <a name="line.15692"></a>
<FONT color="green">15693</FONT>       */<a name="line.15693"></a>
<FONT color="green">15694</FONT>      public static final int DEFAULT_PIE_SLICE_FILL_THICKNESS = 2;<a name="line.15694"></a>
<FONT color="green">15695</FONT>    <a name="line.15695"></a>
<FONT color="green">15696</FONT>      /**<a name="line.15696"></a>
<FONT color="green">15697</FONT>       * The default hovertext template used by symbols when they have a symbol type<a name="line.15697"></a>
<FONT color="green">15698</FONT>       * of of the form PIE_SLICE_*.<a name="line.15698"></a>
<FONT color="green">15699</FONT>       * <a name="line.15699"></a>
<FONT color="green">15700</FONT>       * @see Symbol#setHovertextTemplate setHovertextTemplate<a name="line.15700"></a>
<FONT color="green">15701</FONT>       * @see SymbolType#PIE_SLICE_OPTIMAL_SHADING PIE_SLICE_OPTIMAL_SHADING<a name="line.15701"></a>
<FONT color="green">15702</FONT>       * @see #DEFAULT_HOVERTEXT_TEMPLATE DEFAULT_HOVERTEXT_TEMPLATE<a name="line.15702"></a>
<FONT color="green">15703</FONT>       * <a name="line.15703"></a>
<FONT color="green">15704</FONT>       */<a name="line.15704"></a>
<FONT color="green">15705</FONT>      public static final String DEFAULT_PIE_SLICE_HOVERTEXT_TEMPLATE =<a name="line.15705"></a>
<FONT color="green">15706</FONT>              GChart.formatAsHovertext("${pieSliceSize}");<a name="line.15706"></a>
<FONT color="green">15707</FONT>    <a name="line.15707"></a>
<FONT color="green">15708</FONT>      /**<a name="line.15708"></a>
<FONT color="green">15709</FONT>       * The default hover feedback location used by symbols when they have a symbol<a name="line.15709"></a>
<FONT color="green">15710</FONT>       * type of of the form PIE_SLICE_*.<a name="line.15710"></a>
<FONT color="green">15711</FONT>       * <a name="line.15711"></a>
<FONT color="green">15712</FONT>       * @see Symbol#setHoverLocation setHoverLocation<a name="line.15712"></a>
<FONT color="green">15713</FONT>       * @see #DEFAULT_HOVER_LOCATION DEFAULT_HOVER_LOCATION<a name="line.15713"></a>
<FONT color="green">15714</FONT>       * <a name="line.15714"></a>
<FONT color="green">15715</FONT>       */<a name="line.15715"></a>
<FONT color="green">15716</FONT>      public static final AnnotationLocation DEFAULT_PIE_SLICE_HOVER_LOCATION =<a name="line.15716"></a>
<FONT color="green">15717</FONT>              AnnotationLocation.OUTSIDE_PIE_ARC;<a name="line.15717"></a>
<FONT color="green">15718</FONT>      /**<a name="line.15718"></a>
<FONT color="green">15719</FONT>       * The default height (including borders) used for symbols if none is<a name="line.15719"></a>
<FONT color="green">15720</FONT>       * specified; this default is the same as for &lt;tt&gt;DEFAULT_SYMBOL_WIDTH&lt;/tt&gt;<a name="line.15720"></a>
<FONT color="green">15721</FONT>       * <a name="line.15721"></a>
<FONT color="green">15722</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15722"></a>
<FONT color="green">15723</FONT>       * @see Symbol#setHeight setHeight<a name="line.15723"></a>
<FONT color="green">15724</FONT>       * @see #DEFAULT_SYMBOL_WIDTH DEFAULT_SYMBOL_WIDTH<a name="line.15724"></a>
<FONT color="green">15725</FONT>       * <a name="line.15725"></a>
<FONT color="green">15726</FONT>       */<a name="line.15726"></a>
<FONT color="green">15727</FONT>      public static final int DEFAULT_SYMBOL_HEIGHT = 7;<a name="line.15727"></a>
<FONT color="green">15728</FONT>    <a name="line.15728"></a>
<FONT color="green">15729</FONT>      /**<a name="line.15729"></a>
<FONT color="green">15730</FONT>       * The default symbol type for curve if none is specified; this default is<a name="line.15730"></a>
<FONT color="green">15731</FONT>       * BOX_CENTER<a name="line.15731"></a>
<FONT color="green">15732</FONT>       * <a name="line.15732"></a>
<FONT color="green">15733</FONT>       * @see SymbolType#BOX_CENTER BOX_CENTER<a name="line.15733"></a>
<FONT color="green">15734</FONT>       * @see Symbol#setSymbolType setSymbolType<a name="line.15734"></a>
<FONT color="green">15735</FONT>       * <a name="line.15735"></a>
<FONT color="green">15736</FONT>       */<a name="line.15736"></a>
<FONT color="green">15737</FONT>      public static final SymbolType DEFAULT_SYMBOL_TYPE = SymbolType.BOX_CENTER;<a name="line.15737"></a>
<FONT color="green">15738</FONT>    <a name="line.15738"></a>
<FONT color="green">15739</FONT>      /**<a name="line.15739"></a>
<FONT color="green">15740</FONT>       * The default width (including borders) used for symbols if none is<a name="line.15740"></a>
<FONT color="green">15741</FONT>       * specified.<a name="line.15741"></a>
<FONT color="green">15742</FONT>       * <a name="line.15742"></a>
<FONT color="green">15743</FONT>       * @see Curve#getSymbol getSymbol<a name="line.15743"></a>
<FONT color="green">15744</FONT>       * @see Symbol#setWidth setWidth<a name="line.15744"></a>
<FONT color="green">15745</FONT>       * @see #DEFAULT_SYMBOL_WIDTH DEFAULT_SYMBOL_WIDTH<a name="line.15745"></a>
<FONT color="green">15746</FONT>       */<a name="line.15746"></a>
<FONT color="green">15747</FONT>      public static final int DEFAULT_SYMBOL_WIDTH = DEFAULT_SYMBOL_HEIGHT;<a name="line.15747"></a>
<FONT color="green">15748</FONT>    <a name="line.15748"></a>
<FONT color="green">15749</FONT>      /**<a name="line.15749"></a>
<FONT color="green">15750</FONT>       * The default number of tick marks on each Axis.<a name="line.15750"></a>
<FONT color="green">15751</FONT>       * <a name="line.15751"></a>
<FONT color="green">15752</FONT>       * @see Axis#setTickCount setTickCount<a name="line.15752"></a>
<FONT color="green">15753</FONT>       * <a name="line.15753"></a>
<FONT color="green">15754</FONT>       */<a name="line.15754"></a>
<FONT color="green">15755</FONT>      public static final int DEFAULT_TICK_COUNT = 10;<a name="line.15755"></a>
<FONT color="green">15756</FONT>    <a name="line.15756"></a>
<FONT color="green">15757</FONT>      /**<a name="line.15757"></a>
<FONT color="green">15758</FONT>       * The default color (a CSS color specification) of tick labels<a name="line.15758"></a>
<FONT color="green">15759</FONT>       * <a name="line.15759"></a>
<FONT color="green">15760</FONT>       * @see Axis#setTickLabelFontColor setTickLabelFontColor<a name="line.15760"></a>
<FONT color="green">15761</FONT>       * @see #getXAxis getXAxis<a name="line.15761"></a>
<FONT color="green">15762</FONT>       * @see #getYAxis getYAxis<a name="line.15762"></a>
<FONT color="green">15763</FONT>       * @see #getY2Axis getY2Axis<a name="line.15763"></a>
<FONT color="green">15764</FONT>       */<a name="line.15764"></a>
<FONT color="green">15765</FONT>      public final static String DEFAULT_TICK_LABEL_FONT_COLOR = "black";<a name="line.15765"></a>
<FONT color="green">15766</FONT>    <a name="line.15766"></a>
<FONT color="green">15767</FONT>      /**<a name="line.15767"></a>
<FONT color="green">15768</FONT>       * The default CSS font-style applied to tick labels<a name="line.15768"></a>
<FONT color="green">15769</FONT>       * <a name="line.15769"></a>
<FONT color="green">15770</FONT>       * @see Axis#setTickLabelFontStyle setTickLabelFontStyle<a name="line.15770"></a>
<FONT color="green">15771</FONT>       * @see #getXAxis getXAxis<a name="line.15771"></a>
<FONT color="green">15772</FONT>       * @see #getYAxis getYAxis<a name="line.15772"></a>
<FONT color="green">15773</FONT>       * @see #getY2Axis getY2Axis<a name="line.15773"></a>
<FONT color="green">15774</FONT>       */<a name="line.15774"></a>
<FONT color="green">15775</FONT>      public final static String DEFAULT_TICK_LABEL_FONT_STYLE = "normal";<a name="line.15775"></a>
<FONT color="green">15776</FONT>    <a name="line.15776"></a>
<FONT color="green">15777</FONT>      /**<a name="line.15777"></a>
<FONT color="green">15778</FONT>       * The default CSS font-weight applied to tick labels<a name="line.15778"></a>
<FONT color="green">15779</FONT>       * <a name="line.15779"></a>
<FONT color="green">15780</FONT>       * @see Axis#setTickLabelFontWeight setTickLabelFontWeight<a name="line.15780"></a>
<FONT color="green">15781</FONT>       * @see #getXAxis getXAxis<a name="line.15781"></a>
<FONT color="green">15782</FONT>       * @see #getYAxis getYAxis<a name="line.15782"></a>
<FONT color="green">15783</FONT>       * @see #getY2Axis getY2Axis<a name="line.15783"></a>
<FONT color="green">15784</FONT>       */<a name="line.15784"></a>
<FONT color="green">15785</FONT>      public final static String DEFAULT_TICK_LABEL_FONT_WEIGHT = "normal";<a name="line.15785"></a>
<FONT color="green">15786</FONT>    <a name="line.15786"></a>
<FONT color="green">15787</FONT>      /**<a name="line.15787"></a>
<FONT color="green">15788</FONT>       * The default fontsize (in pixels) of tick labels<a name="line.15788"></a>
<FONT color="green">15789</FONT>       * <a name="line.15789"></a>
<FONT color="green">15790</FONT>       * @see Axis#setTickLabelFontSize setTickLabelFontSize<a name="line.15790"></a>
<FONT color="green">15791</FONT>       * @see #getXAxis getXAxis<a name="line.15791"></a>
<FONT color="green">15792</FONT>       * @see #getYAxis getYAxis<a name="line.15792"></a>
<FONT color="green">15793</FONT>       * @see #getY2Axis getY2Axis<a name="line.15793"></a>
<FONT color="green">15794</FONT>       */<a name="line.15794"></a>
<FONT color="green">15795</FONT>      public final static int DEFAULT_TICK_LABEL_FONTSIZE = 12;<a name="line.15795"></a>
<FONT color="green">15796</FONT>      /**<a name="line.15796"></a>
<FONT color="green">15797</FONT>       * The default GWT &lt;tt&gt;NumberFormat&lt;/tt&gt; format string used to convert numbers<a name="line.15797"></a>
<FONT color="green">15798</FONT>       * to the text strings displayed as tick labels on X, Y, and Y2 axes.<a name="line.15798"></a>
<FONT color="green">15799</FONT>       * <a name="line.15799"></a>
<FONT color="green">15800</FONT>       * @see Axis#setTickLabelFormat setTickLabelFormat<a name="line.15800"></a>
<FONT color="green">15801</FONT>       * @see #getXAxis getXAxis<a name="line.15801"></a>
<FONT color="green">15802</FONT>       * @see #getYAxis getYAxis<a name="line.15802"></a>
<FONT color="green">15803</FONT>       * @see #getY2Axis getY2Axis<a name="line.15803"></a>
<FONT color="green">15804</FONT>       * <a name="line.15804"></a>
<FONT color="green">15805</FONT>       */<a name="line.15805"></a>
<FONT color="green">15806</FONT>      public final static String DEFAULT_TICK_LABEL_FORMAT = "#.##";<a name="line.15806"></a>
<FONT color="green">15807</FONT>    <a name="line.15807"></a>
<FONT color="green">15808</FONT>      /**<a name="line.15808"></a>
<FONT color="green">15809</FONT>       * The default length of tick marks, in pixels.<a name="line.15809"></a>
<FONT color="green">15810</FONT>       * <a name="line.15810"></a>
<FONT color="green">15811</FONT>       * @see Axis#setTickLength setTickLength<a name="line.15811"></a>
<FONT color="green">15812</FONT>       */<a name="line.15812"></a>
<FONT color="green">15813</FONT>      public static final int DEFAULT_TICK_LENGTH = 6;<a name="line.15813"></a>
<FONT color="green">15814</FONT>    <a name="line.15814"></a>
<FONT color="green">15815</FONT>      /**<a name="line.15815"></a>
<FONT color="green">15816</FONT>       * The default tick location.<a name="line.15816"></a>
<FONT color="green">15817</FONT>       * <a name="line.15817"></a>
<FONT color="green">15818</FONT>       * @see Axis#setTickLocation setTickLocation<a name="line.15818"></a>
<FONT color="green">15819</FONT>       */<a name="line.15819"></a>
<FONT color="green">15820</FONT>      public static final TickLocation DEFAULT_TICK_LOCATION = TickLocation.OUTSIDE;<a name="line.15820"></a>
<FONT color="green">15821</FONT>    <a name="line.15821"></a>
<FONT color="green">15822</FONT>      /**<a name="line.15822"></a>
<FONT color="green">15823</FONT>       * The default thickness of tick marks, in pixels.<a name="line.15823"></a>
<FONT color="green">15824</FONT>       * <a name="line.15824"></a>
<FONT color="green">15825</FONT>       * @see Axis#setTickThickness setTickThickness<a name="line.15825"></a>
<FONT color="green">15826</FONT>       */<a name="line.15826"></a>
<FONT color="green">15827</FONT>      public static final int DEFAULT_TICK_THICKNESS = 1; // pixel<a name="line.15827"></a>
<FONT color="green">15828</FONT>    <a name="line.15828"></a>
<FONT color="green">15829</FONT>      /**<a name="line.15829"></a>
<FONT color="green">15830</FONT>       * The default location used to position the hover feedback when the user<a name="line.15830"></a>
<FONT color="green">15831</FONT>       * hovers their mouse above a point on a curve that uses a VBAR_BASELINE_*<a name="line.15831"></a>
<FONT color="green">15832</FONT>       * symbol type.<a name="line.15832"></a>
<FONT color="green">15833</FONT>       * <a name="line.15833"></a>
<FONT color="green">15834</FONT>       * @see Symbol#setHoverLocation setHoverLocation<a name="line.15834"></a>
<FONT color="green">15835</FONT>       * @see #DEFAULT_HOVER_LOCATION DEFAULT_HOVER_LOCATION<a name="line.15835"></a>
<FONT color="green">15836</FONT>       * <a name="line.15836"></a>
<FONT color="green">15837</FONT>       */<a name="line.15837"></a>
<FONT color="green">15838</FONT>      public static final AnnotationLocation DEFAULT_VBAR_BASELINE_HOVER_LOCATION =<a name="line.15838"></a>
<FONT color="green">15839</FONT>              AnnotationLocation.FARTHEST_FROM_HORIZONTAL_BASELINE;<a name="line.15839"></a>
<FONT color="green">15840</FONT>      /**<a name="line.15840"></a>
<FONT color="green">15841</FONT>       * The default location used to position the hover feedback when the user<a name="line.15841"></a>
<FONT color="green">15842</FONT>       * hovers their mouse above a point on a curve that uses a VBAR_SOUTH* symbol<a name="line.15842"></a>
<FONT color="green">15843</FONT>       * type.<a name="line.15843"></a>
<FONT color="green">15844</FONT>       * <a name="line.15844"></a>
<FONT color="green">15845</FONT>       * @see Symbol#setHoverLocation setHoverLocation<a name="line.15845"></a>
<FONT color="green">15846</FONT>       * @see #DEFAULT_HOVER_LOCATION DEFAULT_HOVER_LOCATION<a name="line.15846"></a>
<FONT color="green">15847</FONT>       * <a name="line.15847"></a>
<FONT color="green">15848</FONT>       */<a name="line.15848"></a>
<FONT color="green">15849</FONT>      public static final AnnotationLocation DEFAULT_VBARBOTTOM_HOVER_LOCATION =<a name="line.15849"></a>
<FONT color="green">15850</FONT>              AnnotationLocation.NORTH;<a name="line.15850"></a>
<FONT color="green">15851</FONT>    <a name="line.15851"></a>
<FONT color="green">15852</FONT>      /**<a name="line.15852"></a>
<FONT color="green">15853</FONT>       * The default location used to position the hover feedback when the user<a name="line.15853"></a>
<FONT color="green">15854</FONT>       * hovers their mouse above a point on a curve that uses a VBAR_NORTH* symbol<a name="line.15854"></a>
<FONT color="green">15855</FONT>       * type.<a name="line.15855"></a>
<FONT color="green">15856</FONT>       * <a name="line.15856"></a>
<FONT color="green">15857</FONT>       * @see Symbol#setHoverLocation setHoverLocation<a name="line.15857"></a>
<FONT color="green">15858</FONT>       * @see #DEFAULT_HOVER_LOCATION DEFAULT_HOVER_LOCATION<a name="line.15858"></a>
<FONT color="green">15859</FONT>       * <a name="line.15859"></a>
<FONT color="green">15860</FONT>       */<a name="line.15860"></a>
<FONT color="green">15861</FONT>      public static final AnnotationLocation DEFAULT_VBARTOP_HOVER_LOCATION =<a name="line.15861"></a>
<FONT color="green">15862</FONT>              AnnotationLocation.SOUTH;<a name="line.15862"></a>
<FONT color="green">15863</FONT>    <a name="line.15863"></a>
<FONT color="green">15864</FONT>      /**<a name="line.15864"></a>
<FONT color="green">15865</FONT>       * The default location used to position the hover feedback when the user<a name="line.15865"></a>
<FONT color="green">15866</FONT>       * hovers their mouse above a point on a curve that uses a HBAR_BASELINE_*<a name="line.15866"></a>
<FONT color="green">15867</FONT>       * symbol type.<a name="line.15867"></a>
<FONT color="green">15868</FONT>       * <a name="line.15868"></a>
<FONT color="green">15869</FONT>       * @see Symbol#setHoverLocation setHoverLocation<a name="line.15869"></a>
<FONT color="green">15870</FONT>       * @see #DEFAULT_HOVER_LOCATION DEFAULT_HOVER_LOCATION<a name="line.15870"></a>
<FONT color="green">15871</FONT>       * <a name="line.15871"></a>
<FONT color="green">15872</FONT>       */<a name="line.15872"></a>
<FONT color="green">15873</FONT>      public static final AnnotationLocation DEFAULT_HBAR_BASELINE_HOVER_LOCATION =<a name="line.15873"></a>
<FONT color="green">15874</FONT>              AnnotationLocation.FARTHEST_FROM_VERTICAL_BASELINE;<a name="line.15874"></a>
<FONT color="green">15875</FONT>    <a name="line.15875"></a>
<FONT color="green">15876</FONT>      /**<a name="line.15876"></a>
<FONT color="green">15877</FONT>       * The default location used to position the hover feedback when the user<a name="line.15877"></a>
<FONT color="green">15878</FONT>       * hovers their mouse above a point on a curve that uses an HBAR_*WEST symbol<a name="line.15878"></a>
<FONT color="green">15879</FONT>       * type.<a name="line.15879"></a>
<FONT color="green">15880</FONT>       * <a name="line.15880"></a>
<FONT color="green">15881</FONT>       * @see Symbol#setHoverLocation setHoverLocation<a name="line.15881"></a>
<FONT color="green">15882</FONT>       * @see #DEFAULT_HOVER_LOCATION DEFAULT_HOVER_LOCATION<a name="line.15882"></a>
<FONT color="green">15883</FONT>       * <a name="line.15883"></a>
<FONT color="green">15884</FONT>       */<a name="line.15884"></a>
<FONT color="green">15885</FONT>      public static final AnnotationLocation DEFAULT_HBARLEFT_HOVER_LOCATION =<a name="line.15885"></a>
<FONT color="green">15886</FONT>              AnnotationLocation.EAST;<a name="line.15886"></a>
<FONT color="green">15887</FONT>    <a name="line.15887"></a>
<FONT color="green">15888</FONT>      /**<a name="line.15888"></a>
<FONT color="green">15889</FONT>       * The default location used to position the hover feedback when the user<a name="line.15889"></a>
<FONT color="green">15890</FONT>       * hovers their mouse above a point on a curve that uses an HBAR_*EAST symbol<a name="line.15890"></a>
<FONT color="green">15891</FONT>       * type.<a name="line.15891"></a>
<FONT color="green">15892</FONT>       * <a name="line.15892"></a>
<FONT color="green">15893</FONT>       * @see Symbol#setHoverLocation setHoverLocation<a name="line.15893"></a>
<FONT color="green">15894</FONT>       * @see #DEFAULT_HOVER_LOCATION DEFAULT_HOVER_LOCATION<a name="line.15894"></a>
<FONT color="green">15895</FONT>       * <a name="line.15895"></a>
<FONT color="green">15896</FONT>       */<a name="line.15896"></a>
<FONT color="green">15897</FONT>      public static final AnnotationLocation DEFAULT_HBARRIGHT_HOVER_LOCATION =<a name="line.15897"></a>
<FONT color="green">15898</FONT>              AnnotationLocation.WEST;<a name="line.15898"></a>
<FONT color="green">15899</FONT>    <a name="line.15899"></a>
<FONT color="green">15900</FONT>      /**<a name="line.15900"></a>
<FONT color="green">15901</FONT>       * Default upper bound on the number of pixels any canvas widget used by<a name="line.15901"></a>
<FONT color="green">15902</FONT>       * GChart can have.<a name="line.15902"></a>
<FONT color="green">15903</FONT>       * &lt;p&gt;<a name="line.15903"></a>
<FONT color="green">15904</FONT>       * <a name="line.15904"></a>
<FONT color="green">15905</FONT>       * @see #setMaxCanvasPixels setMaxCanvasPixels<a name="line.15905"></a>
<FONT color="green">15906</FONT>       * <a name="line.15906"></a>
<FONT color="green">15907</FONT>       */<a name="line.15907"></a>
<FONT color="green">15908</FONT>      public static final double DEFAULT_MAX_CANVAS_PIXELS = 4096 * 4096;<a name="line.15908"></a>
<FONT color="green">15909</FONT>    <a name="line.15909"></a>
<FONT color="green">15910</FONT>      /**<a name="line.15910"></a>
<FONT color="green">15911</FONT>       * The default upper bound on the width of widgets used in annotations and<a name="line.15911"></a>
<FONT color="green">15912</FONT>       * tick labels that GChart will assume for centering and similar alignment<a name="line.15912"></a>
<FONT color="green">15913</FONT>       * purposes.<a name="line.15913"></a>
<FONT color="green">15914</FONT>       * <a name="line.15914"></a>
<FONT color="green">15915</FONT>       * @see Curve.Point#setAnnotationWidget setAnnotationWidget<a name="line.15915"></a>
<FONT color="green">15916</FONT>       * @see Axis#addTick(double,Widget,int,int) addTick<a name="line.15916"></a>
<FONT color="green">15917</FONT>       * <a name="line.15917"></a>
<FONT color="green">15918</FONT>       */<a name="line.15918"></a>
<FONT color="green">15919</FONT>      public static final int DEFAULT_WIDGET_WIDTH_UPPERBOUND = 400;<a name="line.15919"></a>
<FONT color="green">15920</FONT>      /**<a name="line.15920"></a>
<FONT color="green">15921</FONT>       * The default upper bound on the height of widgets used in annotations and<a name="line.15921"></a>
<FONT color="green">15922</FONT>       * tick labels that GChart will assume for centering and similar alignment<a name="line.15922"></a>
<FONT color="green">15923</FONT>       * purposes.<a name="line.15923"></a>
<FONT color="green">15924</FONT>       * <a name="line.15924"></a>
<FONT color="green">15925</FONT>       * @see Curve.Point#setAnnotationWidget setAnnotationWidget<a name="line.15925"></a>
<FONT color="green">15926</FONT>       * @see Axis#addTick(double,Widget,int,int) addTick<a name="line.15926"></a>
<FONT color="green">15927</FONT>       * <a name="line.15927"></a>
<FONT color="green">15928</FONT>       */<a name="line.15928"></a>
<FONT color="green">15929</FONT>      public static final int DEFAULT_WIDGET_HEIGHT_UPPERBOUND = 400;<a name="line.15929"></a>
<FONT color="green">15930</FONT>    <a name="line.15930"></a>
<FONT color="green">15931</FONT>      /**<a name="line.15931"></a>
<FONT color="green">15932</FONT>       * The default width of the area of the chart in which curves are displayed,<a name="line.15932"></a>
<FONT color="green">15933</FONT>       * in pixels.<a name="line.15933"></a>
<FONT color="green">15934</FONT>       */<a name="line.15934"></a>
<FONT color="green">15935</FONT>      public final static int DEFAULT_X_CHARTSIZE = 300; // pixels<a name="line.15935"></a>
<FONT color="green">15936</FONT>      /**<a name="line.15936"></a>
<FONT color="green">15937</FONT>       * The default height of the area of the chart in which curves are displayed,<a name="line.15937"></a>
<FONT color="green">15938</FONT>       * in pixels.<a name="line.15938"></a>
<FONT color="green">15939</FONT>       */<a name="line.15939"></a>
<FONT color="green">15940</FONT>      public final static int DEFAULT_Y_CHARTSIZE = 300; // pixels<a name="line.15940"></a>
<FONT color="green">15941</FONT>    <a name="line.15941"></a>
<FONT color="green">15942</FONT>      /**<a name="line.15942"></a>
<FONT color="green">15943</FONT>       * In analogy to how it uses &lt;tt&gt;Double.NaN&lt;/tt&gt; (Not a Number), GChart uses<a name="line.15943"></a>
<FONT color="green">15944</FONT>       * &lt;tt&gt;GChart.NAI&lt;/tt&gt; (Not an Integer) to represent integers whose values<a name="line.15944"></a>
<FONT color="green">15945</FONT>       * have not been explicitly specified.<a name="line.15945"></a>
<FONT color="green">15946</FONT>       * <a name="line.15946"></a>
<FONT color="green">15947</FONT>       */<a name="line.15947"></a>
<FONT color="green">15948</FONT>      public static final int NAI = Integer.MIN_VALUE;<a name="line.15948"></a>
<FONT color="green">15949</FONT>    <a name="line.15949"></a>
<FONT color="green">15950</FONT>      /**<a name="line.15950"></a>
<FONT color="green">15951</FONT>       * Due to a well-known bug (see, for example, &lt;a href=<a name="line.15951"></a>
<FONT color="green">15952</FONT>       * "http://www.hedgerwow.com/360/dhtml/css-ie-transparent-border.html"&gt; this<a name="line.15952"></a>
<FONT color="green">15953</FONT>       * explanation on Hedger Wang's blog&lt;/a&gt;), though white may not be black in<a name="line.15953"></a>
<FONT color="green">15954</FONT>       * IE6, transparent borders certainly are. Besides this outright bug,<a name="line.15954"></a>
<FONT color="green">15955</FONT>       * different browsers define which element's background color "shines through"<a name="line.15955"></a>
<FONT color="green">15956</FONT>       * a transparent border differently. For example, in FF2, the background of<a name="line.15956"></a>
<FONT color="green">15957</FONT>       * the element containing the border shines through, which makes setting the<a name="line.15957"></a>
<FONT color="green">15958</FONT>       * border color to "transparent" equivalent to setting the border color to<a name="line.15958"></a>
<FONT color="green">15959</FONT>       * equal the background color. In IE7, the color of the chart's background<a name="line.15959"></a>
<FONT color="green">15960</FONT>       * "shines through"--which is more likely what you intended when you set a<a name="line.15960"></a>
<FONT color="green">15961</FONT>       * symbol's border to transparent.<a name="line.15961"></a>
<FONT color="green">15962</FONT>       * &lt;p&gt;<a name="line.15962"></a>
<FONT color="green">15963</FONT>       * <a name="line.15963"></a>
<FONT color="green">15964</FONT>       * To make it easy for you to eliminate such problems, and obtain a<a name="line.15964"></a>
<FONT color="green">15965</FONT>       * consistently behaving transparent-border behavior cross-browser, this<a name="line.15965"></a>
<FONT color="green">15966</FONT>       * special GChart-only "color" (recognized by all GChart border color related<a name="line.15966"></a>
<FONT color="green">15967</FONT>       * methods &lt;i&gt;except&lt;/i&gt; &lt;tt&gt;GChart.setBorderColor&lt;/tt&gt;) causes GChart to<a name="line.15967"></a>
<FONT color="green">15968</FONT>       * emulate a transparent border by eliminating the border entirely (setting<a name="line.15968"></a>
<FONT color="green">15969</FONT>       * it's width to 0) and changing the size and position of the element so as to<a name="line.15969"></a>
<FONT color="green">15970</FONT>       * make it look like the border is still "taking up space".<a name="line.15970"></a>
<FONT color="green">15971</FONT>       * <a name="line.15971"></a>
<FONT color="green">15972</FONT>       * &lt;p&gt;<a name="line.15972"></a>
<FONT color="green">15973</FONT>       * <a name="line.15973"></a>
<FONT color="green">15974</FONT>       * <a name="line.15974"></a>
<FONT color="green">15975</FONT>       * &lt;blockquote&gt;&lt;small&gt; &lt;i&gt;Note:&lt;/i&gt;The &lt;tt&gt;GChart.setBorderColor&lt;/tt&gt; method,<a name="line.15975"></a>
<FONT color="green">15976</FONT>       * which sets the color of the border around the entire chart, does &lt;i&gt;not&lt;/i&gt;<a name="line.15976"></a>
<FONT color="green">15977</FONT>       * support this keyword because GChart's transparent border emulation relies<a name="line.15977"></a>
<FONT color="green">15978</FONT>       * on changing the size of, and shifting the position of, the transparently<a name="line.15978"></a>
<FONT color="green">15979</FONT>       * bordered element. But, the position of the GChart as a whole is determined<a name="line.15979"></a>
<FONT color="green">15980</FONT>       * not by GChart, but by the enclosing page. Well-known CSS tricks, such as<a name="line.15980"></a>
<FONT color="green">15981</FONT>       * described in the "hedgerwow" link above, can be used if you need a truely<a name="line.15981"></a>
<FONT color="green">15982</FONT>       * transparent border around the entire chart. Or, just fake it by setting the<a name="line.15982"></a>
<FONT color="green">15983</FONT>       * border color to equal the background color of the containing page.<a name="line.15983"></a>
<FONT color="green">15984</FONT>       * &lt;/small&gt;&lt;/blockquote&gt;<a name="line.15984"></a>
<FONT color="green">15985</FONT>       * <a name="line.15985"></a>
<FONT color="green">15986</FONT>       * &lt;p&gt;<a name="line.15986"></a>
<FONT color="green">15987</FONT>       * <a name="line.15987"></a>
<FONT color="green">15988</FONT>       * This differs from setting the border color to "transparent" (which you can<a name="line.15988"></a>
<FONT color="green">15989</FONT>       * still do should you need the "standard non-standard" transparent border<a name="line.15989"></a>
<FONT color="green">15990</FONT>       * color behavior) in subtle ways that can matter in special cases. For<a name="line.15990"></a>
<FONT color="green">15991</FONT>       * example, because the element is smaller than it is with "transparent", if<a name="line.15991"></a>
<FONT color="green">15992</FONT>       * you draw your symbols outside the chart rectangle, GChart will not be able<a name="line.15992"></a>
<FONT color="green">15993</FONT>       * to track the mouse moves inside the transparent region (yes, this is a fine<a name="line.15993"></a>
<FONT color="green">15994</FONT>       * point, but there could be other differences I'm not aware of). In almost<a name="line.15994"></a>
<FONT color="green">15995</FONT>       * every other case I can think of, though, setting the border color to this<a name="line.15995"></a>
<FONT color="green">15996</FONT>       * special keyword instead of "transparent" will be the simplest way to<a name="line.15996"></a>
<FONT color="green">15997</FONT>       * eliminate these inconsistent transparent border problems from your charts.<a name="line.15997"></a>
<FONT color="green">15998</FONT>       * &lt;p&gt;<a name="line.15998"></a>
<FONT color="green">15999</FONT>       * <a name="line.15999"></a>
<FONT color="green">16000</FONT>       * @see Symbol#setBorderColor setBorderColor<a name="line.16000"></a>
<FONT color="green">16001</FONT>       * <a name="line.16001"></a>
<FONT color="green">16002</FONT>       */<a name="line.16002"></a>
<FONT color="green">16003</FONT>    <a name="line.16003"></a>
<FONT color="green">16004</FONT>      public static final String TRANSPARENT_BORDER_COLOR = null;<a name="line.16004"></a>
<FONT color="green">16005</FONT>    <a name="line.16005"></a>
<FONT color="green">16006</FONT>      /**<a name="line.16006"></a>
<FONT color="green">16007</FONT>       * A special value used to tell GChart that a property should be defined via<a name="line.16007"></a>
<FONT color="green">16008</FONT>       * CSS, not via an explicit Java API specification.<a name="line.16008"></a>
<FONT color="green">16009</FONT>       * <a name="line.16009"></a>
<FONT color="green">16010</FONT>       * &lt;p&gt;<a name="line.16010"></a>
<FONT color="green">16011</FONT>       * <a name="line.16011"></a>
<FONT color="green">16012</FONT>       * This value is mainly used by GChart's "CSS convenience methods" which make<a name="line.16012"></a>
<FONT color="green">16013</FONT>       * it possible to use the Java API to specify certain properties of a GChart<a name="line.16013"></a>
<FONT color="green">16014</FONT>       * that can also be specified via CSS. When the value of the Java property is<a name="line.16014"></a>
<FONT color="green">16015</FONT>       * set to &lt;tt&gt;USE_CSS&lt;/tt&gt; GChart ignores the API specification and allows the<a name="line.16015"></a>
<FONT color="green">16016</FONT>       * standard "CSS cascade" to define the property.<a name="line.16016"></a>
<FONT color="green">16017</FONT>       * <a name="line.16017"></a>
<FONT color="green">16018</FONT>       * The discussion below elaborates on why GChart supports CSS convenience<a name="line.16018"></a>
<FONT color="green">16019</FONT>       * methods, and how the &lt;tt&gt;USE_CSS&lt;/tt&gt; keyword fits into that support.<a name="line.16019"></a>
<FONT color="green">16020</FONT>       * <a name="line.16020"></a>
<FONT color="green">16021</FONT>       * &lt;p&gt;<a name="line.16021"></a>
<FONT color="green">16022</FONT>       * <a name="line.16022"></a>
<FONT color="green">16023</FONT>       * &lt;blockquote&gt;&lt;small&gt; &lt;b&gt;CSS Convenience Methods and the<a name="line.16023"></a>
<FONT color="green">16024</FONT>       * &lt;tt&gt;GChart.USE_CSS&lt;/tt&gt; keyword&lt;/b&gt;<a name="line.16024"></a>
<FONT color="green">16025</FONT>       * &lt;p&gt;<a name="line.16025"></a>
<FONT color="green">16026</FONT>       * <a name="line.16026"></a>
<FONT color="green">16027</FONT>       * Like all GWT Widgets, a GChart is both an object in a Java application, and<a name="line.16027"></a>
<FONT color="green">16028</FONT>       * an HTML element in a web page.<a name="line.16028"></a>
<FONT color="green">16029</FONT>       * <a name="line.16029"></a>
<FONT color="green">16030</FONT>       * &lt;p&gt;<a name="line.16030"></a>
<FONT color="green">16031</FONT>       * This duality naturally divides the properties of a GChart into three<a name="line.16031"></a>
<FONT color="green">16032</FONT>       * categories:<a name="line.16032"></a>
<FONT color="green">16033</FONT>       * <a name="line.16033"></a>
<FONT color="green">16034</FONT>       * &lt;ol&gt;<a name="line.16034"></a>
<FONT color="green">16035</FONT>       * <a name="line.16035"></a>
<FONT color="green">16036</FONT>       * &lt;li&gt;Those you can access only via the Java API.<a name="line.16036"></a>
<FONT color="green">16037</FONT>       * &lt;li&gt;Those you can access only via CSS and the DOM.<a name="line.16037"></a>
<FONT color="green">16038</FONT>       * &lt;li&gt;Those you can access both ways.<a name="line.16038"></a>
<FONT color="green">16039</FONT>       * &lt;/ol&gt;<a name="line.16039"></a>
<FONT color="green">16040</FONT>       * &lt;p&gt;<a name="line.16040"></a>
<FONT color="green">16041</FONT>       * <a name="line.16041"></a>
<FONT color="green">16042</FONT>       * I've used the following criteria to determine the access method appropriate<a name="line.16042"></a>
<FONT color="green">16043</FONT>       * for a given GChart property:<a name="line.16043"></a>
<FONT color="green">16044</FONT>       * &lt;p&gt;<a name="line.16044"></a>
<FONT color="green">16045</FONT>       * <a name="line.16045"></a>
<FONT color="green">16046</FONT>       * &lt;ol&gt;<a name="line.16046"></a>
<FONT color="green">16047</FONT>       * <a name="line.16047"></a>
<FONT color="green">16048</FONT>       * &lt;li&gt;Those properties that mainly define the chart itself--independent of<a name="line.16048"></a>
<FONT color="green">16049</FONT>       * its relationship to any containing web page--are exclusively accessed via<a name="line.16049"></a>
<FONT color="green">16050</FONT>       * the Java API.<a name="line.16050"></a>
<FONT color="green">16051</FONT>       * <a name="line.16051"></a>
<FONT color="green">16052</FONT>       * &lt;p&gt;<a name="line.16052"></a>
<FONT color="green">16053</FONT>       * <a name="line.16053"></a>
<FONT color="green">16054</FONT>       * For example, the x,y data values of a curve have everything to do with the<a name="line.16054"></a>
<FONT color="green">16055</FONT>       * chart itself and nothing to do with the enclosing web page, so all the<a name="line.16055"></a>
<FONT color="green">16056</FONT>       * defining x,y data of a curve can only be accessed via the Java API.<a name="line.16056"></a>
<FONT color="green">16057</FONT>       * &lt;p&gt;<a name="line.16057"></a>
<FONT color="green">16058</FONT>       * <a name="line.16058"></a>
<FONT color="green">16059</FONT>       * &lt;li&gt;Those properties that mainly define how the chart fits into the<a name="line.16059"></a>
<FONT color="green">16060</FONT>       * enclosing web page and have nothing to do with the chart itself are<a name="line.16060"></a>
<FONT color="green">16061</FONT>       * accessed exclusively via CSS stylesheets or the GWT DOM class.<a name="line.16061"></a>
<FONT color="green">16062</FONT>       * <a name="line.16062"></a>
<FONT color="green">16063</FONT>       * &lt;p&gt;<a name="line.16063"></a>
<FONT color="green">16064</FONT>       * For example, how big of a margin should be placed around a GChart is only<a name="line.16064"></a>
<FONT color="green">16065</FONT>       * about how the GChart fits into the enclosing web page, so you must define a<a name="line.16065"></a>
<FONT color="green">16066</FONT>       * GChart's margins using a CSS stylesheet (or via the GWT DOM class)--there<a name="line.16066"></a>
<FONT color="green">16067</FONT>       * is no &lt;tt&gt;GChart.setMargin&lt;/tt&gt; method.<a name="line.16067"></a>
<FONT color="green">16068</FONT>       * <a name="line.16068"></a>
<FONT color="green">16069</FONT>       * &lt;li&gt;Finally, those properties that, in some situations are best viewed as<a name="line.16069"></a>
<FONT color="green">16070</FONT>       * part of the chart itself, and in other situations as defining how the chart<a name="line.16070"></a>
<FONT color="green">16071</FONT>       * fits into the enclosing web page can be accessed &lt;i&gt;either&lt;/i&gt; via the Java<a name="line.16071"></a>
<FONT color="green">16072</FONT>       * API, or via CSS/DOM.<a name="line.16072"></a>
<FONT color="green">16073</FONT>       * &lt;p&gt;<a name="line.16073"></a>
<FONT color="green">16074</FONT>       * <a name="line.16074"></a>
<FONT color="green">16075</FONT>       * For example, if you are focused on assuring that the chart has a the same<a name="line.16075"></a>
<FONT color="green">16076</FONT>       * border as every other element on the page, the border around the chart as a<a name="line.16076"></a>
<FONT color="green">16077</FONT>       * whole can be viewed as relating to how the chart fits into the enclosing<a name="line.16077"></a>
<FONT color="green">16078</FONT>       * web page. On the other hand, if you are focused on assuring that, like the<a name="line.16078"></a>
<FONT color="green">16079</FONT>       * frame around a picture, the border looks good around that particular chart,<a name="line.16079"></a>
<FONT color="green">16080</FONT>       * it makes more sense to view it as a part of the chart itself.<a name="line.16080"></a>
<FONT color="green">16081</FONT>       * <a name="line.16081"></a>
<FONT color="green">16082</FONT>       * &lt;/ol&gt;<a name="line.16082"></a>
<FONT color="green">16083</FONT>       * <a name="line.16083"></a>
<FONT color="green">16084</FONT>       * &lt;p&gt;<a name="line.16084"></a>
<FONT color="green">16085</FONT>       * <a name="line.16085"></a>
<FONT color="green">16086</FONT>       * The Java API methods for GChart properties in this third category are known<a name="line.16086"></a>
<FONT color="green">16087</FONT>       * as "CSS convenience methods" because, though you could do the same thing by<a name="line.16087"></a>
<FONT color="green">16088</FONT>       * exploiting the "GChart as HTML element" perspective, these methods save you<a name="line.16088"></a>
<FONT color="green">16089</FONT>       * the trouble of looking up CSS syntax, splitting up your chart's<a name="line.16089"></a>
<FONT color="green">16090</FONT>       * specification between Java code and a CSS stylesheet, invoking a rather<a name="line.16090"></a>
<FONT color="green">16091</FONT>       * hard-to-remember method call in the GWT DOM class, etc.<a name="line.16091"></a>
<FONT color="green">16092</FONT>       * <a name="line.16092"></a>
<FONT color="green">16093</FONT>       * &lt;p&gt;<a name="line.16093"></a>
<FONT color="green">16094</FONT>       * Specifications made via the GChart Java API always take precedence over<a name="line.16094"></a>
<FONT color="green">16095</FONT>       * those made via stylesheets or the DOM class. To instruct GChart that you<a name="line.16095"></a>
<FONT color="green">16096</FONT>       * want one of these properties to be defined via CSS or the DOM, set the<a name="line.16096"></a>
<FONT color="green">16097</FONT>       * associated Java API property to the special value &lt;tt&gt;GChart.USE_CSS&lt;/tt&gt;.<a name="line.16097"></a>
<FONT color="green">16098</FONT>       * <a name="line.16098"></a>
<FONT color="green">16099</FONT>       * &lt;p&gt;<a name="line.16099"></a>
<FONT color="green">16100</FONT>       * Fortunately, since &lt;tt&gt;USE_CSS&lt;/tt&gt; is the default value for every one of<a name="line.16100"></a>
<FONT color="green">16101</FONT>       * these CSS convenience properties, if you never use the Java API to set<a name="line.16101"></a>
<FONT color="green">16102</FONT>       * them, you can use CSS to control them just as you would for a GWT widget<a name="line.16102"></a>
<FONT color="green">16103</FONT>       * that did not support convenience properties.<a name="line.16103"></a>
<FONT color="green">16104</FONT>       * <a name="line.16104"></a>
<FONT color="green">16105</FONT>       * <a name="line.16105"></a>
<FONT color="green">16106</FONT>       * Unfortunately, these CSS defaults rarely produce a great looking chart out<a name="line.16106"></a>
<FONT color="green">16107</FONT>       * of the box; the example CSS snippet below defines all of these convenience<a name="line.16107"></a>
<FONT color="green">16108</FONT>       * properties and attaches them to GChart's default CSS selector (aka<a name="line.16108"></a>
<FONT color="green">16109</FONT>       * stylename) in a way that I think looks better. A comment to the right of<a name="line.16109"></a>
<FONT color="green">16110</FONT>       * each line contains the corresponding CSS convenience-method call that has<a name="line.16110"></a>
<FONT color="green">16111</FONT>       * the same effect.<a name="line.16111"></a>
<FONT color="green">16112</FONT>       * <a name="line.16112"></a>
<FONT color="green">16113</FONT>       * &lt;p&gt;<a name="line.16113"></a>
<FONT color="green">16114</FONT>       * <a name="line.16114"></a>
<FONT color="green">16115</FONT>       * &lt;pre&gt;<a name="line.16115"></a>
<FONT color="green">16116</FONT>       * .gchart-GChart {<a name="line.16116"></a>
<FONT color="green">16117</FONT>       *    background-color: #DDF;   /* setBackgroundColor("#DDF"); *&amp;#47;<a name="line.16117"></a>
<FONT color="green">16118</FONT>       *    border-width: 1px;         /* setBorderWidth("1px"); *&amp;#47;<a name="line.16118"></a>
<FONT color="green">16119</FONT>       *    border-color: black;       /* setBorderColor("black"); *&amp;#47; <a name="line.16119"></a>
<FONT color="green">16120</FONT>       *    border-style: solid;       /* setBorderStyle("solid");  *&amp;#47; <a name="line.16120"></a>
<FONT color="green">16121</FONT>       *  }<a name="line.16121"></a>
<FONT color="green">16122</FONT>       * &lt;/pre&gt;<a name="line.16122"></a>
<FONT color="green">16123</FONT>       * <a name="line.16123"></a>
<FONT color="green">16124</FONT>       * <a name="line.16124"></a>
<FONT color="green">16125</FONT>       * Note that certain CSS convenience methods that could in principle have been<a name="line.16125"></a>
<FONT color="green">16126</FONT>       * added, such as those for defining the background image of a chart, were<a name="line.16126"></a>
<FONT color="green">16127</FONT>       * omitted because I thought they would almost never be used. Of course, you<a name="line.16127"></a>
<FONT color="green">16128</FONT>       * can always access these CSS properties "the old fashioned way" (via a CSS<a name="line.16128"></a>
<FONT color="green">16129</FONT>       * specification or methods of the GWT DOM class).<a name="line.16129"></a>
<FONT color="green">16130</FONT>       * <a name="line.16130"></a>
<FONT color="green">16131</FONT>       * &lt;p&gt;<a name="line.16131"></a>
<FONT color="green">16132</FONT>       * &lt;/small&gt;&lt;/blockquote&gt;<a name="line.16132"></a>
<FONT color="green">16133</FONT>       * <a name="line.16133"></a>
<FONT color="green">16134</FONT>       * @see #setBorderColor(String) setBorderColor<a name="line.16134"></a>
<FONT color="green">16135</FONT>       * @see #setBorderStyle(String) setBorderStyle<a name="line.16135"></a>
<FONT color="green">16136</FONT>       * @see #setBackgroundColor(String) setBackgroundColor<a name="line.16136"></a>
<FONT color="green">16137</FONT>       * @see #setBorderWidth(String) setBorderWidth<a name="line.16137"></a>
<FONT color="green">16138</FONT>       * <a name="line.16138"></a>
<FONT color="green">16139</FONT>       * <a name="line.16139"></a>
<FONT color="green">16140</FONT>       * <a name="line.16140"></a>
<FONT color="green">16141</FONT>       */<a name="line.16141"></a>
<FONT color="green">16142</FONT>      /*<a name="line.16142"></a>
<FONT color="green">16143</FONT>       * Setting a CSS property to "" generally clears the attribute specification,<a name="line.16143"></a>
<FONT color="green">16144</FONT>       * restoring things to their initial defaults (not sure if this always works,<a name="line.16144"></a>
<FONT color="green">16145</FONT>       * but it appears to so far).<a name="line.16145"></a>
<FONT color="green">16146</FONT>       */<a name="line.16146"></a>
<FONT color="green">16147</FONT>      public final static String USE_CSS = "";<a name="line.16147"></a>
<FONT color="green">16148</FONT>    <a name="line.16148"></a>
<FONT color="green">16149</FONT>      /**<a name="line.16149"></a>
<FONT color="green">16150</FONT>       * Keyword used to indicate that a curve should be displayed on the left<a name="line.16150"></a>
<FONT color="green">16151</FONT>       * y-axis.<a name="line.16151"></a>
<FONT color="green">16152</FONT>       * <a name="line.16152"></a>
<FONT color="green">16153</FONT>       * @see #Y2_AXIS Y2_AXIS<a name="line.16153"></a>
<FONT color="green">16154</FONT>       * @see GChart.Curve#setYAxis(GChart.YAxisId) setYAxis<a name="line.16154"></a>
<FONT color="green">16155</FONT>       * <a name="line.16155"></a>
<FONT color="green">16156</FONT>       */<a name="line.16156"></a>
<FONT color="green">16157</FONT>      public static final YAxisId Y_AXIS = new YAxisId();<a name="line.16157"></a>
<FONT color="green">16158</FONT>    <a name="line.16158"></a>
<FONT color="green">16159</FONT>      /**<a name="line.16159"></a>
<FONT color="green">16160</FONT>       * Keyword used to indicate that a curve should be displayed on the right (the<a name="line.16160"></a>
<FONT color="green">16161</FONT>       * so-called y2) y-axis.<a name="line.16161"></a>
<FONT color="green">16162</FONT>       * <a name="line.16162"></a>
<FONT color="green">16163</FONT>       * @see #Y_AXIS Y_AXIS<a name="line.16163"></a>
<FONT color="green">16164</FONT>       * @see Curve#setYAxis setYAxis<a name="line.16164"></a>
<FONT color="green">16165</FONT>       * <a name="line.16165"></a>
<FONT color="green">16166</FONT>       */<a name="line.16166"></a>
<FONT color="green">16167</FONT>      public static final YAxisId Y2_AXIS = new YAxisId();<a name="line.16167"></a>
<FONT color="green">16168</FONT>    <a name="line.16168"></a>
<FONT color="green">16169</FONT>      /**<a name="line.16169"></a>
<FONT color="green">16170</FONT>       * The default URL GChart will use to access the blank image (specifically, a<a name="line.16170"></a>
<FONT color="green">16171</FONT>       * 1 x 1 pixel transparent GIF) it requires to prevent "missing image" icons<a name="line.16171"></a>
<FONT color="green">16172</FONT>       * from appearing in your charts.<a name="line.16172"></a>
<FONT color="green">16173</FONT>       * <a name="line.16173"></a>
<FONT color="green">16174</FONT>       * @see #setBlankImageURL setBlankImageURL<a name="line.16174"></a>
<FONT color="green">16175</FONT>       * <a name="line.16175"></a>
<FONT color="green">16176</FONT>       */<a name="line.16176"></a>
<FONT color="green">16177</FONT>      public final static String DEFAULT_BLANK_IMAGE_URL = "gchart.gif";<a name="line.16177"></a>
<FONT color="green">16178</FONT>      /**<a name="line.16178"></a>
<FONT color="green">16179</FONT>       * The full path to the default GChart blank image (specifically, a 1 x 1<a name="line.16179"></a>
<FONT color="green">16180</FONT>       * pixel transparent GIF) it requires to prevent "missing image" icons from<a name="line.16180"></a>
<FONT color="green">16181</FONT>       * appearing in your charts.<a name="line.16181"></a>
<FONT color="green">16182</FONT>       * &lt;p&gt;<a name="line.16182"></a>
<FONT color="green">16183</FONT>       * <a name="line.16183"></a>
<FONT color="green">16184</FONT>       * Convenience constant equal to:<a name="line.16184"></a>
<FONT color="green">16185</FONT>       * <a name="line.16185"></a>
<FONT color="green">16186</FONT>       * &lt;pre&gt;<a name="line.16186"></a>
<FONT color="green">16187</FONT>       * GWT.getModuleBaseURL() + GChart.DEFAULT_BLANK_IMAGE_URL<a name="line.16187"></a>
<FONT color="green">16188</FONT>       * &lt;/pre&gt;<a name="line.16188"></a>
<FONT color="green">16189</FONT>       * <a name="line.16189"></a>
<FONT color="green">16190</FONT>       * @see #setBlankImageURL setBlankImageURL<a name="line.16190"></a>
<FONT color="green">16191</FONT>       * <a name="line.16191"></a>
<FONT color="green">16192</FONT>       */<a name="line.16192"></a>
<FONT color="green">16193</FONT>      public final static String DEFAULT_BLANK_IMAGE_URL_FULLPATH =<a name="line.16193"></a>
<FONT color="green">16194</FONT>              GWT.getModuleBaseURL() + GChart.DEFAULT_BLANK_IMAGE_URL;<a name="line.16194"></a>
<FONT color="green">16195</FONT>      private static final int DEFAULT_GRID_HEIGHT = DEFAULT_TICK_THICKNESS;<a name="line.16195"></a>
<FONT color="green">16196</FONT>      private static final int DEFAULT_GRID_WIDTH = DEFAULT_TICK_THICKNESS;<a name="line.16196"></a>
<FONT color="green">16197</FONT>      private static final String GRID_BORDER_STYLE = "solid";<a name="line.16197"></a>
<FONT color="green">16198</FONT>      private static final int GRID_BORDER_WIDTH = 1;<a name="line.16198"></a>
<FONT color="green">16199</FONT>    <a name="line.16199"></a>
<FONT color="green">16200</FONT>      /**<a name="line.16200"></a>
<FONT color="green">16201</FONT>       * The default color used for all axes, gridlines, and ticks.<a name="line.16201"></a>
<FONT color="green">16202</FONT>       * <a name="line.16202"></a>
<FONT color="green">16203</FONT>       * @see #setGridColor setGridColor<a name="line.16203"></a>
<FONT color="green">16204</FONT>       * <a name="line.16204"></a>
<FONT color="green">16205</FONT>       */<a name="line.16205"></a>
<FONT color="green">16206</FONT>      public static final String DEFAULT_GRID_COLOR = "black";<a name="line.16206"></a>
<FONT color="green">16207</FONT>    <a name="line.16207"></a>
<FONT color="green">16208</FONT>      /**<a name="line.16208"></a>
<FONT color="green">16209</FONT>       * The default thickness (height) of the rectangular region at the bottom of<a name="line.16209"></a>
<FONT color="green">16210</FONT>       * the chart allocated for footnotes, per &lt;tt&gt;&amp;lt;br&amp;gt;&lt;/tt&gt; or<a name="line.16210"></a>
<FONT color="green">16211</FONT>       * &lt;tt&gt;&amp;lt;li&amp;gt;&lt;/tt&gt; delimited HTML line. This default is only used when the<a name="line.16211"></a>
<FONT color="green">16212</FONT>       * footnote thickness is set to &lt;tt&gt;GChart.NAI&lt;/tt&gt; (the default).<a name="line.16212"></a>
<FONT color="green">16213</FONT>       * <a name="line.16213"></a>
<FONT color="green">16214</FONT>       * @see #setChartFootnotesThickness setChartFootnotesThickness<a name="line.16214"></a>
<FONT color="green">16215</FONT>       * <a name="line.16215"></a>
<FONT color="green">16216</FONT>       */<a name="line.16216"></a>
<FONT color="green">16217</FONT>      public static final int DEFAULT_FOOTNOTES_THICKNESS = 15;<a name="line.16217"></a>
<FONT color="green">16218</FONT>    <a name="line.16218"></a>
<FONT color="green">16219</FONT>      /**<a name="line.16219"></a>
<FONT color="green">16220</FONT>       * <a name="line.16220"></a>
<FONT color="green">16221</FONT>       * The default thickness (height) of the rectangular region at the top of the<a name="line.16221"></a>
<FONT color="green">16222</FONT>       * chart allocated for the chart's title, per &lt;tt&gt;&amp;lt;br&amp;gt;&lt;/tt&gt; or<a name="line.16222"></a>
<FONT color="green">16223</FONT>       * &lt;tt&gt;&amp;lt;li&amp;gt;&lt;/tt&gt; delimited HTML line. This default is only used when the<a name="line.16223"></a>
<FONT color="green">16224</FONT>       * title thickness is set to &lt;tt&gt;GChart.NAI&lt;/tt&gt;.<a name="line.16224"></a>
<FONT color="green">16225</FONT>       * <a name="line.16225"></a>
<FONT color="green">16226</FONT>       * <a name="line.16226"></a>
<FONT color="green">16227</FONT>       * @see #setChartTitleThickness setChartTitleThickness<a name="line.16227"></a>
<FONT color="green">16228</FONT>       * <a name="line.16228"></a>
<FONT color="green">16229</FONT>       */<a name="line.16229"></a>
<FONT color="green">16230</FONT>      public static final int DEFAULT_TITLE_THICKNESS = 15;<a name="line.16230"></a>
<FONT color="green">16231</FONT>    <a name="line.16231"></a>
<FONT color="green">16232</FONT>      // for purposes of estimating fixed space "band" around the plot<a name="line.16232"></a>
<FONT color="green">16233</FONT>      // panel reserved for the tick labels:<a name="line.16233"></a>
<FONT color="green">16234</FONT>      private static final double TICK_CHARHEIGHT_TO_FONTSIZE_LOWERBOUND = 1.0;<a name="line.16234"></a>
<FONT color="green">16235</FONT>      // a bit larger than the 0.6 rule-of-thumb<a name="line.16235"></a>
<FONT color="green">16236</FONT>      private static final double TICK_CHARWIDTH_TO_FONTSIZE_LOWERBOUND = 0.7;<a name="line.16236"></a>
<FONT color="green">16237</FONT>      // For estimating size of invisible "box" needed for alignment<a name="line.16237"></a>
<FONT color="green">16238</FONT>      // purposes. Note: when these are bigger, annotations remain<a name="line.16238"></a>
<FONT color="green">16239</FONT>      // properly aligned longer as user zooms up font sizes. But,<a name="line.16239"></a>
<FONT color="green">16240</FONT>      // bigger bounding boxes can slow updates (not sure why,<a name="line.16240"></a>
<FONT color="green">16241</FONT>      // maybe it's related to hit testing browser has to do)<a name="line.16241"></a>
<FONT color="green">16242</FONT>      private static final double CHARHEIGHT_TO_FONTSIZE_UPPERBOUND = 2 * 1.5;<a name="line.16242"></a>
<FONT color="green">16243</FONT>      private static final double CHARWIDTH_TO_FONTSIZE_UPPERBOUND = 2 * 0.7;<a name="line.16243"></a>
<FONT color="green">16244</FONT>    <a name="line.16244"></a>
<FONT color="green">16245</FONT>      private static final String TICK_BORDER_STYLE = GRID_BORDER_STYLE;<a name="line.16245"></a>
<FONT color="green">16246</FONT>      private static final int TICK_BORDER_WIDTH = GRID_BORDER_WIDTH;<a name="line.16246"></a>
<FONT color="green">16247</FONT>    <a name="line.16247"></a>
<FONT color="green">16248</FONT>      private static void setBackgroundColor(UIObject uio, String cssColor) {<a name="line.16248"></a>
<FONT color="green">16249</FONT>        DOM.setStyleAttribute(uio.getElement(), "backgroundColor", cssColor);<a name="line.16249"></a>
<FONT color="green">16250</FONT>      }<a name="line.16250"></a>
<FONT color="green">16251</FONT>    <a name="line.16251"></a>
<FONT color="green">16252</FONT>      // private static void setBackground(<a name="line.16252"></a>
<FONT color="green">16253</FONT>      // UIObject uio, String cssColor) {<a name="line.16253"></a>
<FONT color="green">16254</FONT>      // DOM.setStyleAttribute(uio.getElement(),<a name="line.16254"></a>
<FONT color="green">16255</FONT>      // "background", cssColor);<a name="line.16255"></a>
<FONT color="green">16256</FONT>      // }<a name="line.16256"></a>
<FONT color="green">16257</FONT>    <a name="line.16257"></a>
<FONT color="green">16258</FONT>      private static void setBorderColor(UIObject uio, String cssColor) {<a name="line.16258"></a>
<FONT color="green">16259</FONT>        DOM.setStyleAttribute(uio.getElement(), "borderColor", cssColor);<a name="line.16259"></a>
<FONT color="green">16260</FONT>      }<a name="line.16260"></a>
<FONT color="green">16261</FONT>    <a name="line.16261"></a>
<FONT color="green">16262</FONT>      private static void setBorderStyle(UIObject uio, String cssBorderStyle) {<a name="line.16262"></a>
<FONT color="green">16263</FONT>        DOM.setStyleAttribute(uio.getElement(), "borderStyle", cssBorderStyle);<a name="line.16263"></a>
<FONT color="green">16264</FONT>      }<a name="line.16264"></a>
<FONT color="green">16265</FONT>    <a name="line.16265"></a>
<FONT color="green">16266</FONT>      private static void setBorderWidth(UIObject uio, String cssBorderWidth) {<a name="line.16266"></a>
<FONT color="green">16267</FONT>        DOM.setStyleAttribute(uio.getElement(), "borderWidth", cssBorderWidth);<a name="line.16267"></a>
<FONT color="green">16268</FONT>      }<a name="line.16268"></a>
<FONT color="green">16269</FONT>    <a name="line.16269"></a>
<FONT color="green">16270</FONT>      private static void setBorderWidth(UIObject uio, int borderWidth) {<a name="line.16270"></a>
<FONT color="green">16271</FONT>        if (borderWidth != GChart.NAI)<a name="line.16271"></a>
<FONT color="green">16272</FONT>          setBorderWidth(uio, borderWidth + "px");<a name="line.16272"></a>
<FONT color="green">16273</FONT>        else<a name="line.16273"></a>
<FONT color="green">16274</FONT>          setBorderWidth(uio, "");<a name="line.16274"></a>
<FONT color="green">16275</FONT>      }<a name="line.16275"></a>
<FONT color="green">16276</FONT>    <a name="line.16276"></a>
<FONT color="green">16277</FONT>      private static void setFontFamily(UIObject uio, String cssFontFamily) {<a name="line.16277"></a>
<FONT color="green">16278</FONT>        DOM.setStyleAttribute(uio.getElement(), "fontFamily", cssFontFamily);<a name="line.16278"></a>
<FONT color="green">16279</FONT>      }<a name="line.16279"></a>
<FONT color="green">16280</FONT>    <a name="line.16280"></a>
<FONT color="green">16281</FONT>      private static void setFontSize(UIObject uio, int fontSize) {<a name="line.16281"></a>
<FONT color="green">16282</FONT>        DOM.setIntStyleAttribute(uio.getElement(), "fontSize", fontSize);<a name="line.16282"></a>
<FONT color="green">16283</FONT>      }<a name="line.16283"></a>
<FONT color="green">16284</FONT>    <a name="line.16284"></a>
<FONT color="green">16285</FONT>      private static void setFontStyle(UIObject uio, String fontStyle) {<a name="line.16285"></a>
<FONT color="green">16286</FONT>        DOM.setStyleAttribute(uio.getElement(), "fontStyle", fontStyle);<a name="line.16286"></a>
<FONT color="green">16287</FONT>      }<a name="line.16287"></a>
<FONT color="green">16288</FONT>    <a name="line.16288"></a>
<FONT color="green">16289</FONT>      private static void setFontWeight(UIObject uio, String fontWeight) {<a name="line.16289"></a>
<FONT color="green">16290</FONT>        DOM.setStyleAttribute(uio.getElement(), "fontWeight", fontWeight);<a name="line.16290"></a>
<FONT color="green">16291</FONT>      }<a name="line.16291"></a>
<FONT color="green">16292</FONT>    <a name="line.16292"></a>
<FONT color="green">16293</FONT>      private static void setColor(UIObject uio, String cssColor) {<a name="line.16293"></a>
<FONT color="green">16294</FONT>        DOM.setStyleAttribute(uio.getElement(), "color", cssColor);<a name="line.16294"></a>
<FONT color="green">16295</FONT>      }<a name="line.16295"></a>
<FONT color="green">16296</FONT>    <a name="line.16296"></a>
<FONT color="green">16297</FONT>      // valid layout strings are fixed, auto, and inherit<a name="line.16297"></a>
<FONT color="green">16298</FONT>      // private static void setTableLayout(<a name="line.16298"></a>
<FONT color="green">16299</FONT>      // UIObject uio, String layout) {<a name="line.16299"></a>
<FONT color="green">16300</FONT>      // DOM.setStyleAttribute(<a name="line.16300"></a>
<FONT color="green">16301</FONT>      // uio.getElement(), "table-layout", layout);<a name="line.16301"></a>
<FONT color="green">16302</FONT>      // }<a name="line.16302"></a>
<FONT color="green">16303</FONT>    <a name="line.16303"></a>
<FONT color="green">16304</FONT>      // private static void setLineHeight(<a name="line.16304"></a>
<FONT color="green">16305</FONT>      // UIObject uio, String cssLineHeight) {<a name="line.16305"></a>
<FONT color="green">16306</FONT>      // DOM.setStyleAttribute(uio.getElement(),<a name="line.16306"></a>
<FONT color="green">16307</FONT>      // "lineHeight", cssLineHeight);<a name="line.16307"></a>
<FONT color="green">16308</FONT>      // }<a name="line.16308"></a>
<FONT color="green">16309</FONT>    <a name="line.16309"></a>
<FONT color="green">16310</FONT>      // private static void setTextAlign(<a name="line.16310"></a>
<FONT color="green">16311</FONT>      // UIObject uio, String cssTextAlign) {<a name="line.16311"></a>
<FONT color="green">16312</FONT>      // DOM.setStyleAttribute(<a name="line.16312"></a>
<FONT color="green">16313</FONT>      // uio.getElement(), "textAlign", cssTextAlign);<a name="line.16313"></a>
<FONT color="green">16314</FONT>      // }<a name="line.16314"></a>
<FONT color="green">16315</FONT>      //  <a name="line.16315"></a>
<FONT color="green">16316</FONT>      // private static void setMargin(<a name="line.16316"></a>
<FONT color="green">16317</FONT>      // UIObject uio, String cssMargin) {<a name="line.16317"></a>
<FONT color="green">16318</FONT>      // DOM.setStyleAttribute(<a name="line.16318"></a>
<FONT color="green">16319</FONT>      // uio.getElement(), "margin", cssMargin);<a name="line.16319"></a>
<FONT color="green">16320</FONT>      // }<a name="line.16320"></a>
<FONT color="green">16321</FONT>      private static void setPadding(UIObject uio, String cssPadding) {<a name="line.16321"></a>
<FONT color="green">16322</FONT>        DOM.setStyleAttribute(uio.getElement(), "padding", cssPadding);<a name="line.16322"></a>
<FONT color="green">16323</FONT>      }<a name="line.16323"></a>
<FONT color="green">16324</FONT>    <a name="line.16324"></a>
<FONT color="green">16325</FONT>      // valid choices are block, inline, list-item, or none<a name="line.16325"></a>
<FONT color="green">16326</FONT>      // private static void setDisplay(<a name="line.16326"></a>
<FONT color="green">16327</FONT>      // UIObject uio, String cssDisplay) {<a name="line.16327"></a>
<FONT color="green">16328</FONT>      // DOM.setStyleAttribute(<a name="line.16328"></a>
<FONT color="green">16329</FONT>      // uio.getElement(), "display", cssDisplay);<a name="line.16329"></a>
<FONT color="green">16330</FONT>      // }<a name="line.16330"></a>
<FONT color="green">16331</FONT>      // choices are: visible, hidden, scroll or auto<a name="line.16331"></a>
<FONT color="green">16332</FONT>      private static void setOverflow(UIObject uio, String cssOverflow) {<a name="line.16332"></a>
<FONT color="green">16333</FONT>        DOM.setStyleAttribute(uio.getElement(), "overflow", cssOverflow);<a name="line.16333"></a>
<FONT color="green">16334</FONT>      }<a name="line.16334"></a>
<FONT color="green">16335</FONT>    <a name="line.16335"></a>
<FONT color="green">16336</FONT>      // private static void setTextLeading(<a name="line.16336"></a>
<FONT color="green">16337</FONT>      // UIObject uio, String cssTextLeading) {<a name="line.16337"></a>
<FONT color="green">16338</FONT>      // DOM.setStyleAttribute(<a name="line.16338"></a>
<FONT color="green">16339</FONT>      // uio.getElement(), "textTrailing", cssTextLeading);<a name="line.16339"></a>
<FONT color="green">16340</FONT>      // }<a name="line.16340"></a>
<FONT color="green">16341</FONT>      // private static void setVerticalAlign(<a name="line.16341"></a>
<FONT color="green">16342</FONT>      // UIObject uio, String cssVerticalAlign) {<a name="line.16342"></a>
<FONT color="green">16343</FONT>      // DOM.setStyleAttribute(<a name="line.16343"></a>
<FONT color="green">16344</FONT>      // uio.getElement(), "verticalAlign", cssVerticalAlign);<a name="line.16344"></a>
<FONT color="green">16345</FONT>      // }<a name="line.16345"></a>
<FONT color="green">16346</FONT>    <a name="line.16346"></a>
<FONT color="green">16347</FONT>      // returns the sign of the given number<a name="line.16347"></a>
<FONT color="green">16348</FONT>      static int sign(double x) {<a name="line.16348"></a>
<FONT color="green">16349</FONT>        int result = (x &lt; 0) ? -1 : 1;<a name="line.16349"></a>
<FONT color="green">16350</FONT>        return result;<a name="line.16350"></a>
<FONT color="green">16351</FONT>      }<a name="line.16351"></a>
<FONT color="green">16352</FONT>    <a name="line.16352"></a>
<FONT color="green">16353</FONT>      // Validates multipliers used to simplify computing the<a name="line.16353"></a>
<FONT color="green">16354</FONT>      // upper left corner location of symbols and labels to<a name="line.16354"></a>
<FONT color="green">16355</FONT>      // properly reflect their alignment relative to the<a name="line.16355"></a>
<FONT color="green">16356</FONT>      // plotted point or labeled symbol.<a name="line.16356"></a>
<FONT color="green">16357</FONT>      static void validateMultipliers(int widthMultiplier, int heightMultiplier) {<a name="line.16357"></a>
<FONT color="green">16358</FONT>        if (!(widthMultiplier == 0 || Math.abs(widthMultiplier) == 1)<a name="line.16358"></a>
<FONT color="green">16359</FONT>            &amp;&amp; !(heightMultiplier == 0 || Math.abs(heightMultiplier) == 1))<a name="line.16359"></a>
<FONT color="green">16360</FONT>          throw new IllegalArgumentException(<a name="line.16360"></a>
<FONT color="green">16361</FONT>              "widthMultiplier, heightMultiplier args must both be "<a name="line.16361"></a>
<FONT color="green">16362</FONT>              + "either 0, 1, or -1");<a name="line.16362"></a>
<FONT color="green">16363</FONT>      }<a name="line.16363"></a>
<FONT color="green">16364</FONT>    <a name="line.16364"></a>
<FONT color="green">16365</FONT>      // is value within given limits, inclusive?<a name="line.16365"></a>
<FONT color="green">16366</FONT>      static boolean withinRange(double x, double minLim, double maxLim) {<a name="line.16366"></a>
<FONT color="green">16367</FONT>        // x!=x is a faster isNaN; NaN is considered in range<a name="line.16367"></a>
<FONT color="green">16368</FONT>        boolean result = (x != x) ? true : (x &gt;= minLim &amp;&amp; x &lt;= maxLim);<a name="line.16368"></a>
<FONT color="green">16369</FONT>        return result;<a name="line.16369"></a>
<FONT color="green">16370</FONT>      }<a name="line.16370"></a>
<FONT color="green">16371</FONT>    <a name="line.16371"></a>
<FONT color="green">16372</FONT>      private Widget chartFootnotes;<a name="line.16372"></a>
<FONT color="green">16373</FONT>      private boolean chartFootnotesLeftJustified;<a name="line.16373"></a>
<FONT color="green">16374</FONT>    <a name="line.16374"></a>
<FONT color="green">16375</FONT>      // outer container needed so CSS-defined paddings don't interfere with<a name="line.16375"></a>
<FONT color="green">16376</FONT>      // positioning<a name="line.16376"></a>
<FONT color="green">16377</FONT>      private SimplePanel chartPanel = new SimplePanel();<a name="line.16377"></a>
<FONT color="green">16378</FONT>    <a name="line.16378"></a>
<FONT color="green">16379</FONT>      private String borderWidth = USE_CSS;<a name="line.16379"></a>
<FONT color="green">16380</FONT>      private String borderStyle = USE_CSS;<a name="line.16380"></a>
<FONT color="green">16381</FONT>      private String borderColor = USE_CSS;<a name="line.16381"></a>
<FONT color="green">16382</FONT>      private String backgroundColor = USE_CSS;<a name="line.16382"></a>
<FONT color="green">16383</FONT>      private static String blankImageURL = null;<a name="line.16383"></a>
<FONT color="green">16384</FONT>      private double canvasExpansionFactorX = 0;<a name="line.16384"></a>
<FONT color="green">16385</FONT>      private double canvasExpansionFactorY = 0;<a name="line.16385"></a>
<FONT color="green">16386</FONT>      boolean chartDecorationsChanged = true;<a name="line.16386"></a>
<FONT color="green">16387</FONT>      private Widget chartTitle;<a name="line.16387"></a>
<FONT color="green">16388</FONT>      // collection of curves associated with this chart.<a name="line.16388"></a>
<FONT color="green">16389</FONT>      private ArrayList&lt;Curve&gt; curves = new ArrayList&lt;Curve&gt;();<a name="line.16389"></a>
<FONT color="green">16390</FONT>      private String fontFamily = DEFAULT_FONT_FAMILY;<a name="line.16390"></a>
<FONT color="green">16391</FONT>      private int footnotesThickness = GChart.NAI;<a name="line.16391"></a>
<FONT color="green">16392</FONT>      private String legendBackgroundColor = DEFAULT_LEGEND_BACKGROUND_COLOR;<a name="line.16392"></a>
<FONT color="green">16393</FONT>      private String legendBorderColor = DEFAULT_LEGEND_BORDER_COLOR;<a name="line.16393"></a>
<FONT color="green">16394</FONT>      private int legendBorderWidth = DEFAULT_LEGEND_BORDER_WIDTH;<a name="line.16394"></a>
<FONT color="green">16395</FONT>      private String legendBorderStyle = DEFAULT_LEGEND_BORDER_STYLE;<a name="line.16395"></a>
<FONT color="green">16396</FONT>      private int legendThickness = GChart.NAI;<a name="line.16396"></a>
<FONT color="green">16397</FONT>    <a name="line.16397"></a>
<FONT color="green">16398</FONT>      private boolean isLegendVisible = true;<a name="line.16398"></a>
<FONT color="green">16399</FONT>    <a name="line.16399"></a>
<FONT color="green">16400</FONT>      private String legendFontColor = DEFAULT_FONT_COLOR;<a name="line.16400"></a>
<FONT color="green">16401</FONT>      private String legendFontFamily = null;<a name="line.16401"></a>
<FONT color="green">16402</FONT>      private int legendFontSize = DEFAULT_LEGEND_FONTSIZE;<a name="line.16402"></a>
<FONT color="green">16403</FONT>      private String legendFontStyle = DEFAULT_FONT_STYLE;<a name="line.16403"></a>
<FONT color="green">16404</FONT>      private String legendFontWeight = DEFAULT_FONT_WEIGHT;<a name="line.16404"></a>
<FONT color="green">16405</FONT>      private Widget legend = null; // developer-defined<a name="line.16405"></a>
<FONT color="green">16406</FONT>      // legend<a name="line.16406"></a>
<FONT color="green">16407</FONT>      private LegendLocation legendLocation = LegendLocation.OUTSIDE_RIGHT;<a name="line.16407"></a>
<FONT color="green">16408</FONT>      private int legendXShift = 0;<a name="line.16408"></a>
<FONT color="green">16409</FONT>      private int legendYShift = 0;<a name="line.16409"></a>
<FONT color="green">16410</FONT>      private double maxCanvasPixels = DEFAULT_MAX_CANVAS_PIXELS;<a name="line.16410"></a>
<FONT color="green">16411</FONT>    <a name="line.16411"></a>
<FONT color="green">16412</FONT>      /*<a name="line.16412"></a>
<FONT color="green">16413</FONT>       * Contains the plotting region, as well as axes, ticks, and tick-labels<a name="line.16413"></a>
<FONT color="green">16414</FONT>       * associated with that region. Note that tickText must be centered on the<a name="line.16414"></a>
<FONT color="green">16415</FONT>       * ticks--placing them on the same AbsolutePanel as the ticks/plots<a name="line.16415"></a>
<FONT color="green">16416</FONT>       * facilitates this.<a name="line.16416"></a>
<FONT color="green">16417</FONT>       */<a name="line.16417"></a>
<FONT color="green">16418</FONT>      PlotPanel plotPanel = new PlotPanel();<a name="line.16418"></a>
<FONT color="green">16419</FONT>      private String padding = USE_CSS;<a name="line.16419"></a>
<FONT color="green">16420</FONT>      private boolean optimizeForMemory = false;<a name="line.16420"></a>
<FONT color="green">16421</FONT>      private double renderPaddingFactor = 0.0;<a name="line.16421"></a>
<FONT color="green">16422</FONT>      private boolean clipToPlotArea = false;<a name="line.16422"></a>
<FONT color="green">16423</FONT>      private boolean clipToDecoratedChart = false;<a name="line.16423"></a>
<FONT color="green">16424</FONT>      private int titleThickness = GChart.NAI;<a name="line.16424"></a>
<FONT color="green">16425</FONT>    <a name="line.16425"></a>
<FONT color="green">16426</FONT>      private Axis xAxis; // must be created in constructor<a name="line.16426"></a>
<FONT color="green">16427</FONT>      private Axis yAxis; // because they use system curves<a name="line.16427"></a>
<FONT color="green">16428</FONT>      private Axis y2Axis;<a name="line.16428"></a>
<FONT color="green">16429</FONT>    <a name="line.16429"></a>
<FONT color="green">16430</FONT>      private int xChartSize; // pixel size of plotting region<a name="line.16430"></a>
<FONT color="green">16431</FONT>      private int yChartSize;<a name="line.16431"></a>
<FONT color="green">16432</FONT>    <a name="line.16432"></a>
<FONT color="green">16433</FONT>      // # of system curves "underneath" (before in DOM-order) user's curves<a name="line.16433"></a>
<FONT color="green">16434</FONT>      private static int N_PRE_SYSTEM_CURVES = 16;<a name="line.16434"></a>
<FONT color="green">16435</FONT>      // # of system curves "on top of" (after in DOM-order) user's curves<a name="line.16435"></a>
<FONT color="green">16436</FONT>      private static int N_POST_SYSTEM_CURVES = 2;<a name="line.16436"></a>
<FONT color="green">16437</FONT>      private static int N_SYSTEM_CURVES = N_PRE_SYSTEM_CURVES<a name="line.16437"></a>
<FONT color="green">16438</FONT>          + N_POST_SYSTEM_CURVES;<a name="line.16438"></a>
<FONT color="green">16439</FONT>      // index of curve that holds correspondingly-named chart part<a name="line.16439"></a>
<FONT color="green">16440</FONT>      // (sys curve indexes are negative &amp; not directly developer-accessible)<a name="line.16440"></a>
<FONT color="green">16441</FONT>      private final static int PLOTAREA_ID = 0 - N_SYSTEM_CURVES;<a name="line.16441"></a>
<FONT color="green">16442</FONT>      private final static int TITLE_ID = 1 - N_SYSTEM_CURVES;<a name="line.16442"></a>
<FONT color="green">16443</FONT>      private final static int YAXIS_ID = 2 - N_SYSTEM_CURVES;<a name="line.16443"></a>
<FONT color="green">16444</FONT>      private final static int YTICKS_ID = 3 - N_SYSTEM_CURVES;<a name="line.16444"></a>
<FONT color="green">16445</FONT>      private final static int YGRIDLINES_ID = 4 - N_SYSTEM_CURVES;<a name="line.16445"></a>
<FONT color="green">16446</FONT>      private final static int YLABEL_ID = 5 - N_SYSTEM_CURVES;<a name="line.16446"></a>
<FONT color="green">16447</FONT>      private final static int Y2AXIS_ID = 6 - N_SYSTEM_CURVES;<a name="line.16447"></a>
<FONT color="green">16448</FONT>      private final static int Y2TICKS_ID = 7 - N_SYSTEM_CURVES;<a name="line.16448"></a>
<FONT color="green">16449</FONT>      private final static int Y2GRIDLINES_ID = 8 - N_SYSTEM_CURVES;<a name="line.16449"></a>
<FONT color="green">16450</FONT>      private final static int Y2LABEL_ID = 9 - N_SYSTEM_CURVES;<a name="line.16450"></a>
<FONT color="green">16451</FONT>      private final static int LEGEND_ID = 10 - N_SYSTEM_CURVES;<a name="line.16451"></a>
<FONT color="green">16452</FONT>      private final static int XAXIS_ID = 11 - N_SYSTEM_CURVES;<a name="line.16452"></a>
<FONT color="green">16453</FONT>      private final static int XTICKS_ID = 12 - N_SYSTEM_CURVES;<a name="line.16453"></a>
<FONT color="green">16454</FONT>      private final static int XGRIDLINES_ID = 13 - N_SYSTEM_CURVES;<a name="line.16454"></a>
<FONT color="green">16455</FONT>      private final static int XLABEL_ID = 14 - N_SYSTEM_CURVES;<a name="line.16455"></a>
<FONT color="green">16456</FONT>      private final static int FOOTNOTES_ID = 15 - N_SYSTEM_CURVES;<a name="line.16456"></a>
<FONT color="green">16457</FONT>      private final static int HOVER_CURSOR_ID = 16 - N_SYSTEM_CURVES;<a name="line.16457"></a>
<FONT color="green">16458</FONT>      private final static int HOVER_ANNOTATION_ID = 17 - N_SYSTEM_CURVES;<a name="line.16458"></a>
<FONT color="green">16459</FONT>    <a name="line.16459"></a>
<FONT color="green">16460</FONT>      // adds system curves GChart uses to render title, ticks, etc.<a name="line.16460"></a>
<FONT color="green">16461</FONT>      private void addSystemCurves() {<a name="line.16461"></a>
<FONT color="green">16462</FONT>        // Must be first: other methods assume sys curves exist<a name="line.16462"></a>
<FONT color="green">16463</FONT>        for (int i = 0; i &lt; N_SYSTEM_CURVES; i++) {<a name="line.16463"></a>
<FONT color="green">16464</FONT>          Curve c = new Curve(i);<a name="line.16464"></a>
<FONT color="green">16465</FONT>          curves.add(c);<a name="line.16465"></a>
<FONT color="green">16466</FONT>          // Required rendering panels are added lazily, later on<a name="line.16466"></a>
<FONT color="green">16467</FONT>        }<a name="line.16467"></a>
<FONT color="green">16468</FONT>    <a name="line.16468"></a>
<FONT color="green">16469</FONT>        // define static (or default) properties, points on, system curves<a name="line.16469"></a>
<FONT color="green">16470</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.16470"></a>
<FONT color="green">16471</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16471"></a>
<FONT color="green">16472</FONT>        c.getSymbol().setSymbolType(SymbolType.BOX_SOUTHEAST);<a name="line.16472"></a>
<FONT color="green">16473</FONT>        c.getSymbol().setBackgroundColor(DEFAULT_PLOTAREA_BACKGROUND_COLOR);<a name="line.16473"></a>
<FONT color="green">16474</FONT>        c.getSymbol().setBorderColor(DEFAULT_PLOTAREA_BORDER_COLOR);<a name="line.16474"></a>
<FONT color="green">16475</FONT>        c.getSymbol().setBorderStyle(DEFAULT_PLOTAREA_BORDER_STYLE);<a name="line.16475"></a>
<FONT color="green">16476</FONT>        c.getSymbol().setBorderWidth(DEFAULT_PLOTAREA_BORDER_WIDTH);<a name="line.16476"></a>
<FONT color="green">16477</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16477"></a>
<FONT color="green">16478</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16478"></a>
<FONT color="green">16479</FONT>        c.addPoint(-Double.MAX_VALUE, Double.MAX_VALUE);<a name="line.16479"></a>
<FONT color="green">16480</FONT>    <a name="line.16480"></a>
<FONT color="green">16481</FONT>        c = getSystemCurve(TITLE_ID);<a name="line.16481"></a>
<FONT color="green">16482</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16482"></a>
<FONT color="green">16483</FONT>        c.getSymbol().setSymbolType(SymbolType.ANCHOR_NORTHWEST);<a name="line.16483"></a>
<FONT color="green">16484</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16484"></a>
<FONT color="green">16485</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16485"></a>
<FONT color="green">16486</FONT>        c.addPoint(Double.MAX_VALUE, Double.MAX_VALUE);<a name="line.16486"></a>
<FONT color="green">16487</FONT>        c.getPoint().setAnnotationLocation(AnnotationLocation.CENTER);<a name="line.16487"></a>
<FONT color="green">16488</FONT>    <a name="line.16488"></a>
<FONT color="green">16489</FONT>        c = getSystemCurve(YAXIS_ID);<a name="line.16489"></a>
<FONT color="green">16490</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16490"></a>
<FONT color="green">16491</FONT>        c.getSymbol().setSymbolType(SymbolType.XGRIDLINE);<a name="line.16491"></a>
<FONT color="green">16492</FONT>        c.getSymbol().setBackgroundColor(DEFAULT_GRID_COLOR);<a name="line.16492"></a>
<FONT color="green">16493</FONT>        c.getSymbol().setBorderColor(DEFAULT_GRID_COLOR);<a name="line.16493"></a>
<FONT color="green">16494</FONT>        c.getSymbol().setBorderStyle(GRID_BORDER_STYLE);<a name="line.16494"></a>
<FONT color="green">16495</FONT>        c.getSymbol().setBorderWidth(GRID_BORDER_WIDTH);<a name="line.16495"></a>
<FONT color="green">16496</FONT>        c.getSymbol().setWidth(DEFAULT_GRID_WIDTH);<a name="line.16496"></a>
<FONT color="green">16497</FONT>        c.getSymbol().setHeight(DEFAULT_GRID_HEIGHT);<a name="line.16497"></a>
<FONT color="green">16498</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16498"></a>
<FONT color="green">16499</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16499"></a>
<FONT color="green">16500</FONT>        c.addPoint(-Double.MAX_VALUE, -Double.MAX_VALUE);<a name="line.16500"></a>
<FONT color="green">16501</FONT>    <a name="line.16501"></a>
<FONT color="green">16502</FONT>        c = getSystemCurve(YTICKS_ID);<a name="line.16502"></a>
<FONT color="green">16503</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16503"></a>
<FONT color="green">16504</FONT>        c.getSymbol().setSymbolType(SymbolType.BOX_WEST);<a name="line.16504"></a>
<FONT color="green">16505</FONT>        c.getSymbol().setBackgroundColor(DEFAULT_GRID_COLOR);<a name="line.16505"></a>
<FONT color="green">16506</FONT>        c.getSymbol().setBorderColor(DEFAULT_GRID_COLOR);<a name="line.16506"></a>
<FONT color="green">16507</FONT>        c.getSymbol().setBorderStyle(TICK_BORDER_STYLE);<a name="line.16507"></a>
<FONT color="green">16508</FONT>        c.getSymbol().setBorderWidth(TICK_BORDER_WIDTH);<a name="line.16508"></a>
<FONT color="green">16509</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16509"></a>
<FONT color="green">16510</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16510"></a>
<FONT color="green">16511</FONT>        // points, annotation locations added when ticks are<a name="line.16511"></a>
<FONT color="green">16512</FONT>    <a name="line.16512"></a>
<FONT color="green">16513</FONT>        c = getSystemCurve(YGRIDLINES_ID);<a name="line.16513"></a>
<FONT color="green">16514</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16514"></a>
<FONT color="green">16515</FONT>        c.getSymbol().setSymbolType(SymbolType.YGRIDLINE);<a name="line.16515"></a>
<FONT color="green">16516</FONT>        c.getSymbol().setBackgroundColor(DEFAULT_GRID_COLOR);<a name="line.16516"></a>
<FONT color="green">16517</FONT>        c.getSymbol().setBorderColor(DEFAULT_GRID_COLOR);<a name="line.16517"></a>
<FONT color="green">16518</FONT>        c.getSymbol().setBorderStyle(GRID_BORDER_STYLE);<a name="line.16518"></a>
<FONT color="green">16519</FONT>        c.getSymbol().setBorderWidth(GRID_BORDER_WIDTH);<a name="line.16519"></a>
<FONT color="green">16520</FONT>        c.getSymbol().setWidth(DEFAULT_GRID_WIDTH);<a name="line.16520"></a>
<FONT color="green">16521</FONT>        c.getSymbol().setHeight(DEFAULT_GRID_HEIGHT);<a name="line.16521"></a>
<FONT color="green">16522</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16522"></a>
<FONT color="green">16523</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16523"></a>
<FONT color="green">16524</FONT>    <a name="line.16524"></a>
<FONT color="green">16525</FONT>        c = getSystemCurve(YLABEL_ID);<a name="line.16525"></a>
<FONT color="green">16526</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16526"></a>
<FONT color="green">16527</FONT>        c.getSymbol().setSymbolType(SymbolType.ANCHOR_WEST);<a name="line.16527"></a>
<FONT color="green">16528</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16528"></a>
<FONT color="green">16529</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16529"></a>
<FONT color="green">16530</FONT>        c.addPoint(Double.MAX_VALUE, Double.MAX_VALUE);<a name="line.16530"></a>
<FONT color="green">16531</FONT>        c.getPoint().setAnnotationLocation(AnnotationLocation.CENTER);<a name="line.16531"></a>
<FONT color="green">16532</FONT>    <a name="line.16532"></a>
<FONT color="green">16533</FONT>        c = getSystemCurve(Y2AXIS_ID);<a name="line.16533"></a>
<FONT color="green">16534</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16534"></a>
<FONT color="green">16535</FONT>        c.setYAxis(Y2_AXIS);<a name="line.16535"></a>
<FONT color="green">16536</FONT>        c.getSymbol().setSymbolType(SymbolType.XGRIDLINE);<a name="line.16536"></a>
<FONT color="green">16537</FONT>        c.getSymbol().setBackgroundColor(DEFAULT_GRID_COLOR);<a name="line.16537"></a>
<FONT color="green">16538</FONT>        c.getSymbol().setBorderColor(DEFAULT_GRID_COLOR);<a name="line.16538"></a>
<FONT color="green">16539</FONT>        c.getSymbol().setBorderStyle(GRID_BORDER_STYLE);<a name="line.16539"></a>
<FONT color="green">16540</FONT>        c.getSymbol().setBorderWidth(GRID_BORDER_WIDTH);<a name="line.16540"></a>
<FONT color="green">16541</FONT>        c.getSymbol().setWidth(DEFAULT_GRID_WIDTH);<a name="line.16541"></a>
<FONT color="green">16542</FONT>        c.getSymbol().setHeight(DEFAULT_GRID_HEIGHT);<a name="line.16542"></a>
<FONT color="green">16543</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16543"></a>
<FONT color="green">16544</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16544"></a>
<FONT color="green">16545</FONT>        c.addPoint(Double.MAX_VALUE, -Double.MAX_VALUE);<a name="line.16545"></a>
<FONT color="green">16546</FONT>    <a name="line.16546"></a>
<FONT color="green">16547</FONT>        c = getSystemCurve(Y2TICKS_ID);<a name="line.16547"></a>
<FONT color="green">16548</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16548"></a>
<FONT color="green">16549</FONT>        c.setYAxis(Y2_AXIS);<a name="line.16549"></a>
<FONT color="green">16550</FONT>        c.getSymbol().setSymbolType(SymbolType.BOX_EAST);<a name="line.16550"></a>
<FONT color="green">16551</FONT>        c.getSymbol().setBackgroundColor(DEFAULT_GRID_COLOR);<a name="line.16551"></a>
<FONT color="green">16552</FONT>        c.getSymbol().setBorderColor(DEFAULT_GRID_COLOR);<a name="line.16552"></a>
<FONT color="green">16553</FONT>        c.getSymbol().setBorderStyle(TICK_BORDER_STYLE);<a name="line.16553"></a>
<FONT color="green">16554</FONT>        c.getSymbol().setBorderWidth(TICK_BORDER_WIDTH);<a name="line.16554"></a>
<FONT color="green">16555</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16555"></a>
<FONT color="green">16556</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16556"></a>
<FONT color="green">16557</FONT>    <a name="line.16557"></a>
<FONT color="green">16558</FONT>        c = getSystemCurve(Y2GRIDLINES_ID);<a name="line.16558"></a>
<FONT color="green">16559</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16559"></a>
<FONT color="green">16560</FONT>        c.setYAxis(Y2_AXIS);<a name="line.16560"></a>
<FONT color="green">16561</FONT>        c.getSymbol().setSymbolType(SymbolType.YGRIDLINE);<a name="line.16561"></a>
<FONT color="green">16562</FONT>        c.getSymbol().setBackgroundColor(DEFAULT_GRID_COLOR);<a name="line.16562"></a>
<FONT color="green">16563</FONT>        c.getSymbol().setBorderColor(DEFAULT_GRID_COLOR);<a name="line.16563"></a>
<FONT color="green">16564</FONT>        c.getSymbol().setBorderStyle(GRID_BORDER_STYLE);<a name="line.16564"></a>
<FONT color="green">16565</FONT>        c.getSymbol().setBorderWidth(GRID_BORDER_WIDTH);<a name="line.16565"></a>
<FONT color="green">16566</FONT>        c.getSymbol().setWidth(DEFAULT_GRID_WIDTH);<a name="line.16566"></a>
<FONT color="green">16567</FONT>        c.getSymbol().setHeight(DEFAULT_GRID_HEIGHT);<a name="line.16567"></a>
<FONT color="green">16568</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16568"></a>
<FONT color="green">16569</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16569"></a>
<FONT color="green">16570</FONT>    <a name="line.16570"></a>
<FONT color="green">16571</FONT>        c = getSystemCurve(Y2LABEL_ID);<a name="line.16571"></a>
<FONT color="green">16572</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16572"></a>
<FONT color="green">16573</FONT>        c.getSymbol().setSymbolType(SymbolType.ANCHOR_EAST);<a name="line.16573"></a>
<FONT color="green">16574</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16574"></a>
<FONT color="green">16575</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16575"></a>
<FONT color="green">16576</FONT>        c.addPoint(Double.MAX_VALUE, Double.MAX_VALUE);<a name="line.16576"></a>
<FONT color="green">16577</FONT>        c.getPoint().setAnnotationLocation(AnnotationLocation.CENTER);<a name="line.16577"></a>
<FONT color="green">16578</FONT>    <a name="line.16578"></a>
<FONT color="green">16579</FONT>        c = getSystemCurve(LEGEND_ID);<a name="line.16579"></a>
<FONT color="green">16580</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16580"></a>
<FONT color="green">16581</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16581"></a>
<FONT color="green">16582</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16582"></a>
<FONT color="green">16583</FONT>        c.getSymbol().setSymbolType(SymbolType.ANCHOR_EAST);<a name="line.16583"></a>
<FONT color="green">16584</FONT>        c.addPoint(Double.MAX_VALUE, Double.MAX_VALUE);<a name="line.16584"></a>
<FONT color="green">16585</FONT>    <a name="line.16585"></a>
<FONT color="green">16586</FONT>        c = getSystemCurve(XAXIS_ID);<a name="line.16586"></a>
<FONT color="green">16587</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16587"></a>
<FONT color="green">16588</FONT>        c.getSymbol().setSymbolType(SymbolType.YGRIDLINE);<a name="line.16588"></a>
<FONT color="green">16589</FONT>        c.getSymbol().setBackgroundColor(DEFAULT_GRID_COLOR);<a name="line.16589"></a>
<FONT color="green">16590</FONT>        c.getSymbol().setBorderColor(DEFAULT_GRID_COLOR);<a name="line.16590"></a>
<FONT color="green">16591</FONT>        c.getSymbol().setBorderStyle(GRID_BORDER_STYLE);<a name="line.16591"></a>
<FONT color="green">16592</FONT>        c.getSymbol().setBorderWidth(GRID_BORDER_WIDTH);<a name="line.16592"></a>
<FONT color="green">16593</FONT>        c.getSymbol().setWidth(DEFAULT_GRID_WIDTH);<a name="line.16593"></a>
<FONT color="green">16594</FONT>        c.getSymbol().setHeight(DEFAULT_GRID_HEIGHT);<a name="line.16594"></a>
<FONT color="green">16595</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16595"></a>
<FONT color="green">16596</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16596"></a>
<FONT color="green">16597</FONT>        c.addPoint(-Double.MAX_VALUE, -Double.MAX_VALUE);<a name="line.16597"></a>
<FONT color="green">16598</FONT>    <a name="line.16598"></a>
<FONT color="green">16599</FONT>        // tick thickness and length get set in the axis constructors<a name="line.16599"></a>
<FONT color="green">16600</FONT>        c = getSystemCurve(XTICKS_ID);<a name="line.16600"></a>
<FONT color="green">16601</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16601"></a>
<FONT color="green">16602</FONT>        c.getSymbol().setSymbolType(SymbolType.BOX_SOUTH);<a name="line.16602"></a>
<FONT color="green">16603</FONT>        c.getSymbol().setBackgroundColor(DEFAULT_GRID_COLOR);<a name="line.16603"></a>
<FONT color="green">16604</FONT>        c.getSymbol().setBorderColor(DEFAULT_GRID_COLOR);<a name="line.16604"></a>
<FONT color="green">16605</FONT>        c.getSymbol().setBorderStyle(TICK_BORDER_STYLE);<a name="line.16605"></a>
<FONT color="green">16606</FONT>        c.getSymbol().setBorderWidth(TICK_BORDER_WIDTH);<a name="line.16606"></a>
<FONT color="green">16607</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16607"></a>
<FONT color="green">16608</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16608"></a>
<FONT color="green">16609</FONT>    <a name="line.16609"></a>
<FONT color="green">16610</FONT>        c = getSystemCurve(XGRIDLINES_ID);<a name="line.16610"></a>
<FONT color="green">16611</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16611"></a>
<FONT color="green">16612</FONT>        c.getSymbol().setSymbolType(SymbolType.XGRIDLINE);<a name="line.16612"></a>
<FONT color="green">16613</FONT>        c.getSymbol().setBackgroundColor(DEFAULT_GRID_COLOR);<a name="line.16613"></a>
<FONT color="green">16614</FONT>        c.getSymbol().setBorderColor(DEFAULT_GRID_COLOR);<a name="line.16614"></a>
<FONT color="green">16615</FONT>        c.getSymbol().setBorderStyle(GRID_BORDER_STYLE);<a name="line.16615"></a>
<FONT color="green">16616</FONT>        c.getSymbol().setBorderWidth(GRID_BORDER_WIDTH);<a name="line.16616"></a>
<FONT color="green">16617</FONT>        c.getSymbol().setWidth(DEFAULT_GRID_WIDTH);<a name="line.16617"></a>
<FONT color="green">16618</FONT>        c.getSymbol().setHeight(DEFAULT_GRID_HEIGHT);<a name="line.16618"></a>
<FONT color="green">16619</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16619"></a>
<FONT color="green">16620</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16620"></a>
<FONT color="green">16621</FONT>    <a name="line.16621"></a>
<FONT color="green">16622</FONT>        c = getSystemCurve(XLABEL_ID);<a name="line.16622"></a>
<FONT color="green">16623</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16623"></a>
<FONT color="green">16624</FONT>        c.getSymbol().setSymbolType(SymbolType.ANCHOR_SOUTH);<a name="line.16624"></a>
<FONT color="green">16625</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16625"></a>
<FONT color="green">16626</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16626"></a>
<FONT color="green">16627</FONT>        c.addPoint(Double.MAX_VALUE, Double.MAX_VALUE);<a name="line.16627"></a>
<FONT color="green">16628</FONT>        c.getPoint().setAnnotationLocation(AnnotationLocation.CENTER);<a name="line.16628"></a>
<FONT color="green">16629</FONT>    <a name="line.16629"></a>
<FONT color="green">16630</FONT>        c = getSystemCurve(FOOTNOTES_ID);<a name="line.16630"></a>
<FONT color="green">16631</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16631"></a>
<FONT color="green">16632</FONT>        c.getSymbol().setSymbolType(SymbolType.ANCHOR_SOUTHWEST);<a name="line.16632"></a>
<FONT color="green">16633</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16633"></a>
<FONT color="green">16634</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16634"></a>
<FONT color="green">16635</FONT>        c.addPoint(Double.MAX_VALUE, Double.MAX_VALUE);<a name="line.16635"></a>
<FONT color="green">16636</FONT>        c.getPoint().setAnnotationLocation(AnnotationLocation.CENTER);<a name="line.16636"></a>
<FONT color="green">16637</FONT>    <a name="line.16637"></a>
<FONT color="green">16638</FONT>        c = getSystemCurve(HOVER_ANNOTATION_ID);<a name="line.16638"></a>
<FONT color="green">16639</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16639"></a>
<FONT color="green">16640</FONT>        c.setVisible(false); // initially no hover annotation<a name="line.16640"></a>
<FONT color="green">16641</FONT>        c.getSymbol().setSymbolType(SymbolType.NONE);<a name="line.16641"></a>
<FONT color="green">16642</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16642"></a>
<FONT color="green">16643</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16643"></a>
<FONT color="green">16644</FONT>        c.addPoint(Double.NaN, Double.NaN); // off initially, set on-the-fly<a name="line.16644"></a>
<FONT color="green">16645</FONT>        c.getPoint().setAnnotationLocation(AnnotationLocation.CENTER);<a name="line.16645"></a>
<FONT color="green">16646</FONT>    <a name="line.16646"></a>
<FONT color="green">16647</FONT>        c = getSystemCurve(HOVER_CURSOR_ID);<a name="line.16647"></a>
<FONT color="green">16648</FONT>        c.setClipToPlotArea(Boolean.FALSE);<a name="line.16648"></a>
<FONT color="green">16649</FONT>        c.setVisible(false); // initially no hover selection<a name="line.16649"></a>
<FONT color="green">16650</FONT>        c.getSymbol().setSymbolType(SymbolType.NONE);<a name="line.16650"></a>
<FONT color="green">16651</FONT>        c.getSymbol().setHoverAnnotationEnabled(false);<a name="line.16651"></a>
<FONT color="green">16652</FONT>        c.getSymbol().setHoverSelectionEnabled(false);<a name="line.16652"></a>
<FONT color="green">16653</FONT>        c.addPoint(Double.NaN, Double.NaN);<a name="line.16653"></a>
<FONT color="green">16654</FONT>        c.getPoint().setAnnotationLocation(AnnotationLocation.CENTER);<a name="line.16654"></a>
<FONT color="green">16655</FONT>    <a name="line.16655"></a>
<FONT color="green">16656</FONT>        // external "curve count" should now be 0 (system curves don't count)<a name="line.16656"></a>
<FONT color="green">16657</FONT>        if (getNCurves() != 0)<a name="line.16657"></a>
<FONT color="green">16658</FONT>          throw new IllegalStateException(<a name="line.16658"></a>
<FONT color="green">16659</FONT>              "getNCurves() != 0. Probably a GChart bug.");<a name="line.16659"></a>
<FONT color="green">16660</FONT>    <a name="line.16660"></a>
<FONT color="green">16661</FONT>      }<a name="line.16661"></a>
<FONT color="green">16662</FONT>    <a name="line.16662"></a>
<FONT color="green">16663</FONT>      /*<a name="line.16663"></a>
<FONT color="green">16664</FONT>       * Updates the system curves that represent chart decorations (axis labels,<a name="line.16664"></a>
<FONT color="green">16665</FONT>       * title, ticks, etc.).&lt;p&gt;<a name="line.16665"></a>
<FONT color="green">16666</FONT>       * <a name="line.16666"></a>
<FONT color="green">16667</FONT>       * Note that all x, y shifts are relative to the "anchoring" symbol type<a name="line.16667"></a>
<FONT color="green">16668</FONT>       * locations defined once and for all in the addSystemCurves method above.<a name="line.16668"></a>
<FONT color="green">16669</FONT>       */<a name="line.16669"></a>
<FONT color="green">16670</FONT>      private void updateDecorations(int xChartSizeDecorated) {<a name="line.16670"></a>
<FONT color="green">16671</FONT>    <a name="line.16671"></a>
<FONT color="green">16672</FONT>        // x-axis label<a name="line.16672"></a>
<FONT color="green">16673</FONT>        Curve.Point p = getSystemCurve(XLABEL_ID).getPoint(0);<a name="line.16673"></a>
<FONT color="green">16674</FONT>        p.setAnnotationWidget(getXAxis().getAxisLabel(), getXChartSize(),<a name="line.16674"></a>
<FONT color="green">16675</FONT>            getXAxis().getAxisLabelThickness());<a name="line.16675"></a>
<FONT color="green">16676</FONT>        p.setAnnotationYShift(-getXAxis().getTickLabelThickness(false)<a name="line.16676"></a>
<FONT color="green">16677</FONT>            - getXAxis().getTickSpace() - getXAxis().getTickLabelPadding()<a name="line.16677"></a>
<FONT color="green">16678</FONT>            - getXAxis().getAxisLabelThickness() / 2);<a name="line.16678"></a>
<FONT color="green">16679</FONT>    <a name="line.16679"></a>
<FONT color="green">16680</FONT>        // y-axis label<a name="line.16680"></a>
<FONT color="green">16681</FONT>        p = getSystemCurve(YLABEL_ID).getPoint(0);<a name="line.16681"></a>
<FONT color="green">16682</FONT>        p.setAnnotationWidget(getYAxis().getAxisLabel(), getYAxis()<a name="line.16682"></a>
<FONT color="green">16683</FONT>            .getAxisLabelThickness(), getYChartSize());<a name="line.16683"></a>
<FONT color="green">16684</FONT>        p.setAnnotationXShift(-getYAxis().getTickLabelThickness(false)<a name="line.16684"></a>
<FONT color="green">16685</FONT>            - getYAxis().getTickSpace() - getYAxis().getTickLabelPadding()<a name="line.16685"></a>
<FONT color="green">16686</FONT>            - getYAxis().getAxisLabelThickness() / 2);<a name="line.16686"></a>
<FONT color="green">16687</FONT>    <a name="line.16687"></a>
<FONT color="green">16688</FONT>        // y2-axis label<a name="line.16688"></a>
<FONT color="green">16689</FONT>        p = getSystemCurve(Y2LABEL_ID).getPoint(0);<a name="line.16689"></a>
<FONT color="green">16690</FONT>        p.setAnnotationWidget(getY2Axis().getAxisLabel(), getY2Axis()<a name="line.16690"></a>
<FONT color="green">16691</FONT>            .getAxisLabelThickness(), getYChartSize());<a name="line.16691"></a>
<FONT color="green">16692</FONT>        p.setAnnotationXShift(+getY2Axis().getTickLabelThickness(false)<a name="line.16692"></a>
<FONT color="green">16693</FONT>            + getY2Axis().getTickSpace()<a name="line.16693"></a>
<FONT color="green">16694</FONT>            + getY2Axis().getTickLabelPadding()<a name="line.16694"></a>
<FONT color="green">16695</FONT>            + getY2Axis().getAxisLabelThickness() / 2);<a name="line.16695"></a>
<FONT color="green">16696</FONT>    <a name="line.16696"></a>
<FONT color="green">16697</FONT>        // legend<a name="line.16697"></a>
<FONT color="green">16698</FONT>    <a name="line.16698"></a>
<FONT color="green">16699</FONT>        Curve c = getSystemCurve(LEGEND_ID);<a name="line.16699"></a>
<FONT color="green">16700</FONT>        p = c.getPoint(0);<a name="line.16700"></a>
<FONT color="green">16701</FONT>        if (null == legend<a name="line.16701"></a>
<FONT color="green">16702</FONT>            &amp;&amp; (!isLegendVisible() || 0 == getNVisibleCurvesOnLegend())) {<a name="line.16702"></a>
<FONT color="green">16703</FONT>          p.setAnnotationWidget(null);<a name="line.16703"></a>
<FONT color="green">16704</FONT>        } else {<a name="line.16704"></a>
<FONT color="green">16705</FONT>          c.getSymbol().setSymbolType(legendLocation.getSymbolType());<a name="line.16705"></a>
<FONT color="green">16706</FONT>          Widget theLegend = (null == legend) ? createLegend(plotPanel)<a name="line.16706"></a>
<FONT color="green">16707</FONT>              : legend;<a name="line.16707"></a>
<FONT color="green">16708</FONT>          p.setAnnotationWidget(theLegend, getLegendThickness(),<a name="line.16708"></a>
<FONT color="green">16709</FONT>              getYChartSize());<a name="line.16709"></a>
<FONT color="green">16710</FONT>          p.setAnnotationLocation(legendLocation.getAnnotationLocation());<a name="line.16710"></a>
<FONT color="green">16711</FONT>          p.setAnnotationXShift(legendLocation.getInitialXShift(this)<a name="line.16711"></a>
<FONT color="green">16712</FONT>              + legendXShift);<a name="line.16712"></a>
<FONT color="green">16713</FONT>          p.setAnnotationYShift(legendLocation.getInitialYShift(this)<a name="line.16713"></a>
<FONT color="green">16714</FONT>                                + legendYShift);<a name="line.16714"></a>
<FONT color="green">16715</FONT>          // GChart generated legends set font-family at a lower level. But,<a name="line.16715"></a>
<FONT color="green">16716</FONT>          // if user supplied their own legend, this line causes any legend<a name="line.16716"></a>
<FONT color="green">16717</FONT>          // font-family to be inherited (to the extent CSS cascade allows that)<a name="line.16717"></a>
<FONT color="green">16718</FONT>          p.setAnnotationFontFamily(getLegendFontFamily());<a name="line.16718"></a>
<FONT color="green">16719</FONT>        }<a name="line.16719"></a>
<FONT color="green">16720</FONT>        // title<a name="line.16720"></a>
<FONT color="green">16721</FONT>        int shiftToLeftEdge = -getYAxis().getAxisLabelThickness()<a name="line.16721"></a>
<FONT color="green">16722</FONT>            - getYAxis().getTickLabelThickness(false)<a name="line.16722"></a>
<FONT color="green">16723</FONT>            - getYAxis().getTickSpace() - getYAxis().getTickLabelPadding();<a name="line.16723"></a>
<FONT color="green">16724</FONT>        int shiftToHorizontalMidpoint = shiftToLeftEdge + xChartSizeDecorated<a name="line.16724"></a>
<FONT color="green">16725</FONT>            / 2;<a name="line.16725"></a>
<FONT color="green">16726</FONT>        p = getSystemCurve(TITLE_ID).getPoint(0);<a name="line.16726"></a>
<FONT color="green">16727</FONT>        p.setAnnotationWidget(getChartTitle(), xChartSizeDecorated,<a name="line.16727"></a>
<FONT color="green">16728</FONT>            getChartTitleThickness());<a name="line.16728"></a>
<FONT color="green">16729</FONT>        p.setAnnotationYShift(getChartTitleThickness() / 2);<a name="line.16729"></a>
<FONT color="green">16730</FONT>        p.setAnnotationXShift(shiftToHorizontalMidpoint);<a name="line.16730"></a>
<FONT color="green">16731</FONT>    <a name="line.16731"></a>
<FONT color="green">16732</FONT>        // footnotes<a name="line.16732"></a>
<FONT color="green">16733</FONT>        p = getSystemCurve(FOOTNOTES_ID).getPoint(0);<a name="line.16733"></a>
<FONT color="green">16734</FONT>        p.setAnnotationWidget(getChartFootnotes(), xChartSizeDecorated,<a name="line.16734"></a>
<FONT color="green">16735</FONT>            getChartFootnotesThickness());<a name="line.16735"></a>
<FONT color="green">16736</FONT>        p.setAnnotationYShift(-getXAxis().getTickLabelThickness(false)<a name="line.16736"></a>
<FONT color="green">16737</FONT>            - getXAxis().getTickSpace() - getXAxis().getTickLabelPadding()<a name="line.16737"></a>
<FONT color="green">16738</FONT>            - getXAxis().getAxisLabelThickness()<a name="line.16738"></a>
<FONT color="green">16739</FONT>            - getChartFootnotesThickness() / 2);<a name="line.16739"></a>
<FONT color="green">16740</FONT>        if (getChartFootnotesLeftJustified()) {<a name="line.16740"></a>
<FONT color="green">16741</FONT>          p.setAnnotationXShift(shiftToLeftEdge);<a name="line.16741"></a>
<FONT color="green">16742</FONT>          p.setAnnotationLocation(AnnotationLocation.EAST);<a name="line.16742"></a>
<FONT color="green">16743</FONT>        } else { // footnotes centered<a name="line.16743"></a>
<FONT color="green">16744</FONT>          p.setAnnotationXShift(shiftToHorizontalMidpoint);<a name="line.16744"></a>
<FONT color="green">16745</FONT>          p.setAnnotationLocation(AnnotationLocation.CENTER);<a name="line.16745"></a>
<FONT color="green">16746</FONT>        }<a name="line.16746"></a>
<FONT color="green">16747</FONT>    <a name="line.16747"></a>
<FONT color="green">16748</FONT>        // add points to ticks and gridlines curves in accord with chart specs<a name="line.16748"></a>
<FONT color="green">16749</FONT>    <a name="line.16749"></a>
<FONT color="green">16750</FONT>        // x &amp; y axis can be present even if no curves mapped to them<a name="line.16750"></a>
<FONT color="green">16751</FONT>        getSystemCurve(XAXIS_ID).setVisible(getXAxis().getAxisVisible());<a name="line.16751"></a>
<FONT color="green">16752</FONT>        getXAxis().populateGridlines();<a name="line.16752"></a>
<FONT color="green">16753</FONT>        getSystemCurve(YAXIS_ID).setVisible(getYAxis().getAxisVisible());<a name="line.16753"></a>
<FONT color="green">16754</FONT>        getYAxis().populateGridlines();<a name="line.16754"></a>
<FONT color="green">16755</FONT>    <a name="line.16755"></a>
<FONT color="green">16756</FONT>        // y2 axis is present only if at least 1 curve is on it.<a name="line.16756"></a>
<FONT color="green">16757</FONT>        if (hasY2Axis()) {<a name="line.16757"></a>
<FONT color="green">16758</FONT>          getY2Axis().populateGridlines();<a name="line.16758"></a>
<FONT color="green">16759</FONT>          getSystemCurve(Y2AXIS_ID).setVisible(getY2Axis().getAxisVisible());<a name="line.16759"></a>
<FONT color="green">16760</FONT>          getSystemCurve(Y2TICKS_ID).setVisible(true);<a name="line.16760"></a>
<FONT color="green">16761</FONT>          getSystemCurve(Y2GRIDLINES_ID).setVisible(true);<a name="line.16761"></a>
<FONT color="green">16762</FONT>        } else {<a name="line.16762"></a>
<FONT color="green">16763</FONT>          getSystemCurve(Y2AXIS_ID).setVisible(false);<a name="line.16763"></a>
<FONT color="green">16764</FONT>          getSystemCurve(Y2TICKS_ID).setVisible(false);<a name="line.16764"></a>
<FONT color="green">16765</FONT>          getSystemCurve(Y2GRIDLINES_ID).setVisible(false);<a name="line.16765"></a>
<FONT color="green">16766</FONT>        }<a name="line.16766"></a>
<FONT color="green">16767</FONT>    <a name="line.16767"></a>
<FONT color="green">16768</FONT>      }<a name="line.16768"></a>
<FONT color="green">16769</FONT>    <a name="line.16769"></a>
<FONT color="green">16770</FONT>      /**<a name="line.16770"></a>
<FONT color="green">16771</FONT>       * Instantiates a GChart with a curve display region of the specified size.<a name="line.16771"></a>
<FONT color="green">16772</FONT>       * <a name="line.16772"></a>
<FONT color="green">16773</FONT>       * <a name="line.16773"></a>
<FONT color="green">16774</FONT>       * @param xChartSize<a name="line.16774"></a>
<FONT color="green">16775</FONT>       *          the width of the curve display region, in pixels.<a name="line.16775"></a>
<FONT color="green">16776</FONT>       * @param yChartSize<a name="line.16776"></a>
<FONT color="green">16777</FONT>       *          the height of the curve display region, in pixels.<a name="line.16777"></a>
<FONT color="green">16778</FONT>       * <a name="line.16778"></a>
<FONT color="green">16779</FONT>       * @see #setXChartSize setXChartSize<a name="line.16779"></a>
<FONT color="green">16780</FONT>       * @see #setYChartSize setYChartSize<a name="line.16780"></a>
<FONT color="green">16781</FONT>       * @see #setChartSize setChartSize<a name="line.16781"></a>
<FONT color="green">16782</FONT>       */<a name="line.16782"></a>
<FONT color="green">16783</FONT>      public GChart(int xChartSize, int yChartSize) {<a name="line.16783"></a>
<FONT color="green">16784</FONT>        super();<a name="line.16784"></a>
<FONT color="green">16785</FONT>        addSystemCurves(); // must come first: later lines use system curves<a name="line.16785"></a>
<FONT color="green">16786</FONT>        xAxis = new XAxis();<a name="line.16786"></a>
<FONT color="green">16787</FONT>        yAxis = new YAxis();<a name="line.16787"></a>
<FONT color="green">16788</FONT>        y2Axis = new Y2Axis();<a name="line.16788"></a>
<FONT color="green">16789</FONT>        setXChartSize(xChartSize);<a name="line.16789"></a>
<FONT color="green">16790</FONT>        setYChartSize(yChartSize);<a name="line.16790"></a>
<FONT color="green">16791</FONT>        // Note: plotPanel (where real chart resides) won't get<a name="line.16791"></a>
<FONT color="green">16792</FONT>        // added to chartPanel (top-level do-nothing container for<a name="line.16792"></a>
<FONT color="green">16793</FONT>        // padding and such) until AFTER first update; FF2 has some<a name="line.16793"></a>
<FONT color="green">16794</FONT>        // serious performance problems otherwise for common usage<a name="line.16794"></a>
<FONT color="green">16795</FONT>        // scenarios with large widget-count pages.<a name="line.16795"></a>
<FONT color="green">16796</FONT>        initWidget(chartPanel);<a name="line.16796"></a>
<FONT color="green">16797</FONT>        /*<a name="line.16797"></a>
<FONT color="green">16798</FONT>         * See the block comment at top of "class GChart" for a detailed<a name="line.16798"></a>
<FONT color="green">16799</FONT>         * discussion/rational for GChart's (very minimal support) of stylenames.<a name="line.16799"></a>
<FONT color="green">16800</FONT>         * Would like deeper support if I can ever figure out how to do it without<a name="line.16800"></a>
<FONT color="green">16801</FONT>         * hamstringing future versions by locking them into a particular<a name="line.16801"></a>
<FONT color="green">16802</FONT>         * implementation I might need to change later on. In particular, I don't<a name="line.16802"></a>
<FONT color="green">16803</FONT>         * know how to provide such "deep" stylenames that also work consistently<a name="line.16803"></a>
<FONT color="green">16804</FONT>         * with canvas-rendered curves.<a name="line.16804"></a>
<FONT color="green">16805</FONT>         */<a name="line.16805"></a>
<FONT color="green">16806</FONT>        setStyleName("gchart-GChart");<a name="line.16806"></a>
<FONT color="green">16807</FONT>      }<a name="line.16807"></a>
<FONT color="green">16808</FONT>    <a name="line.16808"></a>
<FONT color="green">16809</FONT>      /**<a name="line.16809"></a>
<FONT color="green">16810</FONT>       * Convenience no-arg constructor equivalent to<a name="line.16810"></a>
<FONT color="green">16811</FONT>       * &lt;tt&gt;GChart(DEFAULT_X_CHARTSIZE,DEFAULT_Y_CHARTSIZE)&lt;/tt&gt;.<a name="line.16811"></a>
<FONT color="green">16812</FONT>       * <a name="line.16812"></a>
<FONT color="green">16813</FONT>       * @see #GChart(int,int) GChart(int,int)<a name="line.16813"></a>
<FONT color="green">16814</FONT>       * <a name="line.16814"></a>
<FONT color="green">16815</FONT>       */<a name="line.16815"></a>
<FONT color="green">16816</FONT>      public GChart() {<a name="line.16816"></a>
<FONT color="green">16817</FONT>        this(DEFAULT_X_CHARTSIZE, DEFAULT_Y_CHARTSIZE);<a name="line.16817"></a>
<FONT color="green">16818</FONT>      }<a name="line.16818"></a>
<FONT color="green">16819</FONT>    <a name="line.16819"></a>
<FONT color="green">16820</FONT>      /**<a name="line.16820"></a>
<FONT color="green">16821</FONT>       * <a name="line.16821"></a>
<FONT color="green">16822</FONT>       * Adds an object to handle click events on this chart, that is, an object<a name="line.16822"></a>
<FONT color="green">16823</FONT>       * whose &lt;tt&gt;ClickHandler.onClick&lt;/tt&gt; method will be called whenever the user<a name="line.16823"></a>
<FONT color="green">16824</FONT>       * clicks on this chart.<a name="line.16824"></a>
<FONT color="green">16825</FONT>       * <a name="line.16825"></a>
<FONT color="green">16826</FONT>       * &lt;p&gt;<a name="line.16826"></a>
<FONT color="green">16827</FONT>       * <a name="line.16827"></a>
<FONT color="green">16828</FONT>       * When implementing a class that handles GChart click events, you'll need to<a name="line.16828"></a>
<FONT color="green">16829</FONT>       * know the following facts:<a name="line.16829"></a>
<FONT color="green">16830</FONT>       * &lt;p&gt;<a name="line.16830"></a>
<FONT color="green">16831</FONT>       * <a name="line.16831"></a>
<FONT color="green">16832</FONT>       * &lt;ol&gt;<a name="line.16832"></a>
<FONT color="green">16833</FONT>       * <a name="line.16833"></a>
<FONT color="green">16834</FONT>       * &lt;li&gt;You can use the &lt;tt&gt;getSource&lt;/tt&gt; method of the &lt;tt&gt;ClickEvent&lt;/tt&gt;<a name="line.16834"></a>
<FONT color="green">16835</FONT>       * passed into your &lt;tt&gt;onClick&lt;/tt&gt; handler to retrieve the &lt;tt&gt;GChart&lt;/tt&gt;<a name="line.16835"></a>
<FONT color="green">16836</FONT>       * that was clicked on. For example:<a name="line.16836"></a>
<FONT color="green">16837</FONT>       * &lt;p&gt;<a name="line.16837"></a>
<FONT color="green">16838</FONT>       * <a name="line.16838"></a>
<FONT color="green">16839</FONT>       * &lt;pre&gt;<a name="line.16839"></a>
<FONT color="green">16840</FONT>       * // Deletes the clicked-on curve<a name="line.16840"></a>
<FONT color="green">16841</FONT>       * public void onClick(ClickEvent event) {<a name="line.16841"></a>
<FONT color="green">16842</FONT>       *   GChart theGChart = (GChart) event.getSource();<a name="line.16842"></a>
<FONT color="green">16843</FONT>       *   GChart.Curve c = theGChart.getTouchedCurve();<a name="line.16843"></a>
<FONT color="green">16844</FONT>       *   if (null != c) {<a name="line.16844"></a>
<FONT color="green">16845</FONT>       *     theGChart.removeCurve(c);<a name="line.16845"></a>
<FONT color="green">16846</FONT>       *     // what you see in browser won't change without an update <a name="line.16846"></a>
<FONT color="green">16847</FONT>       *     theGChart.update();<a name="line.16847"></a>
<FONT color="green">16848</FONT>       *   }<a name="line.16848"></a>
<FONT color="green">16849</FONT>       * }<a name="line.16849"></a>
<FONT color="green">16850</FONT>       * &lt;/pre&gt;<a name="line.16850"></a>
<FONT color="green">16851</FONT>       * <a name="line.16851"></a>
<FONT color="green">16852</FONT>       * &lt;p&gt;<a name="line.16852"></a>
<FONT color="green">16853</FONT>       * <a name="line.16853"></a>
<FONT color="green">16854</FONT>       * &lt;li&gt;The &lt;tt&gt;GChart&lt;/tt&gt; methods &lt;tt&gt;getTouchedPoint&lt;/tt&gt; and<a name="line.16854"></a>
<FONT color="green">16855</FONT>       * &lt;tt&gt;getTouchedCurve&lt;/tt&gt; return either the point and curve that were<a name="line.16855"></a>
<FONT color="green">16856</FONT>       * clicked on, or &lt;tt&gt;null&lt;/tt&gt; if the click didn't "touch" any points.<a name="line.16856"></a>
<FONT color="green">16857</FONT>       * <a name="line.16857"></a>
<FONT color="green">16858</FONT>       * &lt;p&gt;<a name="line.16858"></a>
<FONT color="green">16859</FONT>       * <a name="line.16859"></a>
<FONT color="green">16860</FONT>       *&lt;/ol&gt;<a name="line.16860"></a>
<FONT color="green">16861</FONT>       * &lt;p&gt;<a name="line.16861"></a>
<FONT color="green">16862</FONT>       * <a name="line.16862"></a>
<FONT color="green">16863</FONT>       * The editable pie chart example on the GChart &lt;a<a name="line.16863"></a>
<FONT color="green">16864</FONT>       * href="http://clientsidegchart.googlecode.com/svn/trunk/live-demo/v2_7/com.googlecode.gchart.gchartdemoapp.GChartDemoApp/GChartDemoApp.html"&gt; live demo page&lt;/a&gt; illustrates how to use this method to launch a popup<a name="line.16864"></a>
<FONT color="green">16865</FONT>       * modal &lt;tt&gt;DialogBox&lt;/tt&gt; whenever the user clicks on a point, and how to<a name="line.16865"></a>
<FONT color="green">16866</FONT>       * change the selected point from within that dialog by using GChart's<a name="line.16866"></a>
<FONT color="green">16867</FONT>       * &lt;tt&gt;touch&lt;/tt&gt; method.<a name="line.16867"></a>
<FONT color="green">16868</FONT>       * &lt;p&gt;<a name="line.16868"></a>
<FONT color="green">16869</FONT>       * <a name="line.16869"></a>
<FONT color="green">16870</FONT>       * For a much simpler example that lets the user delete points by clicking on<a name="line.16870"></a>
<FONT color="green">16871</FONT>       * them, see the Chart Gallery's &lt;a<a name="line.16871"></a>
<FONT color="green">16872</FONT>       * href="package-summary.html#GChartExample18a"&gt; GChartExample18a&lt;/a&gt;.<a name="line.16872"></a>
<FONT color="green">16873</FONT>       * &lt;p&gt;<a name="line.16873"></a>
<FONT color="green">16874</FONT>       * <a name="line.16874"></a>
<FONT color="green">16875</FONT>       * @param handler<a name="line.16875"></a>
<FONT color="green">16876</FONT>       *          the click handler that will handle click events on this chart.<a name="line.16876"></a>
<FONT color="green">16877</FONT>       * <a name="line.16877"></a>
<FONT color="green">16878</FONT>       * @return the handler's registration object. You need to retain a reference<a name="line.16878"></a>
<FONT color="green">16879</FONT>       *         to this registration object only if you may later need to remove<a name="line.16879"></a>
<FONT color="green">16880</FONT>       *         the handler (via the registration's &lt;tt&gt;removeHandler&lt;/tt&gt; method).<a name="line.16880"></a>
<FONT color="green">16881</FONT>       *         Most applications don't remove handlers (handlers tend to be<a name="line.16881"></a>
<FONT color="green">16882</FONT>       *         statically defined) and so can ignore the value returned from this<a name="line.16882"></a>
<FONT color="green">16883</FONT>       *         method.<a name="line.16883"></a>
<FONT color="green">16884</FONT>       * <a name="line.16884"></a>
<FONT color="green">16885</FONT>       * @see #getTouchedPoint getTouchedPoint<a name="line.16885"></a>
<FONT color="green">16886</FONT>       * @see #getTouchedCurve getTouchedCurve<a name="line.16886"></a>
<FONT color="green">16887</FONT>       * @see #touch touch<a name="line.16887"></a>
<FONT color="green">16888</FONT>       * @see #isUpdateNeeded isUpdateNeeded<a name="line.16888"></a>
<FONT color="green">16889</FONT>       */<a name="line.16889"></a>
<FONT color="green">16890</FONT>    <a name="line.16890"></a>
<FONT color="green">16891</FONT>      public HandlerRegistration addClickHandler(ClickHandler handler) {<a name="line.16891"></a>
<FONT color="green">16892</FONT>        HandlerRegistration result = addDomHandler(handler, ClickEvent.getType());<a name="line.16892"></a>
<FONT color="green">16893</FONT>        return result;<a name="line.16893"></a>
<FONT color="green">16894</FONT>      }<a name="line.16894"></a>
<FONT color="green">16895</FONT>    <a name="line.16895"></a>
<FONT color="green">16896</FONT>      /**<a name="line.16896"></a>
<FONT color="green">16897</FONT>       * Adds a &lt;tt&gt;DoubleClickEvent&lt;/tt&gt; handler.<a name="line.16897"></a>
<FONT color="green">16898</FONT>       * &lt;p&gt;<a name="line.16898"></a>
<FONT color="green">16899</FONT>       * <a name="line.16899"></a>
<FONT color="green">16900</FONT>       * See &lt;tt&gt;addClickHandler&lt;/tt&gt; for GChart-specific information you will need<a name="line.16900"></a>
<FONT color="green">16901</FONT>       * to properly handle the event.<a name="line.16901"></a>
<FONT color="green">16902</FONT>       * &lt;p&gt;<a name="line.16902"></a>
<FONT color="green">16903</FONT>       * <a name="line.16903"></a>
<FONT color="green">16904</FONT>       * @param handler<a name="line.16904"></a>
<FONT color="green">16905</FONT>       *          the double click handler<a name="line.16905"></a>
<FONT color="green">16906</FONT>       * @return HandlerRegistration used to remove this handler<a name="line.16906"></a>
<FONT color="green">16907</FONT>       * <a name="line.16907"></a>
<FONT color="green">16908</FONT>       * @see #addClickHandler addClickHandler<a name="line.16908"></a>
<FONT color="green">16909</FONT>       * <a name="line.16909"></a>
<FONT color="green">16910</FONT>       */<a name="line.16910"></a>
<FONT color="green">16911</FONT>      public HandlerRegistration addDoubleClickHandler(DoubleClickHandler handler) {<a name="line.16911"></a>
<FONT color="green">16912</FONT>        HandlerRegistration result = addDomHandler(handler, DoubleClickEvent.getType());<a name="line.16912"></a>
<FONT color="green">16913</FONT>        return result;<a name="line.16913"></a>
<FONT color="green">16914</FONT>      }<a name="line.16914"></a>
<FONT color="green">16915</FONT>    <a name="line.16915"></a>
<FONT color="green">16916</FONT>      /**<a name="line.16916"></a>
<FONT color="green">16917</FONT>       * Adds a &lt;tt&gt;MouseDownEvent&lt;/tt&gt; handler.<a name="line.16917"></a>
<FONT color="green">16918</FONT>       * &lt;p&gt;<a name="line.16918"></a>
<FONT color="green">16919</FONT>       * <a name="line.16919"></a>
<FONT color="green">16920</FONT>       * See &lt;tt&gt;addClickHandler&lt;/tt&gt; for GChart-specific information you will need<a name="line.16920"></a>
<FONT color="green">16921</FONT>       * to properly handle the event.<a name="line.16921"></a>
<FONT color="green">16922</FONT>       * &lt;p&gt;<a name="line.16922"></a>
<FONT color="green">16923</FONT>       * <a name="line.16923"></a>
<FONT color="green">16924</FONT>       * @param handler<a name="line.16924"></a>
<FONT color="green">16925</FONT>       *          the mouse down handler<a name="line.16925"></a>
<FONT color="green">16926</FONT>       * @return HandlerRegistration used to remove this handler<a name="line.16926"></a>
<FONT color="green">16927</FONT>       * <a name="line.16927"></a>
<FONT color="green">16928</FONT>       * @see #addClickHandler addClickHandler<a name="line.16928"></a>
<FONT color="green">16929</FONT>       * <a name="line.16929"></a>
<FONT color="green">16930</FONT>       */<a name="line.16930"></a>
<FONT color="green">16931</FONT>      public HandlerRegistration addMouseDownHandler(MouseDownHandler handler) {<a name="line.16931"></a>
<FONT color="green">16932</FONT>        HandlerRegistration result = addDomHandler(handler, MouseDownEvent.getType());<a name="line.16932"></a>
<FONT color="green">16933</FONT>        return result;<a name="line.16933"></a>
<FONT color="green">16934</FONT>      }<a name="line.16934"></a>
<FONT color="green">16935</FONT>    <a name="line.16935"></a>
<FONT color="green">16936</FONT>      /**<a name="line.16936"></a>
<FONT color="green">16937</FONT>       * Adds a &lt;tt&gt;MouseMoveEvent&lt;/tt&gt; handler.<a name="line.16937"></a>
<FONT color="green">16938</FONT>       * &lt;p&gt;<a name="line.16938"></a>
<FONT color="green">16939</FONT>       * <a name="line.16939"></a>
<FONT color="green">16940</FONT>       * See &lt;tt&gt;addClickHandler&lt;/tt&gt; for GChart-specific information you will need<a name="line.16940"></a>
<FONT color="green">16941</FONT>       * to properly handle the event.<a name="line.16941"></a>
<FONT color="green">16942</FONT>       * &lt;p&gt;<a name="line.16942"></a>
<FONT color="green">16943</FONT>       * <a name="line.16943"></a>
<FONT color="green">16944</FONT>       * @param handler<a name="line.16944"></a>
<FONT color="green">16945</FONT>       *          the mouse move handler<a name="line.16945"></a>
<FONT color="green">16946</FONT>       * @return HandlerRegistration used to remove this handler<a name="line.16946"></a>
<FONT color="green">16947</FONT>       * <a name="line.16947"></a>
<FONT color="green">16948</FONT>       * @see #addClickHandler addClickHandler<a name="line.16948"></a>
<FONT color="green">16949</FONT>       * <a name="line.16949"></a>
<FONT color="green">16950</FONT>       */<a name="line.16950"></a>
<FONT color="green">16951</FONT>      public HandlerRegistration addMouseMoveHandler(MouseMoveHandler handler) {<a name="line.16951"></a>
<FONT color="green">16952</FONT>        HandlerRegistration result = addDomHandler(handler, MouseMoveEvent.getType());<a name="line.16952"></a>
<FONT color="green">16953</FONT>        return result;<a name="line.16953"></a>
<FONT color="green">16954</FONT>      }<a name="line.16954"></a>
<FONT color="green">16955</FONT>    <a name="line.16955"></a>
<FONT color="green">16956</FONT>      /**<a name="line.16956"></a>
<FONT color="green">16957</FONT>       * Adds a &lt;tt&gt;MouseOutEvent&lt;/tt&gt; handler.<a name="line.16957"></a>
<FONT color="green">16958</FONT>       * &lt;p&gt;<a name="line.16958"></a>
<FONT color="green">16959</FONT>       * <a name="line.16959"></a>
<FONT color="green">16960</FONT>       * See &lt;tt&gt;addClickHandler&lt;/tt&gt; for GChart-specific information you will need<a name="line.16960"></a>
<FONT color="green">16961</FONT>       * to properly handle the event.<a name="line.16961"></a>
<FONT color="green">16962</FONT>       * &lt;p&gt;<a name="line.16962"></a>
<FONT color="green">16963</FONT>       * <a name="line.16963"></a>
<FONT color="green">16964</FONT>       * @param handler<a name="line.16964"></a>
<FONT color="green">16965</FONT>       *          the mouse out handler<a name="line.16965"></a>
<FONT color="green">16966</FONT>       * @return HandlerRegistration used to remove this handler<a name="line.16966"></a>
<FONT color="green">16967</FONT>       * <a name="line.16967"></a>
<FONT color="green">16968</FONT>       * @see #addClickHandler addClickHandler<a name="line.16968"></a>
<FONT color="green">16969</FONT>       * <a name="line.16969"></a>
<FONT color="green">16970</FONT>       */<a name="line.16970"></a>
<FONT color="green">16971</FONT>      public HandlerRegistration addMouseOutHandler(MouseOutHandler handler) {<a name="line.16971"></a>
<FONT color="green">16972</FONT>        HandlerRegistration result = addDomHandler(handler, MouseOutEvent.getType());<a name="line.16972"></a>
<FONT color="green">16973</FONT>        return result;<a name="line.16973"></a>
<FONT color="green">16974</FONT>      }<a name="line.16974"></a>
<FONT color="green">16975</FONT>    <a name="line.16975"></a>
<FONT color="green">16976</FONT>      /**<a name="line.16976"></a>
<FONT color="green">16977</FONT>       * Adds a &lt;tt&gt;MouseOverEvent&lt;/tt&gt; handler.<a name="line.16977"></a>
<FONT color="green">16978</FONT>       * &lt;p&gt;<a name="line.16978"></a>
<FONT color="green">16979</FONT>       * <a name="line.16979"></a>
<FONT color="green">16980</FONT>       * See &lt;tt&gt;addClickHandler&lt;/tt&gt; for GChart-specific information you will need<a name="line.16980"></a>
<FONT color="green">16981</FONT>       * to properly handle the event.<a name="line.16981"></a>
<FONT color="green">16982</FONT>       * &lt;p&gt;<a name="line.16982"></a>
<FONT color="green">16983</FONT>       * <a name="line.16983"></a>
<FONT color="green">16984</FONT>       * @param handler<a name="line.16984"></a>
<FONT color="green">16985</FONT>       *          the mouse over handler<a name="line.16985"></a>
<FONT color="green">16986</FONT>       * @return HandlerRegistration used to remove this handler<a name="line.16986"></a>
<FONT color="green">16987</FONT>       * <a name="line.16987"></a>
<FONT color="green">16988</FONT>       * @see #addClickHandler addClickHandler<a name="line.16988"></a>
<FONT color="green">16989</FONT>       * <a name="line.16989"></a>
<FONT color="green">16990</FONT>       */<a name="line.16990"></a>
<FONT color="green">16991</FONT>      public HandlerRegistration addMouseOverHandler(MouseOverHandler handler) {<a name="line.16991"></a>
<FONT color="green">16992</FONT>        HandlerRegistration result = addDomHandler(handler, MouseOverEvent.getType());<a name="line.16992"></a>
<FONT color="green">16993</FONT>        return result;<a name="line.16993"></a>
<FONT color="green">16994</FONT>      }<a name="line.16994"></a>
<FONT color="green">16995</FONT>    <a name="line.16995"></a>
<FONT color="green">16996</FONT>      /**<a name="line.16996"></a>
<FONT color="green">16997</FONT>       * Adds a &lt;tt&gt;MouseUpEvent&lt;/tt&gt; handler.<a name="line.16997"></a>
<FONT color="green">16998</FONT>       * &lt;p&gt;<a name="line.16998"></a>
<FONT color="green">16999</FONT>       * <a name="line.16999"></a>
<FONT color="green">17000</FONT>       * See &lt;tt&gt;addClickHandler&lt;/tt&gt; for GChart-specific information you will need<a name="line.17000"></a>
<FONT color="green">17001</FONT>       * to properly handle the event.<a name="line.17001"></a>
<FONT color="green">17002</FONT>       * &lt;p&gt;<a name="line.17002"></a>
<FONT color="green">17003</FONT>       * <a name="line.17003"></a>
<FONT color="green">17004</FONT>       * @param handler<a name="line.17004"></a>
<FONT color="green">17005</FONT>       *          the mouse up handler<a name="line.17005"></a>
<FONT color="green">17006</FONT>       * @return HandlerRegistration used to remove this handler<a name="line.17006"></a>
<FONT color="green">17007</FONT>       * <a name="line.17007"></a>
<FONT color="green">17008</FONT>       * @see #addClickHandler addClickHandler<a name="line.17008"></a>
<FONT color="green">17009</FONT>       * <a name="line.17009"></a>
<FONT color="green">17010</FONT>       */<a name="line.17010"></a>
<FONT color="green">17011</FONT>      public HandlerRegistration addMouseUpHandler(MouseUpHandler handler) {<a name="line.17011"></a>
<FONT color="green">17012</FONT>        HandlerRegistration result = addDomHandler(handler, MouseUpEvent.getType());<a name="line.17012"></a>
<FONT color="green">17013</FONT>        return result;<a name="line.17013"></a>
<FONT color="green">17014</FONT>      }<a name="line.17014"></a>
<FONT color="green">17015</FONT>    <a name="line.17015"></a>
<FONT color="green">17016</FONT>      /**<a name="line.17016"></a>
<FONT color="green">17017</FONT>       * Adds a &lt;tt&gt;MouseWheelEvent&lt;/tt&gt; handler.<a name="line.17017"></a>
<FONT color="green">17018</FONT>       * &lt;p&gt;<a name="line.17018"></a>
<FONT color="green">17019</FONT>       * <a name="line.17019"></a>
<FONT color="green">17020</FONT>       * See &lt;tt&gt;addClickHandler&lt;/tt&gt; for GChart-specific information you will need<a name="line.17020"></a>
<FONT color="green">17021</FONT>       * to properly handle the event.<a name="line.17021"></a>
<FONT color="green">17022</FONT>       * &lt;p&gt;<a name="line.17022"></a>
<FONT color="green">17023</FONT>       * <a name="line.17023"></a>
<FONT color="green">17024</FONT>       * @param handler<a name="line.17024"></a>
<FONT color="green">17025</FONT>       *          the mouse wheel handler<a name="line.17025"></a>
<FONT color="green">17026</FONT>       * @return HandlerRegistration used to remove this handler<a name="line.17026"></a>
<FONT color="green">17027</FONT>       * <a name="line.17027"></a>
<FONT color="green">17028</FONT>       * @see #addClickHandler addClickHandler<a name="line.17028"></a>
<FONT color="green">17029</FONT>       * <a name="line.17029"></a>
<FONT color="green">17030</FONT>       */<a name="line.17030"></a>
<FONT color="green">17031</FONT>      public HandlerRegistration addMouseWheelHandler(MouseWheelHandler handler) {<a name="line.17031"></a>
<FONT color="green">17032</FONT>        HandlerRegistration result = addDomHandler(handler, MouseWheelEvent.getType());<a name="line.17032"></a>
<FONT color="green">17033</FONT>        return result;<a name="line.17033"></a>
<FONT color="green">17034</FONT>      }<a name="line.17034"></a>
<FONT color="green">17035</FONT>    <a name="line.17035"></a>
<FONT color="green">17036</FONT>      /**<a name="line.17036"></a>
<FONT color="green">17037</FONT>       * Adds a new curve to the chart, at the end of the current list of curves.<a name="line.17037"></a>
<FONT color="green">17038</FONT>       * &lt;p&gt;<a name="line.17038"></a>
<FONT color="green">17039</FONT>       * <a name="line.17039"></a>
<FONT color="green">17040</FONT>       * @see #getCurve getCurve<a name="line.17040"></a>
<FONT color="green">17041</FONT>       * @see #addCurve(int) addCurve(int)<a name="line.17041"></a>
<FONT color="green">17042</FONT>       * @see #removeCurve removeCurve<a name="line.17042"></a>
<FONT color="green">17043</FONT>       * @see #clearCurves clearCurves<a name="line.17043"></a>
<FONT color="green">17044</FONT>       * @see #getNCurves getNCurves<a name="line.17044"></a>
<FONT color="green">17045</FONT>       */<a name="line.17045"></a>
<FONT color="green">17046</FONT>    <a name="line.17046"></a>
<FONT color="green">17047</FONT>      public void addCurve() {<a name="line.17047"></a>
<FONT color="green">17048</FONT>        addCurve(getNCurves());<a name="line.17048"></a>
<FONT color="green">17049</FONT>      }<a name="line.17049"></a>
<FONT color="green">17050</FONT>    <a name="line.17050"></a>
<FONT color="green">17051</FONT>      /*<a name="line.17051"></a>
<FONT color="green">17052</FONT>       * Given external, coded, index returns a curve's ArrayList index<a name="line.17052"></a>
<FONT color="green">17053</FONT>       * <a name="line.17053"></a>
<FONT color="green">17054</FONT>       * Basic order within the curves array is as follows:<a name="line.17054"></a>
<FONT color="green">17055</FONT>       * <a name="line.17055"></a>
<FONT color="green">17056</FONT>       * o quite a few decorative curves that hold axis ticks, title, etc.<a name="line.17056"></a>
<FONT color="green">17057</FONT>       * o "getNCurves()" user-created/accessible curves<a name="line.17057"></a>
<FONT color="green">17058</FONT>       * o 1 "Pop-up" hover annotation holding curve<a name="line.17058"></a>
<FONT color="green">17059</FONT>       * o 1 Selection cursor holding curve<a name="line.17059"></a>
<FONT color="green">17060</FONT>       * <a name="line.17060"></a>
<FONT color="green">17061</FONT>       * It's very important that the last two system curves come last, to<a name="line.17061"></a>
<FONT color="green">17062</FONT>       * ensure these elements are always on top of all other chart<a name="line.17062"></a>
<FONT color="green">17063</FONT>       * elements, as required. &lt;p&gt;<a name="line.17063"></a>
<FONT color="green">17064</FONT>       * <a name="line.17064"></a>
<FONT color="green">17065</FONT>       * The "external" system curve indexes are in a continuous range of negative<a name="line.17065"></a>
<FONT color="green">17066</FONT>       * integers, which are mapped into the ArrayList positions given above via this<a name="line.17066"></a>
<FONT color="green">17067</FONT>       * method.<a name="line.17067"></a>
<FONT color="green">17068</FONT>       */<a name="line.17068"></a>
<FONT color="green">17069</FONT>      int internalCurveIndex(int externalIndex) {<a name="line.17069"></a>
<FONT color="green">17070</FONT>        int result;<a name="line.17070"></a>
<FONT color="green">17071</FONT>        if (GChart.NAI == externalIndex)<a name="line.17071"></a>
<FONT color="green">17072</FONT>          // -1 is the "no such curve" index used by an ArrayList<a name="line.17072"></a>
<FONT color="green">17073</FONT>          result = -1;<a name="line.17073"></a>
<FONT color="green">17074</FONT>        else if (externalIndex &lt; -N_POST_SYSTEM_CURVES)<a name="line.17074"></a>
<FONT color="green">17075</FONT>          // decoration related sys curves (before user's)<a name="line.17075"></a>
<FONT color="green">17076</FONT>          result = externalIndex + N_SYSTEM_CURVES;<a name="line.17076"></a>
<FONT color="green">17077</FONT>        else if (externalIndex &lt; 0)<a name="line.17077"></a>
<FONT color="green">17078</FONT>          // hover feedback related, after user curves (at the end)<a name="line.17078"></a>
<FONT color="green">17079</FONT>          result = curves.size() + externalIndex;<a name="line.17079"></a>
<FONT color="green">17080</FONT>        else<a name="line.17080"></a>
<FONT color="green">17081</FONT>          // + indexes mapped to ordinary user-created curves<a name="line.17081"></a>
<FONT color="green">17082</FONT>          result = externalIndex + N_PRE_SYSTEM_CURVES;<a name="line.17082"></a>
<FONT color="green">17083</FONT>        return result;<a name="line.17083"></a>
<FONT color="green">17084</FONT>      }<a name="line.17084"></a>
<FONT color="green">17085</FONT>    <a name="line.17085"></a>
<FONT color="green">17086</FONT>      /*<a name="line.17086"></a>
<FONT color="green">17087</FONT>       * Given a curves ArrayList index returns external, coded, index<a name="line.17087"></a>
<FONT color="green">17088</FONT>       * <a name="line.17088"></a>
<FONT color="green">17089</FONT>       * Companion/inverse of preceeding method.<a name="line.17089"></a>
<FONT color="green">17090</FONT>       */<a name="line.17090"></a>
<FONT color="green">17091</FONT>      int externalCurveIndex(int internalIndex) {<a name="line.17091"></a>
<FONT color="green">17092</FONT>        int result;<a name="line.17092"></a>
<FONT color="green">17093</FONT>        if (internalIndex &lt; 0)<a name="line.17093"></a>
<FONT color="green">17094</FONT>          result = GChart.NAI;<a name="line.17094"></a>
<FONT color="green">17095</FONT>        else if (internalIndex &lt; N_PRE_SYSTEM_CURVES)<a name="line.17095"></a>
<FONT color="green">17096</FONT>          // one of the sys curves that comes before user's curves<a name="line.17096"></a>
<FONT color="green">17097</FONT>          result = internalIndex - N_SYSTEM_CURVES;<a name="line.17097"></a>
<FONT color="green">17098</FONT>        else if (internalIndex &gt;= curves.size() - N_POST_SYSTEM_CURVES)<a name="line.17098"></a>
<FONT color="green">17099</FONT>          // sys curves, like hover feedback, that come after user's<a name="line.17099"></a>
<FONT color="green">17100</FONT>          result = internalIndex - curves.size();<a name="line.17100"></a>
<FONT color="green">17101</FONT>        else<a name="line.17101"></a>
<FONT color="green">17102</FONT>          // ordinary user created curve<a name="line.17102"></a>
<FONT color="green">17103</FONT>          result = internalIndex - N_PRE_SYSTEM_CURVES;<a name="line.17103"></a>
<FONT color="green">17104</FONT>        return result;<a name="line.17104"></a>
<FONT color="green">17105</FONT>      }<a name="line.17105"></a>
<FONT color="green">17106</FONT>    <a name="line.17106"></a>
<FONT color="green">17107</FONT>      // does the external curve index represent a GChart-sys-defined curve?<a name="line.17107"></a>
<FONT color="green">17108</FONT>      private boolean isSystemCurveIndex(int externalIndex) {<a name="line.17108"></a>
<FONT color="green">17109</FONT>        boolean result = externalIndex &lt; 0;<a name="line.17109"></a>
<FONT color="green">17110</FONT>        return result;<a name="line.17110"></a>
<FONT color="green">17111</FONT>      }<a name="line.17111"></a>
<FONT color="green">17112</FONT>    <a name="line.17112"></a>
<FONT color="green">17113</FONT>      /**<a name="line.17113"></a>
<FONT color="green">17114</FONT>       * Adds a new curve to the chart, at the specified position in the curve<a name="line.17114"></a>
<FONT color="green">17115</FONT>       * sequence. Existing curves at postions at or greater than the specified<a name="line.17115"></a>
<FONT color="green">17116</FONT>       * position have their positional indexes increased by 1.<a name="line.17116"></a>
<FONT color="green">17117</FONT>       * &lt;p&gt;<a name="line.17117"></a>
<FONT color="green">17118</FONT>       * <a name="line.17118"></a>
<FONT color="green">17119</FONT>       * @see #getCurve getCurve<a name="line.17119"></a>
<FONT color="green">17120</FONT>       * @see #addCurve() addCurve()<a name="line.17120"></a>
<FONT color="green">17121</FONT>       * @see #removeCurve removeCurve<a name="line.17121"></a>
<FONT color="green">17122</FONT>       * @see #clearCurves clearCurves<a name="line.17122"></a>
<FONT color="green">17123</FONT>       * @see #getNCurves getNCurves<a name="line.17123"></a>
<FONT color="green">17124</FONT>       */<a name="line.17124"></a>
<FONT color="green">17125</FONT>    <a name="line.17125"></a>
<FONT color="green">17126</FONT>      public void addCurve(int iCurve) {<a name="line.17126"></a>
<FONT color="green">17127</FONT>        if (iCurve &gt; getNCurves())<a name="line.17127"></a>
<FONT color="green">17128</FONT>          throw new IllegalArgumentException("iCurve = " + iCurve<a name="line.17128"></a>
<FONT color="green">17129</FONT>              + "; iCurve may not exceed getNCurves() (" + getNCurves()<a name="line.17129"></a>
<FONT color="green">17130</FONT>              + ")");<a name="line.17130"></a>
<FONT color="green">17131</FONT>        else if (iCurve &lt; 0)<a name="line.17131"></a>
<FONT color="green">17132</FONT>          throw new IllegalArgumentException("iCurve = " + iCurve<a name="line.17132"></a>
<FONT color="green">17133</FONT>              + "; iCurve may not be negative.");<a name="line.17133"></a>
<FONT color="green">17134</FONT>        int internalIndex = internalCurveIndex(iCurve);<a name="line.17134"></a>
<FONT color="green">17135</FONT>        Curve c = new Curve(internalIndex);<a name="line.17135"></a>
<FONT color="green">17136</FONT>        curves.add(internalIndex, c);<a name="line.17136"></a>
<FONT color="green">17137</FONT>        // curves are initially added to the x, y axes.<a name="line.17137"></a>
<FONT color="green">17138</FONT>        getXAxis().incrementCurves();<a name="line.17138"></a>
<FONT color="green">17139</FONT>        getYAxis().incrementCurves();<a name="line.17139"></a>
<FONT color="green">17140</FONT>        // adjust ArrayList indexes to account for newly added element<a name="line.17140"></a>
<FONT color="green">17141</FONT>        for (int i = internalIndex + 1; i &lt; curves.size(); i++)<a name="line.17141"></a>
<FONT color="green">17142</FONT>          curves.get(i).incrementIndex();<a name="line.17142"></a>
<FONT color="green">17143</FONT>        if (0 != plotPanel.getRenderingPanelCount()) { // other panels are already there<a name="line.17143"></a>
<FONT color="green">17144</FONT>          int rpIndex = getRenderingPanelIndex(internalIndex);<a name="line.17144"></a>
<FONT color="green">17145</FONT>          plotPanel.addGraphicsRenderingPanel(rpIndex);<a name="line.17145"></a>
<FONT color="green">17146</FONT>          plotPanel.addAnnotationRenderingPanel(rpIndex);<a name="line.17146"></a>
<FONT color="green">17147</FONT>        }<a name="line.17147"></a>
<FONT color="green">17148</FONT>        // otherwise, before 1st update: lazy-add panels when they're 1st used<a name="line.17148"></a>
<FONT color="green">17149</FONT>        c.invalidate();<a name="line.17149"></a>
<FONT color="green">17150</FONT>        if (getNCurves() &gt; 0)<a name="line.17150"></a>
<FONT color="green">17151</FONT>          setDefaultBorderColor(c, getNCurves() - 1);<a name="line.17151"></a>
<FONT color="green">17152</FONT>    <a name="line.17152"></a>
<FONT color="green">17153</FONT>      }<a name="line.17153"></a>
<FONT color="green">17154</FONT>    <a name="line.17154"></a>
<FONT color="green">17155</FONT>      /**<a name="line.17155"></a>
<FONT color="green">17156</FONT>       * Removes every curve this chart contains.<a name="line.17156"></a>
<FONT color="green">17157</FONT>       * <a name="line.17157"></a>
<FONT color="green">17158</FONT>       * @see #getCurve getCurve<a name="line.17158"></a>
<FONT color="green">17159</FONT>       * @see #addCurve() addCurve()<a name="line.17159"></a>
<FONT color="green">17160</FONT>       * @see #addCurve(int) addCurve(int)<a name="line.17160"></a>
<FONT color="green">17161</FONT>       * @see #removeCurve removeCurve<a name="line.17161"></a>
<FONT color="green">17162</FONT>       * @see #getNCurves getNCurves<a name="line.17162"></a>
<FONT color="green">17163</FONT>       */<a name="line.17163"></a>
<FONT color="green">17164</FONT>      public void clearCurves() {<a name="line.17164"></a>
<FONT color="green">17165</FONT>        for (int iCurve = getNCurves() - 1; iCurve &gt;= 0; iCurve--)<a name="line.17165"></a>
<FONT color="green">17166</FONT>          removeCurve(iCurve);<a name="line.17166"></a>
<FONT color="green">17167</FONT>      }<a name="line.17167"></a>
<FONT color="green">17168</FONT>    <a name="line.17168"></a>
<FONT color="green">17169</FONT>      /**<a name="line.17169"></a>
<FONT color="green">17170</FONT>       * Convenience method that, given a plain text label, returns an HTML snippet<a name="line.17170"></a>
<FONT color="green">17171</FONT>       * appropriate for use as an argument to the &lt;tt&gt;setHovertextTemplate&lt;/tt&gt; or<a name="line.17171"></a>
<FONT color="green">17172</FONT>       * &lt;tt&gt;setAnnotationText&lt;/tt&gt; methods, that will display the plain text label<a name="line.17172"></a>
<FONT color="green">17173</FONT>       * with formatting appropriate for use with hovertext.<a name="line.17173"></a>
<FONT color="green">17174</FONT>       * &lt;p&gt;<a name="line.17174"></a>
<FONT color="green">17175</FONT>       * <a name="line.17175"></a>
<FONT color="green">17176</FONT>       * <a name="line.17176"></a>
<FONT color="green">17177</FONT>       * When the string returned from this method is used as an argument to<a name="line.17177"></a>
<FONT color="green">17178</FONT>       * &lt;tt&gt;setHovertextTemplate&lt;/tt&gt;, the hovertext that is generated is similar<a name="line.17178"></a>
<FONT color="green">17179</FONT>       * in format (light yellow background, black 1px border) to what is produced<a name="line.17179"></a>
<FONT color="green">17180</FONT>       * via the &lt;tt&gt;setTitle&lt;/tt&gt; method (standard browser element hovertext).<a name="line.17180"></a>
<FONT color="green">17181</FONT>       * &lt;p&gt;<a name="line.17181"></a>
<FONT color="green">17182</FONT>       * <a name="line.17182"></a>
<FONT color="green">17183</FONT>       * In detail, this method creates the returned string via the line:<a name="line.17183"></a>
<FONT color="green">17184</FONT>       * &lt;p&gt;<a name="line.17184"></a>
<FONT color="green">17185</FONT>       * <a name="line.17185"></a>
<FONT color="green">17186</FONT>       * &lt;pre&gt;<a name="line.17186"></a>
<FONT color="green">17187</FONT>       * result = &amp;quot;&amp;lt;html&amp;gt;&amp;lt;div style='background-color:#FFFFF0; border-color:black; border-style:solid; border-width:1px; padding:2px'&amp;gt;&amp;quot;<a name="line.17187"></a>
<FONT color="green">17188</FONT>       *     + plainTextLabel + &amp;quot;&amp;lt;/div&amp;gt;&amp;quot;;<a name="line.17188"></a>
<FONT color="green">17189</FONT>       * &lt;/pre&gt;<a name="line.17189"></a>
<FONT color="green">17190</FONT>       * <a name="line.17190"></a>
<FONT color="green">17191</FONT>       * &lt;p&gt;<a name="line.17191"></a>
<FONT color="green">17192</FONT>       * This method is provided mainly to simplify transitioning from the old hover<a name="line.17192"></a>
<FONT color="green">17193</FONT>       * feedback system to the new one introduced in v2.4.<a name="line.17193"></a>
<FONT color="green">17194</FONT>       * &lt;p&gt;<a name="line.17194"></a>
<FONT color="green">17195</FONT>       * <a name="line.17195"></a>
<FONT color="green">17196</FONT>       * It is expected that many pre v2.4 GChart applications will find that simply<a name="line.17196"></a>
<FONT color="green">17197</FONT>       * wrapping a &lt;tt&gt;formatAsHovertext&lt;/tt&gt; call around existing hovertext<a name="line.17197"></a>
<FONT color="green">17198</FONT>       * templates will provide acceptable (though somewhat different) hover<a name="line.17198"></a>
<FONT color="green">17199</FONT>       * feedback for existing charts:<a name="line.17199"></a>
<FONT color="green">17200</FONT>       * <a name="line.17200"></a>
<FONT color="green">17201</FONT>       * &lt;pre&gt;<a name="line.17201"></a>
<FONT color="green">17202</FONT>       * getCurve().getSymbol().setHovertextTemplate(<a name="line.17202"></a>
<FONT color="green">17203</FONT>       *     GChart.formatAsHovertext(&amp;quot;(x,y) = (${x}, ${y})&amp;quot;));<a name="line.17203"></a>
<FONT color="green">17204</FONT>       * &lt;/pre&gt;<a name="line.17204"></a>
<FONT color="green">17205</FONT>       * &lt;p&gt;<a name="line.17205"></a>
<FONT color="green">17206</FONT>       * <a name="line.17206"></a>
<FONT color="green">17207</FONT>       * Note that GChart v2.4 automatically includes such a wrapping<a name="line.17207"></a>
<FONT color="green">17208</FONT>       * &lt;tt&gt;formatAsHovertext&lt;/tt&gt; call on all default hovertext templates.<a name="line.17208"></a>
<FONT color="green">17209</FONT>       * <a name="line.17209"></a>
<FONT color="green">17210</FONT>       * &lt;p&gt;<a name="line.17210"></a>
<FONT color="green">17211</FONT>       * <a name="line.17211"></a>
<FONT color="green">17212</FONT>       * See the {@link Symbol#setHoverAnnotationSymbolType<a name="line.17212"></a>
<FONT color="green">17213</FONT>       * setHoverAnnotationSymbolType} method for a code snippet that emulates not<a name="line.17213"></a>
<FONT color="green">17214</FONT>       * just the formatting, but also the at-the-mouse positioning behaviour, of<a name="line.17214"></a>
<FONT color="green">17215</FONT>       * setTitle-based hovertext.<a name="line.17215"></a>
<FONT color="green">17216</FONT>       * <a name="line.17216"></a>
<FONT color="green">17217</FONT>       * &lt;p&gt;<a name="line.17217"></a>
<FONT color="green">17218</FONT>       * <a name="line.17218"></a>
<FONT color="green">17219</FONT>       * <a name="line.17219"></a>
<FONT color="green">17220</FONT>       * @see Symbol#setHovertextTemplate setHovertextTemplate<a name="line.17220"></a>
<FONT color="green">17221</FONT>       * @see Curve.Point#setAnnotationText setAnnotationText<a name="line.17221"></a>
<FONT color="green">17222</FONT>       * @see Symbol#setHoverAnnotationSymbolType setHoverAnnotationSymbolType<a name="line.17222"></a>
<FONT color="green">17223</FONT>       * <a name="line.17223"></a>
<FONT color="green">17224</FONT>       * @param plainTextLabel<a name="line.17224"></a>
<FONT color="green">17225</FONT>       *          the plain text label that is to be HTML-wrapped to make it look<a name="line.17225"></a>
<FONT color="green">17226</FONT>       *          like &lt;tt&gt;setTitle&lt;/tt&gt;-based hovertext.<a name="line.17226"></a>
<FONT color="green">17227</FONT>       * <a name="line.17227"></a>
<FONT color="green">17228</FONT>       * <a name="line.17228"></a>
<FONT color="green">17229</FONT>       */<a name="line.17229"></a>
<FONT color="green">17230</FONT>    <a name="line.17230"></a>
<FONT color="green">17231</FONT>      public static String formatAsHovertext(String plainTextLabel) {<a name="line.17231"></a>
<FONT color="green">17232</FONT>        String result = "&lt;html&gt;&lt;div style='background-color:#FFFFF0; border-color:black; border-style:solid; border-width:1px 1px 1px 1px; padding:2px; text-align:left'&gt;"<a name="line.17232"></a>
<FONT color="green">17233</FONT>            + plainTextLabel + "&lt;/div&gt;";<a name="line.17233"></a>
<FONT color="green">17234</FONT>        return result;<a name="line.17234"></a>
<FONT color="green">17235</FONT>      }<a name="line.17235"></a>
<FONT color="green">17236</FONT>    <a name="line.17236"></a>
<FONT color="green">17237</FONT>      /**<a name="line.17237"></a>
<FONT color="green">17238</FONT>       * Returns the background color of the chart as a whole.<a name="line.17238"></a>
<FONT color="green">17239</FONT>       * <a name="line.17239"></a>
<FONT color="green">17240</FONT>       * @return the chart's background color, in a standard CSS color string<a name="line.17240"></a>
<FONT color="green">17241</FONT>       *         format.<a name="line.17241"></a>
<FONT color="green">17242</FONT>       * <a name="line.17242"></a>
<FONT color="green">17243</FONT>       * @see #setBackgroundColor(String) setBackgroundColor<a name="line.17243"></a>
<FONT color="green">17244</FONT>       * <a name="line.17244"></a>
<FONT color="green">17245</FONT>       */<a name="line.17245"></a>
<FONT color="green">17246</FONT>      public String getBackgroundColor() {<a name="line.17246"></a>
<FONT color="green">17247</FONT>        return (backgroundColor);<a name="line.17247"></a>
<FONT color="green">17248</FONT>      }<a name="line.17248"></a>
<FONT color="green">17249</FONT>    <a name="line.17249"></a>
<FONT color="green">17250</FONT>      /**<a name="line.17250"></a>
<FONT color="green">17251</FONT>       * Returns the color of the border around the chart as a whole.<a name="line.17251"></a>
<FONT color="green">17252</FONT>       * <a name="line.17252"></a>
<FONT color="green">17253</FONT>       * @return the color of the chart's border, in a standard CSS color string<a name="line.17253"></a>
<FONT color="green">17254</FONT>       *         format.<a name="line.17254"></a>
<FONT color="green">17255</FONT>       * <a name="line.17255"></a>
<FONT color="green">17256</FONT>       * @see #setBorderColor(String) setBorderColor<a name="line.17256"></a>
<FONT color="green">17257</FONT>       * <a name="line.17257"></a>
<FONT color="green">17258</FONT>       */<a name="line.17258"></a>
<FONT color="green">17259</FONT>      public String getBorderColor() {<a name="line.17259"></a>
<FONT color="green">17260</FONT>        return borderColor;<a name="line.17260"></a>
<FONT color="green">17261</FONT>      }<a name="line.17261"></a>
<FONT color="green">17262</FONT>    <a name="line.17262"></a>
<FONT color="green">17263</FONT>      /**<a name="line.17263"></a>
<FONT color="green">17264</FONT>       * Returns the width of the border around the chart as a whole<a name="line.17264"></a>
<FONT color="green">17265</FONT>       * <a name="line.17265"></a>
<FONT color="green">17266</FONT>       * @return width of the border around the chart as a whole, as a CSS border<a name="line.17266"></a>
<FONT color="green">17267</FONT>       *         width specification string (e.g. "1px").<a name="line.17267"></a>
<FONT color="green">17268</FONT>       * <a name="line.17268"></a>
<FONT color="green">17269</FONT>       * @see #setBorderWidth(String) setBorderWidth<a name="line.17269"></a>
<FONT color="green">17270</FONT>       * <a name="line.17270"></a>
<FONT color="green">17271</FONT>       */<a name="line.17271"></a>
<FONT color="green">17272</FONT>      public String getBorderWidth() {<a name="line.17272"></a>
<FONT color="green">17273</FONT>        return borderWidth;<a name="line.17273"></a>
<FONT color="green">17274</FONT>      }<a name="line.17274"></a>
<FONT color="green">17275</FONT>    <a name="line.17275"></a>
<FONT color="green">17276</FONT>      /**<a name="line.17276"></a>
<FONT color="green">17277</FONT>       * Returns the style of the border around the chart as a whole<a name="line.17277"></a>
<FONT color="green">17278</FONT>       * <a name="line.17278"></a>
<FONT color="green">17279</FONT>       * @return cssStyle for the border around the chart as a whole<a name="line.17279"></a>
<FONT color="green">17280</FONT>       * <a name="line.17280"></a>
<FONT color="green">17281</FONT>       * @see #setBorderStyle(String) setBorderStyle<a name="line.17281"></a>
<FONT color="green">17282</FONT>       * <a name="line.17282"></a>
<FONT color="green">17283</FONT>       */<a name="line.17283"></a>
<FONT color="green">17284</FONT>      public String getBorderStyle() {<a name="line.17284"></a>
<FONT color="green">17285</FONT>        return borderStyle;<a name="line.17285"></a>
<FONT color="green">17286</FONT>      }<a name="line.17286"></a>
<FONT color="green">17287</FONT>    <a name="line.17287"></a>
<FONT color="green">17288</FONT>      /**<a name="line.17288"></a>
<FONT color="green">17289</FONT>       * Returns the previously specified chart footnotes widget.<a name="line.17289"></a>
<FONT color="green">17290</FONT>       * <a name="line.17290"></a>
<FONT color="green">17291</FONT>       * @return widget representing chart's footnotes or &lt;tt&gt;null&lt;/tt&gt; if none.<a name="line.17291"></a>
<FONT color="green">17292</FONT>       * <a name="line.17292"></a>
<FONT color="green">17293</FONT>       * @see #setChartFootnotes(Widget) setChartFootnotes(Widget)<a name="line.17293"></a>
<FONT color="green">17294</FONT>       * @see #setChartFootnotes(String) setChartFootnotes(String)<a name="line.17294"></a>
<FONT color="green">17295</FONT>       * @see #getChartTitle getChartTitle<a name="line.17295"></a>
<FONT color="green">17296</FONT>       */<a name="line.17296"></a>
<FONT color="green">17297</FONT>      public Widget getChartFootnotes() {<a name="line.17297"></a>
<FONT color="green">17298</FONT>        return chartFootnotes;<a name="line.17298"></a>
<FONT color="green">17299</FONT>      }<a name="line.17299"></a>
<FONT color="green">17300</FONT>    <a name="line.17300"></a>
<FONT color="green">17301</FONT>      /**<a name="line.17301"></a>
<FONT color="green">17302</FONT>       * Returns flag indicating if this chart's footnotes are left-justified or<a name="line.17302"></a>
<FONT color="green">17303</FONT>       * centered.<a name="line.17303"></a>
<FONT color="green">17304</FONT>       * <a name="line.17304"></a>
<FONT color="green">17305</FONT>       * @return true if footnotes are flush against the left edge of the chart,<a name="line.17305"></a>
<FONT color="green">17306</FONT>       *         false if they are horizontally centered across the bottom edge of<a name="line.17306"></a>
<FONT color="green">17307</FONT>       *         the chart.<a name="line.17307"></a>
<FONT color="green">17308</FONT>       * <a name="line.17308"></a>
<FONT color="green">17309</FONT>       * @see #setChartFootnotesLeftJustified setChartFootnotesLeftJustified<a name="line.17309"></a>
<FONT color="green">17310</FONT>       * @see #setChartFootnotes(String) setChartFootnotes(String)<a name="line.17310"></a>
<FONT color="green">17311</FONT>       * @see #setChartTitle setChartTitle<a name="line.17311"></a>
<FONT color="green">17312</FONT>       */<a name="line.17312"></a>
<FONT color="green">17313</FONT>      public boolean getChartFootnotesLeftJustified() {<a name="line.17313"></a>
<FONT color="green">17314</FONT>        return chartFootnotesLeftJustified;<a name="line.17314"></a>
<FONT color="green">17315</FONT>      }<a name="line.17315"></a>
<FONT color="green">17316</FONT>    <a name="line.17316"></a>
<FONT color="green">17317</FONT>      /**<a name="line.17317"></a>
<FONT color="green">17318</FONT>       * Returns the thickness (height) of the rectangular region at the bottom of<a name="line.17318"></a>
<FONT color="green">17319</FONT>       * the chart allocated for footnotes.<a name="line.17319"></a>
<FONT color="green">17320</FONT>       * &lt;p&gt;<a name="line.17320"></a>
<FONT color="green">17321</FONT>       * <a name="line.17321"></a>
<FONT color="green">17322</FONT>       * The width of this region always equals the width of the entire GChart<a name="line.17322"></a>
<FONT color="green">17323</FONT>       * (including legend and axis labels).<a name="line.17323"></a>
<FONT color="green">17324</FONT>       * &lt;p&gt;<a name="line.17324"></a>
<FONT color="green">17325</FONT>       * <a name="line.17325"></a>
<FONT color="green">17326</FONT>       * Your footnotes widget is always vertically centered in this region.<a name="line.17326"></a>
<FONT color="green">17327</FONT>       * &lt;p&gt;<a name="line.17327"></a>
<FONT color="green">17328</FONT>       * <a name="line.17328"></a>
<FONT color="green">17329</FONT>       * <a name="line.17329"></a>
<FONT color="green">17330</FONT>       * Your footnotes widget will either be horizontally centered in this region,<a name="line.17330"></a>
<FONT color="green">17331</FONT>       * or left justified in it, depending on the property defined by the<a name="line.17331"></a>
<FONT color="green">17332</FONT>       * &lt;tt&gt;setChartFootnotesLeftJustified&lt;/tt&gt; method.<a name="line.17332"></a>
<FONT color="green">17333</FONT>       * <a name="line.17333"></a>
<FONT color="green">17334</FONT>       * &lt;p&gt;<a name="line.17334"></a>
<FONT color="green">17335</FONT>       * <a name="line.17335"></a>
<FONT color="green">17336</FONT>       * <a name="line.17336"></a>
<FONT color="green">17337</FONT>       * This method always returns 0 if the footnotes widget is &lt;tt&gt;null&lt;/tt&gt; (the<a name="line.17337"></a>
<FONT color="green">17338</FONT>       * default); the rectangular footnotes region is entirely eliminated in that<a name="line.17338"></a>
<FONT color="green">17339</FONT>       * case.<a name="line.17339"></a>
<FONT color="green">17340</FONT>       * &lt;p&gt;<a name="line.17340"></a>
<FONT color="green">17341</FONT>       * <a name="line.17341"></a>
<FONT color="green">17342</FONT>       * @return the thickness (height) of the rectangular region at the bottom of<a name="line.17342"></a>
<FONT color="green">17343</FONT>       *         the chart allocated for footnotes, in pixels.<a name="line.17343"></a>
<FONT color="green">17344</FONT>       * <a name="line.17344"></a>
<FONT color="green">17345</FONT>       * @see #setChartFootnotesThickness(int) setChartFootnotesThickness<a name="line.17345"></a>
<FONT color="green">17346</FONT>       * @see #setChartFootnotesLeftJustified setChartFootnotesLeftJustified<a name="line.17346"></a>
<FONT color="green">17347</FONT>       */<a name="line.17347"></a>
<FONT color="green">17348</FONT>      public int getChartFootnotesThickness() {<a name="line.17348"></a>
<FONT color="green">17349</FONT>        int result = 0;<a name="line.17349"></a>
<FONT color="green">17350</FONT>        final int EXTRA_HEIGHT = 3; // 1.5 lines padding above/below<a name="line.17350"></a>
<FONT color="green">17351</FONT>        final int DEF_HEIGHT = 1;<a name="line.17351"></a>
<FONT color="green">17352</FONT>        if (null == getChartFootnotes())<a name="line.17352"></a>
<FONT color="green">17353</FONT>          result = 0;<a name="line.17353"></a>
<FONT color="green">17354</FONT>        else if (GChart.NAI != footnotesThickness)<a name="line.17354"></a>
<FONT color="green">17355</FONT>          result = footnotesThickness;<a name="line.17355"></a>
<FONT color="green">17356</FONT>        else if (getChartFootnotes() instanceof HasHTML)<a name="line.17356"></a>
<FONT color="green">17357</FONT>          result = DEFAULT_FOOTNOTES_THICKNESS<a name="line.17357"></a>
<FONT color="green">17358</FONT>              * (EXTRA_HEIGHT + htmlHeight(((HasHTML) (getChartFootnotes())).getHTML()));<a name="line.17358"></a>
<FONT color="green">17359</FONT>        else<a name="line.17359"></a>
<FONT color="green">17360</FONT>          result = DEFAULT_FOOTNOTES_THICKNESS * (DEF_HEIGHT + EXTRA_HEIGHT);<a name="line.17360"></a>
<FONT color="green">17361</FONT>        return result;<a name="line.17361"></a>
<FONT color="green">17362</FONT>      }<a name="line.17362"></a>
<FONT color="green">17363</FONT>    <a name="line.17363"></a>
<FONT color="green">17364</FONT>      /**<a name="line.17364"></a>
<FONT color="green">17365</FONT>       * Returns the previously specified widget representing the chart's title.<a name="line.17365"></a>
<FONT color="green">17366</FONT>       * <a name="line.17366"></a>
<FONT color="green">17367</FONT>       * @return widget representing chart's title or &lt;tt&gt;null&lt;/tt&gt; if none<a name="line.17367"></a>
<FONT color="green">17368</FONT>       * <a name="line.17368"></a>
<FONT color="green">17369</FONT>       * @see #setChartTitle(Widget) setChartTitle(Widget)<a name="line.17369"></a>
<FONT color="green">17370</FONT>       * @see #setChartTitle(String) setChartTitle(String)<a name="line.17370"></a>
<FONT color="green">17371</FONT>       * <a name="line.17371"></a>
<FONT color="green">17372</FONT>       */<a name="line.17372"></a>
<FONT color="green">17373</FONT>      public Widget getChartTitle() {<a name="line.17373"></a>
<FONT color="green">17374</FONT>        return chartTitle;<a name="line.17374"></a>
<FONT color="green">17375</FONT>      }<a name="line.17375"></a>
<FONT color="green">17376</FONT>    <a name="line.17376"></a>
<FONT color="green">17377</FONT>      /**<a name="line.17377"></a>
<FONT color="green">17378</FONT>       * Returns the thickness (height) of the rectangular region at the top of the<a name="line.17378"></a>
<FONT color="green">17379</FONT>       * chart allocated for the title.<a name="line.17379"></a>
<FONT color="green">17380</FONT>       * &lt;p&gt;<a name="line.17380"></a>
<FONT color="green">17381</FONT>       * <a name="line.17381"></a>
<FONT color="green">17382</FONT>       * This method always returns 0 if the title widget is &lt;tt&gt;null&lt;/tt&gt; (the<a name="line.17382"></a>
<FONT color="green">17383</FONT>       * default); the rectangular title region is entirely eliminated in that case.<a name="line.17383"></a>
<FONT color="green">17384</FONT>       * &lt;p&gt;<a name="line.17384"></a>
<FONT color="green">17385</FONT>       * <a name="line.17385"></a>
<FONT color="green">17386</FONT>       * Your title widget is always centered vertically and horizontally within<a name="line.17386"></a>
<FONT color="green">17387</FONT>       * this rectangular region.<a name="line.17387"></a>
<FONT color="green">17388</FONT>       * <a name="line.17388"></a>
<FONT color="green">17389</FONT>       * <a name="line.17389"></a>
<FONT color="green">17390</FONT>       * @return the thickness (height) of the rectangle that contains the chart's<a name="line.17390"></a>
<FONT color="green">17391</FONT>       *         title, in pixels.<a name="line.17391"></a>
<FONT color="green">17392</FONT>       * <a name="line.17392"></a>
<FONT color="green">17393</FONT>       * @see #setChartTitleThickness setChartTitleThickness<a name="line.17393"></a>
<FONT color="green">17394</FONT>       * <a name="line.17394"></a>
<FONT color="green">17395</FONT>       */<a name="line.17395"></a>
<FONT color="green">17396</FONT>      public int getChartTitleThickness() {<a name="line.17396"></a>
<FONT color="green">17397</FONT>        int result = 0;<a name="line.17397"></a>
<FONT color="green">17398</FONT>        final int EXTRA_HEIGHT = 3; // 1.5 lines above &amp; below title<a name="line.17398"></a>
<FONT color="green">17399</FONT>        final int DEF_HEIGHT = 1;<a name="line.17399"></a>
<FONT color="green">17400</FONT>        if (null == getChartTitle())<a name="line.17400"></a>
<FONT color="green">17401</FONT>          result = 0;<a name="line.17401"></a>
<FONT color="green">17402</FONT>        else if (GChart.NAI != titleThickness)<a name="line.17402"></a>
<FONT color="green">17403</FONT>          result = titleThickness;<a name="line.17403"></a>
<FONT color="green">17404</FONT>        else if (getChartTitle() instanceof HasHTML)<a name="line.17404"></a>
<FONT color="green">17405</FONT>          result = DEFAULT_TITLE_THICKNESS<a name="line.17405"></a>
<FONT color="green">17406</FONT>              * (EXTRA_HEIGHT + htmlHeight(((HasHTML) (getChartTitle())).getHTML()));<a name="line.17406"></a>
<FONT color="green">17407</FONT>        else<a name="line.17407"></a>
<FONT color="green">17408</FONT>          result = DEFAULT_TITLE_THICKNESS * (EXTRA_HEIGHT + DEF_HEIGHT);<a name="line.17408"></a>
<FONT color="green">17409</FONT>        return result;<a name="line.17409"></a>
<FONT color="green">17410</FONT>      }<a name="line.17410"></a>
<FONT color="green">17411</FONT>    <a name="line.17411"></a>
<FONT color="green">17412</FONT>      /**<a name="line.17412"></a>
<FONT color="green">17413</FONT>       * Determines if this chart will clip any chart elements that extend beyond<a name="line.17413"></a>
<FONT color="green">17414</FONT>       * the bounds of the decorated chart. The decorated chart includes title,<a name="line.17414"></a>
<FONT color="green">17415</FONT>       * footnotes, etc. as well as the plot area proper.<a name="line.17415"></a>
<FONT color="green">17416</FONT>       * <a name="line.17416"></a>
<FONT color="green">17417</FONT>       * @return true if off-the-decorated-chart elements are clipped, false<a name="line.17417"></a>
<FONT color="green">17418</FONT>       *         otherwise.<a name="line.17418"></a>
<FONT color="green">17419</FONT>       * <a name="line.17419"></a>
<FONT color="green">17420</FONT>       * @see #setClipToDecoratedChart setClipToDecoratedChart<a name="line.17420"></a>
<FONT color="green">17421</FONT>       * <a name="line.17421"></a>
<FONT color="green">17422</FONT>       */<a name="line.17422"></a>
<FONT color="green">17423</FONT>      public boolean getClipToDecoratedChart() {<a name="line.17423"></a>
<FONT color="green">17424</FONT>        return clipToDecoratedChart;<a name="line.17424"></a>
<FONT color="green">17425</FONT>      }<a name="line.17425"></a>
<FONT color="green">17426</FONT>    <a name="line.17426"></a>
<FONT color="green">17427</FONT>      /**<a name="line.17427"></a>
<FONT color="green">17428</FONT>       * Returns true if graphical aspects of the chart that fall outside of the<a name="line.17428"></a>
<FONT color="green">17429</FONT>       * plot area are being clipped off, false otherwise.<a name="line.17429"></a>
<FONT color="green">17430</FONT>       * <a name="line.17430"></a>
<FONT color="green">17431</FONT>       * @return &lt;tt&gt;true&lt;/tt&gt; if clipping to plot area, else &lt;tt&gt;false&lt;/tt&gt;.<a name="line.17431"></a>
<FONT color="green">17432</FONT>       * <a name="line.17432"></a>
<FONT color="green">17433</FONT>       * @see #setClipToPlotArea setClipToPlotArea<a name="line.17433"></a>
<FONT color="green">17434</FONT>       */<a name="line.17434"></a>
<FONT color="green">17435</FONT>    <a name="line.17435"></a>
<FONT color="green">17436</FONT>      public boolean getClipToPlotArea() {<a name="line.17436"></a>
<FONT color="green">17437</FONT>        return clipToPlotArea;<a name="line.17437"></a>
<FONT color="green">17438</FONT>      }<a name="line.17438"></a>
<FONT color="green">17439</FONT>    <a name="line.17439"></a>
<FONT color="green">17440</FONT>      // returns point closest to given plot-panel pixel coordinates<a name="line.17440"></a>
<FONT color="green">17441</FONT>      Curve.Point getClosestBrushTouchingPointNoCheck(int x, int y) {<a name="line.17441"></a>
<FONT color="green">17442</FONT>    <a name="line.17442"></a>
<FONT color="green">17443</FONT>        Curve.Point result = null;<a name="line.17443"></a>
<FONT color="green">17444</FONT>        // NAI means mouse is at some unknown, off-the-chart, position<a name="line.17444"></a>
<FONT color="green">17445</FONT>        if (x == GChart.NAI || y == GChart.NAI)<a name="line.17445"></a>
<FONT color="green">17446</FONT>          return result;<a name="line.17446"></a>
<FONT color="green">17447</FONT>        double dBest = Double.MAX_VALUE; // dist. to closest symbol<a name="line.17447"></a>
<FONT color="green">17448</FONT>    <a name="line.17448"></a>
<FONT color="green">17449</FONT>        // fact that charts tend to have a small number of curves<a name="line.17449"></a>
<FONT color="green">17450</FONT>        // allows us to use simple sequential search across curves<a name="line.17450"></a>
<FONT color="green">17451</FONT>        int nCurves = getNCurves();<a name="line.17451"></a>
<FONT color="green">17452</FONT>        for (int iCurve = 0; iCurve &lt; nCurves; iCurve++) {<a name="line.17452"></a>
<FONT color="green">17453</FONT>          Curve c = getSystemCurve(iCurve);<a name="line.17453"></a>
<FONT color="green">17454</FONT>          if (!c.isVisible())<a name="line.17454"></a>
<FONT color="green">17455</FONT>            continue;<a name="line.17455"></a>
<FONT color="green">17456</FONT>          Symbol sym = c.getSymbol();<a name="line.17456"></a>
<FONT color="green">17457</FONT>          if (!sym.getHoverAnnotationEnabled()<a name="line.17457"></a>
<FONT color="green">17458</FONT>              &amp;&amp; !sym.getHoverSelectionEnabled())<a name="line.17458"></a>
<FONT color="green">17459</FONT>            continue;<a name="line.17459"></a>
<FONT color="green">17460</FONT>          SymbolType symType = sym.getSymbolType();<a name="line.17460"></a>
<FONT color="green">17461</FONT>          boolean onY2 = c.onY2();<a name="line.17461"></a>
<FONT color="green">17462</FONT>          int iClosest = c.getClosestTouchingPoint(x, y);<a name="line.17462"></a>
<FONT color="green">17463</FONT>          if (GChart.NAI == iClosest)<a name="line.17463"></a>
<FONT color="green">17464</FONT>            continue; // no hits on this curve<a name="line.17464"></a>
<FONT color="green">17465</FONT>    <a name="line.17465"></a>
<FONT color="green">17466</FONT>          double xPoint = symType.getCenterX(plotPanel, sym, iClosest);<a name="line.17466"></a>
<FONT color="green">17467</FONT>          double yPoint = symType.getCenterY(plotPanel, sym, iClosest, onY2);<a name="line.17467"></a>
<FONT color="green">17468</FONT>          double dx = sym.xScaleFactor * (x - xPoint);<a name="line.17468"></a>
<FONT color="green">17469</FONT>          double dy = sym.yScaleFactor * (y - yPoint);<a name="line.17469"></a>
<FONT color="green">17470</FONT>          // distance, squared, of mouse from symbol's "center"<a name="line.17470"></a>
<FONT color="green">17471</FONT>          double d = dx * dx + dy * dy;<a name="line.17471"></a>
<FONT color="green">17472</FONT>          if (d &lt;= dBest) { // for ties, use later, "on top", point<a name="line.17472"></a>
<FONT color="green">17473</FONT>            dBest = d;<a name="line.17473"></a>
<FONT color="green">17474</FONT>            result = c.getPoint(iClosest);<a name="line.17474"></a>
<FONT color="green">17475</FONT>          }<a name="line.17475"></a>
<FONT color="green">17476</FONT>        }<a name="line.17476"></a>
<FONT color="green">17477</FONT>        return result;<a name="line.17477"></a>
<FONT color="green">17478</FONT>      }<a name="line.17478"></a>
<FONT color="green">17479</FONT>    <a name="line.17479"></a>
<FONT color="green">17480</FONT>      /**<a name="line.17480"></a>
<FONT color="green">17481</FONT>       * <a name="line.17481"></a>
<FONT color="green">17482</FONT>       * Returns the point that would be touched if the mouse were moved to the<a name="line.17482"></a>
<FONT color="green">17483</FONT>       * given x,y plot-area pixel coordinates, or &lt;tt&gt;null&lt;/tt&gt; if the moving the<a name="line.17483"></a>
<FONT color="green">17484</FONT>       * mouse to these coordinates would not have touched any points.<a name="line.17484"></a>
<FONT color="green">17485</FONT>       * &lt;p&gt;<a name="line.17485"></a>
<FONT color="green">17486</FONT>       * <a name="line.17486"></a>
<FONT color="green">17487</FONT>       * This method only works if the chart rendering is up-to-date (if<a name="line.17487"></a>
<FONT color="green">17488</FONT>       * &lt;tt&gt;isUpdateNeeded&lt;/tt&gt; returns &lt;tt&gt;false&lt;/tt&gt;). Otherwise, &lt;tt&gt;null&lt;/tt&gt;<a name="line.17488"></a>
<FONT color="green">17489</FONT>       * is returned.<a name="line.17489"></a>
<FONT color="green">17490</FONT>       * &lt;p&gt;<a name="line.17490"></a>
<FONT color="green">17491</FONT>       * <a name="line.17491"></a>
<FONT color="green">17492</FONT>       * &lt;small&gt; GChart's hit testing method works best if a chart's points are<a name="line.17492"></a>
<FONT color="green">17493</FONT>       * approximately evenly distributed across the plot area's x or y axis, across<a name="line.17493"></a>
<FONT color="green">17494</FONT>       * a small number of curves. In particular, charts that have many points<a name="line.17494"></a>
<FONT color="green">17495</FONT>       * bunched up into a small part of the plot area, or that have many points<a name="line.17495"></a>
<FONT color="green">17496</FONT>       * completely outside of the plot area, or that place each point into a<a name="line.17496"></a>
<FONT color="green">17497</FONT>       * separate curve, could experience significantly worse that usual hit testing<a name="line.17497"></a>
<FONT color="green">17498</FONT>       * performance. Though such cases are expected to be rare, in the worst case,<a name="line.17498"></a>
<FONT color="green">17499</FONT>       * GChart could be reduced to a simple linear search across all the chart's<a name="line.17499"></a>
<FONT color="green">17500</FONT>       * points during hit testing. &lt;/small&gt;<a name="line.17500"></a>
<FONT color="green">17501</FONT>       * <a name="line.17501"></a>
<FONT color="green">17502</FONT>       * @param xPlotArea<a name="line.17502"></a>
<FONT color="green">17503</FONT>       *          x-coordinate of trial mouse position, in GChart's plot area pixel<a name="line.17503"></a>
<FONT color="green">17504</FONT>       *          coordinates.<a name="line.17504"></a>
<FONT color="green">17505</FONT>       * @param yPlotArea<a name="line.17505"></a>
<FONT color="green">17506</FONT>       *          y-coordinate of trial mouse position, in GChart's plot area pixel<a name="line.17506"></a>
<FONT color="green">17507</FONT>       *          coordinates.<a name="line.17507"></a>
<FONT color="green">17508</FONT>       * <a name="line.17508"></a>
<FONT color="green">17509</FONT>       * @return reference to the point that would have been "touched" by the mouse,<a name="line.17509"></a>
<FONT color="green">17510</FONT>       *         or &lt;tt&gt;null&lt;/tt&gt; if positioning the mouse to these coordinates<a name="line.17510"></a>
<FONT color="green">17511</FONT>       *         would not have touched any point.<a name="line.17511"></a>
<FONT color="green">17512</FONT>       * <a name="line.17512"></a>
<FONT color="green">17513</FONT>       * @see Axis#getMouseCoordinate getMouseCoordinate<a name="line.17513"></a>
<FONT color="green">17514</FONT>       * @see Axis#modelToPlotAreaPixel modelToPlotAreaPixel<a name="line.17514"></a>
<FONT color="green">17515</FONT>       * @see #isUpdateNeeded isUpdateNeeded<a name="line.17515"></a>
<FONT color="green">17516</FONT>       * @see #touch touch<a name="line.17516"></a>
<FONT color="green">17517</FONT>       * <a name="line.17517"></a>
<FONT color="green">17518</FONT>       */<a name="line.17518"></a>
<FONT color="green">17519</FONT>    <a name="line.17519"></a>
<FONT color="green">17520</FONT>      public Curve.Point getClosestBrushTouchingPoint(int xPlotArea, int yPlotArea) {<a name="line.17520"></a>
<FONT color="green">17521</FONT>        Curve.Point result = null;<a name="line.17521"></a>
<FONT color="green">17522</FONT>        if (!isUpdateNeeded()) {<a name="line.17522"></a>
<FONT color="green">17523</FONT>          result = getClosestBrushTouchingPointNoCheck(xPlotArea, yPlotArea);<a name="line.17523"></a>
<FONT color="green">17524</FONT>        }<a name="line.17524"></a>
<FONT color="green">17525</FONT>        return result;<a name="line.17525"></a>
<FONT color="green">17526</FONT>      }<a name="line.17526"></a>
<FONT color="green">17527</FONT>    <a name="line.17527"></a>
<FONT color="green">17528</FONT>      /**<a name="line.17528"></a>
<FONT color="green">17529</FONT>       * Convenience method equivalent to &lt;tt&gt;getCurve(getNCurves()-1)&lt;/tt&gt;.<a name="line.17529"></a>
<FONT color="green">17530</FONT>       * &lt;p&gt;<a name="line.17530"></a>
<FONT color="green">17531</FONT>       * This method, when used in conjunction with no-arg &lt;tt&gt;addCurve&lt;/tt&gt;,<a name="line.17531"></a>
<FONT color="green">17532</FONT>       * method, makes code blocks that create and define the properties of a<a name="line.17532"></a>
<FONT color="green">17533</FONT>       * chart's curves more readable/editable. For example:<a name="line.17533"></a>
<FONT color="green">17534</FONT>       * <a name="line.17534"></a>
<FONT color="green">17535</FONT>       * &lt;pre&gt;<a name="line.17535"></a>
<FONT color="green">17536</FONT>       * addCurve(); // add 1st curve<a name="line.17536"></a>
<FONT color="green">17537</FONT>       * getCurve().setYAxis(Y2_AXIS); // first setting for 1st curve<a name="line.17537"></a>
<FONT color="green">17538</FONT>       * //... other settings for first curve<a name="line.17538"></a>
<FONT color="green">17539</FONT>       * addCurve(); // add 2nd curve<a name="line.17539"></a>
<FONT color="green">17540</FONT>       * getCurve().setYAxis(Y_AXIS); // first setting for 2nd curve<a name="line.17540"></a>
<FONT color="green">17541</FONT>       * // ... other settings for 2nd curve<a name="line.17541"></a>
<FONT color="green">17542</FONT>       * &lt;/pre&gt;<a name="line.17542"></a>
<FONT color="green">17543</FONT>       *&lt;p&gt;<a name="line.17543"></a>
<FONT color="green">17544</FONT>       * Note that using the no-arg methods in this way allows you to copy entire<a name="line.17544"></a>
<FONT color="green">17545</FONT>       * groups of curve properties, unchanged, between such curve related blocks.<a name="line.17545"></a>
<FONT color="green">17546</FONT>       * <a name="line.17546"></a>
<FONT color="green">17547</FONT>       * @return the curve with the highest integer index. In other words, the curve<a name="line.17547"></a>
<FONT color="green">17548</FONT>       *         with an index of &lt;tt&gt;getNCurves()-1&lt;/tt&gt;.<a name="line.17548"></a>
<FONT color="green">17549</FONT>       * <a name="line.17549"></a>
<FONT color="green">17550</FONT>       * @see #getCurve(int) getCurve(int)<a name="line.17550"></a>
<FONT color="green">17551</FONT>       * @see #getNCurves getNCurves<a name="line.17551"></a>
<FONT color="green">17552</FONT>       * @see #addCurve() addCurve()<a name="line.17552"></a>
<FONT color="green">17553</FONT>       */<a name="line.17553"></a>
<FONT color="green">17554</FONT>      public Curve getCurve() {<a name="line.17554"></a>
<FONT color="green">17555</FONT>        int N = getNCurves();<a name="line.17555"></a>
<FONT color="green">17556</FONT>        if (N &lt; 1)<a name="line.17556"></a>
<FONT color="green">17557</FONT>          throw new IllegalStateException(<a name="line.17557"></a>
<FONT color="green">17558</FONT>              "You must add at least 1 curve before invoking getCurve()");<a name="line.17558"></a>
<FONT color="green">17559</FONT>        Curve result = getSystemCurve(N - 1);<a name="line.17559"></a>
<FONT color="green">17560</FONT>        return result;<a name="line.17560"></a>
<FONT color="green">17561</FONT>      }<a name="line.17561"></a>
<FONT color="green">17562</FONT>    <a name="line.17562"></a>
<FONT color="green">17563</FONT>      /**<a name="line.17563"></a>
<FONT color="green">17564</FONT>       * Returns a reference to the curve at the specified positional index. Use the<a name="line.17564"></a>
<FONT color="green">17565</FONT>       * reference returned by this method to modify properties of a curve (the<a name="line.17565"></a>
<FONT color="green">17566</FONT>       * symbol, data points, etc.)<a name="line.17566"></a>
<FONT color="green">17567</FONT>       * <a name="line.17567"></a>
<FONT color="green">17568</FONT>       * &lt;p&gt;<a name="line.17568"></a>
<FONT color="green">17569</FONT>       * <a name="line.17569"></a>
<FONT color="green">17570</FONT>       * @param iCurve<a name="line.17570"></a>
<FONT color="green">17571</FONT>       *          index of the curve to be retrieved.<a name="line.17571"></a>
<FONT color="green">17572</FONT>       * @return reference to the Curve at the specified position.<a name="line.17572"></a>
<FONT color="green">17573</FONT>       * <a name="line.17573"></a>
<FONT color="green">17574</FONT>       * @see #getCurve() getCurve()<a name="line.17574"></a>
<FONT color="green">17575</FONT>       * @see #addCurve() addCurve()<a name="line.17575"></a>
<FONT color="green">17576</FONT>       * @see #addCurve(int) addCurve(int)<a name="line.17576"></a>
<FONT color="green">17577</FONT>       * @see #removeCurve removeCurve<a name="line.17577"></a>
<FONT color="green">17578</FONT>       * @see #clearCurves clearCurves<a name="line.17578"></a>
<FONT color="green">17579</FONT>       * @see #getNCurves getNCurves<a name="line.17579"></a>
<FONT color="green">17580</FONT>       */<a name="line.17580"></a>
<FONT color="green">17581</FONT>      public Curve getCurve(int iCurve) {<a name="line.17581"></a>
<FONT color="green">17582</FONT>    <a name="line.17582"></a>
<FONT color="green">17583</FONT>        if (iCurve &gt;= getNCurves())<a name="line.17583"></a>
<FONT color="green">17584</FONT>          throw new IllegalArgumentException("iCurve = " + iCurve<a name="line.17584"></a>
<FONT color="green">17585</FONT>              + "; iCurve may not exceed getNCurves()-1 ("<a name="line.17585"></a>
<FONT color="green">17586</FONT>              + (getNCurves() - 1) + ")");<a name="line.17586"></a>
<FONT color="green">17587</FONT>        else if (iCurve &lt; 0)<a name="line.17587"></a>
<FONT color="green">17588</FONT>          throw new IllegalArgumentException("iCurve = " + iCurve<a name="line.17588"></a>
<FONT color="green">17589</FONT>              + "; iCurve may not be negative.");<a name="line.17589"></a>
<FONT color="green">17590</FONT>    <a name="line.17590"></a>
<FONT color="green">17591</FONT>        Curve result = getSystemCurve(iCurve);<a name="line.17591"></a>
<FONT color="green">17592</FONT>        return result;<a name="line.17592"></a>
<FONT color="green">17593</FONT>      }<a name="line.17593"></a>
<FONT color="green">17594</FONT>    <a name="line.17594"></a>
<FONT color="green">17595</FONT>      // Version of getCurve that allows sys curve (negative id) access<a name="line.17595"></a>
<FONT color="green">17596</FONT>      Curve getSystemCurve(int iCurve) {<a name="line.17596"></a>
<FONT color="green">17597</FONT>        int internalIndex = internalCurveIndex(iCurve);<a name="line.17597"></a>
<FONT color="green">17598</FONT>        Curve result = curves.get(internalIndex);<a name="line.17598"></a>
<FONT color="green">17599</FONT>        return result;<a name="line.17599"></a>
<FONT color="green">17600</FONT>      }<a name="line.17600"></a>
<FONT color="green">17601</FONT>    <a name="line.17601"></a>
<FONT color="green">17602</FONT>      /**<a name="line.17602"></a>
<FONT color="green">17603</FONT>       * Returns the positional index (within this chart's list of curves) of the<a name="line.17603"></a>
<FONT color="green">17604</FONT>       * specified curve.<a name="line.17604"></a>
<FONT color="green">17605</FONT>       * &lt;p&gt;<a name="line.17605"></a>
<FONT color="green">17606</FONT>       * <a name="line.17606"></a>
<FONT color="green">17607</FONT>       * Returns &lt;i&gt;GChart.NAI&lt;/i&gt; if the specified curve is not found on this<a name="line.17607"></a>
<FONT color="green">17608</FONT>       * GChart's curve list.<a name="line.17608"></a>
<FONT color="green">17609</FONT>       * <a name="line.17609"></a>
<FONT color="green">17610</FONT>       * &lt;p&gt;<a name="line.17610"></a>
<FONT color="green">17611</FONT>       * <a name="line.17611"></a>
<FONT color="green">17612</FONT>       * @param curve<a name="line.17612"></a>
<FONT color="green">17613</FONT>       *          whose list position is to be retrieved<a name="line.17613"></a>
<FONT color="green">17614</FONT>       * @return position of curve in GChart's curve list, or &lt;i&gt;GChart.NAI&lt;/i&gt; if<a name="line.17614"></a>
<FONT color="green">17615</FONT>       *         not on this chart's curve list.<a name="line.17615"></a>
<FONT color="green">17616</FONT>       * <a name="line.17616"></a>
<FONT color="green">17617</FONT>       * @see #getCurve() getCurve()<a name="line.17617"></a>
<FONT color="green">17618</FONT>       * @see #getCurve(int) getCurve(int)<a name="line.17618"></a>
<FONT color="green">17619</FONT>       * @see #addCurve() addCurve()<a name="line.17619"></a>
<FONT color="green">17620</FONT>       * @see #addCurve(int) addCurve(int)<a name="line.17620"></a>
<FONT color="green">17621</FONT>       * @see #removeCurve removeCurve<a name="line.17621"></a>
<FONT color="green">17622</FONT>       * @see #clearCurves clearCurves<a name="line.17622"></a>
<FONT color="green">17623</FONT>       * @see #getNCurves getNCurves<a name="line.17623"></a>
<FONT color="green">17624</FONT>       */<a name="line.17624"></a>
<FONT color="green">17625</FONT>      public int getCurveIndex(Curve curve) {<a name="line.17625"></a>
<FONT color="green">17626</FONT>        int internalIndex = curve.getIndexOf();<a name="line.17626"></a>
<FONT color="green">17627</FONT>        int result = externalCurveIndex(internalIndex);<a name="line.17627"></a>
<FONT color="green">17628</FONT>        return result;<a name="line.17628"></a>
<FONT color="green">17629</FONT>      }<a name="line.17629"></a>
<FONT color="green">17630</FONT>    <a name="line.17630"></a>
<FONT color="green">17631</FONT>      int getInternalCurveIndex(Curve curve) {<a name="line.17631"></a>
<FONT color="green">17632</FONT>        int result = curve.getIndexOf();<a name="line.17632"></a>
<FONT color="green">17633</FONT>        return result;<a name="line.17633"></a>
<FONT color="green">17634</FONT>      }<a name="line.17634"></a>
<FONT color="green">17635</FONT>    <a name="line.17635"></a>
<FONT color="green">17636</FONT>      // maps all background curve indexes into first rendering panel<a name="line.17636"></a>
<FONT color="green">17637</FONT>      int getRenderingPanelIndex(int internalCurveIndex) {<a name="line.17637"></a>
<FONT color="green">17638</FONT>        int result = 0;<a name="line.17638"></a>
<FONT color="green">17639</FONT>        if (N_PRE_SYSTEM_CURVES &lt;= internalCurveIndex)<a name="line.17639"></a>
<FONT color="green">17640</FONT>          result = internalCurveIndex - N_PRE_SYSTEM_CURVES + 1;<a name="line.17640"></a>
<FONT color="green">17641</FONT>        return result;<a name="line.17641"></a>
<FONT color="green">17642</FONT>      }<a name="line.17642"></a>
<FONT color="green">17643</FONT>    <a name="line.17643"></a>
<FONT color="green">17644</FONT>      Curve getCurveFromRenderingPanelIndex(int rpi) {<a name="line.17644"></a>
<FONT color="green">17645</FONT>        int internalCurveIndex = rpi + N_PRE_SYSTEM_CURVES - 1;<a name="line.17645"></a>
<FONT color="green">17646</FONT>        Curve result = curves.get(internalCurveIndex);<a name="line.17646"></a>
<FONT color="green">17647</FONT>        return result;<a name="line.17647"></a>
<FONT color="green">17648</FONT>      }<a name="line.17648"></a>
<FONT color="green">17649</FONT>    <a name="line.17649"></a>
<FONT color="green">17650</FONT>      /**<a name="line.17650"></a>
<FONT color="green">17651</FONT>       * <a name="line.17651"></a>
<FONT color="green">17652</FONT>       * Returns the font-family that is used, by default, for all<a name="line.17652"></a>
<FONT color="green">17653</FONT>       * textual annotations (tick labels, point lables, title, footnotes,<a name="line.17653"></a>
<FONT color="green">17654</FONT>       * legend labels, and axis labels) on that chart. <a name="line.17654"></a>
<FONT color="green">17655</FONT>       * <a name="line.17655"></a>
<FONT color="green">17656</FONT>       * @see #setFontFamily(String) setFontFamily<a name="line.17656"></a>
<FONT color="green">17657</FONT>       * <a name="line.17657"></a>
<FONT color="green">17658</FONT>       * <a name="line.17658"></a>
<FONT color="green">17659</FONT>       */<a name="line.17659"></a>
<FONT color="green">17660</FONT>      public String getFontFamily() {<a name="line.17660"></a>
<FONT color="green">17661</FONT>        return fontFamily;<a name="line.17661"></a>
<FONT color="green">17662</FONT>      }<a name="line.17662"></a>
<FONT color="green">17663</FONT>    <a name="line.17663"></a>
<FONT color="green">17664</FONT>      /**<a name="line.17664"></a>
<FONT color="green">17665</FONT>       * Returns CSS color specification for all gridlines, axes, and tickmarks.<a name="line.17665"></a>
<FONT color="green">17666</FONT>       * <a name="line.17666"></a>
<FONT color="green">17667</FONT>       * @see #setGridColor setGridColor<a name="line.17667"></a>
<FONT color="green">17668</FONT>       * <a name="line.17668"></a>
<FONT color="green">17669</FONT>       * @return the color, in CSS standard color format, used for all gridlines,<a name="line.17669"></a>
<FONT color="green">17670</FONT>       *         axes, and tick marks.<a name="line.17670"></a>
<FONT color="green">17671</FONT>       * <a name="line.17671"></a>
<FONT color="green">17672</FONT>       */<a name="line.17672"></a>
<FONT color="green">17673</FONT>    <a name="line.17673"></a>
<FONT color="green">17674</FONT>      public String getGridColor() {<a name="line.17674"></a>
<FONT color="green">17675</FONT>        Curve cGridlines = getSystemCurve(XGRIDLINES_ID);<a name="line.17675"></a>
<FONT color="green">17676</FONT>        String result = cGridlines.getSymbol().getBorderColor();<a name="line.17676"></a>
<FONT color="green">17677</FONT>        return result;<a name="line.17677"></a>
<FONT color="green">17678</FONT>      }<a name="line.17678"></a>
<FONT color="green">17679</FONT>    <a name="line.17679"></a>
<FONT color="green">17680</FONT>      /**<a name="line.17680"></a>
<FONT color="green">17681</FONT>       * Returns the background color of the chart's legend.<a name="line.17681"></a>
<FONT color="green">17682</FONT>       * <a name="line.17682"></a>
<FONT color="green">17683</FONT>       * @return the legend's background color, in a standard CSS color string<a name="line.17683"></a>
<FONT color="green">17684</FONT>       *         format.<a name="line.17684"></a>
<FONT color="green">17685</FONT>       * <a name="line.17685"></a>
<FONT color="green">17686</FONT>       * @see #setLegendBackgroundColor setLegendBackgroundColor<a name="line.17686"></a>
<FONT color="green">17687</FONT>       * <a name="line.17687"></a>
<FONT color="green">17688</FONT>       */<a name="line.17688"></a>
<FONT color="green">17689</FONT>      public String getLegendBackgroundColor() {<a name="line.17689"></a>
<FONT color="green">17690</FONT>        return legendBackgroundColor;<a name="line.17690"></a>
<FONT color="green">17691</FONT>      }<a name="line.17691"></a>
<FONT color="green">17692</FONT>    <a name="line.17692"></a>
<FONT color="green">17693</FONT>      /**<a name="line.17693"></a>
<FONT color="green">17694</FONT>       * Returns the border color of the chart's legend.<a name="line.17694"></a>
<FONT color="green">17695</FONT>       * <a name="line.17695"></a>
<FONT color="green">17696</FONT>       * @return the color of the legend's border, in a standard CSS color string<a name="line.17696"></a>
<FONT color="green">17697</FONT>       *         format, or else the special GChart keyword<a name="line.17697"></a>
<FONT color="green">17698</FONT>       *         &lt;tt&gt;TRANSPARENT_BORDER_COLOR&lt;/tt&gt;.<a name="line.17698"></a>
<FONT color="green">17699</FONT>       * <a name="line.17699"></a>
<FONT color="green">17700</FONT>       * @see #setLegendBorderColor setLegendBordergroundColor<a name="line.17700"></a>
<FONT color="green">17701</FONT>       * @see #TRANSPARENT_BORDER_COLOR TRANSPARENT_BORDER_COLOR<a name="line.17701"></a>
<FONT color="green">17702</FONT>       * <a name="line.17702"></a>
<FONT color="green">17703</FONT>       */<a name="line.17703"></a>
<FONT color="green">17704</FONT>      public String getLegendBorderColor() {<a name="line.17704"></a>
<FONT color="green">17705</FONT>        return legendBorderColor;<a name="line.17705"></a>
<FONT color="green">17706</FONT>      }<a name="line.17706"></a>
<FONT color="green">17707</FONT>    <a name="line.17707"></a>
<FONT color="green">17708</FONT>      /**<a name="line.17708"></a>
<FONT color="green">17709</FONT>       * Returns the width of the chart's legend's border<a name="line.17709"></a>
<FONT color="green">17710</FONT>       * <a name="line.17710"></a>
<FONT color="green">17711</FONT>       * @return width of the legend's border, in pixels<a name="line.17711"></a>
<FONT color="green">17712</FONT>       * <a name="line.17712"></a>
<FONT color="green">17713</FONT>       * @see #setLegendBorderWidth setLegendBorderWidth<a name="line.17713"></a>
<FONT color="green">17714</FONT>       * <a name="line.17714"></a>
<FONT color="green">17715</FONT>       */<a name="line.17715"></a>
<FONT color="green">17716</FONT>      public int getLegendBorderWidth() {<a name="line.17716"></a>
<FONT color="green">17717</FONT>        return legendBorderWidth;<a name="line.17717"></a>
<FONT color="green">17718</FONT>      }<a name="line.17718"></a>
<FONT color="green">17719</FONT>    <a name="line.17719"></a>
<FONT color="green">17720</FONT>      /**<a name="line.17720"></a>
<FONT color="green">17721</FONT>       * Returns the style of the chart's legend's border<a name="line.17721"></a>
<FONT color="green">17722</FONT>       * <a name="line.17722"></a>
<FONT color="green">17723</FONT>       * @return cssStyle of the legend's border<a name="line.17723"></a>
<FONT color="green">17724</FONT>       * <a name="line.17724"></a>
<FONT color="green">17725</FONT>       * @see #setLegendBorderStyle setLegendBorderStyle<a name="line.17725"></a>
<FONT color="green">17726</FONT>       * <a name="line.17726"></a>
<FONT color="green">17727</FONT>       */<a name="line.17727"></a>
<FONT color="green">17728</FONT>      public String getLegendBorderStyle() {<a name="line.17728"></a>
<FONT color="green">17729</FONT>        return legendBorderStyle;<a name="line.17729"></a>
<FONT color="green">17730</FONT>      }<a name="line.17730"></a>
<FONT color="green">17731</FONT>    <a name="line.17731"></a>
<FONT color="green">17732</FONT>      /**<a name="line.17732"></a>
<FONT color="green">17733</FONT>       * Returns the color of the font used to display the labels within the legend<a name="line.17733"></a>
<FONT color="green">17734</FONT>       * (chart key)<a name="line.17734"></a>
<FONT color="green">17735</FONT>       * <a name="line.17735"></a>
<FONT color="green">17736</FONT>       * @return CSS color string defining the legend text's color<a name="line.17736"></a>
<FONT color="green">17737</FONT>       * <a name="line.17737"></a>
<FONT color="green">17738</FONT>       * @see #setLegendFontColor setLegendFontColor<a name="line.17738"></a>
<FONT color="green">17739</FONT>       */<a name="line.17739"></a>
<FONT color="green">17740</FONT>      public String getLegendFontColor() {<a name="line.17740"></a>
<FONT color="green">17741</FONT>        return legendFontColor;<a name="line.17741"></a>
<FONT color="green">17742</FONT>      }<a name="line.17742"></a>
<FONT color="green">17743</FONT>    <a name="line.17743"></a>
<FONT color="green">17744</FONT>      /**<a name="line.17744"></a>
<FONT color="green">17745</FONT>       * Returns the CSS font size, in pixels, of text displayed in the chart's<a name="line.17745"></a>
<FONT color="green">17746</FONT>       * legend (also know as a chart's key).<a name="line.17746"></a>
<FONT color="green">17747</FONT>       * <a name="line.17747"></a>
<FONT color="green">17748</FONT>       * @return the (previously specified) font size of legend text<a name="line.17748"></a>
<FONT color="green">17749</FONT>       * <a name="line.17749"></a>
<FONT color="green">17750</FONT>       * @see #setLegendFontSize setLegendFontSize<a name="line.17750"></a>
<FONT color="green">17751</FONT>       */<a name="line.17751"></a>
<FONT color="green">17752</FONT>      public int getLegendFontSize() {<a name="line.17752"></a>
<FONT color="green">17753</FONT>        return legendFontSize;<a name="line.17753"></a>
<FONT color="green">17754</FONT>      }<a name="line.17754"></a>
<FONT color="green">17755</FONT>    <a name="line.17755"></a>
<FONT color="green">17756</FONT>      /**<a name="line.17756"></a>
<FONT color="green">17757</FONT>       * Returns the font-family used to render this GChart's legend text.<a name="line.17757"></a>
<FONT color="green">17758</FONT>       * <a name="line.17758"></a>
<FONT color="green">17759</FONT>       * @return font-famly of legend text.<a name="line.17759"></a>
<FONT color="green">17760</FONT>       * <a name="line.17760"></a>
<FONT color="green">17761</FONT>       * @see #setLegendFontFamily setLegendFontFamily<a name="line.17761"></a>
<FONT color="green">17762</FONT>       */<a name="line.17762"></a>
<FONT color="green">17763</FONT>      public String getLegendFontFamily() {<a name="line.17763"></a>
<FONT color="green">17764</FONT>        return legendFontFamily;<a name="line.17764"></a>
<FONT color="green">17765</FONT>      }<a name="line.17765"></a>
<FONT color="green">17766</FONT>    <a name="line.17766"></a>
<FONT color="green">17767</FONT>      /**<a name="line.17767"></a>
<FONT color="green">17768</FONT>       * Returns the font-style in which this GChart's legend text will be rendered.<a name="line.17768"></a>
<FONT color="green">17769</FONT>       * <a name="line.17769"></a>
<FONT color="green">17770</FONT>       * @return font-style of legend text (italic, normal, etc.)<a name="line.17770"></a>
<FONT color="green">17771</FONT>       * <a name="line.17771"></a>
<FONT color="green">17772</FONT>       * @see #setLegendFontStyle setLegendFontStyle<a name="line.17772"></a>
<FONT color="green">17773</FONT>       */<a name="line.17773"></a>
<FONT color="green">17774</FONT>      public String getLegendFontStyle() {<a name="line.17774"></a>
<FONT color="green">17775</FONT>        return legendFontStyle;<a name="line.17775"></a>
<FONT color="green">17776</FONT>      }<a name="line.17776"></a>
<FONT color="green">17777</FONT>    <a name="line.17777"></a>
<FONT color="green">17778</FONT>      /**<a name="line.17778"></a>
<FONT color="green">17779</FONT>       * Returns true if legend text will be rendered in a bold, or false if in<a name="line.17779"></a>
<FONT color="green">17780</FONT>       * normal, weight font.<a name="line.17780"></a>
<FONT color="green">17781</FONT>       * <a name="line.17781"></a>
<FONT color="green">17782</FONT>       * @return if the legend's text is in bold or not.<a name="line.17782"></a>
<FONT color="green">17783</FONT>       * <a name="line.17783"></a>
<FONT color="green">17784</FONT>       * @see #setLegendFontWeight setLegendFontWeight<a name="line.17784"></a>
<FONT color="green">17785</FONT>       */<a name="line.17785"></a>
<FONT color="green">17786</FONT>      public String getLegendFontWeight() {<a name="line.17786"></a>
<FONT color="green">17787</FONT>        return legendFontWeight;<a name="line.17787"></a>
<FONT color="green">17788</FONT>      }<a name="line.17788"></a>
<FONT color="green">17789</FONT>    <a name="line.17789"></a>
<FONT color="green">17790</FONT>      /**<a name="line.17790"></a>
<FONT color="green">17791</FONT>       * Returns the thickness (width) of the rectangular region to the right of the<a name="line.17791"></a>
<FONT color="green">17792</FONT>       * y2-axis label allocated for the chart legend.<a name="line.17792"></a>
<FONT color="green">17793</FONT>       * &lt;p&gt;<a name="line.17793"></a>
<FONT color="green">17794</FONT>       * <a name="line.17794"></a>
<FONT color="green">17795</FONT>       * The region extends vertically in parallel with the right edge of the plot<a name="line.17795"></a>
<FONT color="green">17796</FONT>       * area. The legend is always centered vertically and horizontally within this<a name="line.17796"></a>
<FONT color="green">17797</FONT>       * rectangular region.<a name="line.17797"></a>
<FONT color="green">17798</FONT>       * &lt;p&gt;<a name="line.17798"></a>
<FONT color="green">17799</FONT>       * <a name="line.17799"></a>
<FONT color="green">17800</FONT>       * This method always returns 0 if the legend is not visible; the rectangular<a name="line.17800"></a>
<FONT color="green">17801</FONT>       * legend region is entirely eliminated in that case.<a name="line.17801"></a>
<FONT color="green">17802</FONT>       * <a name="line.17802"></a>
<FONT color="green">17803</FONT>       * @return thickness (width) of legend key holding region, in pixels.<a name="line.17803"></a>
<FONT color="green">17804</FONT>       * <a name="line.17804"></a>
<FONT color="green">17805</FONT>       * @see #setLegendThickness setLegendThickness<a name="line.17805"></a>
<FONT color="green">17806</FONT>       */<a name="line.17806"></a>
<FONT color="green">17807</FONT>      public int getLegendThickness() {<a name="line.17807"></a>
<FONT color="green">17808</FONT>        int result = 0;<a name="line.17808"></a>
<FONT color="green">17809</FONT>        if (isLegendVisible() &amp;&amp; 0 &lt; getNVisibleCurvesOnLegend()) {<a name="line.17809"></a>
<FONT color="green">17810</FONT>          if (GChart.NAI == legendThickness)<a name="line.17810"></a>
<FONT color="green">17811</FONT>            result = getDefaultLegendThickness();<a name="line.17811"></a>
<FONT color="green">17812</FONT>          else<a name="line.17812"></a>
<FONT color="green">17813</FONT>            result = legendThickness;<a name="line.17813"></a>
<FONT color="green">17814</FONT>        }<a name="line.17814"></a>
<FONT color="green">17815</FONT>    <a name="line.17815"></a>
<FONT color="green">17816</FONT>        return result;<a name="line.17816"></a>
<FONT color="green">17817</FONT>    <a name="line.17817"></a>
<FONT color="green">17818</FONT>      }<a name="line.17818"></a>
<FONT color="green">17819</FONT>    <a name="line.17819"></a>
<FONT color="green">17820</FONT>      /**<a name="line.17820"></a>
<FONT color="green">17821</FONT>       * Returns the developer-defined widget used for this chart's Legend.<a name="line.17821"></a>
<FONT color="green">17822</FONT>       * &lt;p&gt;<a name="line.17822"></a>
<FONT color="green">17823</FONT>       * <a name="line.17823"></a>
<FONT color="green">17824</FONT>       * If &lt;tt&gt;null&lt;/tt&gt; (the default) GChart will generate a legend widget<a name="line.17824"></a>
<FONT color="green">17825</FONT>       * internally.<a name="line.17825"></a>
<FONT color="green">17826</FONT>       * <a name="line.17826"></a>
<FONT color="green">17827</FONT>       * <a name="line.17827"></a>
<FONT color="green">17828</FONT>       * @return the developer-defined legend, or &lt;tt&gt;null&lt;/tt&gt; if none.<a name="line.17828"></a>
<FONT color="green">17829</FONT>       * <a name="line.17829"></a>
<FONT color="green">17830</FONT>       * @see #setLegend setLegend<a name="line.17830"></a>
<FONT color="green">17831</FONT>       * <a name="line.17831"></a>
<FONT color="green">17832</FONT>       */<a name="line.17832"></a>
<FONT color="green">17833</FONT>      public Widget getLegend() {<a name="line.17833"></a>
<FONT color="green">17834</FONT>        return legend;<a name="line.17834"></a>
<FONT color="green">17835</FONT>      }<a name="line.17835"></a>
<FONT color="green">17836</FONT>    <a name="line.17836"></a>
<FONT color="green">17837</FONT>      /**<a name="line.17837"></a>
<FONT color="green">17838</FONT>       * The amount, in pixels, the legend is shifted along the x axis from its base<a name="line.17838"></a>
<FONT color="green">17839</FONT>       * position.<a name="line.17839"></a>
<FONT color="green">17840</FONT>       * <a name="line.17840"></a>
<FONT color="green">17841</FONT>       * @return amount legend is shifted along the x axis<a name="line.17841"></a>
<FONT color="green">17842</FONT>       * <a name="line.17842"></a>
<FONT color="green">17843</FONT>       * @see #setLegendXShift setLegendXShift<a name="line.17843"></a>
<FONT color="green">17844</FONT>       * <a name="line.17844"></a>
<FONT color="green">17845</FONT>       */<a name="line.17845"></a>
<FONT color="green">17846</FONT>      public int getLegendXShift() {<a name="line.17846"></a>
<FONT color="green">17847</FONT>        return legendXShift;<a name="line.17847"></a>
<FONT color="green">17848</FONT>      }<a name="line.17848"></a>
<FONT color="green">17849</FONT>      /**<a name="line.17849"></a>
<FONT color="green">17850</FONT>       * Returns a previously specified initial pie slice orientation.<a name="line.17850"></a>
<FONT color="green">17851</FONT>       * <a name="line.17851"></a>
<FONT color="green">17852</FONT>       * @return the fraction of a clockwise rotation, beginning from the 6 o'clock<a name="line.17852"></a>
<FONT color="green">17853</FONT>       *         position, needed to reach the default initial pie slice orientation.<a name="line.17853"></a>
<FONT color="green">17854</FONT>       * <a name="line.17854"></a>
<FONT color="green">17855</FONT>       * @see #setInitialPieSliceOrientation setInitialPieSliceOrientation<a name="line.17855"></a>
<FONT color="green">17856</FONT>       */<a name="line.17856"></a>
<FONT color="green">17857</FONT>      public double getInitialPieSliceOrientation() {<a name="line.17857"></a>
<FONT color="green">17858</FONT>        return initialPieSliceOrientation;<a name="line.17858"></a>
<FONT color="green">17859</FONT>      }<a name="line.17859"></a>
<FONT color="green">17860</FONT>    <a name="line.17860"></a>
<FONT color="green">17861</FONT>      /**<a name="line.17861"></a>
<FONT color="green">17862</FONT>       * The amount, in pixels, the legend is shifted along the y axis from its base<a name="line.17862"></a>
<FONT color="green">17863</FONT>       * position.<a name="line.17863"></a>
<FONT color="green">17864</FONT>       * <a name="line.17864"></a>
<FONT color="green">17865</FONT>       * @return amount legend is shifted along the y axis<a name="line.17865"></a>
<FONT color="green">17866</FONT>       * <a name="line.17866"></a>
<FONT color="green">17867</FONT>       * @see #setLegendYShift setLegendYShift<a name="line.17867"></a>
<FONT color="green">17868</FONT>       * <a name="line.17868"></a>
<FONT color="green">17869</FONT>       */<a name="line.17869"></a>
<FONT color="green">17870</FONT>      public int getLegendYShift() {<a name="line.17870"></a>
<FONT color="green">17871</FONT>        return legendXShift;<a name="line.17871"></a>
<FONT color="green">17872</FONT>      }<a name="line.17872"></a>
<FONT color="green">17873</FONT>    <a name="line.17873"></a>
<FONT color="green">17874</FONT>      /**<a name="line.17874"></a>
<FONT color="green">17875</FONT>       * Returns the maximum number of pixels any canvas Widget used in GChart's<a name="line.17875"></a>
<FONT color="green">17876</FONT>       * rendering can have.<a name="line.17876"></a>
<FONT color="green">17877</FONT>       * <a name="line.17877"></a>
<FONT color="green">17878</FONT>       * @return the maximum number of pixels on a GChart canvas widget<a name="line.17878"></a>
<FONT color="green">17879</FONT>       * <a name="line.17879"></a>
<FONT color="green">17880</FONT>       * @see #setMaxCanvasPixels setMaxCanvasPixels<a name="line.17880"></a>
<FONT color="green">17881</FONT>       */<a name="line.17881"></a>
<FONT color="green">17882</FONT>      public double getMaxCanvasPixels() {<a name="line.17882"></a>
<FONT color="green">17883</FONT>        return maxCanvasPixels;<a name="line.17883"></a>
<FONT color="green">17884</FONT>      }<a name="line.17884"></a>
<FONT color="green">17885</FONT>    <a name="line.17885"></a>
<FONT color="green">17886</FONT>      /**<a name="line.17886"></a>
<FONT color="green">17887</FONT>       * Returns the number of curves on this chart.<a name="line.17887"></a>
<FONT color="green">17888</FONT>       * <a name="line.17888"></a>
<FONT color="green">17889</FONT>       * @return the number of curves on this chart<a name="line.17889"></a>
<FONT color="green">17890</FONT>       * <a name="line.17890"></a>
<FONT color="green">17891</FONT>       * @see #getCurve getCurve<a name="line.17891"></a>
<FONT color="green">17892</FONT>       * @see #addCurve() addCurve()<a name="line.17892"></a>
<FONT color="green">17893</FONT>       * @see #addCurve(int) addCurve(int)<a name="line.17893"></a>
<FONT color="green">17894</FONT>       * @see #removeCurve removeCurve<a name="line.17894"></a>
<FONT color="green">17895</FONT>       * @see #clearCurves clearCurves<a name="line.17895"></a>
<FONT color="green">17896</FONT>       */<a name="line.17896"></a>
<FONT color="green">17897</FONT>      public int getNCurves() {<a name="line.17897"></a>
<FONT color="green">17898</FONT>        return curves.size() - N_SYSTEM_CURVES;<a name="line.17898"></a>
<FONT color="green">17899</FONT>      }<a name="line.17899"></a>
<FONT color="green">17900</FONT>    <a name="line.17900"></a>
<FONT color="green">17901</FONT>      /**<a name="line.17901"></a>
<FONT color="green">17902</FONT>       * Returns the CSS string that specifies the width of the padding between the<a name="line.17902"></a>
<FONT color="green">17903</FONT>       * chart and it's external border<a name="line.17903"></a>
<FONT color="green">17904</FONT>       * &lt;p&gt;<a name="line.17904"></a>
<FONT color="green">17905</FONT>       * <a name="line.17905"></a>
<FONT color="green">17906</FONT>       * @return the CSS string that defines the CSS padding property for the GChart<a name="line.17906"></a>
<FONT color="green">17907</FONT>       *         as a whole.<a name="line.17907"></a>
<FONT color="green">17908</FONT>       * <a name="line.17908"></a>
<FONT color="green">17909</FONT>       * @see #setPadding(String) setPadding<a name="line.17909"></a>
<FONT color="green">17910</FONT>       * <a name="line.17910"></a>
<FONT color="green">17911</FONT>       */<a name="line.17911"></a>
<FONT color="green">17912</FONT>      public String getPadding() {<a name="line.17912"></a>
<FONT color="green">17913</FONT>        return padding;<a name="line.17913"></a>
<FONT color="green">17914</FONT>      }<a name="line.17914"></a>
<FONT color="green">17915</FONT>    <a name="line.17915"></a>
<FONT color="green">17916</FONT>      /**<a name="line.17916"></a>
<FONT color="green">17917</FONT>       * Returns the background color of the area of the chart in which symbols<a name="line.17917"></a>
<FONT color="green">17918</FONT>       * representing curve data are displayed<a name="line.17918"></a>
<FONT color="green">17919</FONT>       * <a name="line.17919"></a>
<FONT color="green">17920</FONT>       * @return CSS color string defining the plot area's background color<a name="line.17920"></a>
<FONT color="green">17921</FONT>       * <a name="line.17921"></a>
<FONT color="green">17922</FONT>       * @see #setPlotAreaBackgroundColor setPlotAreaBackgroundColor<a name="line.17922"></a>
<FONT color="green">17923</FONT>       */<a name="line.17923"></a>
<FONT color="green">17924</FONT>      public String getPlotAreaBackgroundColor() {<a name="line.17924"></a>
<FONT color="green">17925</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.17925"></a>
<FONT color="green">17926</FONT>        String result = c.getSymbol().getBackgroundColor();<a name="line.17926"></a>
<FONT color="green">17927</FONT>        return result;<a name="line.17927"></a>
<FONT color="green">17928</FONT>      }<a name="line.17928"></a>
<FONT color="green">17929</FONT>    <a name="line.17929"></a>
<FONT color="green">17930</FONT>      /**<a name="line.17930"></a>
<FONT color="green">17931</FONT>       * Returns the border color of the area of the chart in which symbols<a name="line.17931"></a>
<FONT color="green">17932</FONT>       * representing curve data are displayed<a name="line.17932"></a>
<FONT color="green">17933</FONT>       * <a name="line.17933"></a>
<FONT color="green">17934</FONT>       * @return CSS color string defining the color of the plot area's border<a name="line.17934"></a>
<FONT color="green">17935</FONT>       * <a name="line.17935"></a>
<FONT color="green">17936</FONT>       * @see #setPlotAreaBorderColor setPlotAreaBorderColor<a name="line.17936"></a>
<FONT color="green">17937</FONT>       */<a name="line.17937"></a>
<FONT color="green">17938</FONT>      public String getPlotAreaBorderColor() {<a name="line.17938"></a>
<FONT color="green">17939</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.17939"></a>
<FONT color="green">17940</FONT>        String result = c.getSymbol().getBorderColor();<a name="line.17940"></a>
<FONT color="green">17941</FONT>        return result;<a name="line.17941"></a>
<FONT color="green">17942</FONT>      }<a name="line.17942"></a>
<FONT color="green">17943</FONT>    <a name="line.17943"></a>
<FONT color="green">17944</FONT>      /**<a name="line.17944"></a>
<FONT color="green">17945</FONT>       * Returns the width of the border around the area of the chart in which<a name="line.17945"></a>
<FONT color="green">17946</FONT>       * symbols representing curve data are displayed.<a name="line.17946"></a>
<FONT color="green">17947</FONT>       * <a name="line.17947"></a>
<FONT color="green">17948</FONT>       * @return width, in pixels, of the border around the plot area<a name="line.17948"></a>
<FONT color="green">17949</FONT>       * <a name="line.17949"></a>
<FONT color="green">17950</FONT>       * @see #setPlotAreaBorderWidth setPlotAreaBorderWidth<a name="line.17950"></a>
<FONT color="green">17951</FONT>       */<a name="line.17951"></a>
<FONT color="green">17952</FONT>      public int getPlotAreaBorderWidth() {<a name="line.17952"></a>
<FONT color="green">17953</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.17953"></a>
<FONT color="green">17954</FONT>        int result = c.getSymbol().getBorderWidth();<a name="line.17954"></a>
<FONT color="green">17955</FONT>        return result;<a name="line.17955"></a>
<FONT color="green">17956</FONT>      }<a name="line.17956"></a>
<FONT color="green">17957</FONT>    <a name="line.17957"></a>
<FONT color="green">17958</FONT>      /**<a name="line.17958"></a>
<FONT color="green">17959</FONT>       * Returns the style of the border around the area of the chart in which<a name="line.17959"></a>
<FONT color="green">17960</FONT>       * symbols representing curve data are displayed (the so-called plot area).<a name="line.17960"></a>
<FONT color="green">17961</FONT>       * <a name="line.17961"></a>
<FONT color="green">17962</FONT>       * @return CSS style of the border around the plot area<a name="line.17962"></a>
<FONT color="green">17963</FONT>       * <a name="line.17963"></a>
<FONT color="green">17964</FONT>       * @see #setPlotAreaBorderStyle setPlotAreaBorderStyle<a name="line.17964"></a>
<FONT color="green">17965</FONT>       */<a name="line.17965"></a>
<FONT color="green">17966</FONT>      public String getPlotAreaBorderStyle() {<a name="line.17966"></a>
<FONT color="green">17967</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.17967"></a>
<FONT color="green">17968</FONT>        String result = c.getSymbol().getBorderStyle();<a name="line.17968"></a>
<FONT color="green">17969</FONT>        return result;<a name="line.17969"></a>
<FONT color="green">17970</FONT>      }<a name="line.17970"></a>
<FONT color="green">17971</FONT>    <a name="line.17971"></a>
<FONT color="green">17972</FONT>      /**<a name="line.17972"></a>
<FONT color="green">17973</FONT>       * <a name="line.17973"></a>
<FONT color="green">17974</FONT>       * Returns the image URL that will be used to define the plot area's<a name="line.17974"></a>
<FONT color="green">17975</FONT>       * background the next time &lt;tt&gt;update&lt;/tt&gt; is called.<a name="line.17975"></a>
<FONT color="green">17976</FONT>       * &lt;p&gt;<a name="line.17976"></a>
<FONT color="green">17977</FONT>       * <a name="line.17977"></a>
<FONT color="green">17978</FONT>       * @return url of image to be used as the background of the plot area the next<a name="line.17978"></a>
<FONT color="green">17979</FONT>       *         time that &lt;tt&gt;update&lt;/tt&gt; is called.<a name="line.17979"></a>
<FONT color="green">17980</FONT>       * <a name="line.17980"></a>
<FONT color="green">17981</FONT>       * @see #setPlotAreaImageURL setPlotAreaImageURL<a name="line.17981"></a>
<FONT color="green">17982</FONT>       * @see #update update<a name="line.17982"></a>
<FONT color="green">17983</FONT>       * <a name="line.17983"></a>
<FONT color="green">17984</FONT>       */<a name="line.17984"></a>
<FONT color="green">17985</FONT>      public String getPlotAreaImageURL() {<a name="line.17985"></a>
<FONT color="green">17986</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.17986"></a>
<FONT color="green">17987</FONT>        String result = c.getSymbol().getImageURL();<a name="line.17987"></a>
<FONT color="green">17988</FONT>        return result;<a name="line.17988"></a>
<FONT color="green">17989</FONT>      }<a name="line.17989"></a>
<FONT color="green">17990</FONT>    <a name="line.17990"></a>
<FONT color="green">17991</FONT>      /**<a name="line.17991"></a>
<FONT color="green">17992</FONT>       * <a name="line.17992"></a>
<FONT color="green">17993</FONT>       * Returns a flag that tells if GChart is configured to perform updates so<a name="line.17993"></a>
<FONT color="green">17994</FONT>       * that the chart uses less memory.<a name="line.17994"></a>
<FONT color="green">17995</FONT>       * <a name="line.17995"></a>
<FONT color="green">17996</FONT>       * @return &lt;tt&gt;true&lt;/tt&gt; if GChart optimizes updates to save memory,<a name="line.17996"></a>
<FONT color="green">17997</FONT>       *         &lt;tt&gt;false&lt;/tt&gt; (the default) if it optimizes them to save time.<a name="line.17997"></a>
<FONT color="green">17998</FONT>       * <a name="line.17998"></a>
<FONT color="green">17999</FONT>       * @see #setOptimizeForMemory setOptimizeForMemory<a name="line.17999"></a>
<FONT color="green">18000</FONT>       * <a name="line.18000"></a>
<FONT color="green">18001</FONT>       */<a name="line.18001"></a>
<FONT color="green">18002</FONT>      public boolean getOptimizeForMemory() {<a name="line.18002"></a>
<FONT color="green">18003</FONT>        return optimizeForMemory;<a name="line.18003"></a>
<FONT color="green">18004</FONT>      }<a name="line.18004"></a>
<FONT color="green">18005</FONT>    <a name="line.18005"></a>
<FONT color="green">18006</FONT>      /**<a name="line.18006"></a>
<FONT color="green">18007</FONT>       * Returns the previously specified render padding factor.<a name="line.18007"></a>
<FONT color="green">18008</FONT>       * <a name="line.18008"></a>
<FONT color="green">18009</FONT>       * @return the render padding factor<a name="line.18009"></a>
<FONT color="green">18010</FONT>       * <a name="line.18010"></a>
<FONT color="green">18011</FONT>       * @see #setRenderPaddingFactor setRenderPaddingFactor<a name="line.18011"></a>
<FONT color="green">18012</FONT>       * <a name="line.18012"></a>
<FONT color="green">18013</FONT>       */<a name="line.18013"></a>
<FONT color="green">18014</FONT>      public double getRenderPaddingFactor() {<a name="line.18014"></a>
<FONT color="green">18015</FONT>        return renderPaddingFactor;<a name="line.18015"></a>
<FONT color="green">18016</FONT>      }<a name="line.18016"></a>
<FONT color="green">18017</FONT>    <a name="line.18017"></a>
<FONT color="green">18018</FONT>      /**<a name="line.18018"></a>
<FONT color="green">18019</FONT>       * @deprecated<a name="line.18019"></a>
<FONT color="green">18020</FONT>       * <a name="line.18020"></a>
<FONT color="green">18021</FONT>       *             Equivalent to &lt;tt&gt;!getClipToPlotArea()&lt;/tt&gt;. Use that method<a name="line.18021"></a>
<FONT color="green">18022</FONT>       *             instead.<a name="line.18022"></a>
<FONT color="green">18023</FONT>       * <a name="line.18023"></a>
<FONT color="green">18024</FONT>       * @see #getClipToPlotArea getClipToPlotArea<a name="line.18024"></a>
<FONT color="green">18025</FONT>       */<a name="line.18025"></a>
<FONT color="green">18026</FONT>    <a name="line.18026"></a>
<FONT color="green">18027</FONT>      public boolean getShowOffChartPoints() {<a name="line.18027"></a>
<FONT color="green">18028</FONT>        return !getClipToPlotArea();<a name="line.18028"></a>
<FONT color="green">18029</FONT>      }<a name="line.18029"></a>
<FONT color="green">18030</FONT>    <a name="line.18030"></a>
<FONT color="green">18031</FONT>      /**<a name="line.18031"></a>
<FONT color="green">18032</FONT>       * @deprecated<a name="line.18032"></a>
<FONT color="green">18033</FONT>       * <a name="line.18033"></a>
<FONT color="green">18034</FONT>       *             Equivalent to &lt;tt&gt;!getClipToDecoratedChart()&lt;/tt&gt;. Use that<a name="line.18034"></a>
<FONT color="green">18035</FONT>       *             method instead.<a name="line.18035"></a>
<FONT color="green">18036</FONT>       * <a name="line.18036"></a>
<FONT color="green">18037</FONT>       * @see #getClipToDecoratedChart getClipToDecoratedChart<a name="line.18037"></a>
<FONT color="green">18038</FONT>       * <a name="line.18038"></a>
<FONT color="green">18039</FONT>       */<a name="line.18039"></a>
<FONT color="green">18040</FONT>      public boolean getShowOffDecoratedChartGlyphs() {<a name="line.18040"></a>
<FONT color="green">18041</FONT>        return !getClipToDecoratedChart();<a name="line.18041"></a>
<FONT color="green">18042</FONT>      }<a name="line.18042"></a>
<FONT color="green">18043</FONT>    <a name="line.18043"></a>
<FONT color="green">18044</FONT>      /**<a name="line.18044"></a>
<FONT color="green">18045</FONT>       * Returns a URL that points to a 1 x 1 pixel blank image file GChart requires<a name="line.18045"></a>
<FONT color="green">18046</FONT>       * to render its charts without producing missing image icons.<a name="line.18046"></a>
<FONT color="green">18047</FONT>       * <a name="line.18047"></a>
<FONT color="green">18048</FONT>       * &lt;p&gt;<a name="line.18048"></a>
<FONT color="green">18049</FONT>       * <a name="line.18049"></a>
<FONT color="green">18050</FONT>       * @return the URL of the file GChart needs to prevent missing image icons<a name="line.18050"></a>
<FONT color="green">18051</FONT>       *         from appearing on your chart.<a name="line.18051"></a>
<FONT color="green">18052</FONT>       * <a name="line.18052"></a>
<FONT color="green">18053</FONT>       * @see #setBlankImageURL setBlankImageURL<a name="line.18053"></a>
<FONT color="green">18054</FONT>       * <a name="line.18054"></a>
<FONT color="green">18055</FONT>       */<a name="line.18055"></a>
<FONT color="green">18056</FONT>    <a name="line.18056"></a>
<FONT color="green">18057</FONT>      public static String getBlankImageURL() {<a name="line.18057"></a>
<FONT color="green">18058</FONT>        return null == blankImageURL ? DEFAULT_BLANK_IMAGE_URL_FULLPATH<a name="line.18058"></a>
<FONT color="green">18059</FONT>            : blankImageURL;<a name="line.18059"></a>
<FONT color="green">18060</FONT>      }<a name="line.18060"></a>
<FONT color="green">18061</FONT>    <a name="line.18061"></a>
<FONT color="green">18062</FONT>      private static Object currentCurveData = null;<a name="line.18062"></a>
<FONT color="green">18063</FONT>    <a name="line.18063"></a>
<FONT color="green">18064</FONT>      /**<a name="line.18064"></a>
<FONT color="green">18065</FONT>       * <a name="line.18065"></a>
<FONT color="green">18066</FONT>       * Returns a reference to the auxiliary data object of the curve that is<a name="line.18066"></a>
<FONT color="green">18067</FONT>       * currently being rendered by GChart. If no curve is currently being<a name="line.18067"></a>
<FONT color="green">18068</FONT>       * rendered, returns &lt;tt&gt;null&lt;/tt&gt;.<a name="line.18068"></a>
<FONT color="green">18069</FONT>       * <a name="line.18069"></a>
<FONT color="green">18070</FONT>       * &lt;p&gt;<a name="line.18070"></a>
<FONT color="green">18071</FONT>       * <a name="line.18071"></a>
<FONT color="green">18072</FONT>       * Vector graphics widgets that implement &lt;tt&gt;GChartCanvasLite&lt;/tt&gt; can use<a name="line.18072"></a>
<FONT color="green">18073</FONT>       * this method to retrieve auxiliary curve data that can then be used to<a name="line.18073"></a>
<FONT color="green">18074</FONT>       * control advanced features of the vector graphics (<a name="line.18074"></a>
<FONT color="green">18075</FONT>       * &lt;tt&gt;GChartCanvasLite&lt;/tt&gt; implementing) widget that GChart does not<a name="line.18075"></a>
<FONT color="green">18076</FONT>       * directly support. In other words, this method lets you access any custom<a name="line.18076"></a>
<FONT color="green">18077</FONT>       * curve specific data you may need to extend GChart's vector graphics<a name="line.18077"></a>
<FONT color="green">18078</FONT>       * capabilities in various ways.<a name="line.18078"></a>
<FONT color="green">18079</FONT>       * <a name="line.18079"></a>
<FONT color="green">18080</FONT>       * &lt;p&gt;<a name="line.18080"></a>
<FONT color="green">18081</FONT>       * <a name="line.18081"></a>
<FONT color="green">18082</FONT>       * For example, the GChart live demo uses this method to retrieve a special<a name="line.18082"></a>
<FONT color="green">18083</FONT>       * "Catmull-Rom tension parameter" from the curve's auxiliary data that it<a name="line.18083"></a>
<FONT color="green">18084</FONT>       * uses to adjust the amount of "curvyness" in its various connecting lines.<a name="line.18084"></a>
<FONT color="green">18085</FONT>       * By default, GChart only supports straight connecting lines so the live demo<a name="line.18085"></a>
<FONT color="green">18086</FONT>       * overrides the &lt;tt&gt;lineTo&lt;/tt&gt; method in its &lt;tt&gt;GChartCanvasLite&lt;/tt&gt;<a name="line.18086"></a>
<FONT color="green">18087</FONT>       * implementation so as to call the GWTCanvas method's &lt;tt&gt;cubicCurveTo&lt;/tt&gt;<a name="line.18087"></a>
<FONT color="green">18088</FONT>       * to produce curvy connecting lines with the specified amount of "tension".<a name="line.18088"></a>
<FONT color="green">18089</FONT>       * &lt;p&gt;<a name="line.18089"></a>
<FONT color="green">18090</FONT>       * <a name="line.18090"></a>
<FONT color="green">18091</FONT>       * As you've probably gathered by now, this kind of thing is not for the faint<a name="line.18091"></a>
<FONT color="green">18092</FONT>       * of heart, and relies on hidden connections with aspects of GChart's<a name="line.18092"></a>
<FONT color="green">18093</FONT>       * internal implementation that could break your code in future GChart<a name="line.18093"></a>
<FONT color="green">18094</FONT>       * releases. On the other hand, there are a myriad of vector graphics library<a name="line.18094"></a>
<FONT color="green">18095</FONT>       * features GChart does not support (curvy lines, gradients, image-based area<a name="line.18095"></a>
<FONT color="green">18096</FONT>       * filling, etc.) and this "backdoor" approach is flexible enough that, if you<a name="line.18096"></a>
<FONT color="green">18097</FONT>       * work a bit, you may be able to exploit many of these advanced features in<a name="line.18097"></a>
<FONT color="green">18098</FONT>       * your charts.<a name="line.18098"></a>
<FONT color="green">18099</FONT>       * &lt;p&gt;<a name="line.18099"></a>
<FONT color="green">18100</FONT>       * <a name="line.18100"></a>
<FONT color="green">18101</FONT>       * If you implement such a rendering extension that would be helpful to<a name="line.18101"></a>
<FONT color="green">18102</FONT>       * others, please share it on the GChart issue tracker. As we learn more about<a name="line.18102"></a>
<FONT color="green">18103</FONT>       * how people exploit this backdoor, we can probably improve it, make it more<a name="line.18103"></a>
<FONT color="green">18104</FONT>       * reliable, and/or incorporate new vector graphics capabilities directly into<a name="line.18104"></a>
<FONT color="green">18105</FONT>       * GChart.<a name="line.18105"></a>
<FONT color="green">18106</FONT>       * &lt;p&gt;<a name="line.18106"></a>
<FONT color="green">18107</FONT>       * <a name="line.18107"></a>
<FONT color="green">18108</FONT>       * &lt;i&gt;Tip:&lt;/i&gt; This method does not return a reference to the curve itself,<a name="line.18108"></a>
<FONT color="green">18109</FONT>       * because GChart's rendering code assumes that curve specifications proper do<a name="line.18109"></a>
<FONT color="green">18110</FONT>       * not change during rendering. If really you need to get at the curve itself,<a name="line.18110"></a>
<FONT color="green">18111</FONT>       * store a reference to it within your custom data object.<a name="line.18111"></a>
<FONT color="green">18112</FONT>       * <a name="line.18112"></a>
<FONT color="green">18113</FONT>       * @see GChartCanvasLite GChartCanvasLite<a name="line.18113"></a>
<FONT color="green">18114</FONT>       * @see #setCanvasFactory setCanvasFactory<a name="line.18114"></a>
<FONT color="green">18115</FONT>       * @see Curve#setCurveData setCurveData<a name="line.18115"></a>
<FONT color="green">18116</FONT>       * <a name="line.18116"></a>
<FONT color="green">18117</FONT>       * @return the auxiliary, developer-defined, curve data object associated with<a name="line.18117"></a>
<FONT color="green">18118</FONT>       *         the currently-being-rendered curve, or &lt;tt&gt;null&lt;/tt&gt; if no curve is<a name="line.18118"></a>
<FONT color="green">18119</FONT>       *         currently being rendered.<a name="line.18119"></a>
<FONT color="green">18120</FONT>       * <a name="line.18120"></a>
<FONT color="green">18121</FONT>       */<a name="line.18121"></a>
<FONT color="green">18122</FONT>      public static Object getCurrentCurveData() {<a name="line.18122"></a>
<FONT color="green">18123</FONT>        return currentCurveData;<a name="line.18123"></a>
<FONT color="green">18124</FONT>      }<a name="line.18124"></a>
<FONT color="green">18125</FONT>    <a name="line.18125"></a>
<FONT color="green">18126</FONT>      private HoverParameterInterpreter hoverParameterInterpreter = null;<a name="line.18126"></a>
<FONT color="green">18127</FONT>    <a name="line.18127"></a>
<FONT color="green">18128</FONT>      /**<a name="line.18128"></a>
<FONT color="green">18129</FONT>       * Returns this GChart's hover parameter interpreter.<a name="line.18129"></a>
<FONT color="green">18130</FONT>       * <a name="line.18130"></a>
<FONT color="green">18131</FONT>       * @see #setHoverParameterInterpreter setHoverParameterInterpreter<a name="line.18131"></a>
<FONT color="green">18132</FONT>       * <a name="line.18132"></a>
<FONT color="green">18133</FONT>       * @return the hover parameter interpreter used by this GChart, or<a name="line.18133"></a>
<FONT color="green">18134</FONT>       *         &lt;tt&gt;null&lt;/tt&gt; if none.<a name="line.18134"></a>
<FONT color="green">18135</FONT>       * <a name="line.18135"></a>
<FONT color="green">18136</FONT>       */<a name="line.18136"></a>
<FONT color="green">18137</FONT>      public HoverParameterInterpreter getHoverParameterInterpreter() {<a name="line.18137"></a>
<FONT color="green">18138</FONT>        return hoverParameterInterpreter;<a name="line.18138"></a>
<FONT color="green">18139</FONT>      }<a name="line.18139"></a>
<FONT color="green">18140</FONT>    <a name="line.18140"></a>
<FONT color="green">18141</FONT>      private boolean hoverTouchingEnabled = true;<a name="line.18141"></a>
<FONT color="green">18142</FONT>    <a name="line.18142"></a>
<FONT color="green">18143</FONT>      /**<a name="line.18143"></a>
<FONT color="green">18144</FONT>       * Is it possible to select points and have their hover annotations pop up,<a name="line.18144"></a>
<FONT color="green">18145</FONT>       * merely by "touching" them with the mouse-attached "brush"?<a name="line.18145"></a>
<FONT color="green">18146</FONT>       * <a name="line.18146"></a>
<FONT color="green">18147</FONT>       * @return true (the default) if just hovering over a point can select it,<a name="line.18147"></a>
<FONT color="green">18148</FONT>       *         false if you must click on a point to select it.<a name="line.18148"></a>
<FONT color="green">18149</FONT>       * <a name="line.18149"></a>
<FONT color="green">18150</FONT>       * @see #setHoverTouchingEnabled setHoverTouchingEnabled<a name="line.18150"></a>
<FONT color="green">18151</FONT>       * <a name="line.18151"></a>
<FONT color="green">18152</FONT>       */<a name="line.18152"></a>
<FONT color="green">18153</FONT>      public boolean getHoverTouchingEnabled() {<a name="line.18153"></a>
<FONT color="green">18154</FONT>        return hoverTouchingEnabled;<a name="line.18154"></a>
<FONT color="green">18155</FONT>      }<a name="line.18155"></a>
<FONT color="green">18156</FONT>    <a name="line.18156"></a>
<FONT color="green">18157</FONT>      /**<a name="line.18157"></a>
<FONT color="green">18158</FONT>       * Returns the x-axis associated with this chart. Use the returned reference<a name="line.18158"></a>
<FONT color="green">18159</FONT>       * to manipulate axis min and max, number of ticks, tick positions, tick label<a name="line.18159"></a>
<FONT color="green">18160</FONT>       * formats, etc.<a name="line.18160"></a>
<FONT color="green">18161</FONT>       * &lt;p&gt;<a name="line.18161"></a>
<FONT color="green">18162</FONT>       * <a name="line.18162"></a>
<FONT color="green">18163</FONT>       * @return object representing the x-axis of this chart.<a name="line.18163"></a>
<FONT color="green">18164</FONT>       * <a name="line.18164"></a>
<FONT color="green">18165</FONT>       * @see #getYAxis getYAxis<a name="line.18165"></a>
<FONT color="green">18166</FONT>       * @see #getY2Axis getY2Axis<a name="line.18166"></a>
<FONT color="green">18167</FONT>       */<a name="line.18167"></a>
<FONT color="green">18168</FONT>      public Axis getXAxis() {<a name="line.18168"></a>
<FONT color="green">18169</FONT>        return xAxis;<a name="line.18169"></a>
<FONT color="green">18170</FONT>      }<a name="line.18170"></a>
<FONT color="green">18171</FONT>    <a name="line.18171"></a>
<FONT color="green">18172</FONT>      /**<a name="line.18172"></a>
<FONT color="green">18173</FONT>       * Returns the number of x-pixels in the region of the chart used for curve<a name="line.18173"></a>
<FONT color="green">18174</FONT>       * display purposes.<a name="line.18174"></a>
<FONT color="green">18175</FONT>       * <a name="line.18175"></a>
<FONT color="green">18176</FONT>       * @return the number of x-pixels available for curve display.<a name="line.18176"></a>
<FONT color="green">18177</FONT>       * <a name="line.18177"></a>
<FONT color="green">18178</FONT>       * @see #setXChartSize setXChartSize<a name="line.18178"></a>
<FONT color="green">18179</FONT>       * <a name="line.18179"></a>
<FONT color="green">18180</FONT>       */<a name="line.18180"></a>
<FONT color="green">18181</FONT>      public int getXChartSize() {<a name="line.18181"></a>
<FONT color="green">18182</FONT>        return xChartSize;<a name="line.18182"></a>
<FONT color="green">18183</FONT>      }<a name="line.18183"></a>
<FONT color="green">18184</FONT>    <a name="line.18184"></a>
<FONT color="green">18185</FONT>      /**<a name="line.18185"></a>
<FONT color="green">18186</FONT>       * Returns the number of x-pixels reserved for the chart as a whole, including<a name="line.18186"></a>
<FONT color="green">18187</FONT>       * space reserved for decorations (title, footnotes, axis labels, ticks, tick<a name="line.18187"></a>
<FONT color="green">18188</FONT>       * labels, legend key, etc.).<a name="line.18188"></a>
<FONT color="green">18189</FONT>       * &lt;p&gt;<a name="line.18189"></a>
<FONT color="green">18190</FONT>       * <a name="line.18190"></a>
<FONT color="green">18191</FONT>       * The returned size does not include the border or padding around the chart<a name="line.18191"></a>
<FONT color="green">18192</FONT>       * as a whole.<a name="line.18192"></a>
<FONT color="green">18193</FONT>       * &lt;p&gt;<a name="line.18193"></a>
<FONT color="green">18194</FONT>       * <a name="line.18194"></a>
<FONT color="green">18195</FONT>       * You cannot directly set the decorated x chart size. Instead, you must set<a name="line.18195"></a>
<FONT color="green">18196</FONT>       * the width of the plot area, and the thicknesses of certain of the<a name="line.18196"></a>
<FONT color="green">18197</FONT>       * decoration-holding regions (using methods linked to below) that, summed<a name="line.18197"></a>
<FONT color="green">18198</FONT>       * together, define the total width of the chart.<a name="line.18198"></a>
<FONT color="green">18199</FONT>       * <a name="line.18199"></a>
<FONT color="green">18200</FONT>       * @return the width of the entire chart, in pixels.<a name="line.18200"></a>
<FONT color="green">18201</FONT>       * <a name="line.18201"></a>
<FONT color="green">18202</FONT>       * @see #setXChartSize setXChartSize<a name="line.18202"></a>
<FONT color="green">18203</FONT>       * @see #getYChartSizeDecorated getYChartSizeDecorated<a name="line.18203"></a>
<FONT color="green">18204</FONT>       * @see Axis#setAxisLabelThickness setAxisLabelThickness<a name="line.18204"></a>
<FONT color="green">18205</FONT>       * @see Axis#setTickLabelThickness setTickLabelThickness<a name="line.18205"></a>
<FONT color="green">18206</FONT>       * @see Axis#setTickLength setTickLength<a name="line.18206"></a>
<FONT color="green">18207</FONT>       * @see Axis#setTickLocation setTickLocation<a name="line.18207"></a>
<FONT color="green">18208</FONT>       * @see Axis#setTickLabelPadding setTickLabelPadding<a name="line.18208"></a>
<FONT color="green">18209</FONT>       * @see Axis#setLegendThickness setLegendThickness<a name="line.18209"></a>
<FONT color="green">18210</FONT>       * <a name="line.18210"></a>
<FONT color="green">18211</FONT>       */<a name="line.18211"></a>
<FONT color="green">18212</FONT>      public int getXChartSizeDecorated() {<a name="line.18212"></a>
<FONT color="green">18213</FONT>        int result = getXChartSize() + getYAxis().getAxisLabelThickness()<a name="line.18213"></a>
<FONT color="green">18214</FONT>            + getYAxis().getTickLabelThickness()<a name="line.18214"></a>
<FONT color="green">18215</FONT>            + getYAxis().getTickSpace() + getYAxis().getTickLabelPadding()<a name="line.18215"></a>
<FONT color="green">18216</FONT>            + getY2Axis().getAxisLabelThickness()<a name="line.18216"></a>
<FONT color="green">18217</FONT>            + getY2Axis().getTickLabelThickness()<a name="line.18217"></a>
<FONT color="green">18218</FONT>            + getY2Axis().getTickSpace()<a name="line.18218"></a>
<FONT color="green">18219</FONT>            + getY2Axis().getTickLabelPadding()<a name="line.18219"></a>
<FONT color="green">18220</FONT>            + legendLocation.getLeftThickness(this)<a name="line.18220"></a>
<FONT color="green">18221</FONT>            + legendLocation.getRightThickness(this);<a name="line.18221"></a>
<FONT color="green">18222</FONT>        return result;<a name="line.18222"></a>
<FONT color="green">18223</FONT>      }<a name="line.18223"></a>
<FONT color="green">18224</FONT>    <a name="line.18224"></a>
<FONT color="green">18225</FONT>      /**<a name="line.18225"></a>
<FONT color="green">18226</FONT>       * Returns the y2-axis (right y axis) associated with this chart. Use the<a name="line.18226"></a>
<FONT color="green">18227</FONT>       * returned reference to manipulate axis min and max, number of ticks, tick<a name="line.18227"></a>
<FONT color="green">18228</FONT>       * positions, tick label formats, etc.<a name="line.18228"></a>
<FONT color="green">18229</FONT>       * <a name="line.18229"></a>
<FONT color="green">18230</FONT>       * &lt;p&gt;<a name="line.18230"></a>
<FONT color="green">18231</FONT>       * <a name="line.18231"></a>
<FONT color="green">18232</FONT>       * @return object representing the y2-axis of this chart.<a name="line.18232"></a>
<FONT color="green">18233</FONT>       * <a name="line.18233"></a>
<FONT color="green">18234</FONT>       * @see #getYAxis getYAxis<a name="line.18234"></a>
<FONT color="green">18235</FONT>       * @see #getXAxis getXAxis<a name="line.18235"></a>
<FONT color="green">18236</FONT>       */<a name="line.18236"></a>
<FONT color="green">18237</FONT>      public Axis getY2Axis() {<a name="line.18237"></a>
<FONT color="green">18238</FONT>        return y2Axis;<a name="line.18238"></a>
<FONT color="green">18239</FONT>      }<a name="line.18239"></a>
<FONT color="green">18240</FONT>    <a name="line.18240"></a>
<FONT color="green">18241</FONT>      /**<a name="line.18241"></a>
<FONT color="green">18242</FONT>       * Returns the (left) y-axis associated with this chart. Use the returned<a name="line.18242"></a>
<FONT color="green">18243</FONT>       * reference to manipulate axis min and max, number of ticks, tick positions,<a name="line.18243"></a>
<FONT color="green">18244</FONT>       * tick label formats, etc.<a name="line.18244"></a>
<FONT color="green">18245</FONT>       * &lt;p&gt;<a name="line.18245"></a>
<FONT color="green">18246</FONT>       * <a name="line.18246"></a>
<FONT color="green">18247</FONT>       * @return object representing the y-axis of this chart.<a name="line.18247"></a>
<FONT color="green">18248</FONT>       * <a name="line.18248"></a>
<FONT color="green">18249</FONT>       * @see #getXAxis getXAxis<a name="line.18249"></a>
<FONT color="green">18250</FONT>       * @see #getY2Axis getY2Axis<a name="line.18250"></a>
<FONT color="green">18251</FONT>       */<a name="line.18251"></a>
<FONT color="green">18252</FONT>      public Axis getYAxis() {<a name="line.18252"></a>
<FONT color="green">18253</FONT>        return yAxis;<a name="line.18253"></a>
<FONT color="green">18254</FONT>      }<a name="line.18254"></a>
<FONT color="green">18255</FONT>    <a name="line.18255"></a>
<FONT color="green">18256</FONT>      /**<a name="line.18256"></a>
<FONT color="green">18257</FONT>       * Returns the number of y-pixels in the region of the chart used for curve<a name="line.18257"></a>
<FONT color="green">18258</FONT>       * display purposes.<a name="line.18258"></a>
<FONT color="green">18259</FONT>       * <a name="line.18259"></a>
<FONT color="green">18260</FONT>       * @return the number of y-pixels available for curve display.<a name="line.18260"></a>
<FONT color="green">18261</FONT>       * <a name="line.18261"></a>
<FONT color="green">18262</FONT>       * @see #setYChartSize setYChartSize<a name="line.18262"></a>
<FONT color="green">18263</FONT>       * <a name="line.18263"></a>
<FONT color="green">18264</FONT>       */<a name="line.18264"></a>
<FONT color="green">18265</FONT>      public int getYChartSize() {<a name="line.18265"></a>
<FONT color="green">18266</FONT>        return yChartSize;<a name="line.18266"></a>
<FONT color="green">18267</FONT>      }<a name="line.18267"></a>
<FONT color="green">18268</FONT>    <a name="line.18268"></a>
<FONT color="green">18269</FONT>      /**<a name="line.18269"></a>
<FONT color="green">18270</FONT>       * Returns the number of y-pixels reserved for the chart as a whole, including<a name="line.18270"></a>
<FONT color="green">18271</FONT>       * space reserved for decorations (title, footnotes, axis labels, ticks, tick<a name="line.18271"></a>
<FONT color="green">18272</FONT>       * labels, etc.).<a name="line.18272"></a>
<FONT color="green">18273</FONT>       * &lt;p&gt;<a name="line.18273"></a>
<FONT color="green">18274</FONT>       * <a name="line.18274"></a>
<FONT color="green">18275</FONT>       * The returned size does not include the border or padding around the chart<a name="line.18275"></a>
<FONT color="green">18276</FONT>       * as a whole.<a name="line.18276"></a>
<FONT color="green">18277</FONT>       * &lt;p&gt;<a name="line.18277"></a>
<FONT color="green">18278</FONT>       * <a name="line.18278"></a>
<FONT color="green">18279</FONT>       * You cannot directly set the decorated y chart size. Instead, you must set<a name="line.18279"></a>
<FONT color="green">18280</FONT>       * sizes and thicknesses of the plot area and certain of the<a name="line.18280"></a>
<FONT color="green">18281</FONT>       * decoration-holding regions (using the methods linked-to below) that, when<a name="line.18281"></a>
<FONT color="green">18282</FONT>       * summed together, define the height of the decorated chart.<a name="line.18282"></a>
<FONT color="green">18283</FONT>       * <a name="line.18283"></a>
<FONT color="green">18284</FONT>       * @return the height of the entire chart, in pixels.<a name="line.18284"></a>
<FONT color="green">18285</FONT>       * <a name="line.18285"></a>
<FONT color="green">18286</FONT>       * @see #setYChartSize setYChartSize<a name="line.18286"></a>
<FONT color="green">18287</FONT>       * @see #getXChartSizeDecorated getXChartSizeDecorated<a name="line.18287"></a>
<FONT color="green">18288</FONT>       * @see Axis#setAxisLabelThickness setAxisLabelThickness<a name="line.18288"></a>
<FONT color="green">18289</FONT>       * @see Axis#setTickLabelThickness setTickLabelThickness<a name="line.18289"></a>
<FONT color="green">18290</FONT>       * @see Axis#setTickLength setTickLength<a name="line.18290"></a>
<FONT color="green">18291</FONT>       * @see Axis#setTickLocation setTickLocation<a name="line.18291"></a>
<FONT color="green">18292</FONT>       * @see Axis#setTickLabelPadding setTickLabelPadding<a name="line.18292"></a>
<FONT color="green">18293</FONT>       * @see #setChartTitleThickness setChartTitleThickness<a name="line.18293"></a>
<FONT color="green">18294</FONT>       * @see #setChartFootnotesThickness setChartFootnotesThickness<a name="line.18294"></a>
<FONT color="green">18295</FONT>       * <a name="line.18295"></a>
<FONT color="green">18296</FONT>       */<a name="line.18296"></a>
<FONT color="green">18297</FONT>      public int getYChartSizeDecorated() {<a name="line.18297"></a>
<FONT color="green">18298</FONT>        int result = getYChartSize() + getXAxis().getAxisLabelThickness()<a name="line.18298"></a>
<FONT color="green">18299</FONT>            + getXAxis().getTickLabelThickness()<a name="line.18299"></a>
<FONT color="green">18300</FONT>            + getXAxis().getTickSpace() + getXAxis().getTickLabelPadding()<a name="line.18300"></a>
<FONT color="green">18301</FONT>            + getChartTitleThickness() + getChartFootnotesThickness();<a name="line.18301"></a>
<FONT color="green">18302</FONT>    <a name="line.18302"></a>
<FONT color="green">18303</FONT>        return result;<a name="line.18303"></a>
<FONT color="green">18304</FONT>      }<a name="line.18304"></a>
<FONT color="green">18305</FONT>    <a name="line.18305"></a>
<FONT color="green">18306</FONT>      /**<a name="line.18306"></a>
<FONT color="green">18307</FONT>       * Determines if this chart has a "y2" (right) y-axis.<a name="line.18307"></a>
<FONT color="green">18308</FONT>       * &lt;p&gt;<a name="line.18308"></a>
<FONT color="green">18309</FONT>       * Only charts that have at least one curve on the right y axis will have a<a name="line.18309"></a>
<FONT color="green">18310</FONT>       * y2-axis.<a name="line.18310"></a>
<FONT color="green">18311</FONT>       * <a name="line.18311"></a>
<FONT color="green">18312</FONT>       * @return true if the chart has a second y axis, false otherwise.<a name="line.18312"></a>
<FONT color="green">18313</FONT>       * <a name="line.18313"></a>
<FONT color="green">18314</FONT>       * @see Curve#setYAxis Curve.setYAxis<a name="line.18314"></a>
<FONT color="green">18315</FONT>       */<a name="line.18315"></a>
<FONT color="green">18316</FONT>      public boolean hasY2Axis() {<a name="line.18316"></a>
<FONT color="green">18317</FONT>        boolean result = getY2Axis().getNCurvesVisibleOnAxis() &gt; 0;<a name="line.18317"></a>
<FONT color="green">18318</FONT>        return result;<a name="line.18318"></a>
<FONT color="green">18319</FONT>      }<a name="line.18319"></a>
<FONT color="green">18320</FONT>    <a name="line.18320"></a>
<FONT color="green">18321</FONT>      /**<a name="line.18321"></a>
<FONT color="green">18322</FONT>       * Determines if this chart has an ordinary, or left, y-axis.<a name="line.18322"></a>
<FONT color="green">18323</FONT>       * &lt;p&gt;<a name="line.18323"></a>
<FONT color="green">18324</FONT>       * Only charts that have at least one curve on the left y axis will have a<a name="line.18324"></a>
<FONT color="green">18325</FONT>       * y-axis.<a name="line.18325"></a>
<FONT color="green">18326</FONT>       * <a name="line.18326"></a>
<FONT color="green">18327</FONT>       * @return true if the chart has a left y axis, false otherwise<a name="line.18327"></a>
<FONT color="green">18328</FONT>       * <a name="line.18328"></a>
<FONT color="green">18329</FONT>       * @see Curve#setYAxis Curve.setYAxis<a name="line.18329"></a>
<FONT color="green">18330</FONT>       * <a name="line.18330"></a>
<FONT color="green">18331</FONT>       */<a name="line.18331"></a>
<FONT color="green">18332</FONT>      public boolean hasYAxis() {<a name="line.18332"></a>
<FONT color="green">18333</FONT>        boolean result = getYAxis().getNCurvesVisibleOnAxis() &gt; 0;<a name="line.18333"></a>
<FONT color="green">18334</FONT>        return result;<a name="line.18334"></a>
<FONT color="green">18335</FONT>      }<a name="line.18335"></a>
<FONT color="green">18336</FONT>    <a name="line.18336"></a>
<FONT color="green">18337</FONT>      /**<a name="line.18337"></a>
<FONT color="green">18338</FONT>       * Determines if the legend of this chart is visible.<a name="line.18338"></a>
<FONT color="green">18339</FONT>       * <a name="line.18339"></a>
<FONT color="green">18340</FONT>       * <a name="line.18340"></a>
<FONT color="green">18341</FONT>       * @return true if the legend is visible, false otherwise.<a name="line.18341"></a>
<FONT color="green">18342</FONT>       * <a name="line.18342"></a>
<FONT color="green">18343</FONT>       * @see #setLegendVisible setLegendVisible<a name="line.18343"></a>
<FONT color="green">18344</FONT>       */<a name="line.18344"></a>
<FONT color="green">18345</FONT>      public boolean isLegendVisible() {<a name="line.18345"></a>
<FONT color="green">18346</FONT>        return isLegendVisible;<a name="line.18346"></a>
<FONT color="green">18347</FONT>      }<a name="line.18347"></a>
<FONT color="green">18348</FONT>    <a name="line.18348"></a>
<FONT color="green">18349</FONT>      /**<a name="line.18349"></a>
<FONT color="green">18350</FONT>       * <a name="line.18350"></a>
<FONT color="green">18351</FONT>       * Is the in-browser rendition of the chart inconsistent with the current<a name="line.18351"></a>
<FONT color="green">18352</FONT>       * chart specs? In other words, is a call to GChart's &lt;tt&gt;update&lt;/tt&gt; method<a name="line.18352"></a>
<FONT color="green">18353</FONT>       * needed to bring the browser's display into agreement with current chart<a name="line.18353"></a>
<FONT color="green">18354</FONT>       * specs?<a name="line.18354"></a>
<FONT color="green">18355</FONT>       * &lt;p&gt;<a name="line.18355"></a>
<FONT color="green">18356</FONT>       * <a name="line.18356"></a>
<FONT color="green">18357</FONT>       * &lt;i&gt;Note:&lt;/i&gt; Whenever this method returns &lt;tt&gt;true&lt;/tt&gt;, GChart "freezes"<a name="line.18357"></a>
<FONT color="green">18358</FONT>       * hover feedback, and can no longer actively track the currently "touched"<a name="line.18358"></a>
<FONT color="green">18359</FONT>       * point. This is because GChart, to simplify its bookkeeping, assumes<a name="line.18359"></a>
<FONT color="green">18360</FONT>       * in-browser (DOM) rendering and current chart specs are in synch when<a name="line.18360"></a>
<FONT color="green">18361</FONT>       * determining the point selection consequences of mouse events over the<a name="line.18361"></a>
<FONT color="green">18362</FONT>       * chart.<a name="line.18362"></a>
<FONT color="green">18363</FONT>       * <a name="line.18363"></a>
<FONT color="green">18364</FONT>       * @return true if a call to &lt;tt&gt;update&lt;/tt&gt; is needed to bring current chart<a name="line.18364"></a>
<FONT color="green">18365</FONT>       *         specifications and browser-rendered representation into synch,<a name="line.18365"></a>
<FONT color="green">18366</FONT>       *         false otherwise.<a name="line.18366"></a>
<FONT color="green">18367</FONT>       * <a name="line.18367"></a>
<FONT color="green">18368</FONT>       * @see #update update<a name="line.18368"></a>
<FONT color="green">18369</FONT>       * @see #getTouchedPoint getTouchedPoint<a name="line.18369"></a>
<FONT color="green">18370</FONT>       * <a name="line.18370"></a>
<FONT color="green">18371</FONT>       */<a name="line.18371"></a>
<FONT color="green">18372</FONT>      public boolean isUpdateNeeded() {<a name="line.18372"></a>
<FONT color="green">18373</FONT>        boolean result = chartDecorationsChanged || !plotPanel.isValidated();<a name="line.18373"></a>
<FONT color="green">18374</FONT>        return result;<a name="line.18374"></a>
<FONT color="green">18375</FONT>      }<a name="line.18375"></a>
<FONT color="green">18376</FONT>    <a name="line.18376"></a>
<FONT color="green">18377</FONT>      /**<a name="line.18377"></a>
<FONT color="green">18378</FONT>       * Removes the curve at the specified positional index.<a name="line.18378"></a>
<FONT color="green">18379</FONT>       * &lt;p&gt;<a name="line.18379"></a>
<FONT color="green">18380</FONT>       * <a name="line.18380"></a>
<FONT color="green">18381</FONT>       * @param iCurve<a name="line.18381"></a>
<FONT color="green">18382</FONT>       *          index of the curve to be removed<a name="line.18382"></a>
<FONT color="green">18383</FONT>       * <a name="line.18383"></a>
<FONT color="green">18384</FONT>       * @see #removeCurve(Curve) removeCurve(Curve)<a name="line.18384"></a>
<FONT color="green">18385</FONT>       * @see #getCurve getCurve<a name="line.18385"></a>
<FONT color="green">18386</FONT>       * @see #addCurve() addCurve()<a name="line.18386"></a>
<FONT color="green">18387</FONT>       * @see #addCurve(int) addCurve(int)<a name="line.18387"></a>
<FONT color="green">18388</FONT>       * @see #clearCurves clearCurves<a name="line.18388"></a>
<FONT color="green">18389</FONT>       * @see #getNCurves getNCurves<a name="line.18389"></a>
<FONT color="green">18390</FONT>       */<a name="line.18390"></a>
<FONT color="green">18391</FONT>      public void removeCurve(int iCurve) {<a name="line.18391"></a>
<FONT color="green">18392</FONT>        if (iCurve &gt;= getNCurves())<a name="line.18392"></a>
<FONT color="green">18393</FONT>          throw new IllegalArgumentException("iCurve = " + iCurve<a name="line.18393"></a>
<FONT color="green">18394</FONT>              + "; iCurve may not exceed getNCurves()-1 ("<a name="line.18394"></a>
<FONT color="green">18395</FONT>              + (getNCurves() - 1) + ")");<a name="line.18395"></a>
<FONT color="green">18396</FONT>        else if (iCurve &lt; 0)<a name="line.18396"></a>
<FONT color="green">18397</FONT>          throw new IllegalArgumentException("iCurve = " + iCurve<a name="line.18397"></a>
<FONT color="green">18398</FONT>              + "; iCurve may not be negative.");<a name="line.18398"></a>
<FONT color="green">18399</FONT>    <a name="line.18399"></a>
<FONT color="green">18400</FONT>        invalidateDependentSlices(iCurve);<a name="line.18400"></a>
<FONT color="green">18401</FONT>    <a name="line.18401"></a>
<FONT color="green">18402</FONT>        /*<a name="line.18402"></a>
<FONT color="green">18403</FONT>         * Simulate user moving away from point before it is deleted (this assures<a name="line.18403"></a>
<FONT color="green">18404</FONT>         * that any required hoverCleanup gets called, and clears the otherwise<a name="line.18404"></a>
<FONT color="green">18405</FONT>         * dangling reference to the touched point).<a name="line.18405"></a>
<FONT color="green">18406</FONT>         */<a name="line.18406"></a>
<FONT color="green">18407</FONT>        if (plotPanel.touchedPoint != null<a name="line.18407"></a>
<FONT color="green">18408</FONT>            &amp;&amp; plotPanel.touchedPoint.getParent() == getSystemCurve(iCurve))<a name="line.18408"></a>
<FONT color="green">18409</FONT>          plotPanel.touch(null);<a name="line.18409"></a>
<FONT color="green">18410</FONT>    <a name="line.18410"></a>
<FONT color="green">18411</FONT>        // remove the rendering panel that corresponds to this curve<a name="line.18411"></a>
<FONT color="green">18412</FONT>        // (must keep the two lists in synch or 1-to-1 mapping breaks)<a name="line.18412"></a>
<FONT color="green">18413</FONT>        int internalIndex = internalCurveIndex(iCurve);<a name="line.18413"></a>
<FONT color="green">18414</FONT>        if (0 != plotPanel.getRenderingPanelCount()) {<a name="line.18414"></a>
<FONT color="green">18415</FONT>          int rpIndex = getRenderingPanelIndex(internalIndex);<a name="line.18415"></a>
<FONT color="green">18416</FONT>          plotPanel.removeGraphicsRenderingPanel(rpIndex);<a name="line.18416"></a>
<FONT color="green">18417</FONT>          plotPanel.removeAnnotationRenderingPanel(rpIndex);<a name="line.18417"></a>
<FONT color="green">18418</FONT>        }<a name="line.18418"></a>
<FONT color="green">18419</FONT>        // else before 1st update, no rendering panels created yet<a name="line.18419"></a>
<FONT color="green">18420</FONT>    <a name="line.18420"></a>
<FONT color="green">18421</FONT>        Curve c = curves.get(internalIndex);<a name="line.18421"></a>
<FONT color="green">18422</FONT>        if (c.isVisible()) {<a name="line.18422"></a>
<FONT color="green">18423</FONT>          getXAxis().decrementCurves();<a name="line.18423"></a>
<FONT color="green">18424</FONT>          if (c.getYAxis() == Y_AXIS)<a name="line.18424"></a>
<FONT color="green">18425</FONT>            getYAxis().decrementCurves();<a name="line.18425"></a>
<FONT color="green">18426</FONT>          else<a name="line.18426"></a>
<FONT color="green">18427</FONT>            getY2Axis().decrementCurves();<a name="line.18427"></a>
<FONT color="green">18428</FONT>        }<a name="line.18428"></a>
<FONT color="green">18429</FONT>        c.clearIndex();<a name="line.18429"></a>
<FONT color="green">18430</FONT>    <a name="line.18430"></a>
<FONT color="green">18431</FONT>        curves.remove(internalIndex);<a name="line.18431"></a>
<FONT color="green">18432</FONT>        // adjust ArrayList indexes to account for newly removed element<a name="line.18432"></a>
<FONT color="green">18433</FONT>        for (int i = internalIndex; i &lt; curves.size(); i++)<a name="line.18433"></a>
<FONT color="green">18434</FONT>          curves.get(i).decrementIndex();<a name="line.18434"></a>
<FONT color="green">18435</FONT>      }<a name="line.18435"></a>
<FONT color="green">18436</FONT>    <a name="line.18436"></a>
<FONT color="green">18437</FONT>      /**<a name="line.18437"></a>
<FONT color="green">18438</FONT>       * Removes the given curve from this GChart.<a name="line.18438"></a>
<FONT color="green">18439</FONT>       * &lt;p&gt;<a name="line.18439"></a>
<FONT color="green">18440</FONT>       * <a name="line.18440"></a>
<FONT color="green">18441</FONT>       * If the given curve is &lt;tt&gt;null&lt;/tt&gt; or is not a curve on this GChart, an<a name="line.18441"></a>
<FONT color="green">18442</FONT>       * exception is thrown.<a name="line.18442"></a>
<FONT color="green">18443</FONT>       * <a name="line.18443"></a>
<FONT color="green">18444</FONT>       * &lt;p&gt;<a name="line.18444"></a>
<FONT color="green">18445</FONT>       * <a name="line.18445"></a>
<FONT color="green">18446</FONT>       * @param curve<a name="line.18446"></a>
<FONT color="green">18447</FONT>       *          the curve to be removed.<a name="line.18447"></a>
<FONT color="green">18448</FONT>       * <a name="line.18448"></a>
<FONT color="green">18449</FONT>       * @see #removeCurve(int) removeCurve(int)<a name="line.18449"></a>
<FONT color="green">18450</FONT>       * <a name="line.18450"></a>
<FONT color="green">18451</FONT>       */<a name="line.18451"></a>
<FONT color="green">18452</FONT>    <a name="line.18452"></a>
<FONT color="green">18453</FONT>      public void removeCurve(Curve curve) {<a name="line.18453"></a>
<FONT color="green">18454</FONT>        if (null == curve)<a name="line.18454"></a>
<FONT color="green">18455</FONT>          throw new IllegalArgumentException("Curve cannot be null.");<a name="line.18455"></a>
<FONT color="green">18456</FONT>        int index = getCurveIndex(curve);<a name="line.18456"></a>
<FONT color="green">18457</FONT>        if (index == GChart.NAI)<a name="line.18457"></a>
<FONT color="green">18458</FONT>          throw new IllegalArgumentException(<a name="line.18458"></a>
<FONT color="green">18459</FONT>              "Curve is not one of this GChart's curves.");<a name="line.18459"></a>
<FONT color="green">18460</FONT>    <a name="line.18460"></a>
<FONT color="green">18461</FONT>        if (index &lt; 0)<a name="line.18461"></a>
<FONT color="green">18462</FONT>          throw new IllegalArgumentException(<a name="line.18462"></a>
<FONT color="green">18463</FONT>              "System curves cannot be removed (this should be impossible; a GChart bug is likely.)");<a name="line.18463"></a>
<FONT color="green">18464</FONT>        else<a name="line.18464"></a>
<FONT color="green">18465</FONT>          removeCurve(index);<a name="line.18465"></a>
<FONT color="green">18466</FONT>      }<a name="line.18466"></a>
<FONT color="green">18467</FONT>    <a name="line.18467"></a>
<FONT color="green">18468</FONT>      /**<a name="line.18468"></a>
<FONT color="green">18469</FONT>       * Specifies the background color of the chart as a whole.<a name="line.18469"></a>
<FONT color="green">18470</FONT>       * <a name="line.18470"></a>
<FONT color="green">18471</FONT>       * &lt;p&gt;<a name="line.18471"></a>
<FONT color="green">18472</FONT>       * The default background color is &lt;tt&gt;USE_CSS&lt;/tt&gt;.<a name="line.18472"></a>
<FONT color="green">18473</FONT>       * &lt;p&gt;<a name="line.18473"></a>
<FONT color="green">18474</FONT>       * <a name="line.18474"></a>
<FONT color="green">18475</FONT>       * For more information on standard CSS color specifications see the<a name="line.18475"></a>
<FONT color="green">18476</FONT>       * discussion in {@link Symbol#setBackgroundColor Symbol.setBackgroundColor}.<a name="line.18476"></a>
<FONT color="green">18477</FONT>       * &lt;p&gt;<a name="line.18477"></a>
<FONT color="green">18478</FONT>       * <a name="line.18478"></a>
<FONT color="green">18479</FONT>       * @param cssColor<a name="line.18479"></a>
<FONT color="green">18480</FONT>       *          the chart's background color, in a standard CSS color string<a name="line.18480"></a>
<FONT color="green">18481</FONT>       *          format.<a name="line.18481"></a>
<FONT color="green">18482</FONT>       * <a name="line.18482"></a>
<FONT color="green">18483</FONT>       * <a name="line.18483"></a>
<FONT color="green">18484</FONT>       * @see #USE_CSS USE_CSS<a name="line.18484"></a>
<FONT color="green">18485</FONT>       * <a name="line.18485"></a>
<FONT color="green">18486</FONT>       */<a name="line.18486"></a>
<FONT color="green">18487</FONT>      public void setBackgroundColor(String cssColor) {<a name="line.18487"></a>
<FONT color="green">18488</FONT>        chartDecorationsChanged = true;<a name="line.18488"></a>
<FONT color="green">18489</FONT>        backgroundColor = cssColor;<a name="line.18489"></a>
<FONT color="green">18490</FONT>      }<a name="line.18490"></a>
<FONT color="green">18491</FONT>    <a name="line.18491"></a>
<FONT color="green">18492</FONT>      /**<a name="line.18492"></a>
<FONT color="green">18493</FONT>       * Specifies a URL that points to the transparent, 1 x 1 pixel, "blank GIF"<a name="line.18493"></a>
<FONT color="green">18494</FONT>       * that GChart uses in order to render your chart without adding spurious<a name="line.18494"></a>
<FONT color="green">18495</FONT>       * "missing image" icons to it.<a name="line.18495"></a>
<FONT color="green">18496</FONT>       * &lt;p&gt;<a name="line.18496"></a>
<FONT color="green">18497</FONT>       * <a name="line.18497"></a>
<FONT color="green">18498</FONT>       * When GWT compiles an application that imports the GChart library, it<a name="line.18498"></a>
<FONT color="green">18499</FONT>       * automatically adds an appropriate blank image, &lt;tt&gt;gchart.gif&lt;/tt&gt;, to the<a name="line.18499"></a>
<FONT color="green">18500</FONT>       * module base directory (this is the directory into which GWT also copies<a name="line.18500"></a>
<FONT color="green">18501</FONT>       * your compiled Javascript, all the files in your public directory, etc.).<a name="line.18501"></a>
<FONT color="green">18502</FONT>       * &lt;p&gt;<a name="line.18502"></a>
<FONT color="green">18503</FONT>       * <a name="line.18503"></a>
<FONT color="green">18504</FONT>       * By default, GChart uses the following blank image URL:<a name="line.18504"></a>
<FONT color="green">18505</FONT>       * &lt;p&gt;<a name="line.18505"></a>
<FONT color="green">18506</FONT>       * <a name="line.18506"></a>
<FONT color="green">18507</FONT>       * &lt;pre&gt;<a name="line.18507"></a>
<FONT color="green">18508</FONT>       * GWT.getModuleBaseURL() + &amp;quot;gchart.gif&amp;quot;<a name="line.18508"></a>
<FONT color="green">18509</FONT>       * &lt;/pre&gt;<a name="line.18509"></a>
<FONT color="green">18510</FONT>       * &lt;p&gt;<a name="line.18510"></a>
<FONT color="green">18511</FONT>       * <a name="line.18511"></a>
<FONT color="green">18512</FONT>       * &lt;small&gt; Earlier versions used "gchart.gif" as this default url. &lt;a href=<a name="line.18512"></a>
<FONT color="green">18513</FONT>       * "http://groups.google.com/group/Google-Web-Toolkit/msg/4be3f19dc14f958a"&gt;<a name="line.18513"></a>
<FONT color="green">18514</FONT>       * This GWT forum post by Dean S. Jones&lt;/a&gt; identified the need to add the<a name="line.18514"></a>
<FONT color="green">18515</FONT>       * &lt;tt&gt;GWT.getModuleBaseURL()&lt;/tt&gt; prefix. &lt;/small&gt;<a name="line.18515"></a>
<FONT color="green">18516</FONT>       * &lt;p&gt;<a name="line.18516"></a>
<FONT color="green">18517</FONT>       * <a name="line.18517"></a>
<FONT color="green">18518</FONT>       * Note that this default adds a potentially very long URL to every<a name="line.18518"></a>
<FONT color="green">18519</FONT>       * &lt;tt&gt;img&lt;/tt&gt; element added by GChart to render your chart, which can (in<a name="line.18519"></a>
<FONT color="green">18520</FONT>       * theory) more than double the memory required to represent your chart in the<a name="line.18520"></a>
<FONT color="green">18521</FONT>       * browser, because the absolute URLs can be of undetermined length. In<a name="line.18521"></a>
<FONT color="green">18522</FONT>       * practice, browser memory usage increases of 10% have been observed with the<a name="line.18522"></a>
<FONT color="green">18523</FONT>       * on-line demo GChart and a typicial, 60-odd character absolute URL.<a name="line.18523"></a>
<FONT color="green">18524</FONT>       * &lt;p&gt;<a name="line.18524"></a>
<FONT color="green">18525</FONT>       * <a name="line.18525"></a>
<FONT color="green">18526</FONT>       * You have several alternatives to the above default that can often reduce<a name="line.18526"></a>
<FONT color="green">18527</FONT>       * the length of the URL and thus save browser memory:<a name="line.18527"></a>
<FONT color="green">18528</FONT>       * <a name="line.18528"></a>
<FONT color="green">18529</FONT>       * &lt;p&gt;<a name="line.18529"></a>
<FONT color="green">18530</FONT>       * <a name="line.18530"></a>
<FONT color="green">18531</FONT>       * &lt;ol&gt;<a name="line.18531"></a>
<FONT color="green">18532</FONT>       * &lt;li&gt;Simply copy &lt;tt&gt;gchart.gif&lt;/tt&gt; from the module base directory into<a name="line.18532"></a>
<FONT color="green">18533</FONT>       * your host page's base directory, and then use<a name="line.18533"></a>
<FONT color="green">18534</FONT>       * &lt;tt&gt;setBlankImageURL("gchart.gif")&lt;/tt&gt; to access this URL relatively.<a name="line.18534"></a>
<FONT color="green">18535</FONT>       * <a name="line.18535"></a>
<FONT color="green">18536</FONT>       * &lt;li&gt;If the relative path from the host page base directory to the module<a name="line.18536"></a>
<FONT color="green">18537</FONT>       * base directory is reasonably short, pass that alternative relative URL to<a name="line.18537"></a>
<FONT color="green">18538</FONT>       * this method (note that all relative URLs are interpreted relative to the<a name="line.18538"></a>
<FONT color="green">18539</FONT>       * base directory of the host page containing your GChart).<a name="line.18539"></a>
<FONT color="green">18540</FONT>       * <a name="line.18540"></a>
<FONT color="green">18541</FONT>       * &lt;li&gt;Place a copy of &lt;tt&gt;gchart.gif&lt;/tt&gt; into a directory whose absolute URL<a name="line.18541"></a>
<FONT color="green">18542</FONT>       * is very short, and then pass that short absolute URL to this method.<a name="line.18542"></a>
<FONT color="green">18543</FONT>       * <a name="line.18543"></a>
<FONT color="green">18544</FONT>       * &lt;/ol&gt;<a name="line.18544"></a>
<FONT color="green">18545</FONT>       * &lt;p&gt;<a name="line.18545"></a>
<FONT color="green">18546</FONT>       * <a name="line.18546"></a>
<FONT color="green">18547</FONT>       * &lt;small&gt; &lt;i&gt;Special note to anyone reading this who designed HTML's<a name="line.18547"></a>
<FONT color="green">18548</FONT>       * &lt;tt&gt;image&lt;/tt&gt; tag:&lt;/i&gt; If you had provided a &lt;tt&gt;src=none&lt;/tt&gt; option,<a name="line.18548"></a>
<FONT color="green">18549</FONT>       * this method would not have to exist. &lt;/small&gt;<a name="line.18549"></a>
<FONT color="green">18550</FONT>       * &lt;p&gt;<a name="line.18550"></a>
<FONT color="green">18551</FONT>       * <a name="line.18551"></a>
<FONT color="green">18552</FONT>       * &lt;i&gt;Tip:&lt;/i&gt; If you already have an appropriate blank gif on your site that<a name="line.18552"></a>
<FONT color="green">18553</FONT>       * is accessible from the host page via a reasonably short URL there is no<a name="line.18553"></a>
<FONT color="green">18554</FONT>       * need to copy &lt;tt&gt;gchart.gif&lt;/tt&gt;. You can just pass that URL to this<a name="line.18554"></a>
<FONT color="green">18555</FONT>       * method.<a name="line.18555"></a>
<FONT color="green">18556</FONT>       * <a name="line.18556"></a>
<FONT color="green">18557</FONT>       * &lt;p&gt;<a name="line.18557"></a>
<FONT color="green">18558</FONT>       * <a name="line.18558"></a>
<FONT color="green">18559</FONT>       * &lt;i&gt;Note:&lt;/i&gt; Though GChart uses this blank image by default, you can use<a name="line.18559"></a>
<FONT color="green">18560</FONT>       * the &lt;tt&gt;setImageURL&lt;/tt&gt; method to specify a non-blank image for use in<a name="line.18560"></a>
<FONT color="green">18561</FONT>       * rendering a specific curve.<a name="line.18561"></a>
<FONT color="green">18562</FONT>       * &lt;p&gt;<a name="line.18562"></a>
<FONT color="green">18563</FONT>       * <a name="line.18563"></a>
<FONT color="green">18564</FONT>       * <a name="line.18564"></a>
<FONT color="green">18565</FONT>       * @param blankImageURL<a name="line.18565"></a>
<FONT color="green">18566</FONT>       *          a URL that points to a 1 x 1 pixel transparent image that GChart<a name="line.18566"></a>
<FONT color="green">18567</FONT>       *          needs to render your charts without adding a spurious<a name="line.18567"></a>
<FONT color="green">18568</FONT>       *          "missing image" icon.<a name="line.18568"></a>
<FONT color="green">18569</FONT>       * <a name="line.18569"></a>
<FONT color="green">18570</FONT>       * @see #getBlankImageURL getBlankImageURL<a name="line.18570"></a>
<FONT color="green">18571</FONT>       * @see #DEFAULT_BLANK_IMAGE_URL DEFAULT_BLANK_IMAGE_URL<a name="line.18571"></a>
<FONT color="green">18572</FONT>       * @see Symbol#setImageURL setImageURL<a name="line.18572"></a>
<FONT color="green">18573</FONT>       * <a name="line.18573"></a>
<FONT color="green">18574</FONT>       */<a name="line.18574"></a>
<FONT color="green">18575</FONT>    <a name="line.18575"></a>
<FONT color="green">18576</FONT>      public static void setBlankImageURL(String blankImageURL) {<a name="line.18576"></a>
<FONT color="green">18577</FONT>        if (blankImageURL != GChart.blankImageURL) {<a name="line.18577"></a>
<FONT color="green">18578</FONT>          GChart.blankImageURL = blankImageURL;<a name="line.18578"></a>
<FONT color="green">18579</FONT>          // Decided not to prefetch blank image URL because 1) pre-fetching<a name="line.18579"></a>
<FONT color="green">18580</FONT>          // doesn't improve performance noticably in tested browsers,<a name="line.18580"></a>
<FONT color="green">18581</FONT>          // 2) there are reports of possible memory leaks associated with<a name="line.18581"></a>
<FONT color="green">18582</FONT>          // its use in the GWT issue tracker, and 3) users can<a name="line.18582"></a>
<FONT color="green">18583</FONT>          // easily do the prefetch on their own if they want to, and that<a name="line.18583"></a>
<FONT color="green">18584</FONT>          // is really the right place to do a prefetch anyway.<a name="line.18584"></a>
<FONT color="green">18585</FONT>          // Image.prefetch(GChart.getBlankImageURL());<a name="line.18585"></a>
<FONT color="green">18586</FONT>        }<a name="line.18586"></a>
<FONT color="green">18587</FONT>      }<a name="line.18587"></a>
<FONT color="green">18588</FONT>    <a name="line.18588"></a>
<FONT color="green">18589</FONT>      /**<a name="line.18589"></a>
<FONT color="green">18590</FONT>       * Specifies the color of the border around the chart as a whole.<a name="line.18590"></a>
<FONT color="green">18591</FONT>       * <a name="line.18591"></a>
<FONT color="green">18592</FONT>       * &lt;p&gt;<a name="line.18592"></a>
<FONT color="green">18593</FONT>       * The default border color is &lt;tt&gt;USE_CSS&lt;/tt&gt;.<a name="line.18593"></a>
<FONT color="green">18594</FONT>       * <a name="line.18594"></a>
<FONT color="green">18595</FONT>       * &lt;p&gt;<a name="line.18595"></a>
<FONT color="green">18596</FONT>       * &lt;blockquote&gt;&lt;small&gt; &lt;i&gt;Tip:&lt;/i&gt; No border will appear if either<a name="line.18596"></a>
<FONT color="green">18597</FONT>       * &lt;tt&gt;borderStyle&lt;/tt&gt; is &lt;tt&gt;none&lt;/tt&gt;, &lt;tt&gt;borderWidth&lt;/tt&gt; is &lt;tt&gt;0px&lt;/tt&gt;<a name="line.18597"></a>
<FONT color="green">18598</FONT>       * or &lt;tt&gt;borderColor&lt;/tt&gt; is &lt;tt&gt;transparent&lt;/tt&gt;. Since these will often be<a name="line.18598"></a>
<FONT color="green">18599</FONT>       * the "CSS inherited" values, generally, it's best to set all three<a name="line.18599"></a>
<FONT color="green">18600</FONT>       * properties whenever you set any one of them. &lt;/small&gt;&lt;/blockquote&gt;<a name="line.18600"></a>
<FONT color="green">18601</FONT>       * &lt;p&gt;<a name="line.18601"></a>
<FONT color="green">18602</FONT>       * <a name="line.18602"></a>
<FONT color="green">18603</FONT>       * <a name="line.18603"></a>
<FONT color="green">18604</FONT>       * For more information on standard CSS color specifications see the<a name="line.18604"></a>
<FONT color="green">18605</FONT>       * discussion in {@link Symbol#setBackgroundColor Symbol.setBackgroundColor}.<a name="line.18605"></a>
<FONT color="green">18606</FONT>       * &lt;p&gt;<a name="line.18606"></a>
<FONT color="green">18607</FONT>       * <a name="line.18607"></a>
<FONT color="green">18608</FONT>       * @param cssColor<a name="line.18608"></a>
<FONT color="green">18609</FONT>       *          the color of the chart's border, in a standard CSS color string<a name="line.18609"></a>
<FONT color="green">18610</FONT>       *          format.<a name="line.18610"></a>
<FONT color="green">18611</FONT>       * <a name="line.18611"></a>
<FONT color="green">18612</FONT>       * @see #setBorderWidth(String) setBorderWidth<a name="line.18612"></a>
<FONT color="green">18613</FONT>       * @see #setBorderStyle(String) setBorderStyle<a name="line.18613"></a>
<FONT color="green">18614</FONT>       * @see #getBorderColor getBorderColor<a name="line.18614"></a>
<FONT color="green">18615</FONT>       * @see #USE_CSS USE_CSS<a name="line.18615"></a>
<FONT color="green">18616</FONT>       * <a name="line.18616"></a>
<FONT color="green">18617</FONT>       */<a name="line.18617"></a>
<FONT color="green">18618</FONT>      public void setBorderColor(String cssColor) {<a name="line.18618"></a>
<FONT color="green">18619</FONT>        chartDecorationsChanged = true;<a name="line.18619"></a>
<FONT color="green">18620</FONT>        if (borderColor == null || borderColor == TRANSPARENT_BORDER_COLOR)<a name="line.18620"></a>
<FONT color="green">18621</FONT>          throw new IllegalArgumentException(<a name="line.18621"></a>
<FONT color="green">18622</FONT>              "null and TRANSPARENT_BORDER_COLOR are not allowed. This method requires a valid CSS color specification String.");<a name="line.18622"></a>
<FONT color="green">18623</FONT>        borderColor = cssColor;<a name="line.18623"></a>
<FONT color="green">18624</FONT>      }<a name="line.18624"></a>
<FONT color="green">18625</FONT>    <a name="line.18625"></a>
<FONT color="green">18626</FONT>      /**<a name="line.18626"></a>
<FONT color="green">18627</FONT>       * Sets style of the border around the chart as a whole.<a name="line.18627"></a>
<FONT color="green">18628</FONT>       * <a name="line.18628"></a>
<FONT color="green">18629</FONT>       * &lt;p&gt;<a name="line.18629"></a>
<FONT color="green">18630</FONT>       * The default border style is &lt;tt&gt;USE_CSS&lt;/tt&gt;.<a name="line.18630"></a>
<FONT color="green">18631</FONT>       * &lt;p&gt;<a name="line.18631"></a>
<FONT color="green">18632</FONT>       * <a name="line.18632"></a>
<FONT color="green">18633</FONT>       * &lt;p&gt;<a name="line.18633"></a>
<FONT color="green">18634</FONT>       * &lt;blockquote&gt;&lt;small&gt; &lt;i&gt;Tip:&lt;/i&gt; No border will appear if either<a name="line.18634"></a>
<FONT color="green">18635</FONT>       * &lt;tt&gt;borderStyle&lt;/tt&gt; is &lt;tt&gt;none&lt;/tt&gt;, &lt;tt&gt;borderWidth&lt;/tt&gt; is &lt;tt&gt;0px&lt;/tt&gt;<a name="line.18635"></a>
<FONT color="green">18636</FONT>       * or &lt;tt&gt;borderColor&lt;/tt&gt; is &lt;tt&gt;transparent&lt;/tt&gt;. Since these will often be<a name="line.18636"></a>
<FONT color="green">18637</FONT>       * the "CSS inherited" values, generally, it's best to set all three<a name="line.18637"></a>
<FONT color="green">18638</FONT>       * properties whenever you set any one of them. &lt;/small&gt;&lt;/blockquote&gt;<a name="line.18638"></a>
<FONT color="green">18639</FONT>       * &lt;p&gt;<a name="line.18639"></a>
<FONT color="green">18640</FONT>       * <a name="line.18640"></a>
<FONT color="green">18641</FONT>       * <a name="line.18641"></a>
<FONT color="green">18642</FONT>       * @param borderStyle<a name="line.18642"></a>
<FONT color="green">18643</FONT>       *          a CSS border style such as "solid", "dotted", "dashed", etc.<a name="line.18643"></a>
<FONT color="green">18644</FONT>       * <a name="line.18644"></a>
<FONT color="green">18645</FONT>       * @see #getBorderStyle getBorderStyle<a name="line.18645"></a>
<FONT color="green">18646</FONT>       * @see #setBackgroundColor(String) setBackgroundColor<a name="line.18646"></a>
<FONT color="green">18647</FONT>       * @see #setBorderColor(String) setBorderColor<a name="line.18647"></a>
<FONT color="green">18648</FONT>       * @see #setBorderWidth(String) setBorderWidth<a name="line.18648"></a>
<FONT color="green">18649</FONT>       * @see #USE_CSS USE_CSS<a name="line.18649"></a>
<FONT color="green">18650</FONT>       * <a name="line.18650"></a>
<FONT color="green">18651</FONT>       * <a name="line.18651"></a>
<FONT color="green">18652</FONT>       */<a name="line.18652"></a>
<FONT color="green">18653</FONT>      public void setBorderStyle(String borderStyle) {<a name="line.18653"></a>
<FONT color="green">18654</FONT>        chartDecorationsChanged = true;<a name="line.18654"></a>
<FONT color="green">18655</FONT>        this.borderStyle = borderStyle;<a name="line.18655"></a>
<FONT color="green">18656</FONT>      }<a name="line.18656"></a>
<FONT color="green">18657</FONT>    <a name="line.18657"></a>
<FONT color="green">18658</FONT>      /**<a name="line.18658"></a>
<FONT color="green">18659</FONT>       * Specifies the width of the border around the chart as a whole.<a name="line.18659"></a>
<FONT color="green">18660</FONT>       * <a name="line.18660"></a>
<FONT color="green">18661</FONT>       * &lt;p&gt;<a name="line.18661"></a>
<FONT color="green">18662</FONT>       * The default border width is &lt;tt&gt;USE_CSS&lt;/tt&gt;.<a name="line.18662"></a>
<FONT color="green">18663</FONT>       * <a name="line.18663"></a>
<FONT color="green">18664</FONT>       * &lt;p&gt;<a name="line.18664"></a>
<FONT color="green">18665</FONT>       * &lt;blockquote&gt;&lt;small&gt; &lt;i&gt;Tip:&lt;/i&gt; No border will appear if either<a name="line.18665"></a>
<FONT color="green">18666</FONT>       * &lt;tt&gt;borderStyle&lt;/tt&gt; is &lt;tt&gt;none&lt;/tt&gt;, &lt;tt&gt;borderWidth&lt;/tt&gt; is &lt;tt&gt;0px&lt;/tt&gt;<a name="line.18666"></a>
<FONT color="green">18667</FONT>       * or &lt;tt&gt;borderColor&lt;/tt&gt; is &lt;tt&gt;transparent&lt;/tt&gt;. Since these will often be<a name="line.18667"></a>
<FONT color="green">18668</FONT>       * the "CSS inherited" values, generally, it's best to set all three<a name="line.18668"></a>
<FONT color="green">18669</FONT>       * properties whenever you set any one of them. &lt;/small&gt;&lt;/blockquote&gt;<a name="line.18669"></a>
<FONT color="green">18670</FONT>       * <a name="line.18670"></a>
<FONT color="green">18671</FONT>       * @param cssWidth<a name="line.18671"></a>
<FONT color="green">18672</FONT>       *          width of the border around the chart as a whole, expressed as a<a name="line.18672"></a>
<FONT color="green">18673</FONT>       *          CSS border-width specification string, such as "1px".<a name="line.18673"></a>
<FONT color="green">18674</FONT>       * <a name="line.18674"></a>
<FONT color="green">18675</FONT>       * @see #getBorderWidth getBorderWidth<a name="line.18675"></a>
<FONT color="green">18676</FONT>       * @see #setBorderStyle(String) setBorderStyle<a name="line.18676"></a>
<FONT color="green">18677</FONT>       * @see #setBorderColor(String) setBorderColor<a name="line.18677"></a>
<FONT color="green">18678</FONT>       * @see #USE_CSS USE_CSS<a name="line.18678"></a>
<FONT color="green">18679</FONT>       */<a name="line.18679"></a>
<FONT color="green">18680</FONT>      public void setBorderWidth(String cssWidth) {<a name="line.18680"></a>
<FONT color="green">18681</FONT>        chartDecorationsChanged = true;<a name="line.18681"></a>
<FONT color="green">18682</FONT>        borderWidth = cssWidth;<a name="line.18682"></a>
<FONT color="green">18683</FONT>      }<a name="line.18683"></a>
<FONT color="green">18684</FONT>    <a name="line.18684"></a>
<FONT color="green">18685</FONT>      /**<a name="line.18685"></a>
<FONT color="green">18686</FONT>       * Specifies the fractional amount that the default width and height of each<a name="line.18686"></a>
<FONT color="green">18687</FONT>       * canvas used to render this chart will be increased. For example, with 100px<a name="line.18687"></a>
<FONT color="green">18688</FONT>       * x 200px default sized canvas rectangle, and canvas width and height<a name="line.18688"></a>
<FONT color="green">18689</FONT>       * expansion factors of 0.1 and 0.2, the canvas rectangle would be increased<a name="line.18689"></a>
<FONT color="green">18690</FONT>       * to 110px x 240px.<a name="line.18690"></a>
<FONT color="green">18691</FONT>       * <a name="line.18691"></a>
<FONT color="green">18692</FONT>       * &lt;p&gt;<a name="line.18692"></a>
<FONT color="green">18693</FONT>       * <a name="line.18693"></a>
<FONT color="green">18694</FONT>       * If you plug in an external vector graphics library via<a name="line.18694"></a>
<FONT color="green">18695</FONT>       * &lt;tt&gt;setCanvasFactory&lt;/tt&gt;, GChart creates a vector graphics "canvas" for<a name="line.18695"></a>
<FONT color="green">18696</FONT>       * each curve that is &lt;i&gt;just big enough&lt;/i&gt; to contain the points on that<a name="line.18696"></a>
<FONT color="green">18697</FONT>       * curve. These "shrink-wrapped" canvas rectangles save memory. But, if you<a name="line.18697"></a>
<FONT color="green">18698</FONT>       * use Bezier curves, your curves can easily extend outside of these<a name="line.18698"></a>
<FONT color="green">18699</FONT>       * rectangles. So, this method lets you "pad" these canvas rectangles with<a name="line.18699"></a>
<FONT color="green">18700</FONT>       * extra space, thus preventing such "overshooting" curves from being<a name="line.18700"></a>
<FONT color="green">18701</FONT>       * improperly clipped off.<a name="line.18701"></a>
<FONT color="green">18702</FONT>       * &lt;p&gt;<a name="line.18702"></a>
<FONT color="green">18703</FONT>       * <a name="line.18703"></a>
<FONT color="green">18704</FONT>       * &lt;small&gt;To handle every possible Bezier overshoot contingency, these canvas<a name="line.18704"></a>
<FONT color="green">18705</FONT>       * expansion factors would have to be huge. But, in the oil price simulation<a name="line.18705"></a>
<FONT color="green">18706</FONT>       * of the live demo, even with its "100% curvy" option, a factor of 0.3 on the<a name="line.18706"></a>
<FONT color="green">18707</FONT>       * y axis and 0.0 on the x axis (a 30% memory hit for this chart) works well.<a name="line.18707"></a>
<FONT color="green">18708</FONT>       * 0.1 on y even works OK, if you don't mind truncatiing the wildest<a name="line.18708"></a>
<FONT color="green">18709</FONT>       * overshooting curves. &lt;/small&gt;<a name="line.18709"></a>
<FONT color="green">18710</FONT>       * <a name="line.18710"></a>
<FONT color="green">18711</FONT>       * @param widthExpansionFactor<a name="line.18711"></a>
<FONT color="green">18712</FONT>       *          the fraction that the width of the canvas rectangle will be<a name="line.18712"></a>
<FONT color="green">18713</FONT>       *          expanded. The default is &lt;tt&gt;0&lt;/tt&gt; (no width expansion).<a name="line.18713"></a>
<FONT color="green">18714</FONT>       * @param heightExpansionFactor<a name="line.18714"></a>
<FONT color="green">18715</FONT>       *          the fraction that the height of the canvas rectangle will be<a name="line.18715"></a>
<FONT color="green">18716</FONT>       *          expanded. The default is &lt;tt&gt;0&lt;/tt&gt; (no height expansion).<a name="line.18716"></a>
<FONT color="green">18717</FONT>       * <a name="line.18717"></a>
<FONT color="green">18718</FONT>       * @see #setCanvasFactory setCanvasFactory<a name="line.18718"></a>
<FONT color="green">18719</FONT>       * <a name="line.18719"></a>
<FONT color="green">18720</FONT>       */<a name="line.18720"></a>
<FONT color="green">18721</FONT>      public void setCanvasExpansionFactors(double widthExpansionFactor,<a name="line.18721"></a>
<FONT color="green">18722</FONT>          double heightExpansionFactor) {<a name="line.18722"></a>
<FONT color="green">18723</FONT>        invalidateAccessibleCurves();<a name="line.18723"></a>
<FONT color="green">18724</FONT>        canvasExpansionFactorX = widthExpansionFactor;<a name="line.18724"></a>
<FONT color="green">18725</FONT>        canvasExpansionFactorY = heightExpansionFactor;<a name="line.18725"></a>
<FONT color="green">18726</FONT>      }<a name="line.18726"></a>
<FONT color="green">18727</FONT>    <a name="line.18727"></a>
<FONT color="green">18728</FONT>      /**<a name="line.18728"></a>
<FONT color="green">18729</FONT>       * Convenience method equivalent to &lt;tt&gt;setChartFootnotes(new HTML(html))&lt;/tt&gt;<a name="line.18729"></a>
<FONT color="green">18730</FONT>       * .<a name="line.18730"></a>
<FONT color="green">18731</FONT>       * <a name="line.18731"></a>
<FONT color="green">18732</FONT>       * @param html<a name="line.18732"></a>
<FONT color="green">18733</FONT>       *          HTML text used to define the chart's title.<a name="line.18733"></a>
<FONT color="green">18734</FONT>       * <a name="line.18734"></a>
<FONT color="green">18735</FONT>       * @see #setChartFootnotes(Widget) setChartFootnotes(Widget)<a name="line.18735"></a>
<FONT color="green">18736</FONT>       */<a name="line.18736"></a>
<FONT color="green">18737</FONT>      public void setChartFootnotes(String html) {<a name="line.18737"></a>
<FONT color="green">18738</FONT>        setChartFootnotes(new HTML(html));<a name="line.18738"></a>
<FONT color="green">18739</FONT>      }<a name="line.18739"></a>
<FONT color="green">18740</FONT>    <a name="line.18740"></a>
<FONT color="green">18741</FONT>      /**<a name="line.18741"></a>
<FONT color="green">18742</FONT>       * Sets widget that appears just below the chart.<a name="line.18742"></a>
<FONT color="green">18743</FONT>       * &lt;p&gt;<a name="line.18743"></a>
<FONT color="green">18744</FONT>       * <a name="line.18744"></a>
<FONT color="green">18745</FONT>       * The widget will vertically centered within a band just below the x axis<a name="line.18745"></a>
<FONT color="green">18746</FONT>       * label that stretches along the entire bottom edge of the chart, and whose<a name="line.18746"></a>
<FONT color="green">18747</FONT>       * height is defined by &lt;tt&gt;setChartFootnotesThickness&lt;/tt&gt;.<a name="line.18747"></a>
<FONT color="green">18748</FONT>       * <a name="line.18748"></a>
<FONT color="green">18749</FONT>       * &lt;p&gt;<a name="line.18749"></a>
<FONT color="green">18750</FONT>       * <a name="line.18750"></a>
<FONT color="green">18751</FONT>       * The widget will either be left justified, or horizontally centered, within<a name="line.18751"></a>
<FONT color="green">18752</FONT>       * this band depending on the property defined by<a name="line.18752"></a>
<FONT color="green">18753</FONT>       * &lt;tt&gt;setChartFootnotesLeftJustified&lt;/tt&gt;<a name="line.18753"></a>
<FONT color="green">18754</FONT>       * <a name="line.18754"></a>
<FONT color="green">18755</FONT>       * <a name="line.18755"></a>
<FONT color="green">18756</FONT>       * @param chartFootnotes<a name="line.18756"></a>
<FONT color="green">18757</FONT>       *          widget representing the chart's footnotes<a name="line.18757"></a>
<FONT color="green">18758</FONT>       * <a name="line.18758"></a>
<FONT color="green">18759</FONT>       * @see #setChartFootnotes(String) setChartFootnotes(String)<a name="line.18759"></a>
<FONT color="green">18760</FONT>       * @see #setChartFootnotesThickness setChartFootnotesThickness<a name="line.18760"></a>
<FONT color="green">18761</FONT>       * @see #getChartFootnotes getChartFootnotes<a name="line.18761"></a>
<FONT color="green">18762</FONT>       * @see #setChartFootnotesLeftJustified setChartFootnotesLeftJustified<a name="line.18762"></a>
<FONT color="green">18763</FONT>       */<a name="line.18763"></a>
<FONT color="green">18764</FONT>      public void setChartFootnotes(Widget chartFootnotes) {<a name="line.18764"></a>
<FONT color="green">18765</FONT>        chartDecorationsChanged = true;<a name="line.18765"></a>
<FONT color="green">18766</FONT>        this.chartFootnotes = chartFootnotes;<a name="line.18766"></a>
<FONT color="green">18767</FONT>      }<a name="line.18767"></a>
<FONT color="green">18768</FONT>    <a name="line.18768"></a>
<FONT color="green">18769</FONT>      /**<a name="line.18769"></a>
<FONT color="green">18770</FONT>       * Defines if this chart's footnotes are left justified, or horizontally<a name="line.18770"></a>
<FONT color="green">18771</FONT>       * centered across the bottom edge of the chart.<a name="line.18771"></a>
<FONT color="green">18772</FONT>       * &lt;p&gt;<a name="line.18772"></a>
<FONT color="green">18773</FONT>       * Note that a chart's footnotes are always vertically centered within the<a name="line.18773"></a>
<FONT color="green">18774</FONT>       * band at the bottom of the chart reserved for chart footnotes. Use the<a name="line.18774"></a>
<FONT color="green">18775</FONT>       * &lt;tt&gt;setChartFootnotesThickness&lt;/tt&gt; method to set the height of this band.<a name="line.18775"></a>
<FONT color="green">18776</FONT>       * <a name="line.18776"></a>
<FONT color="green">18777</FONT>       * @param footnotesLeftJustified<a name="line.18777"></a>
<FONT color="green">18778</FONT>       *          true to position chart footnotes flush against the left edge of<a name="line.18778"></a>
<FONT color="green">18779</FONT>       *          the chart, false (the default) to center them horizontally across<a name="line.18779"></a>
<FONT color="green">18780</FONT>       *          the chart's bottom edge.<a name="line.18780"></a>
<FONT color="green">18781</FONT>       * <a name="line.18781"></a>
<FONT color="green">18782</FONT>       * @see #setChartFootnotes(String) setChartFootnotes(String)<a name="line.18782"></a>
<FONT color="green">18783</FONT>       * @see #getChartFootnotes getChartFootnotes<a name="line.18783"></a>
<FONT color="green">18784</FONT>       * @see #setChartFootnotesThickness<a name="line.18784"></a>
<FONT color="green">18785</FONT>       */<a name="line.18785"></a>
<FONT color="green">18786</FONT>      public void setChartFootnotesLeftJustified(boolean footnotesLeftJustified) {<a name="line.18786"></a>
<FONT color="green">18787</FONT>        chartDecorationsChanged = true;<a name="line.18787"></a>
<FONT color="green">18788</FONT>        chartFootnotesLeftJustified = footnotesLeftJustified;<a name="line.18788"></a>
<FONT color="green">18789</FONT>      }<a name="line.18789"></a>
<FONT color="green">18790</FONT>    <a name="line.18790"></a>
<FONT color="green">18791</FONT>      /**<a name="line.18791"></a>
<FONT color="green">18792</FONT>       * Sets the thickness (height) of the rectangular region at the bottom of the<a name="line.18792"></a>
<FONT color="green">18793</FONT>       * chart allocated for the footnotes.<a name="line.18793"></a>
<FONT color="green">18794</FONT>       * &lt;p&gt;<a name="line.18794"></a>
<FONT color="green">18795</FONT>       * <a name="line.18795"></a>
<FONT color="green">18796</FONT>       * The width of this region always equals the width of the entire GChart<a name="line.18796"></a>
<FONT color="green">18797</FONT>       * (including legend and axis labels).<a name="line.18797"></a>
<FONT color="green">18798</FONT>       * &lt;p&gt;<a name="line.18798"></a>
<FONT color="green">18799</FONT>       * <a name="line.18799"></a>
<FONT color="green">18800</FONT>       * Your footnotes widget is always vertically centered in this region.<a name="line.18800"></a>
<FONT color="green">18801</FONT>       * &lt;p&gt;<a name="line.18801"></a>
<FONT color="green">18802</FONT>       * <a name="line.18802"></a>
<FONT color="green">18803</FONT>       * <a name="line.18803"></a>
<FONT color="green">18804</FONT>       * Your footnotes widget will either be horizontally centered in this region,<a name="line.18804"></a>
<FONT color="green">18805</FONT>       * or left justified in it, depending on the property defined by the<a name="line.18805"></a>
<FONT color="green">18806</FONT>       * &lt;tt&gt;setChartFootnotesLeftJustified&lt;/tt&gt; method.<a name="line.18806"></a>
<FONT color="green">18807</FONT>       * &lt;p&gt;<a name="line.18807"></a>
<FONT color="green">18808</FONT>       * <a name="line.18808"></a>
<FONT color="green">18809</FONT>       * This setting has no impact on chart layout if the footnotes widget is<a name="line.18809"></a>
<FONT color="green">18810</FONT>       * &lt;tt&gt;null&lt;/tt&gt; (the default); the rectangular footnotes region is entirely<a name="line.18810"></a>
<FONT color="green">18811</FONT>       * eliminated, and in effect has a 0 thickness, in that case.<a name="line.18811"></a>
<FONT color="green">18812</FONT>       * &lt;p&gt;<a name="line.18812"></a>
<FONT color="green">18813</FONT>       * <a name="line.18813"></a>
<FONT color="green">18814</FONT>       * If you set the footnotes thickness to &lt;tt&gt;GChart.NAI&lt;/tt&gt; (the default)<a name="line.18814"></a>
<FONT color="green">18815</FONT>       * GChart will use a thickness based on the estimated number of (<a name="line.18815"></a>
<FONT color="green">18816</FONT>       * &lt;tt&gt;&amp;lt;br&amp;gt;&lt;/tt&gt; or &lt;tt&gt;&amp;lt;li&amp;gt;&lt;/tt&gt; delimited) lines.<a name="line.18816"></a>
<FONT color="green">18817</FONT>       * <a name="line.18817"></a>
<FONT color="green">18818</FONT>       * @param thickness<a name="line.18818"></a>
<FONT color="green">18819</FONT>       *          the thickness (height) of the rectangle that contains the<a name="line.18819"></a>
<FONT color="green">18820</FONT>       *          footnotes, in pixels, or &lt;tt&gt;GChart.NAI&lt;/tt&gt; to use the default<a name="line.18820"></a>
<FONT color="green">18821</FONT>       *          thickness.<a name="line.18821"></a>
<FONT color="green">18822</FONT>       * <a name="line.18822"></a>
<FONT color="green">18823</FONT>       * @see #getChartFootnotesThickness getChartFootnotesThickness<a name="line.18823"></a>
<FONT color="green">18824</FONT>       * @see #setChartFootnotesLeftJustified setChartFootnotesLeftJustified<a name="line.18824"></a>
<FONT color="green">18825</FONT>       * @see GChart#NAI GChart.NAI<a name="line.18825"></a>
<FONT color="green">18826</FONT>       * @see #DEFAULT_FOOTNOTES_THICKNESS DEFAULT_FOOTNOTES_THICKNESS<a name="line.18826"></a>
<FONT color="green">18827</FONT>       * <a name="line.18827"></a>
<FONT color="green">18828</FONT>       */<a name="line.18828"></a>
<FONT color="green">18829</FONT>      public void setChartFootnotesThickness(int thickness) {<a name="line.18829"></a>
<FONT color="green">18830</FONT>        chartDecorationsChanged = true;<a name="line.18830"></a>
<FONT color="green">18831</FONT>        this.footnotesThickness = thickness;<a name="line.18831"></a>
<FONT color="green">18832</FONT>      }<a name="line.18832"></a>
<FONT color="green">18833</FONT>    <a name="line.18833"></a>
<FONT color="green">18834</FONT>      /**<a name="line.18834"></a>
<FONT color="green">18835</FONT>       * Convenience method equivalent to<a name="line.18835"></a>
<FONT color="green">18836</FONT>       * &lt;tt&gt;setXChartSize(xChartSize); setYChartSize(yChartSize)&lt;/tt&gt;.<a name="line.18836"></a>
<FONT color="green">18837</FONT>       * <a name="line.18837"></a>
<FONT color="green">18838</FONT>       * @param xChartSize<a name="line.18838"></a>
<FONT color="green">18839</FONT>       *          number of x-pixels in the curve display area of the chart<a name="line.18839"></a>
<FONT color="green">18840</FONT>       * @param yChartSize<a name="line.18840"></a>
<FONT color="green">18841</FONT>       *          number of y-pixels in the curve display area of the chart<a name="line.18841"></a>
<FONT color="green">18842</FONT>       * <a name="line.18842"></a>
<FONT color="green">18843</FONT>       * @see #setXChartSize setXChartSize<a name="line.18843"></a>
<FONT color="green">18844</FONT>       * @see #setYChartSize setYChartSize<a name="line.18844"></a>
<FONT color="green">18845</FONT>       * <a name="line.18845"></a>
<FONT color="green">18846</FONT>       */<a name="line.18846"></a>
<FONT color="green">18847</FONT>      public void setChartSize(int xChartSize, int yChartSize) {<a name="line.18847"></a>
<FONT color="green">18848</FONT>        setXChartSize(xChartSize);<a name="line.18848"></a>
<FONT color="green">18849</FONT>        setYChartSize(yChartSize);<a name="line.18849"></a>
<FONT color="green">18850</FONT>      }<a name="line.18850"></a>
<FONT color="green">18851</FONT>    <a name="line.18851"></a>
<FONT color="green">18852</FONT>      /**<a name="line.18852"></a>
<FONT color="green">18853</FONT>       * Convenience method equivalent to &lt;tt&gt;setChartTitle(new HTML(html))&lt;/tt&gt;.<a name="line.18853"></a>
<FONT color="green">18854</FONT>       * <a name="line.18854"></a>
<FONT color="green">18855</FONT>       * @param html<a name="line.18855"></a>
<FONT color="green">18856</FONT>       *          HTML text used to define the chart's title.<a name="line.18856"></a>
<FONT color="green">18857</FONT>       * <a name="line.18857"></a>
<FONT color="green">18858</FONT>       * @see #setChartTitle(Widget) setChartTitle(Widget)<a name="line.18858"></a>
<FONT color="green">18859</FONT>       */<a name="line.18859"></a>
<FONT color="green">18860</FONT>      public void setChartTitle(String html) {<a name="line.18860"></a>
<FONT color="green">18861</FONT>        setChartTitle(new HTML(html));<a name="line.18861"></a>
<FONT color="green">18862</FONT>      }<a name="line.18862"></a>
<FONT color="green">18863</FONT>    <a name="line.18863"></a>
<FONT color="green">18864</FONT>      // returns x,y min/max over every plotted curve<a name="line.18864"></a>
<FONT color="green">18865</FONT>    <a name="line.18865"></a>
<FONT color="green">18866</FONT>      /**<a name="line.18866"></a>
<FONT color="green">18867</FONT>       * Specifies the widget that appears centered just above the chart.<a name="line.18867"></a>
<FONT color="green">18868</FONT>       * <a name="line.18868"></a>
<FONT color="green">18869</FONT>       * @param chartTitle<a name="line.18869"></a>
<FONT color="green">18870</FONT>       *          the widget to be used as this chart's title.<a name="line.18870"></a>
<FONT color="green">18871</FONT>       * <a name="line.18871"></a>
<FONT color="green">18872</FONT>       * @see #setChartTitle(String) setChartTitle(String)<a name="line.18872"></a>
<FONT color="green">18873</FONT>       * @see #setChartTitleThickness setChartTitleThickness<a name="line.18873"></a>
<FONT color="green">18874</FONT>       * @see #getChartTitle getChartTitle<a name="line.18874"></a>
<FONT color="green">18875</FONT>       * <a name="line.18875"></a>
<FONT color="green">18876</FONT>       */<a name="line.18876"></a>
<FONT color="green">18877</FONT>      public void setChartTitle(Widget chartTitle) {<a name="line.18877"></a>
<FONT color="green">18878</FONT>        chartDecorationsChanged = true;<a name="line.18878"></a>
<FONT color="green">18879</FONT>        this.chartTitle = chartTitle;<a name="line.18879"></a>
<FONT color="green">18880</FONT>      }<a name="line.18880"></a>
<FONT color="green">18881</FONT>    <a name="line.18881"></a>
<FONT color="green">18882</FONT>      /**<a name="line.18882"></a>
<FONT color="green">18883</FONT>       * Sets the thickness (height) of the rectangular region at the top of the<a name="line.18883"></a>
<FONT color="green">18884</FONT>       * chart allocated for the title.<a name="line.18884"></a>
<FONT color="green">18885</FONT>       * &lt;p&gt;<a name="line.18885"></a>
<FONT color="green">18886</FONT>       * <a name="line.18886"></a>
<FONT color="green">18887</FONT>       * Your title widget is always centered vertically and horizontally within<a name="line.18887"></a>
<FONT color="green">18888</FONT>       * this rectangular region.<a name="line.18888"></a>
<FONT color="green">18889</FONT>       * &lt;p&gt;<a name="line.18889"></a>
<FONT color="green">18890</FONT>       * <a name="line.18890"></a>
<FONT color="green">18891</FONT>       * This setting has no impact on chart layout if the title widget is<a name="line.18891"></a>
<FONT color="green">18892</FONT>       * &lt;tt&gt;null&lt;/tt&gt;, since the title-holding region is entirely eliminated in<a name="line.18892"></a>
<FONT color="green">18893</FONT>       * that case.<a name="line.18893"></a>
<FONT color="green">18894</FONT>       * <a name="line.18894"></a>
<FONT color="green">18895</FONT>       * If you set the title thickness to &lt;tt&gt;GChart.NAI&lt;/tt&gt; (the default) GChart<a name="line.18895"></a>
<FONT color="green">18896</FONT>       * will use a thickness that is based on the the number of &lt;tt&gt;&amp;lt;br&amp;gt;&lt;/tt&gt;<a name="line.18896"></a>
<FONT color="green">18897</FONT>       * or &lt;tt&gt;&amp;lt;li&amp;gt;&lt;/tt&gt; delimited HTML lines if the title Widget implements<a name="line.18897"></a>
<FONT color="green">18898</FONT>       * &lt;tt&gt;HasHTML&lt;/tt&gt;.<a name="line.18898"></a>
<FONT color="green">18899</FONT>       * <a name="line.18899"></a>
<FONT color="green">18900</FONT>       * @param thickness<a name="line.18900"></a>
<FONT color="green">18901</FONT>       *          the thickness (height) of the rectangle that contains the title,<a name="line.18901"></a>
<FONT color="green">18902</FONT>       *          in pixels, or &lt;tt&gt;GChart.NAI&lt;/tt&gt; to use the default thickness.<a name="line.18902"></a>
<FONT color="green">18903</FONT>       * <a name="line.18903"></a>
<FONT color="green">18904</FONT>       * @see #getChartTitleThickness getChartTitleThickness<a name="line.18904"></a>
<FONT color="green">18905</FONT>       * @see GChart#NAI GChart.NAI<a name="line.18905"></a>
<FONT color="green">18906</FONT>       * @see #DEFAULT_TITLE_THICKNESS DEFAULT_TITLE_THICKNESS<a name="line.18906"></a>
<FONT color="green">18907</FONT>       * <a name="line.18907"></a>
<FONT color="green">18908</FONT>       */<a name="line.18908"></a>
<FONT color="green">18909</FONT>      public void setChartTitleThickness(int thickness) {<a name="line.18909"></a>
<FONT color="green">18910</FONT>        chartDecorationsChanged = true;<a name="line.18910"></a>
<FONT color="green">18911</FONT>        this.titleThickness = thickness;<a name="line.18911"></a>
<FONT color="green">18912</FONT>      }<a name="line.18912"></a>
<FONT color="green">18913</FONT>    <a name="line.18913"></a>
<FONT color="green">18914</FONT>      /**<a name="line.18914"></a>
<FONT color="green">18915</FONT>       * Specifies if this chart will clip any rendered chart elements (including<a name="line.18915"></a>
<FONT color="green">18916</FONT>       * hover selection feedback and popup annotations) that extends beyond the<a name="line.18916"></a>
<FONT color="green">18917</FONT>       * bounds of the decorated chart.<a name="line.18917"></a>
<FONT color="green">18918</FONT>       * &lt;p&gt;<a name="line.18918"></a>
<FONT color="green">18919</FONT>       * <a name="line.18919"></a>
<FONT color="green">18920</FONT>       * The decorated chart includes not just the plot area, but space allocated<a name="line.18920"></a>
<FONT color="green">18921</FONT>       * for titles, footnotes, legend key, axis labels, tick marks, etc. The size<a name="line.18921"></a>
<FONT color="green">18922</FONT>       * of this decorated chart can be obtained via the<a name="line.18922"></a>
<FONT color="green">18923</FONT>       * &lt;tt&gt;getXChartSizeDecorated&lt;/tt&gt; and &lt;tt&gt;getYChartSizeDecorated&lt;/tt&gt;<a name="line.18923"></a>
<FONT color="green">18924</FONT>       * methods.<a name="line.18924"></a>
<FONT color="green">18925</FONT>       * &lt;p&gt;<a name="line.18925"></a>
<FONT color="green">18926</FONT>       * <a name="line.18926"></a>
<FONT color="green">18927</FONT>       * &lt;small&gt; Note that, in non-IE browsers, drawing a curve via<a name="line.18927"></a>
<FONT color="green">18928</FONT>       * &lt;tt&gt;GWTCanvas&lt;/tt&gt; that falls outside the bounds of the decorated chart<a name="line.18928"></a>
<FONT color="green">18929</FONT>       * could occlude mouse events over elements on the enclosing page &lt;i&gt;that fall<a name="line.18929"></a>
<FONT color="green">18930</FONT>       * within the smallest bounding rectangle that contains the canvas-rendered<a name="line.18930"></a>
<FONT color="green">18931</FONT>       * curve&lt;/i&gt;. HTML rendering (IE's element-based VML used by<a name="line.18931"></a>
<FONT color="green">18932</FONT>       * &lt;tt&gt;GWTCanvas&lt;/tt&gt; is essentially HTML-like in this respect) only creates<a name="line.18932"></a>
<FONT color="green">18933</FONT>       * such occlusions at the positions where the curve is actually rendered.<a name="line.18933"></a>
<FONT color="green">18934</FONT>       * &lt;/small&gt;<a name="line.18934"></a>
<FONT color="green">18935</FONT>       * <a name="line.18935"></a>
<FONT color="green">18936</FONT>       * @param clipToDecoratedChart<a name="line.18936"></a>
<FONT color="green">18937</FONT>       *          use &lt;tt&gt;true&lt;/tt&gt; to clip off-the-decorated-chart symbols,<a name="line.18937"></a>
<FONT color="green">18938</FONT>       *          annotations, etc. or &lt;tt&gt;false&lt;/tt&gt; (the default) to allow such<a name="line.18938"></a>
<FONT color="green">18939</FONT>       *          chart elements to be drawn outside of the rectangular region<a name="line.18939"></a>
<FONT color="green">18940</FONT>       *          allocated for the chart.<a name="line.18940"></a>
<FONT color="green">18941</FONT>       * <a name="line.18941"></a>
<FONT color="green">18942</FONT>       * @see #getClipToDecoratedChart getClipToDecoratedChart<a name="line.18942"></a>
<FONT color="green">18943</FONT>       * @see GChart#setClipToPlotArea GChart.setClipToPlotArea<a name="line.18943"></a>
<FONT color="green">18944</FONT>       * @see Curve#setClipToPlotArea Curve.setClipToPlotArea<a name="line.18944"></a>
<FONT color="green">18945</FONT>       * @see #getXChartSizeDecorated getXChartSizeDecorated<a name="line.18945"></a>
<FONT color="green">18946</FONT>       * @see #getYChartSizeDecorated getYChartSizeDecorated<a name="line.18946"></a>
<FONT color="green">18947</FONT>       * @see #setCanvasFactory setCanvasFactory<a name="line.18947"></a>
<FONT color="green">18948</FONT>       * <a name="line.18948"></a>
<FONT color="green">18949</FONT>       */<a name="line.18949"></a>
<FONT color="green">18950</FONT>    <a name="line.18950"></a>
<FONT color="green">18951</FONT>      public void setClipToDecoratedChart(boolean clipToDecoratedChart) {<a name="line.18951"></a>
<FONT color="green">18952</FONT>        chartDecorationsChanged = true;<a name="line.18952"></a>
<FONT color="green">18953</FONT>        invalidateAccessibleCurves();<a name="line.18953"></a>
<FONT color="green">18954</FONT>        this.clipToDecoratedChart = clipToDecoratedChart;<a name="line.18954"></a>
<FONT color="green">18955</FONT>      }<a name="line.18955"></a>
<FONT color="green">18956</FONT>    <a name="line.18956"></a>
<FONT color="green">18957</FONT>      /**<a name="line.18957"></a>
<FONT color="green">18958</FONT>       * Specifies if rendered graphics falling outside the plot area will be<a name="line.18958"></a>
<FONT color="green">18959</FONT>       * clipped off.<a name="line.18959"></a>
<FONT color="green">18960</FONT>       * &lt;p&gt;<a name="line.18960"></a>
<FONT color="green">18961</FONT>       * <a name="line.18961"></a>
<FONT color="green">18962</FONT>       * &lt;i&gt;Note:&lt;/i&gt; This clipping does not apply to the hover selection feedback.<a name="line.18962"></a>
<FONT color="green">18963</FONT>       * In particular, points that fall outside the plot area, though not visible,<a name="line.18963"></a>
<FONT color="green">18964</FONT>       * will still display their selection feedback and pop-up hover annotations<a name="line.18964"></a>
<FONT color="green">18965</FONT>       * when the user mouses over them.<a name="line.18965"></a>
<FONT color="green">18966</FONT>       * <a name="line.18966"></a>
<FONT color="green">18967</FONT>       * @param clipToPlotArea<a name="line.18967"></a>
<FONT color="green">18968</FONT>       *          &lt;tt&gt;false&lt;/tt&gt; (the default) to display off-the-plot-area<a name="line.18968"></a>
<FONT color="green">18969</FONT>       *          graphics, &lt;tt&gt;true&lt;/tt&gt; to clip them off.<a name="line.18969"></a>
<FONT color="green">18970</FONT>       * <a name="line.18970"></a>
<FONT color="green">18971</FONT>       * @see #getClipToPlotArea getClipToPlotArea<a name="line.18971"></a>
<FONT color="green">18972</FONT>       * @see #setClipToDecoratedChart setClipToDecoratedChart<a name="line.18972"></a>
<FONT color="green">18973</FONT>       * @see Curve#setClipToPlotArea Curve.setClipToPlotArea<a name="line.18973"></a>
<FONT color="green">18974</FONT>       * <a name="line.18974"></a>
<FONT color="green">18975</FONT>       */<a name="line.18975"></a>
<FONT color="green">18976</FONT>      public void setClipToPlotArea(boolean clipToPlotArea) {<a name="line.18976"></a>
<FONT color="green">18977</FONT>        chartDecorationsChanged = true;<a name="line.18977"></a>
<FONT color="green">18978</FONT>        invalidateAccessibleCurves();<a name="line.18978"></a>
<FONT color="green">18979</FONT>        this.clipToPlotArea = clipToPlotArea;<a name="line.18979"></a>
<FONT color="green">18980</FONT>      }<a name="line.18980"></a>
<FONT color="green">18981</FONT>    <a name="line.18981"></a>
<FONT color="green">18982</FONT>      /**<a name="line.18982"></a>
<FONT color="green">18983</FONT>       * Sets the symbol border colors that are used by default for newly created<a name="line.18983"></a>
<FONT color="green">18984</FONT>       * curves. The array must contain one or more elements, each a standard CSS or<a name="line.18984"></a>
<FONT color="green">18985</FONT>       * RGBA color specification string (see the &lt;tt&gt;setBackgroundColor&lt;/tt&gt; link<a name="line.18985"></a>
<FONT color="green">18986</FONT>       * below for more on CSS color specification strings) or the special GChart<a name="line.18986"></a>
<FONT color="green">18987</FONT>       * keyword &lt;tt&gt;TRANSPARENT_BORDER_COLOR&lt;/tt&gt;.<a name="line.18987"></a>
<FONT color="green">18988</FONT>       * &lt;p&gt;<a name="line.18988"></a>
<FONT color="green">18989</FONT>       * <a name="line.18989"></a>
<FONT color="green">18990</FONT>       * GChart uses the first color in this array as the default border color of<a name="line.18990"></a>
<FONT color="green">18991</FONT>       * the first curve added (via &lt;tt&gt;addCurve&lt;/tt&gt;), the second color for the<a name="line.18991"></a>
<FONT color="green">18992</FONT>       * second curve added, and so on. If more curves are added than the number of<a name="line.18992"></a>
<FONT color="green">18993</FONT>       * elements in the default border colors array, the sequence is repeated.<a name="line.18993"></a>
<FONT color="green">18994</FONT>       * <a name="line.18994"></a>
<FONT color="green">18995</FONT>       * &lt;p&gt;<a name="line.18995"></a>
<FONT color="green">18996</FONT>       * &lt;small&gt; Note that each curve/symbol's default color is "locked in" at the<a name="line.18996"></a>
<FONT color="green">18997</FONT>       * point when that curve/symbol is first added, based on the total number of<a name="line.18997"></a>
<FONT color="green">18998</FONT>       * curves at that time. &lt;/small&gt;<a name="line.18998"></a>
<FONT color="green">18999</FONT>       * <a name="line.18999"></a>
<FONT color="green">19000</FONT>       * &lt;p&gt;<a name="line.19000"></a>
<FONT color="green">19001</FONT>       * <a name="line.19001"></a>
<FONT color="green">19002</FONT>       * Because, by default, GChart uses a transparent symbol background color, the<a name="line.19002"></a>
<FONT color="green">19003</FONT>       * default border color will usually, in effect, define the default color of<a name="line.19003"></a>
<FONT color="green">19004</FONT>       * each curve. The default border color also defines the default color of<a name="line.19004"></a>
<FONT color="green">19005</FONT>       * point-to-point connecting lines in a line chart.<a name="line.19005"></a>
<FONT color="green">19006</FONT>       * &lt;p&gt;<a name="line.19006"></a>
<FONT color="green">19007</FONT>       * <a name="line.19007"></a>
<FONT color="green">19008</FONT>       * If not explicitly specified via this method, GChart uses<a name="line.19008"></a>
<FONT color="green">19009</FONT>       * &lt;tt&gt;GChart.DEFAULT_SYMBOL_BORDER_COLORS&lt;/tt&gt; by default. However, most<a name="line.19009"></a>
<FONT color="green">19010</FONT>       * people find the color sequence &lt;a href=<a name="line.19010"></a>
<FONT color="green">19011</FONT>       * "http://ui.openoffice.org/VisualDesign/OOoChart_colors_drafts.html#02"&gt;<a name="line.19011"></a>
<FONT color="green">19012</FONT>       * used by OpenOffice's Charts&lt;/a&gt; more aesthetically pleasing. The &lt;a<a name="line.19012"></a>
<FONT color="green">19013</FONT>       * href="package-summary.html#GChartExample22a"&gt;World's Simplest Line Chart<a name="line.19013"></a>
<FONT color="green">19014</FONT>       * Editor&lt;/a&gt; example chart contains a line of code that makes GChart use the<a name="line.19014"></a>
<FONT color="green">19015</FONT>       * OpenOffice defaults.<a name="line.19015"></a>
<FONT color="green">19016</FONT>       * &lt;p&gt;<a name="line.19016"></a>
<FONT color="green">19017</FONT>       * <a name="line.19017"></a>
<FONT color="green">19018</FONT>       * &lt;small&gt;This feature was added in response to an email from &lt;a<a name="line.19018"></a>
<FONT color="green">19019</FONT>       * href="http://www.profilercorp.com"&gt;Joe Cole&lt;/a&gt; and &lt;a<a name="line.19019"></a>
<FONT color="green">19020</FONT>       * href="http://gwt-ext.com/forum/viewtopic.php?f=13&amp;t=3465&amp;start=3"&gt; this<a name="line.19020"></a>
<FONT color="green">19021</FONT>       * post&lt;/a&gt; by Sanjiv Jivan. They both pointed out the importance of changing<a name="line.19021"></a>
<FONT color="green">19022</FONT>       * GChart's default colors.&lt;/small&gt;<a name="line.19022"></a>
<FONT color="green">19023</FONT>       * <a name="line.19023"></a>
<FONT color="green">19024</FONT>       * <a name="line.19024"></a>
<FONT color="green">19025</FONT>       * @param defaultBorderColors<a name="line.19025"></a>
<FONT color="green">19026</FONT>       *          array of CSS color strings whose successive elements define the<a name="line.19026"></a>
<FONT color="green">19027</FONT>       *          initial symbol border colors for curves in the order that they are<a name="line.19027"></a>
<FONT color="green">19028</FONT>       *          added.<a name="line.19028"></a>
<FONT color="green">19029</FONT>       * <a name="line.19029"></a>
<FONT color="green">19030</FONT>       * @see #DEFAULT_SYMBOL_BORDER_COLORS DEFAULT_SYMBOL_BORDER_COLORS<a name="line.19030"></a>
<FONT color="green">19031</FONT>       * @see #TRANSPARENT_BORDER_COLOR TRANSPARENT_BORDER_COLOR<a name="line.19031"></a>
<FONT color="green">19032</FONT>       * @see Symbol#setBackgroundColor setBackgroundColor<a name="line.19032"></a>
<FONT color="green">19033</FONT>       * @see Symbol#setBorderColor setBorderColor<a name="line.19033"></a>
<FONT color="green">19034</FONT>       * @see #addCurve addCurve<a name="line.19034"></a>
<FONT color="green">19035</FONT>       * <a name="line.19035"></a>
<FONT color="green">19036</FONT>       */<a name="line.19036"></a>
<FONT color="green">19037</FONT>    <a name="line.19037"></a>
<FONT color="green">19038</FONT>      static public void setDefaultSymbolBorderColors(String[] defaultBorderColors) {<a name="line.19038"></a>
<FONT color="green">19039</FONT>        if (null == defaultBorderColors)<a name="line.19039"></a>
<FONT color="green">19040</FONT>          throw new IllegalArgumentException(<a name="line.19040"></a>
<FONT color="green">19041</FONT>              "defaultBorderColors array cannot be null.");<a name="line.19041"></a>
<FONT color="green">19042</FONT>        else if (defaultBorderColors.length &lt; 1)<a name="line.19042"></a>
<FONT color="green">19043</FONT>          throw new IllegalArgumentException(<a name="line.19043"></a>
<FONT color="green">19044</FONT>              "defaultBorderColors array must have at least 1 element.");<a name="line.19044"></a>
<FONT color="green">19045</FONT>        else<a name="line.19045"></a>
<FONT color="green">19046</FONT>          defaultSymbolBorderColors = defaultBorderColors;<a name="line.19046"></a>
<FONT color="green">19047</FONT>    <a name="line.19047"></a>
<FONT color="green">19048</FONT>      }<a name="line.19048"></a>
<FONT color="green">19049</FONT>    <a name="line.19049"></a>
<FONT color="green">19050</FONT>      /**<a name="line.19050"></a>
<FONT color="green">19051</FONT>       * Specifies the font-family that is used, by default, for all<a name="line.19051"></a>
<FONT color="green">19052</FONT>       * textual annotations (tick labels, point labels, title, footnotes,<a name="line.19052"></a>
<FONT color="green">19053</FONT>       * legend labels, and axis labels) on this chart. <a name="line.19053"></a>
<FONT color="green">19054</FONT>       * &lt;p&gt;<a name="line.19054"></a>
<FONT color="green">19055</FONT>       *<a name="line.19055"></a>
<FONT color="green">19056</FONT>       * This chart-specific default font family setting will be overridden<a name="line.19056"></a>
<FONT color="green">19057</FONT>       * if a more specific method of setting the font family has been<a name="line.19057"></a>
<FONT color="green">19058</FONT>       * employed.<a name="line.19058"></a>
<FONT color="green">19059</FONT>       * <a name="line.19059"></a>
<FONT color="green">19060</FONT>       * &lt;p&gt;<a name="line.19060"></a>
<FONT color="green">19061</FONT>       *<a name="line.19061"></a>
<FONT color="green">19062</FONT>       * The default overall font family is &lt;tt&gt;DEFAULT_FONT_FAMILY&lt;/tt&gt;.<a name="line.19062"></a>
<FONT color="green">19063</FONT>       * <a name="line.19063"></a>
<FONT color="green">19064</FONT>       * @see Axis#setTickLabelFontFamily setTickLabelFontFamily<a name="line.19064"></a>
<FONT color="green">19065</FONT>       * @see Point#setAnnotationFontFamily setAnnotationFontFamily<a name="line.19065"></a>
<FONT color="green">19066</FONT>       * @see #setLegendFontFamily setLegendFontFamily<a name="line.19066"></a>
<FONT color="green">19067</FONT>       * @see #DEFAULT_FONT_FAMILY DEFAULT_FONT_FAMILY<a name="line.19067"></a>
<FONT color="green">19068</FONT>       * <a name="line.19068"></a>
<FONT color="green">19069</FONT>       */<a name="line.19069"></a>
<FONT color="green">19070</FONT>      public void setFontFamily(String fontFamily) {<a name="line.19070"></a>
<FONT color="green">19071</FONT>        chartDecorationsChanged = true;<a name="line.19071"></a>
<FONT color="green">19072</FONT>        this.fontFamily = fontFamily;<a name="line.19072"></a>
<FONT color="green">19073</FONT>      }<a name="line.19073"></a>
<FONT color="green">19074</FONT>    <a name="line.19074"></a>
<FONT color="green">19075</FONT>      /**<a name="line.19075"></a>
<FONT color="green">19076</FONT>       * Specifies the single color used for all gridlines, axes lines, and tick<a name="line.19076"></a>
<FONT color="green">19077</FONT>       * marks.<a name="line.19077"></a>
<FONT color="green">19078</FONT>       * <a name="line.19078"></a>
<FONT color="green">19079</FONT>       * <a name="line.19079"></a>
<FONT color="green">19080</FONT>       * &lt;p&gt;<a name="line.19080"></a>
<FONT color="green">19081</FONT>       * For more information on standard CSS color specifications see the<a name="line.19081"></a>
<FONT color="green">19082</FONT>       * discussion in {@link Symbol#setBackgroundColor Symbol.setBackgroundColor}.<a name="line.19082"></a>
<FONT color="green">19083</FONT>       * &lt;p&gt;<a name="line.19083"></a>
<FONT color="green">19084</FONT>       * <a name="line.19084"></a>
<FONT color="green">19085</FONT>       * @param cssColor<a name="line.19085"></a>
<FONT color="green">19086</FONT>       *          the color, in CSS standard color format, to be used for all<a name="line.19086"></a>
<FONT color="green">19087</FONT>       *          gridlines, axes, and tick marks.<a name="line.19087"></a>
<FONT color="green">19088</FONT>       * <a name="line.19088"></a>
<FONT color="green">19089</FONT>       * @see #getGridColor getGridColor<a name="line.19089"></a>
<FONT color="green">19090</FONT>       * @see #DEFAULT_GRID_COLOR DEFAULT_GRID_COLOR<a name="line.19090"></a>
<FONT color="green">19091</FONT>       * <a name="line.19091"></a>
<FONT color="green">19092</FONT>       */<a name="line.19092"></a>
<FONT color="green">19093</FONT>      public void setGridColor(String cssColor) {<a name="line.19093"></a>
<FONT color="green">19094</FONT>        // TODO: support line style for dotted/dashed gridlines lines,<a name="line.19094"></a>
<FONT color="green">19095</FONT>        // allow tick and grid colors to be specified separately, etc.<a name="line.19095"></a>
<FONT color="green">19096</FONT>        getSystemCurve(XGRIDLINES_ID).getSymbol().setBorderColor(cssColor);<a name="line.19096"></a>
<FONT color="green">19097</FONT>        getSystemCurve(YGRIDLINES_ID).getSymbol().setBorderColor(cssColor);<a name="line.19097"></a>
<FONT color="green">19098</FONT>        getSystemCurve(Y2GRIDLINES_ID).getSymbol().setBorderColor(cssColor);<a name="line.19098"></a>
<FONT color="green">19099</FONT>        getSystemCurve(XAXIS_ID).getSymbol().setBorderColor(cssColor);<a name="line.19099"></a>
<FONT color="green">19100</FONT>        getSystemCurve(YAXIS_ID).getSymbol().setBorderColor(cssColor);<a name="line.19100"></a>
<FONT color="green">19101</FONT>        getSystemCurve(Y2AXIS_ID).getSymbol().setBorderColor(cssColor);<a name="line.19101"></a>
<FONT color="green">19102</FONT>        getSystemCurve(XTICKS_ID).getSymbol().setBorderColor(cssColor);<a name="line.19102"></a>
<FONT color="green">19103</FONT>        getSystemCurve(YTICKS_ID).getSymbol().setBorderColor(cssColor);<a name="line.19103"></a>
<FONT color="green">19104</FONT>        getSystemCurve(Y2TICKS_ID).getSymbol().setBorderColor(cssColor);<a name="line.19104"></a>
<FONT color="green">19105</FONT>      }<a name="line.19105"></a>
<FONT color="green">19106</FONT>    <a name="line.19106"></a>
<FONT color="green">19107</FONT>      /**<a name="line.19107"></a>
<FONT color="green">19108</FONT>       * Defines this GChart's hover parameter interpreter.<a name="line.19108"></a>
<FONT color="green">19109</FONT>       * &lt;p&gt;<a name="line.19109"></a>
<FONT color="green">19110</FONT>       * <a name="line.19110"></a>
<FONT color="green">19111</FONT>       * Hovertext template strings can include &lt;tt&gt;${&lt;/tt&gt;... &lt;tt&gt;}&lt;/tt&gt; bracketed<a name="line.19111"></a>
<FONT color="green">19112</FONT>       * references to built-in parameters such as &lt;tt&gt;${x}&lt;/tt&gt; and &lt;tt&gt;${y}&lt;/tt&gt;<a name="line.19112"></a>
<FONT color="green">19113</FONT>       * that get get replaced with appropriate string representations of the x or y<a name="line.19113"></a>
<FONT color="green">19114</FONT>       * values of the hovered-over point in displayed hovertext. You can add new,<a name="line.19114"></a>
<FONT color="green">19115</FONT>       * custom, named parameters, and/or redefine the meaning of built-in<a name="line.19115"></a>
<FONT color="green">19116</FONT>       * parameters, by passing a hover parameter interpreter to this method.<a name="line.19116"></a>
<FONT color="green">19117</FONT>       * &lt;p&gt;<a name="line.19117"></a>
<FONT color="green">19118</FONT>       * <a name="line.19118"></a>
<FONT color="green">19119</FONT>       * For sample code that shows you how to define a hover parameter interpreter,<a name="line.19119"></a>
<FONT color="green">19120</FONT>       * see &lt;tt&gt;HoverParameterInterpreter&lt;/tt&gt;.<a name="line.19120"></a>
<FONT color="green">19121</FONT>       * <a name="line.19121"></a>
<FONT color="green">19122</FONT>       * @see HoverParameterInterpreter HoverParameterInterpreter<a name="line.19122"></a>
<FONT color="green">19123</FONT>       * @see Symbol#setHovertextTemplate setHovertextTemplate<a name="line.19123"></a>
<FONT color="green">19124</FONT>       * <a name="line.19124"></a>
<FONT color="green">19125</FONT>       * @param hpi<a name="line.19125"></a>
<FONT color="green">19126</FONT>       *          the hover parameter interpreter to use with all hovertext<a name="line.19126"></a>
<FONT color="green">19127</FONT>       *          templates on this GChart (this interpreter is responsible for<a name="line.19127"></a>
<FONT color="green">19128</FONT>       *          replacing &lt;tt&gt;${&lt;/tt&gt;...&lt;tt&gt;}&lt;/tt&gt; bracketed embedded parameter<a name="line.19128"></a>
<FONT color="green">19129</FONT>       *          names in the hover text template with appropriate HTML snippets<a name="line.19129"></a>
<FONT color="green">19130</FONT>       *          representing the value of that parameter at the hovered-over<a name="line.19130"></a>
<FONT color="green">19131</FONT>       *          point).<a name="line.19131"></a>
<FONT color="green">19132</FONT>       * <a name="line.19132"></a>
<FONT color="green">19133</FONT>       */<a name="line.19133"></a>
<FONT color="green">19134</FONT>      public void setHoverParameterInterpreter(HoverParameterInterpreter hpi) {<a name="line.19134"></a>
<FONT color="green">19135</FONT>        hoverParameterInterpreter = hpi;<a name="line.19135"></a>
<FONT color="green">19136</FONT>      }<a name="line.19136"></a>
<FONT color="green">19137</FONT>    <a name="line.19137"></a>
<FONT color="green">19138</FONT>      /**<a name="line.19138"></a>
<FONT color="green">19139</FONT>       * Specifies if merely hovering over a point is sufficient to select it and<a name="line.19139"></a>
<FONT color="green">19140</FONT>       * display its hover annotation (&lt;tt&gt;true&lt;/tt&gt;), or if an actual click is<a name="line.19140"></a>
<FONT color="green">19141</FONT>       * needed (&lt;tt&gt;false&lt;/tt&gt;).<a name="line.19141"></a>
<FONT color="green">19142</FONT>       * &lt;p&gt;<a name="line.19142"></a>
<FONT color="green">19143</FONT>       * <a name="line.19143"></a>
<FONT color="green">19144</FONT>       * With the default of &lt;tt&gt;true&lt;/tt&gt;, points are auto-selected as the user<a name="line.19144"></a>
<FONT color="green">19145</FONT>       * "touches" them with the mouse-attached "brush"--no clicking is required.<a name="line.19145"></a>
<FONT color="green">19146</FONT>       * &lt;p&gt;<a name="line.19146"></a>
<FONT color="green">19147</FONT>       * <a name="line.19147"></a>
<FONT color="green">19148</FONT>       * When hover touching is disabled, a GChart can be used in a manner analogous<a name="line.19148"></a>
<FONT color="green">19149</FONT>       * to a single-selection (sorry there's no multi-selection capability)<a name="line.19149"></a>
<FONT color="green">19150</FONT>       * listbox, with its click-selectable points playing the role of the<a name="line.19150"></a>
<FONT color="green">19151</FONT>       * selectable list items. Specifically, disabling hover touching lets you move<a name="line.19151"></a>
<FONT color="green">19152</FONT>       * the mouse freely without any danger of changing the selected point--the<a name="line.19152"></a>
<FONT color="green">19153</FONT>       * point even remains selected if the mouse moves entirely off the chart. This<a name="line.19153"></a>
<FONT color="green">19154</FONT>       * is helpful when your application follows the common pattern of "select the<a name="line.19154"></a>
<FONT color="green">19155</FONT>       * thing you want to operate on, then issue a command that operates on that<a name="line.19155"></a>
<FONT color="green">19156</FONT>       * thing". This option is also helpful if you use very compute-intensive hover<a name="line.19156"></a>
<FONT color="green">19157</FONT>       * widgets, or if you simply prefer explictly-clicked-open/closed pop-up<a name="line.19157"></a>
<FONT color="green">19158</FONT>       * annotations.<a name="line.19158"></a>
<FONT color="green">19159</FONT>       * &lt;p&gt;<a name="line.19159"></a>
<FONT color="green">19160</FONT>       * <a name="line.19160"></a>
<FONT color="green">19161</FONT>       * &lt;small&gt; &lt;i&gt;How to Stop Leaky Clicks:&lt;/i&gt; In IE7 and the hosted mode<a name="line.19161"></a>
<FONT color="green">19162</FONT>       * browser, clicking ahead on a &lt;tt&gt;Button&lt;/tt&gt; widget "leaks" clicks upwards<a name="line.19162"></a>
<FONT color="green">19163</FONT>       * to the enclosing parent, even if you call<a name="line.19163"></a>
<FONT color="green">19164</FONT>       * &lt;tt&gt;event.cancelBubble(true)&lt;/tt&gt;.<a name="line.19164"></a>
<FONT color="green">19165</FONT>       * Such "leaky clicks" can inappropriately change the selected point, when<a name="line.19165"></a>
<FONT color="green">19166</FONT>       * you really just wanted to operate on it. This does not happen in Firefox 2,<a name="line.19166"></a>
<FONT color="green">19167</FONT>       * 3, or Chrome, whose buttons properly "eat" the clicks--even when they come<a name="line.19167"></a>
<FONT color="green">19168</FONT>       * in fast. To workaround the problem, you can place the buttons into a hover<a name="line.19168"></a>
<FONT color="green">19169</FONT>       * widget (as shown in &lt;tt&gt;GChartExample21.java&lt;/tt&gt; in the chart gallery).<a name="line.19169"></a>
<FONT color="green">19170</FONT>       * This works because GChart applies checks that ignore any mouse events that<a name="line.19170"></a>
<FONT color="green">19171</FONT>       * occur within the rectangular region associated with the opened hover<a name="line.19171"></a>
<FONT color="green">19172</FONT>       * widget. &lt;/small&gt;<a name="line.19172"></a>
<FONT color="green">19173</FONT>       * &lt;p&gt;<a name="line.19173"></a>
<FONT color="green">19174</FONT>       * <a name="line.19174"></a>
<FONT color="green">19175</FONT>       * For an example that uses &lt;tt&gt;setHoverTouchingEnabled(false)&lt;/tt&gt; to allow<a name="line.19175"></a>
<FONT color="green">19176</FONT>       * the user to change the y-value of the selected point, see the Chart<a name="line.19176"></a>
<FONT color="green">19177</FONT>       * Gallery's &lt;a href="package-summary.html#GChartExample21"&gt;<a name="line.19177"></a>
<FONT color="green">19178</FONT>       * GChartExample21&lt;/a&gt;.<a name="line.19178"></a>
<FONT color="green">19179</FONT>       * <a name="line.19179"></a>
<FONT color="green">19180</FONT>       * <a name="line.19180"></a>
<FONT color="green">19181</FONT>       * @param hoverTouchingEnabled<a name="line.19181"></a>
<FONT color="green">19182</FONT>       *          &lt;tt&gt;true&lt;/tt&gt; (the default) if you want users to be able to select<a name="line.19182"></a>
<FONT color="green">19183</FONT>       *          points simply by hovering over them with their mouse,<a name="line.19183"></a>
<FONT color="green">19184</FONT>       *          &lt;tt&gt;false&lt;/tt&gt; if you want to require that they actually click on<a name="line.19184"></a>
<FONT color="green">19185</FONT>       *          points to select them.<a name="line.19185"></a>
<FONT color="green">19186</FONT>       * <a name="line.19186"></a>
<FONT color="green">19187</FONT>       * @see #getHoverTouchingEnabled getHoverTouchingEnabled<a name="line.19187"></a>
<FONT color="green">19188</FONT>       * @see Symbol#setBrushHeight setBrushHeight<a name="line.19188"></a>
<FONT color="green">19189</FONT>       * @see #touch touch<a name="line.19189"></a>
<FONT color="green">19190</FONT>       * @see #update update<a name="line.19190"></a>
<FONT color="green">19191</FONT>       * @see HoverUpdateable HoverUpdateable<a name="line.19191"></a>
<FONT color="green">19192</FONT>       * <a name="line.19192"></a>
<FONT color="green">19193</FONT>       */<a name="line.19193"></a>
<FONT color="green">19194</FONT>      public void setHoverTouchingEnabled(boolean hoverTouchingEnabled) {<a name="line.19194"></a>
<FONT color="green">19195</FONT>        this.hoverTouchingEnabled = hoverTouchingEnabled;<a name="line.19195"></a>
<FONT color="green">19196</FONT>      }<a name="line.19196"></a>
<FONT color="green">19197</FONT>    <a name="line.19197"></a>
<FONT color="green">19198</FONT>      private double initialPieSliceOrientation = 0.0;<a name="line.19198"></a>
<FONT color="green">19199</FONT>      /**<a name="line.19199"></a>
<FONT color="green">19200</FONT>       * Sets the default initial orientation for pie slices.<a name="line.19200"></a>
<FONT color="green">19201</FONT>       * &lt;p&gt;<a name="line.19201"></a>
<FONT color="green">19202</FONT>       * <a name="line.19202"></a>
<FONT color="green">19203</FONT>       * The default initial orientation is used as the first pie slice's first<a name="line.19203"></a>
<FONT color="green">19204</FONT>       * edge's orientation setting only if the symbol associated with that pie<a name="line.19204"></a>
<FONT color="green">19205</FONT>       * slice has the default, undefined, orientation setting of<a name="line.19205"></a>
<FONT color="green">19206</FONT>       * &lt;tt&gt;Double.NaN&lt;/tt&gt;.<a name="line.19206"></a>
<FONT color="green">19207</FONT>       * &lt;p&gt;<a name="line.19207"></a>
<FONT color="green">19208</FONT>       * <a name="line.19208"></a>
<FONT color="green">19209</FONT>       * The default value of this setting is 0, which corresponds to due south (6<a name="line.19209"></a>
<FONT color="green">19210</FONT>       * o'clock). The value specifies the fraction of a complete clockwise<a name="line.19210"></a>
<FONT color="green">19211</FONT>       * rotation, beginning at due south, required to reach the first edge of the<a name="line.19211"></a>
<FONT color="green">19212</FONT>       * pie slice.<a name="line.19212"></a>
<FONT color="green">19213</FONT>       * <a name="line.19213"></a>
<FONT color="green">19214</FONT>       * @see Symbol#setPieSliceOrientation setPieSliceOrientation<a name="line.19214"></a>
<FONT color="green">19215</FONT>       * <a name="line.19215"></a>
<FONT color="green">19216</FONT>       * @param orientation<a name="line.19216"></a>
<FONT color="green">19217</FONT>       *          the orientation to use for the first edge of the first pie slice<a name="line.19217"></a>
<FONT color="green">19218</FONT>       *          in this GChart, in cases in which that first pie slice's<a name="line.19218"></a>
<FONT color="green">19219</FONT>       *          orientation is undefined (&lt;tt&gt;Double.NaN&lt;/tt&gt;).<a name="line.19219"></a>
<FONT color="green">19220</FONT>       */<a name="line.19220"></a>
<FONT color="green">19221</FONT>    <a name="line.19221"></a>
<FONT color="green">19222</FONT>      public void setInitialPieSliceOrientation(double orientation) {<a name="line.19222"></a>
<FONT color="green">19223</FONT>        if (orientation &lt; 0 || orientation &gt;= 1)<a name="line.19223"></a>
<FONT color="green">19224</FONT>          throw new IllegalArgumentException("orientation=" + orientation<a name="line.19224"></a>
<FONT color="green">19225</FONT>                                             + "; " + "orientation must be &gt;=0 and &lt; 1.");<a name="line.19225"></a>
<FONT color="green">19226</FONT>        this.initialPieSliceOrientation = orientation;<a name="line.19226"></a>
<FONT color="green">19227</FONT>        invalidateAllSlices();<a name="line.19227"></a>
<FONT color="green">19228</FONT>      }<a name="line.19228"></a>
<FONT color="green">19229</FONT>    <a name="line.19229"></a>
<FONT color="green">19230</FONT>      /**<a name="line.19230"></a>
<FONT color="green">19231</FONT>       * Sets the background color of the chart's legend.<a name="line.19231"></a>
<FONT color="green">19232</FONT>       * <a name="line.19232"></a>
<FONT color="green">19233</FONT>       * <a name="line.19233"></a>
<FONT color="green">19234</FONT>       * &lt;p&gt;<a name="line.19234"></a>
<FONT color="green">19235</FONT>       * For more information on standard CSS color specifications see the<a name="line.19235"></a>
<FONT color="green">19236</FONT>       * discussion in {@link Symbol#setBackgroundColor Symbol.setBackgroundColor}.<a name="line.19236"></a>
<FONT color="green">19237</FONT>       * &lt;p&gt;<a name="line.19237"></a>
<FONT color="green">19238</FONT>       * <a name="line.19238"></a>
<FONT color="green">19239</FONT>       * @param cssColor<a name="line.19239"></a>
<FONT color="green">19240</FONT>       *          the legend's background color, in a standard CSS color string<a name="line.19240"></a>
<FONT color="green">19241</FONT>       *          format.<a name="line.19241"></a>
<FONT color="green">19242</FONT>       * <a name="line.19242"></a>
<FONT color="green">19243</FONT>       * @see #getLegendBackgroundColor getLegendBackgroundColor<a name="line.19243"></a>
<FONT color="green">19244</FONT>       * @see #DEFAULT_LEGEND_BACKGROUND_COLOR DEFAULT_LEGEND_BACKGROUND_COLOR<a name="line.19244"></a>
<FONT color="green">19245</FONT>       */<a name="line.19245"></a>
<FONT color="green">19246</FONT>      public void setLegendBackgroundColor(String cssColor) {<a name="line.19246"></a>
<FONT color="green">19247</FONT>        chartDecorationsChanged = true;<a name="line.19247"></a>
<FONT color="green">19248</FONT>        legendBackgroundColor = cssColor;<a name="line.19248"></a>
<FONT color="green">19249</FONT>      }<a name="line.19249"></a>
<FONT color="green">19250</FONT>    <a name="line.19250"></a>
<FONT color="green">19251</FONT>      /**<a name="line.19251"></a>
<FONT color="green">19252</FONT>       * Sets the border color of the chart's legend.<a name="line.19252"></a>
<FONT color="green">19253</FONT>       * <a name="line.19253"></a>
<FONT color="green">19254</FONT>       * <a name="line.19254"></a>
<FONT color="green">19255</FONT>       * &lt;p&gt;<a name="line.19255"></a>
<FONT color="green">19256</FONT>       * For more information on standard CSS color specifications see the<a name="line.19256"></a>
<FONT color="green">19257</FONT>       * discussion in {@link Symbol#setBackgroundColor Symbol.setBackgroundColor}.<a name="line.19257"></a>
<FONT color="green">19258</FONT>       * &lt;p&gt;<a name="line.19258"></a>
<FONT color="green">19259</FONT>       * <a name="line.19259"></a>
<FONT color="green">19260</FONT>       * @param cssColor<a name="line.19260"></a>
<FONT color="green">19261</FONT>       *          the color of the legend's border, in a standard CSS color string<a name="line.19261"></a>
<FONT color="green">19262</FONT>       *          format, of the special GChart keyword<a name="line.19262"></a>
<FONT color="green">19263</FONT>       *          &lt;tt&gt;TRANSPARENT_BORDER_COLOR&lt;/tt&gt; for a transparent border.<a name="line.19263"></a>
<FONT color="green">19264</FONT>       * <a name="line.19264"></a>
<FONT color="green">19265</FONT>       * <a name="line.19265"></a>
<FONT color="green">19266</FONT>       * @see #getLegendBorderColor getLegendBorderColor<a name="line.19266"></a>
<FONT color="green">19267</FONT>       * @see #DEFAULT_LEGEND_BORDER_COLOR DEFAULT_LEGEND_BORDER_COLOR<a name="line.19267"></a>
<FONT color="green">19268</FONT>       * @see #TRANSPARENT_BORDER_COLOR TRANSPARENT_BORDER_COLOR<a name="line.19268"></a>
<FONT color="green">19269</FONT>       * <a name="line.19269"></a>
<FONT color="green">19270</FONT>       */<a name="line.19270"></a>
<FONT color="green">19271</FONT>      public void setLegendBorderColor(String cssColor) {<a name="line.19271"></a>
<FONT color="green">19272</FONT>        chartDecorationsChanged = true;<a name="line.19272"></a>
<FONT color="green">19273</FONT>        legendBorderColor = cssColor;<a name="line.19273"></a>
<FONT color="green">19274</FONT>      }<a name="line.19274"></a>
<FONT color="green">19275</FONT>    <a name="line.19275"></a>
<FONT color="green">19276</FONT>      /**<a name="line.19276"></a>
<FONT color="green">19277</FONT>       * Sets the width of the chart legend's border.<a name="line.19277"></a>
<FONT color="green">19278</FONT>       * <a name="line.19278"></a>
<FONT color="green">19279</FONT>       * @param width<a name="line.19279"></a>
<FONT color="green">19280</FONT>       *          the width of the legend's border, in pixels<a name="line.19280"></a>
<FONT color="green">19281</FONT>       * <a name="line.19281"></a>
<FONT color="green">19282</FONT>       * @see #getLegendBorderWidth getLegendBorderWidth<a name="line.19282"></a>
<FONT color="green">19283</FONT>       * @see #DEFAULT_LEGEND_BORDER_WIDTH DEFAULT_LEGEND_BORDER_WIDTH<a name="line.19283"></a>
<FONT color="green">19284</FONT>       */<a name="line.19284"></a>
<FONT color="green">19285</FONT>      public void setLegendBorderWidth(int width) {<a name="line.19285"></a>
<FONT color="green">19286</FONT>        chartDecorationsChanged = true;<a name="line.19286"></a>
<FONT color="green">19287</FONT>        legendBorderWidth = width;<a name="line.19287"></a>
<FONT color="green">19288</FONT>      }<a name="line.19288"></a>
<FONT color="green">19289</FONT>    <a name="line.19289"></a>
<FONT color="green">19290</FONT>      /**<a name="line.19290"></a>
<FONT color="green">19291</FONT>       * Sets style of the border around the chart's legend (key).<a name="line.19291"></a>
<FONT color="green">19292</FONT>       * <a name="line.19292"></a>
<FONT color="green">19293</FONT>       * &lt;p&gt;<a name="line.19293"></a>
<FONT color="green">19294</FONT>       * <a name="line.19294"></a>
<FONT color="green">19295</FONT>       * &lt;p&gt;<a name="line.19295"></a>
<FONT color="green">19296</FONT>       * <a name="line.19296"></a>
<FONT color="green">19297</FONT>       * @param borderStyle<a name="line.19297"></a>
<FONT color="green">19298</FONT>       *          a CSS border style such as "solid", "dotted", "dashed", etc.<a name="line.19298"></a>
<FONT color="green">19299</FONT>       * <a name="line.19299"></a>
<FONT color="green">19300</FONT>       * @see #getLegendBorderStyle getLegendBorderStyle<a name="line.19300"></a>
<FONT color="green">19301</FONT>       * @see #setLegendBackgroundColor setLegendBackgroundColor<a name="line.19301"></a>
<FONT color="green">19302</FONT>       * @see #setLegendBorderColor setLegendBorderColor<a name="line.19302"></a>
<FONT color="green">19303</FONT>       * @see #DEFAULT_LEGEND_BORDER_STYLE DEFAULT_LEGEND_BORDER_STYLE<a name="line.19303"></a>
<FONT color="green">19304</FONT>       */<a name="line.19304"></a>
<FONT color="green">19305</FONT>      public void setLegendBorderStyle(String borderStyle) {<a name="line.19305"></a>
<FONT color="green">19306</FONT>        chartDecorationsChanged = true;<a name="line.19306"></a>
<FONT color="green">19307</FONT>        legendBorderStyle = borderStyle;<a name="line.19307"></a>
<FONT color="green">19308</FONT>      }<a name="line.19308"></a>
<FONT color="green">19309</FONT>    <a name="line.19309"></a>
<FONT color="green">19310</FONT>      /**<a name="line.19310"></a>
<FONT color="green">19311</FONT>       * Specifies the color of the legend's font. Default is<a name="line.19311"></a>
<FONT color="green">19312</FONT>       * &lt;tt&gt;DEFAULT_FONT_COLOR&lt;/tt&gt;.<a name="line.19312"></a>
<FONT color="green">19313</FONT>       * <a name="line.19313"></a>
<FONT color="green">19314</FONT>       * <a name="line.19314"></a>
<FONT color="green">19315</FONT>       * &lt;p&gt;<a name="line.19315"></a>
<FONT color="green">19316</FONT>       * For more information on standard CSS color specifications see the<a name="line.19316"></a>
<FONT color="green">19317</FONT>       * discussion in {@link Symbol#setBackgroundColor Symbol.setBackgroundColor}.<a name="line.19317"></a>
<FONT color="green">19318</FONT>       * &lt;p&gt;<a name="line.19318"></a>
<FONT color="green">19319</FONT>       * <a name="line.19319"></a>
<FONT color="green">19320</FONT>       * @param cssColor<a name="line.19320"></a>
<FONT color="green">19321</FONT>       *          color of the font used to display the labels in the legend.<a name="line.19321"></a>
<FONT color="green">19322</FONT>       * <a name="line.19322"></a>
<FONT color="green">19323</FONT>       * @see #getLegendFontColor getLegendFontColor<a name="line.19323"></a>
<FONT color="green">19324</FONT>       * @see #DEFAULT_FONT_COLOR DEFAULT_FONT_COLOR<a name="line.19324"></a>
<FONT color="green">19325</FONT>       * <a name="line.19325"></a>
<FONT color="green">19326</FONT>       */<a name="line.19326"></a>
<FONT color="green">19327</FONT>      public void setLegendFontColor(String cssColor) {<a name="line.19327"></a>
<FONT color="green">19328</FONT>        chartDecorationsChanged = true;<a name="line.19328"></a>
<FONT color="green">19329</FONT>        legendFontColor = cssColor;<a name="line.19329"></a>
<FONT color="green">19330</FONT>      }<a name="line.19330"></a>
<FONT color="green">19331</FONT>    <a name="line.19331"></a>
<FONT color="green">19332</FONT>      /**<a name="line.19332"></a>
<FONT color="green">19333</FONT>       * Specifies the CSS font size, in pixels, of text displayed in the chart's<a name="line.19333"></a>
<FONT color="green">19334</FONT>       * legend (also know as a chart's key).<a name="line.19334"></a>
<FONT color="green">19335</FONT>       * &lt;p&gt;<a name="line.19335"></a>
<FONT color="green">19336</FONT>       * This size also governs the size of the symbol icon displayed in the legend.<a name="line.19336"></a>
<FONT color="green">19337</FONT>       * &lt;p&gt;<a name="line.19337"></a>
<FONT color="green">19338</FONT>       * Default is &lt;tt&gt;DEFAULT_LEGEND_FONTSIZE&lt;/tt&gt;.<a name="line.19338"></a>
<FONT color="green">19339</FONT>       * <a name="line.19339"></a>
<FONT color="green">19340</FONT>       * @param legendFontSize<a name="line.19340"></a>
<FONT color="green">19341</FONT>       *          the font size of legend text<a name="line.19341"></a>
<FONT color="green">19342</FONT>       * <a name="line.19342"></a>
<FONT color="green">19343</FONT>       * @see #getLegendFontSize getLegendFontSize<a name="line.19343"></a>
<FONT color="green">19344</FONT>       * @see #DEFAULT_LEGEND_FONTSIZE DEFAULT_LEGEND_FONTSIZE<a name="line.19344"></a>
<FONT color="green">19345</FONT>       * <a name="line.19345"></a>
<FONT color="green">19346</FONT>       */<a name="line.19346"></a>
<FONT color="green">19347</FONT>      public void setLegendFontSize(int legendFontSize) {<a name="line.19347"></a>
<FONT color="green">19348</FONT>        chartDecorationsChanged = true;<a name="line.19348"></a>
<FONT color="green">19349</FONT>        this.legendFontSize = legendFontSize;<a name="line.19349"></a>
<FONT color="green">19350</FONT>      }<a name="line.19350"></a>
<FONT color="green">19351</FONT>    <a name="line.19351"></a>
<FONT color="green">19352</FONT>      /**<a name="line.19352"></a>
<FONT color="green">19353</FONT>       * Specifies the CSS font-family of the font used to render the legend's<a name="line.19353"></a>
<FONT color="green">19354</FONT>       * labels.<a name="line.19354"></a>
<FONT color="green">19355</FONT>       * &lt;p&gt;<a name="line.19355"></a>
<FONT color="green">19356</FONT>       *<a name="line.19356"></a>
<FONT color="green">19357</FONT>       * If &lt;tt&gt;null&lt;/tt&gt; (the default) the legend will just use the font<a name="line.19357"></a>
<FONT color="green">19358</FONT>       * family specified via &lt;tt&gt;GChart.setFontFamily&lt;/tt&gt;.<a name="line.19358"></a>
<FONT color="green">19359</FONT>       * <a name="line.19359"></a>
<FONT color="green">19360</FONT>       * @param cssFontFamily<a name="line.19360"></a>
<FONT color="green">19361</FONT>       *          any valid CSS font-family, such as<a name="line.19361"></a>
<FONT color="green">19362</FONT>       *          &lt;tt&gt;"serif", "sans-serif", "monospace", "cursive",<a name="line.19362"></a>
<FONT color="green">19363</FONT>       * * "fantasy"&lt;/tt&gt; or &lt;tt&gt;"Arial, sans-serif"&lt;/tt&gt;.<a name="line.19363"></a>
<FONT color="green">19364</FONT>       * <a name="line.19364"></a>
<FONT color="green">19365</FONT>       * @see #getLegendFontFamily getLegendFontFamily<a name="line.19365"></a>
<FONT color="green">19366</FONT>       * @see #DEFAULT_FONT_FAMILY DEFAULT_FONT_FAMILY<a name="line.19366"></a>
<FONT color="green">19367</FONT>       * <a name="line.19367"></a>
<FONT color="green">19368</FONT>       */<a name="line.19368"></a>
<FONT color="green">19369</FONT>      public void setLegendFontFamily(String cssFontFamily) {<a name="line.19369"></a>
<FONT color="green">19370</FONT>        chartDecorationsChanged = true;<a name="line.19370"></a>
<FONT color="green">19371</FONT>        legendFontFamily = cssFontFamily;<a name="line.19371"></a>
<FONT color="green">19372</FONT>      }<a name="line.19372"></a>
<FONT color="green">19373</FONT>    <a name="line.19373"></a>
<FONT color="green">19374</FONT>      /**<a name="line.19374"></a>
<FONT color="green">19375</FONT>       * Specifies the cssStyle of the font used to render the legend's labels.<a name="line.19375"></a>
<FONT color="green">19376</FONT>       * Default is &lt;tt&gt;DEFAULT_FONT_STYLE&lt;/tt&gt;.<a name="line.19376"></a>
<FONT color="green">19377</FONT>       * <a name="line.19377"></a>
<FONT color="green">19378</FONT>       * @param cssStyle<a name="line.19378"></a>
<FONT color="green">19379</FONT>       *          any valid CSS font-style, namely, normal, italic, oblique, or<a name="line.19379"></a>
<FONT color="green">19380</FONT>       *          inherit.<a name="line.19380"></a>
<FONT color="green">19381</FONT>       * <a name="line.19381"></a>
<FONT color="green">19382</FONT>       * @see #getLegendFontStyle getLegendFontStyle<a name="line.19382"></a>
<FONT color="green">19383</FONT>       * @see #DEFAULT_FONT_STYLE DEFAULT_FONT_STYLE<a name="line.19383"></a>
<FONT color="green">19384</FONT>       */<a name="line.19384"></a>
<FONT color="green">19385</FONT>      public void setLegendFontStyle(String cssStyle) {<a name="line.19385"></a>
<FONT color="green">19386</FONT>        chartDecorationsChanged = true;<a name="line.19386"></a>
<FONT color="green">19387</FONT>        legendFontStyle = cssStyle;<a name="line.19387"></a>
<FONT color="green">19388</FONT>      }<a name="line.19388"></a>
<FONT color="green">19389</FONT>    <a name="line.19389"></a>
<FONT color="green">19390</FONT>      /**<a name="line.19390"></a>
<FONT color="green">19391</FONT>       * Specifies the weight of the font used in the labels of the legend. Default<a name="line.19391"></a>
<FONT color="green">19392</FONT>       * is &lt;tt&gt;DEFAULT_FONT_WEIGHT&lt;/tt&gt;.<a name="line.19392"></a>
<FONT color="green">19393</FONT>       * <a name="line.19393"></a>
<FONT color="green">19394</FONT>       * @param cssWeight<a name="line.19394"></a>
<FONT color="green">19395</FONT>       *          a CSS font-weight specification, such as bold, bolder, normal,<a name="line.19395"></a>
<FONT color="green">19396</FONT>       *          light, 100, 200, ... or 900.<a name="line.19396"></a>
<FONT color="green">19397</FONT>       * <a name="line.19397"></a>
<FONT color="green">19398</FONT>       * @see #getLegendFontWeight getLegendFontWeight<a name="line.19398"></a>
<FONT color="green">19399</FONT>       * @see #DEFAULT_FONT_WEIGHT DEFAULT_FONT_WEIGHT<a name="line.19399"></a>
<FONT color="green">19400</FONT>       */<a name="line.19400"></a>
<FONT color="green">19401</FONT>      public void setLegendFontWeight(String cssWeight) {<a name="line.19401"></a>
<FONT color="green">19402</FONT>        chartDecorationsChanged = true;<a name="line.19402"></a>
<FONT color="green">19403</FONT>        legendFontWeight = cssWeight;<a name="line.19403"></a>
<FONT color="green">19404</FONT>      }<a name="line.19404"></a>
<FONT color="green">19405</FONT>    <a name="line.19405"></a>
<FONT color="green">19406</FONT>      /**<a name="line.19406"></a>
<FONT color="green">19407</FONT>       * Specifies the position of the legend on the chart.<a name="line.19407"></a>
<FONT color="green">19408</FONT>       * &lt;p&gt;<a name="line.19408"></a>
<FONT color="green">19409</FONT>       * <a name="line.19409"></a>
<FONT color="green">19410</FONT>       * The default &lt;tt&gt;LegendLocation&lt;/tt&gt; is<a name="line.19410"></a>
<FONT color="green">19411</FONT>       * &lt;tt&gt;LegendLocation.OUTSIDE_RIGHT&lt;/tt&gt;.  &lt;p&gt;<a name="line.19411"></a>
<FONT color="green">19412</FONT>       * <a name="line.19412"></a>
<FONT color="green">19413</FONT>       * To shift the legend relative to these base locations, use<a name="line.19413"></a>
<FONT color="green">19414</FONT>       * &lt;tt&gt;setLegendXShift&lt;/tt&gt; and &lt;tt&gt;setLegendYShift&lt;/tt&gt;.<a name="line.19414"></a>
<FONT color="green">19415</FONT>       * <a name="line.19415"></a>
<FONT color="green">19416</FONT>       * @param legendLocation<a name="line.19416"></a>
<FONT color="green">19417</FONT>       *          the postion of the legend on the chart<a name="line.19417"></a>
<FONT color="green">19418</FONT>       * <a name="line.19418"></a>
<FONT color="green">19419</FONT>       * @see #setLegendXShift setLegendXShift<a name="line.19419"></a>
<FONT color="green">19420</FONT>       * @see #setLegendYShift setLegendYShift<a name="line.19420"></a>
<FONT color="green">19421</FONT>       * @see #setLegend setLegend<a name="line.19421"></a>
<FONT color="green">19422</FONT>       * <a name="line.19422"></a>
<FONT color="green">19423</FONT>       */<a name="line.19423"></a>
<FONT color="green">19424</FONT>      public void setLegendLocation(LegendLocation legendLocation) {<a name="line.19424"></a>
<FONT color="green">19425</FONT>        this.legendLocation = legendLocation;<a name="line.19425"></a>
<FONT color="green">19426</FONT>      }<a name="line.19426"></a>
<FONT color="green">19427</FONT>    <a name="line.19427"></a>
<FONT color="green">19428</FONT>      /**<a name="line.19428"></a>
<FONT color="green">19429</FONT>       * This method allows you to replace GChart's legend with a Widget you create<a name="line.19429"></a>
<FONT color="green">19430</FONT>       * to represent the chart legend.<a name="line.19430"></a>
<FONT color="green">19431</FONT>       * &lt;p&gt;<a name="line.19431"></a>
<FONT color="green">19432</FONT>       * <a name="line.19432"></a>
<FONT color="green">19433</FONT>       * Passing in &lt;tt&gt;null&lt;/tt&gt; reverts to the default GChart-generated legend.<a name="line.19433"></a>
<FONT color="green">19434</FONT>       * <a name="line.19434"></a>
<FONT color="green">19435</FONT>       * @param legend<a name="line.19435"></a>
<FONT color="green">19436</FONT>       *          - a Widget that will be placed at the location specified by<a name="line.19436"></a>
<FONT color="green">19437</FONT>       *          &lt;tt&gt;setLegendLocation&lt;/tt&gt;, or &lt;tt&gt;null&lt;/tt&gt; to let GChart create<a name="line.19437"></a>
<FONT color="green">19438</FONT>       *          the legend Widget.<a name="line.19438"></a>
<FONT color="green">19439</FONT>       * <a name="line.19439"></a>
<FONT color="green">19440</FONT>       * @see #getLegend getLegend<a name="line.19440"></a>
<FONT color="green">19441</FONT>       * @see #setLegendLocation setLegendLocation<a name="line.19441"></a>
<FONT color="green">19442</FONT>       * @see #setLegendXShift setLegendXShift<a name="line.19442"></a>
<FONT color="green">19443</FONT>       * @see #setLegendYShift setLegendYShift<a name="line.19443"></a>
<FONT color="green">19444</FONT>       * <a name="line.19444"></a>
<FONT color="green">19445</FONT>       */<a name="line.19445"></a>
<FONT color="green">19446</FONT>      public void setLegend(Widget legend) {<a name="line.19446"></a>
<FONT color="green">19447</FONT>        this.legend = legend;<a name="line.19447"></a>
<FONT color="green">19448</FONT>      }<a name="line.19448"></a>
<FONT color="green">19449</FONT>    <a name="line.19449"></a>
<FONT color="green">19450</FONT>      /**<a name="line.19450"></a>
<FONT color="green">19451</FONT>       * Specifies the number of pixels (along the x-axis) to move the legend from<a name="line.19451"></a>
<FONT color="green">19452</FONT>       * its default, &lt;tt&gt;LegendLocation&lt;/tt&gt;-defined, position. Negative values<a name="line.19452"></a>
<FONT color="green">19453</FONT>       * move the legend in the negative x direction.<a name="line.19453"></a>
<FONT color="green">19454</FONT>       * &lt;p&gt;<a name="line.19454"></a>
<FONT color="green">19455</FONT>       * <a name="line.19455"></a>
<FONT color="green">19456</FONT>       * @param xShift<a name="line.19456"></a>
<FONT color="green">19457</FONT>       *          number of pixels to move legend along the x axis from it's<a name="line.19457"></a>
<FONT color="green">19458</FONT>       *          default, &lt;tt&gt;LegendLocation&lt;/tt&gt;-defined, position.<a name="line.19458"></a>
<FONT color="green">19459</FONT>       * <a name="line.19459"></a>
<FONT color="green">19460</FONT>       * @see #setLegendLocation setLegendLocation<a name="line.19460"></a>
<FONT color="green">19461</FONT>       * @see #setLegendYShift setLegendYShift<a name="line.19461"></a>
<FONT color="green">19462</FONT>       * <a name="line.19462"></a>
<FONT color="green">19463</FONT>       */<a name="line.19463"></a>
<FONT color="green">19464</FONT>      public void setLegendXShift(int xShift) {<a name="line.19464"></a>
<FONT color="green">19465</FONT>        this.legendXShift = xShift;<a name="line.19465"></a>
<FONT color="green">19466</FONT>      }<a name="line.19466"></a>
<FONT color="green">19467</FONT>    <a name="line.19467"></a>
<FONT color="green">19468</FONT>      /**<a name="line.19468"></a>
<FONT color="green">19469</FONT>       * Specifies the number of pixels (along the y-axis) to move the legend from<a name="line.19469"></a>
<FONT color="green">19470</FONT>       * its default, &lt;tt&gt;LegendLocation&lt;/tt&gt;-defined, position. Postive values<a name="line.19470"></a>
<FONT color="green">19471</FONT>       * shift the legend towards the top of the page, negative values towards the<a name="line.19471"></a>
<FONT color="green">19472</FONT>       * bottom.<a name="line.19472"></a>
<FONT color="green">19473</FONT>       * &lt;p&gt;<a name="line.19473"></a>
<FONT color="green">19474</FONT>       * <a name="line.19474"></a>
<FONT color="green">19475</FONT>       * @param yShift<a name="line.19475"></a>
<FONT color="green">19476</FONT>       *          number of pixels to move legend along the y axis from it's<a name="line.19476"></a>
<FONT color="green">19477</FONT>       *          default, &lt;tt&gt;LegendLocation&lt;/tt&gt;-defined, position.<a name="line.19477"></a>
<FONT color="green">19478</FONT>       * <a name="line.19478"></a>
<FONT color="green">19479</FONT>       * @see #setLegendLocation setLegendLocation<a name="line.19479"></a>
<FONT color="green">19480</FONT>       * @see #setLegendXShift setLegendXShift<a name="line.19480"></a>
<FONT color="green">19481</FONT>       */<a name="line.19481"></a>
<FONT color="green">19482</FONT>      public void setLegendYShift(int yShift) {<a name="line.19482"></a>
<FONT color="green">19483</FONT>        this.legendYShift = yShift;<a name="line.19483"></a>
<FONT color="green">19484</FONT>      }<a name="line.19484"></a>
<FONT color="green">19485</FONT>    <a name="line.19485"></a>
<FONT color="green">19486</FONT>      /**<a name="line.19486"></a>
<FONT color="green">19487</FONT>       * Sets the thickness (width) of the rectangular region at the right or left<a name="line.19487"></a>
<FONT color="green">19488</FONT>       * of the chart allocated for the legend key.<a name="line.19488"></a>
<FONT color="green">19489</FONT>       * &lt;p&gt;<a name="line.19489"></a>
<FONT color="green">19490</FONT>       * <a name="line.19490"></a>
<FONT color="green">19491</FONT>       * This setting has no impact on chart layout if the legend key is not<a name="line.19491"></a>
<FONT color="green">19492</FONT>       * visible, or if the legend key is placed inside the plot area of the chart,<a name="line.19492"></a>
<FONT color="green">19493</FONT>       * since the legend takes up no space on the left or right sides of the chart<a name="line.19493"></a>
<FONT color="green">19494</FONT>       * in such cases.<a name="line.19494"></a>
<FONT color="green">19495</FONT>       * <a name="line.19495"></a>
<FONT color="green">19496</FONT>       * &lt;p&gt;<a name="line.19496"></a>
<FONT color="green">19497</FONT>       * <a name="line.19497"></a>
<FONT color="green">19498</FONT>       * If the legend thickness is set to &lt;tt&gt;GChart.NAI&lt;/tt&gt; (the default) GChart<a name="line.19498"></a>
<FONT color="green">19499</FONT>       * uses an heuristic to set the legend thickness based on the number of<a name="line.19499"></a>
<FONT color="green">19500</FONT>       * characters in each curve's legend label.<a name="line.19500"></a>
<FONT color="green">19501</FONT>       * <a name="line.19501"></a>
<FONT color="green">19502</FONT>       * <a name="line.19502"></a>
<FONT color="green">19503</FONT>       * @param legendThickness<a name="line.19503"></a>
<FONT color="green">19504</FONT>       *          the thickness (width) of the rectangle that contains the legend<a name="line.19504"></a>
<FONT color="green">19505</FONT>       *          key, in pixels, or &lt;tt&gt;GChart.NAI&lt;/tt&gt; to use a built-in heurstic<a name="line.19505"></a>
<FONT color="green">19506</FONT>       *          to determine the legend width.<a name="line.19506"></a>
<FONT color="green">19507</FONT>       * <a name="line.19507"></a>
<FONT color="green">19508</FONT>       * @see #getLegendThickness getLegendThickness<a name="line.19508"></a>
<FONT color="green">19509</FONT>       * @see Curve#setLegendLabel setLegendLabel<a name="line.19509"></a>
<FONT color="green">19510</FONT>       * @see Y2Axis#setAxisLabelThickness Y2Axis.setAxisLabelThickness<a name="line.19510"></a>
<FONT color="green">19511</FONT>       * <a name="line.19511"></a>
<FONT color="green">19512</FONT>       */<a name="line.19512"></a>
<FONT color="green">19513</FONT>      public void setLegendThickness(int legendThickness) {<a name="line.19513"></a>
<FONT color="green">19514</FONT>        chartDecorationsChanged = true;<a name="line.19514"></a>
<FONT color="green">19515</FONT>        this.legendThickness = legendThickness;<a name="line.19515"></a>
<FONT color="green">19516</FONT>      }<a name="line.19516"></a>
<FONT color="green">19517</FONT>    <a name="line.19517"></a>
<FONT color="green">19518</FONT>      /**<a name="line.19518"></a>
<FONT color="green">19519</FONT>       * Specifies if the legend is to be visible on this chart. Legends are visible<a name="line.19519"></a>
<FONT color="green">19520</FONT>       * by default. However, a legend is only generated if at least one curve's<a name="line.19520"></a>
<FONT color="green">19521</FONT>       * legend label has been specified.<a name="line.19521"></a>
<FONT color="green">19522</FONT>       * <a name="line.19522"></a>
<FONT color="green">19523</FONT>       * @param isLegendVisible<a name="line.19523"></a>
<FONT color="green">19524</FONT>       *          true to display the legend, false to hide it.<a name="line.19524"></a>
<FONT color="green">19525</FONT>       * <a name="line.19525"></a>
<FONT color="green">19526</FONT>       * @see #isLegendVisible isLegendVisible<a name="line.19526"></a>
<FONT color="green">19527</FONT>       * @see Curve#setLegendLabel setLegendLabel<a name="line.19527"></a>
<FONT color="green">19528</FONT>       */<a name="line.19528"></a>
<FONT color="green">19529</FONT>      public void setLegendVisible(boolean isLegendVisible) {<a name="line.19529"></a>
<FONT color="green">19530</FONT>        chartDecorationsChanged = true;<a name="line.19530"></a>
<FONT color="green">19531</FONT>        this.isLegendVisible = isLegendVisible;<a name="line.19531"></a>
<FONT color="green">19532</FONT>      }<a name="line.19532"></a>
<FONT color="green">19533</FONT>    <a name="line.19533"></a>
<FONT color="green">19534</FONT>      /**<a name="line.19534"></a>
<FONT color="green">19535</FONT>       * Sets the upper bound on the number of pixels any canvas widget used by<a name="line.19535"></a>
<FONT color="green">19536</FONT>       * GChart can have.<a name="line.19536"></a>
<FONT color="green">19537</FONT>       * &lt;p&gt;<a name="line.19537"></a>
<FONT color="green">19538</FONT>       * <a name="line.19538"></a>
<FONT color="green">19539</FONT>       * If the number of pixels ever exceeds this amount, GChart will scale<a name="line.19539"></a>
<FONT color="green">19540</FONT>       * the offending canvas down uniformly in width and height, until it<a name="line.19540"></a>
<FONT color="green">19541</FONT>       * has around the specified number of pixels, and then move it as<a name="line.19541"></a>
<FONT color="green">19542</FONT>       * close to being centered on the plot area as is consistent with<a name="line.19542"></a>
<FONT color="green">19543</FONT>       * remaining within the original, unshrunken, clipping rectangle. This<a name="line.19543"></a>
<FONT color="green">19544</FONT>       * strategy means that points furthest off the plot area could be<a name="line.19544"></a>
<FONT color="green">19545</FONT>       * dropped due to this max pixel limit.<a name="line.19545"></a>
<FONT color="green">19546</FONT>       * <a name="line.19546"></a>
<FONT color="green">19547</FONT>       * &lt;p&gt;<a name="line.19547"></a>
<FONT color="green">19548</FONT>       * <a name="line.19548"></a>
<FONT color="green">19549</FONT>       * Because GChart allows you to draw outside of the decorated chart,<a name="line.19549"></a>
<FONT color="green">19550</FONT>       * the size of the required canvas is not always known in advance. But<a name="line.19550"></a>
<FONT color="green">19551</FONT>       * the use of very large sized canvas widgets can lead to serious<a name="line.19551"></a>
<FONT color="green">19552</FONT>       * performance problems (including large memory use on some browsers,<a name="line.19552"></a>
<FONT color="green">19553</FONT>       * e.g. Firefox). This method provides a simple way for developers to<a name="line.19553"></a>
<FONT color="green">19554</FONT>       * avoid such problems without having to explicitly eliminate "far off<a name="line.19554"></a>
<FONT color="green">19555</FONT>       * the chart" data points from their charts.<a name="line.19555"></a>
<FONT color="green">19556</FONT>       * <a name="line.19556"></a>
<FONT color="green">19557</FONT>       * @param maxCanvasPixels<a name="line.19557"></a>
<FONT color="green">19558</FONT>       *          the maximum number of pixels any single GChart canvas Widget<a name="line.19558"></a>
<FONT color="green">19559</FONT>       *          (GChartCanvasLite) will contain.<a name="line.19559"></a>
<FONT color="green">19560</FONT>       * <a name="line.19560"></a>
<FONT color="green">19561</FONT>       * @see #DEFAULT_MAX_CANVAS_PIXELS DEFAULT_MAX_CANVAS_PIXELS<a name="line.19561"></a>
<FONT color="green">19562</FONT>       * @see #getMaxCanvasPixels getMaxCanvasPixels<a name="line.19562"></a>
<FONT color="green">19563</FONT>       * <a name="line.19563"></a>
<FONT color="green">19564</FONT>       */<a name="line.19564"></a>
<FONT color="green">19565</FONT>      public void setMaxCanvasPixels(double maxCanvasPixels) {<a name="line.19565"></a>
<FONT color="green">19566</FONT>        this.maxCanvasPixels = maxCanvasPixels;<a name="line.19566"></a>
<FONT color="green">19567</FONT>      }<a name="line.19567"></a>
<FONT color="green">19568</FONT>    <a name="line.19568"></a>
<FONT color="green">19569</FONT>      /**<a name="line.19569"></a>
<FONT color="green">19570</FONT>       * By default, this property is &lt;tt&gt;false&lt;/tt&gt;, which means that GChart will<a name="line.19570"></a>
<FONT color="green">19571</FONT>       * retain no-longer-needed Image and Grid widgets (plus any user object<a name="line.19571"></a>
<FONT color="green">19572</FONT>       * references associated with those widgets, such as those created via the<a name="line.19572"></a>
<FONT color="green">19573</FONT>       * &lt;tt&gt;setAnnotationText&lt;/tt&gt; and &lt;tt&gt;setAnnotationWidget&lt;/tt&gt; methods)<a name="line.19573"></a>
<FONT color="green">19574</FONT>       * between &lt;tt&gt;updates&lt;/tt&gt; in the expectation that they may be needed by<a name="line.19574"></a>
<FONT color="green">19575</FONT>       * future updates. This strategy often makes updates faster, because building<a name="line.19575"></a>
<FONT color="green">19576</FONT>       * new Image and Grid elements "from scratch" is very expensive. However,<a name="line.19576"></a>
<FONT color="green">19577</FONT>       * strictly speaking, GChart is holding onto memory it no longer needs to<a name="line.19577"></a>
<FONT color="green">19578</FONT>       * render the chart &lt;i&gt;right now&lt;/i&gt;--which would normally be considered a<a name="line.19578"></a>
<FONT color="green">19579</FONT>       * memory leak if it were not being done deliberately.<a name="line.19579"></a>
<FONT color="green">19580</FONT>       * &lt;p&gt;<a name="line.19580"></a>
<FONT color="green">19581</FONT>       * <a name="line.19581"></a>
<FONT color="green">19582</FONT>       * If &lt;tt&gt;optimizeForMemory&lt;/tt&gt; is set to &lt;tt&gt;true&lt;/tt&gt;, GChart will (at the<a name="line.19582"></a>
<FONT color="green">19583</FONT>       * very next &lt;tt&gt;update()&lt;/tt&gt; call) free up any Image or Grid elements that<a name="line.19583"></a>
<FONT color="green">19584</FONT>       * are no longer required to render the current chart. Should a chart's size<a name="line.19584"></a>
<FONT color="green">19585</FONT>       * grow back to a former size, the subsequent update would be slower, though.<a name="line.19585"></a>
<FONT color="green">19586</FONT>       * <a name="line.19586"></a>
<FONT color="green">19587</FONT>       * &lt;p&gt;<a name="line.19587"></a>
<FONT color="green">19588</FONT>       * Charts that use exactly the same number of Image and Grid elements for each<a name="line.19588"></a>
<FONT color="green">19589</FONT>       * update (for example a bar chart where the number of bars is fixed) will see<a name="line.19589"></a>
<FONT color="green">19590</FONT>       * no impact on either memory use or update speeds by setting this parameter.<a name="line.19590"></a>
<FONT color="green">19591</FONT>       * Charts that have a highly variable number of Image or Grid elements (for<a name="line.19591"></a>
<FONT color="green">19592</FONT>       * example, a chart whose number of points varies randomly between 5 and 500)<a name="line.19592"></a>
<FONT color="green">19593</FONT>       * may see a very large impact on speed (false is faster) or memory (true is<a name="line.19593"></a>
<FONT color="green">19594</FONT>       * more compact).<a name="line.19594"></a>
<FONT color="green">19595</FONT>       * &lt;p&gt;<a name="line.19595"></a>
<FONT color="green">19596</FONT>       * <a name="line.19596"></a>
<FONT color="green">19597</FONT>       * The setting of this parameter never has any impact on the speed or memory<a name="line.19597"></a>
<FONT color="green">19598</FONT>       * used on the &lt;i&gt;very first&lt;/i&gt; chart update.<a name="line.19598"></a>
<FONT color="green">19599</FONT>       * &lt;p&gt;<a name="line.19599"></a>
<FONT color="green">19600</FONT>       * <a name="line.19600"></a>
<FONT color="green">19601</FONT>       * In one test using the future oil price simulation chart of GChart's live<a name="line.19601"></a>
<FONT color="green">19602</FONT>       * demo (which has only small changes in the number of elements required to<a name="line.19602"></a>
<FONT color="green">19603</FONT>       * render the chart between updates) setting this parameter to true made the<a name="line.19603"></a>
<FONT color="green">19604</FONT>       * updates, on average, around 10% slower, but also reduced the memory<a name="line.19604"></a>
<FONT color="green">19605</FONT>       * footprint by around 2%.<a name="line.19605"></a>
<FONT color="green">19606</FONT>       * <a name="line.19606"></a>
<FONT color="green">19607</FONT>       * @param optimizeForMemory<a name="line.19607"></a>
<FONT color="green">19608</FONT>       *          &lt;tt&gt;true&lt;/tt&gt; to optimize updates to use less memory,<a name="line.19608"></a>
<FONT color="green">19609</FONT>       *          &lt;tt&gt;false&lt;/tt&gt; (the default) to optimize them to use less time.<a name="line.19609"></a>
<FONT color="green">19610</FONT>       * <a name="line.19610"></a>
<FONT color="green">19611</FONT>       * @see #update update<a name="line.19611"></a>
<FONT color="green">19612</FONT>       * <a name="line.19612"></a>
<FONT color="green">19613</FONT>       */<a name="line.19613"></a>
<FONT color="green">19614</FONT>      public void setOptimizeForMemory(boolean optimizeForMemory) {<a name="line.19614"></a>
<FONT color="green">19615</FONT>        this.optimizeForMemory = optimizeForMemory;<a name="line.19615"></a>
<FONT color="green">19616</FONT>      }<a name="line.19616"></a>
<FONT color="green">19617</FONT>    <a name="line.19617"></a>
<FONT color="green">19618</FONT>      /**<a name="line.19618"></a>
<FONT color="green">19619</FONT>       * Specifies the amount of padding to add just inside of the chart's border,<a name="line.19619"></a>
<FONT color="green">19620</FONT>       * as a CSS padding specification string.<a name="line.19620"></a>
<FONT color="green">19621</FONT>       * &lt;p&gt;<a name="line.19621"></a>
<FONT color="green">19622</FONT>       * <a name="line.19622"></a>
<FONT color="green">19623</FONT>       * &lt;p&gt;<a name="line.19623"></a>
<FONT color="green">19624</FONT>       * The default padding is &lt;tt&gt;USE_CSS&lt;/tt&gt;.<a name="line.19624"></a>
<FONT color="green">19625</FONT>       * <a name="line.19625"></a>
<FONT color="green">19626</FONT>       * &lt;p&gt;<a name="line.19626"></a>
<FONT color="green">19627</FONT>       * <a name="line.19627"></a>
<FONT color="green">19628</FONT>       * @param cssPadding<a name="line.19628"></a>
<FONT color="green">19629</FONT>       *          the width of the padding, as a CSS padding specification string<a name="line.19629"></a>
<FONT color="green">19630</FONT>       *          (e.g. use "1px" to introduce a 1 pixel padding just between the<a name="line.19630"></a>
<FONT color="green">19631</FONT>       *          chart' border and the chart itself)<a name="line.19631"></a>
<FONT color="green">19632</FONT>       * <a name="line.19632"></a>
<FONT color="green">19633</FONT>       * @see #getPadding getPadding<a name="line.19633"></a>
<FONT color="green">19634</FONT>       * @see #setBorderWidth setBorderWidth<a name="line.19634"></a>
<FONT color="green">19635</FONT>       * @see #setBorderStyle(String) setBorderStyle<a name="line.19635"></a>
<FONT color="green">19636</FONT>       * @see #setBorderColor(String) setBorderColor<a name="line.19636"></a>
<FONT color="green">19637</FONT>       * @see #USE_CSS USE_CSS<a name="line.19637"></a>
<FONT color="green">19638</FONT>       */<a name="line.19638"></a>
<FONT color="green">19639</FONT>      public void setPadding(String cssPadding) {<a name="line.19639"></a>
<FONT color="green">19640</FONT>        chartDecorationsChanged = true;<a name="line.19640"></a>
<FONT color="green">19641</FONT>        padding = cssPadding;<a name="line.19641"></a>
<FONT color="green">19642</FONT>      }<a name="line.19642"></a>
<FONT color="green">19643</FONT>    <a name="line.19643"></a>
<FONT color="green">19644</FONT>      /**<a name="line.19644"></a>
<FONT color="green">19645</FONT>       * Specifies the background color of the area of the chart in which symbols<a name="line.19645"></a>
<FONT color="green">19646</FONT>       * representing curve data are displayed<a name="line.19646"></a>
<FONT color="green">19647</FONT>       * <a name="line.19647"></a>
<FONT color="green">19648</FONT>       * <a name="line.19648"></a>
<FONT color="green">19649</FONT>       * &lt;p&gt;<a name="line.19649"></a>
<FONT color="green">19650</FONT>       * For more information on standard CSS color specifications see the<a name="line.19650"></a>
<FONT color="green">19651</FONT>       * discussion in {@link Symbol#setBackgroundColor Symbol.setBackgroundColor}.<a name="line.19651"></a>
<FONT color="green">19652</FONT>       * &lt;p&gt;<a name="line.19652"></a>
<FONT color="green">19653</FONT>       * <a name="line.19653"></a>
<FONT color="green">19654</FONT>       * @param cssColor<a name="line.19654"></a>
<FONT color="green">19655</FONT>       *          CSS color string defining the plot area's background color<a name="line.19655"></a>
<FONT color="green">19656</FONT>       * <a name="line.19656"></a>
<FONT color="green">19657</FONT>       * @see #getPlotAreaBackgroundColor getPlotAreaBackgroundColor<a name="line.19657"></a>
<FONT color="green">19658</FONT>       */<a name="line.19658"></a>
<FONT color="green">19659</FONT>      public void setPlotAreaBackgroundColor(String cssColor) {<a name="line.19659"></a>
<FONT color="green">19660</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.19660"></a>
<FONT color="green">19661</FONT>        c.getSymbol().setBackgroundColor(cssColor);<a name="line.19661"></a>
<FONT color="green">19662</FONT>      }<a name="line.19662"></a>
<FONT color="green">19663</FONT>    <a name="line.19663"></a>
<FONT color="green">19664</FONT>      /**<a name="line.19664"></a>
<FONT color="green">19665</FONT>       * Specifies the color of the border around the area of the chart in which<a name="line.19665"></a>
<FONT color="green">19666</FONT>       * symbols representing curve data are displayed.<a name="line.19666"></a>
<FONT color="green">19667</FONT>       * <a name="line.19667"></a>
<FONT color="green">19668</FONT>       * <a name="line.19668"></a>
<FONT color="green">19669</FONT>       * &lt;p&gt;<a name="line.19669"></a>
<FONT color="green">19670</FONT>       * For more information on standard CSS color specifications see the<a name="line.19670"></a>
<FONT color="green">19671</FONT>       * discussion in {@link Symbol#setBackgroundColor Symbol.setBackgroundColor}.<a name="line.19671"></a>
<FONT color="green">19672</FONT>       * &lt;p&gt;<a name="line.19672"></a>
<FONT color="green">19673</FONT>       * <a name="line.19673"></a>
<FONT color="green">19674</FONT>       * @param cssColor<a name="line.19674"></a>
<FONT color="green">19675</FONT>       *          CSS color string defining the color of the plot area's border<a name="line.19675"></a>
<FONT color="green">19676</FONT>       * <a name="line.19676"></a>
<FONT color="green">19677</FONT>       * @see #getPlotAreaBorderColor getPlotAreaBorderColor<a name="line.19677"></a>
<FONT color="green">19678</FONT>       */<a name="line.19678"></a>
<FONT color="green">19679</FONT>      public void setPlotAreaBorderColor(String cssColor) {<a name="line.19679"></a>
<FONT color="green">19680</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.19680"></a>
<FONT color="green">19681</FONT>        c.getSymbol().setBorderColor(cssColor);<a name="line.19681"></a>
<FONT color="green">19682</FONT>      }<a name="line.19682"></a>
<FONT color="green">19683</FONT>    <a name="line.19683"></a>
<FONT color="green">19684</FONT>      /**<a name="line.19684"></a>
<FONT color="green">19685</FONT>       * Specifies the width of the border around the area of the chart in which<a name="line.19685"></a>
<FONT color="green">19686</FONT>       * symbols representing curve data are displayed.<a name="line.19686"></a>
<FONT color="green">19687</FONT>       * <a name="line.19687"></a>
<FONT color="green">19688</FONT>       * @param width<a name="line.19688"></a>
<FONT color="green">19689</FONT>       *          the width, in pixels, of the border around the plot area<a name="line.19689"></a>
<FONT color="green">19690</FONT>       * <a name="line.19690"></a>
<FONT color="green">19691</FONT>       * @see #getPlotAreaBorderWidth getPlotAreaBorderWidth<a name="line.19691"></a>
<FONT color="green">19692</FONT>       */<a name="line.19692"></a>
<FONT color="green">19693</FONT>      public void setPlotAreaBorderWidth(int width) {<a name="line.19693"></a>
<FONT color="green">19694</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.19694"></a>
<FONT color="green">19695</FONT>        c.getSymbol().setBorderWidth(width);<a name="line.19695"></a>
<FONT color="green">19696</FONT>      }<a name="line.19696"></a>
<FONT color="green">19697</FONT>    <a name="line.19697"></a>
<FONT color="green">19698</FONT>      /**<a name="line.19698"></a>
<FONT color="green">19699</FONT>       * Sets style of the border around the chart's plot area (the rectangular area<a name="line.19699"></a>
<FONT color="green">19700</FONT>       * where the curves are drawn).<a name="line.19700"></a>
<FONT color="green">19701</FONT>       * <a name="line.19701"></a>
<FONT color="green">19702</FONT>       * &lt;p&gt;<a name="line.19702"></a>
<FONT color="green">19703</FONT>       * <a name="line.19703"></a>
<FONT color="green">19704</FONT>       * &lt;p&gt;<a name="line.19704"></a>
<FONT color="green">19705</FONT>       * <a name="line.19705"></a>
<FONT color="green">19706</FONT>       * @param borderStyle<a name="line.19706"></a>
<FONT color="green">19707</FONT>       *          a CSS border style such as "solid", "dotted", "dashed", etc.<a name="line.19707"></a>
<FONT color="green">19708</FONT>       * <a name="line.19708"></a>
<FONT color="green">19709</FONT>       * @see #getPlotAreaBorderStyle getPlotAreaBorderStyle<a name="line.19709"></a>
<FONT color="green">19710</FONT>       * @see #setPlotAreaBackgroundColor setPlotAreaBackgroundColor<a name="line.19710"></a>
<FONT color="green">19711</FONT>       * @see #setPlotAreaBorderColor setPlotAreaBorderColor<a name="line.19711"></a>
<FONT color="green">19712</FONT>       */<a name="line.19712"></a>
<FONT color="green">19713</FONT>      public void setPlotAreaBorderStyle(String borderStyle) {<a name="line.19713"></a>
<FONT color="green">19714</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.19714"></a>
<FONT color="green">19715</FONT>        c.getSymbol().setBorderStyle(borderStyle);<a name="line.19715"></a>
<FONT color="green">19716</FONT>      }<a name="line.19716"></a>
<FONT color="green">19717</FONT>    <a name="line.19717"></a>
<FONT color="green">19718</FONT>      /**<a name="line.19718"></a>
<FONT color="green">19719</FONT>       * Sets the image URL that defines the background of the GChart plot area. The<a name="line.19719"></a>
<FONT color="green">19720</FONT>       * GChart plot area is the rectangular region defined by the x and y axes of<a name="line.19720"></a>
<FONT color="green">19721</FONT>       * the plot, but does not include those axes (or their ticks).<a name="line.19721"></a>
<FONT color="green">19722</FONT>       * &lt;p&gt;<a name="line.19722"></a>
<FONT color="green">19723</FONT>       * Note that by default, or if this URL is set to &lt;tt&gt;null&lt;/tt&gt;, GChart will<a name="line.19723"></a>
<FONT color="green">19724</FONT>       * use the URL returned by &lt;tt&gt;getBlankImageURL&lt;/tt&gt;.<a name="line.19724"></a>
<FONT color="green">19725</FONT>       * &lt;p&gt;<a name="line.19725"></a>
<FONT color="green">19726</FONT>       * <a name="line.19726"></a>
<FONT color="green">19727</FONT>       * &lt;small&gt;&lt;b&gt;Ideas/tips for using the plot area background URL:&lt;/b&gt;<a name="line.19727"></a>
<FONT color="green">19728</FONT>       * &lt;blockquote&gt;<a name="line.19728"></a>
<FONT color="green">19729</FONT>       * &lt;ol&gt;<a name="line.19729"></a>
<FONT color="green">19730</FONT>       * &lt;li&gt;It's often best to exactly match the width and height of the image with<a name="line.19730"></a>
<FONT color="green">19731</FONT>       * the GChart plot area width and height (defined via (via<a name="line.19731"></a>
<FONT color="green">19732</FONT>       * &lt;tt&gt;setChartSize&lt;/tt&gt;). Otherwise, the image will be scaled up or down to<a name="line.19732"></a>
<FONT color="green">19733</FONT>       * fit the plot area, which usually doesn't look that great.<a name="line.19733"></a>
<FONT color="green">19734</FONT>       * <a name="line.19734"></a>
<FONT color="green">19735</FONT>       * &lt;li&gt;Note that since a Google Chart API url is just an image url to GChart,<a name="line.19735"></a>
<FONT color="green">19736</FONT>       * you can easily use a Google Chart API url to define the background of an<a name="line.19736"></a>
<FONT color="green">19737</FONT>       * otherwise client-side chart. For example, you might place a static 3-D pie<a name="line.19737"></a>
<FONT color="green">19738</FONT>       * chart behind a rapidly changing client-side GChart bar chart.<a name="line.19738"></a>
<FONT color="green">19739</FONT>       * <a name="line.19739"></a>
<FONT color="green">19740</FONT>       * &lt;li&gt;Note that this method's image will appear &lt;i&gt;behind&lt;/i&gt; every gridline<a name="line.19740"></a>
<FONT color="green">19741</FONT>       * and curve on the chart. To overlay images &lt;i&gt;on top of&lt;/i&gt; the gridlines or<a name="line.19741"></a>
<FONT color="green">19742</FONT>       * other curves, or even to place them outside of the plot area, use a<a name="line.19742"></a>
<FONT color="green">19743</FONT>       * dedicated curve and its symbol's &lt;tt&gt;setImageURL&lt;/tt&gt; method, or simply<a name="line.19743"></a>
<FONT color="green">19744</FONT>       * embed such images within HTML-defined point annotations.<a name="line.19744"></a>
<FONT color="green">19745</FONT>       * &lt;/ol&gt;<a name="line.19745"></a>
<FONT color="green">19746</FONT>       * <a name="line.19746"></a>
<FONT color="green">19747</FONT>       * &lt;/blockquote&gt;&lt;/small&gt;<a name="line.19747"></a>
<FONT color="green">19748</FONT>       * <a name="line.19748"></a>
<FONT color="green">19749</FONT>       * @see #getPlotAreaImageURL getPlotAreaImageURL<a name="line.19749"></a>
<FONT color="green">19750</FONT>       * @see #setBlankImageURL setBlankImageURL<a name="line.19750"></a>
<FONT color="green">19751</FONT>       * @see GChart.Symbol#setImageURL setImageURL<a name="line.19751"></a>
<FONT color="green">19752</FONT>       * <a name="line.19752"></a>
<FONT color="green">19753</FONT>       * @param imageURL<a name="line.19753"></a>
<FONT color="green">19754</FONT>       *          URL of the image used as the background of the plot area.<a name="line.19754"></a>
<FONT color="green">19755</FONT>       * <a name="line.19755"></a>
<FONT color="green">19756</FONT>       */<a name="line.19756"></a>
<FONT color="green">19757</FONT>    <a name="line.19757"></a>
<FONT color="green">19758</FONT>      public void setPlotAreaImageURL(String imageURL) {<a name="line.19758"></a>
<FONT color="green">19759</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.19759"></a>
<FONT color="green">19760</FONT>        c.getSymbol().setImageURL(imageURL);<a name="line.19760"></a>
<FONT color="green">19761</FONT>      }<a name="line.19761"></a>
<FONT color="green">19762</FONT>    <a name="line.19762"></a>
<FONT color="green">19763</FONT>      /**<a name="line.19763"></a>
<FONT color="green">19764</FONT>       * Defines a region around the perimeter of the currently visible area of the<a name="line.19764"></a>
<FONT color="green">19765</FONT>       * chart that will be rendered, even though it cannot at present be seen (due<a name="line.19765"></a>
<FONT color="green">19766</FONT>       * to clipping).<a name="line.19766"></a>
<FONT color="green">19767</FONT>       * &lt;p&gt;<a name="line.19767"></a>
<FONT color="green">19768</FONT>       * <a name="line.19768"></a>
<FONT color="green">19769</FONT>       * By default, this factor is &lt;tt&gt;0.0&lt;/tt&gt; and GChart is free to skip the<a name="line.19769"></a>
<FONT color="green">19770</FONT>       * rendering any parts of the chart that would have been clipped off anyway.<a name="line.19770"></a>
<FONT color="green">19771</FONT>       * However, special applications, such as panning, may find it advantageous to<a name="line.19771"></a>
<FONT color="green">19772</FONT>       * fully render areas adjacent to the clipping window, so that these<a name="line.19772"></a>
<FONT color="green">19773</FONT>       * pre-rendered areas can then be quickly shifted into view via the<a name="line.19773"></a>
<FONT color="green">19774</FONT>       * &lt;tt&gt;setXShift&lt;/tt&gt; and &lt;tt&gt;setYShift&lt;/tt&gt; methods.<a name="line.19774"></a>
<FONT color="green">19775</FONT>       * &lt;p&gt;<a name="line.19775"></a>
<FONT color="green">19776</FONT>       * <a name="line.19776"></a>
<FONT color="green">19777</FONT>       * The width and height of the clipping window (typically the plot area) are<a name="line.19777"></a>
<FONT color="green">19778</FONT>       * expanded by the specified fraction along each edge. For example, a render<a name="line.19778"></a>
<FONT color="green">19779</FONT>       * padding factor of &lt;tt&gt;1.0&lt;/tt&gt; expands the rendered height by a factor of<a name="line.19779"></a>
<FONT color="green">19780</FONT>       * 300% (100% extra above, and 100% extra below) and the width by the same<a name="line.19780"></a>
<FONT color="green">19781</FONT>       * factor (100% extra to the left, and 100% extra to the right).<a name="line.19781"></a>
<FONT color="green">19782</FONT>       * &lt;p&gt;<a name="line.19782"></a>
<FONT color="green">19783</FONT>       * <a name="line.19783"></a>
<FONT color="green">19784</FONT>       * @param renderPaddingFactor<a name="line.19784"></a>
<FONT color="green">19785</FONT>       *          the fractional amount to expand to the rendering window around the<a name="line.19785"></a>
<FONT color="green">19786</FONT>       *          perimeter of the clipping window.<a name="line.19786"></a>
<FONT color="green">19787</FONT>       * <a name="line.19787"></a>
<FONT color="green">19788</FONT>       * @see Curve#setXShift setXShift<a name="line.19788"></a>
<FONT color="green">19789</FONT>       * @see Curve#setYShift setYShift<a name="line.19789"></a>
<FONT color="green">19790</FONT>       * @see #getRenderPaddingFactor getRenderPaddingFactor<a name="line.19790"></a>
<FONT color="green">19791</FONT>       * <a name="line.19791"></a>
<FONT color="green">19792</FONT>       */<a name="line.19792"></a>
<FONT color="green">19793</FONT>      public void setRenderPaddingFactor(double renderPaddingFactor) {<a name="line.19793"></a>
<FONT color="green">19794</FONT>        this.renderPaddingFactor = renderPaddingFactor;<a name="line.19794"></a>
<FONT color="green">19795</FONT>      }<a name="line.19795"></a>
<FONT color="green">19796</FONT>    <a name="line.19796"></a>
<FONT color="green">19797</FONT>      /**<a name="line.19797"></a>
<FONT color="green">19798</FONT>       * @deprecated<a name="line.19798"></a>
<FONT color="green">19799</FONT>       * <a name="line.19799"></a>
<FONT color="green">19800</FONT>       *             Equivalent to &lt;tt&gt;setClipToPlotArea(!showOffChartPoints)&lt;/tt&gt; .<a name="line.19800"></a>
<FONT color="green">19801</FONT>       *             Use that method instead.<a name="line.19801"></a>
<FONT color="green">19802</FONT>       *             &lt;p&gt;<a name="line.19802"></a>
<FONT color="green">19803</FONT>       * <a name="line.19803"></a>
<FONT color="green">19804</FONT>       *             &lt;small&gt; As of GChart 2.5, the clip-to-plot-area algorithm no<a name="line.19804"></a>
<FONT color="green">19805</FONT>       *             longer drops the entire symbol if it's x,y coordinates are<a name="line.19805"></a>
<FONT color="green">19806</FONT>       *             outside of the plot area; instead, it clips them off in the<a name="line.19806"></a>
<FONT color="green">19807</FONT>       *             traditional "&lt;tt&gt;overflow: hidden&lt;/tt&gt;" manner. Though unlikely<a name="line.19807"></a>
<FONT color="green">19808</FONT>       *             you would need to, there is no easy way to recreate the<a name="line.19808"></a>
<FONT color="green">19809</FONT>       *             previous behavior.<a name="line.19809"></a>
<FONT color="green">19810</FONT>       *             &lt;p&gt;<a name="line.19810"></a>
<FONT color="green">19811</FONT>       * <a name="line.19811"></a>
<FONT color="green">19812</FONT>       *             This change was made so that both rectangular HTML and<a name="line.19812"></a>
<FONT color="green">19813</FONT>       *             continuous, canvas-rendered chart elements would be clipped in<a name="line.19813"></a>
<FONT color="green">19814</FONT>       *             a consistent and sensible way. &lt;/small&gt;<a name="line.19814"></a>
<FONT color="green">19815</FONT>       * <a name="line.19815"></a>
<FONT color="green">19816</FONT>       * @see #setClipToPlotArea setClipToPlotArea<a name="line.19816"></a>
<FONT color="green">19817</FONT>       * <a name="line.19817"></a>
<FONT color="green">19818</FONT>       */<a name="line.19818"></a>
<FONT color="green">19819</FONT>      public void setShowOffChartPoints(boolean showOffChartPoints) {<a name="line.19819"></a>
<FONT color="green">19820</FONT>        setClipToPlotArea(!showOffChartPoints);<a name="line.19820"></a>
<FONT color="green">19821</FONT>      }<a name="line.19821"></a>
<FONT color="green">19822</FONT>    <a name="line.19822"></a>
<FONT color="green">19823</FONT>      /**<a name="line.19823"></a>
<FONT color="green">19824</FONT>       * @deprecated<a name="line.19824"></a>
<FONT color="green">19825</FONT>       * <a name="line.19825"></a>
<FONT color="green">19826</FONT>       *             Equivalent to setClipToDecoratedChart(!showOffDecoratedChart),<a name="line.19826"></a>
<FONT color="green">19827</FONT>       *             please use that method instead.<a name="line.19827"></a>
<FONT color="green">19828</FONT>       * <a name="line.19828"></a>
<FONT color="green">19829</FONT>       * @see #setClipToDecoratedChart setClipToDecoratedChart<a name="line.19829"></a>
<FONT color="green">19830</FONT>       */<a name="line.19830"></a>
<FONT color="green">19831</FONT>      public void setShowOffDecoratedChartGlyphs(<a name="line.19831"></a>
<FONT color="green">19832</FONT>          boolean showOffDecoratedChartGlyphs) {<a name="line.19832"></a>
<FONT color="green">19833</FONT>        setClipToDecoratedChart(!showOffDecoratedChartGlyphs);<a name="line.19833"></a>
<FONT color="green">19834</FONT>      }<a name="line.19834"></a>
<FONT color="green">19835</FONT>    <a name="line.19835"></a>
<FONT color="green">19836</FONT>      /**<a name="line.19836"></a>
<FONT color="green">19837</FONT>       * Returns the curve that the mouse "brush" is currently "touching" (the<a name="line.19837"></a>
<FONT color="green">19838</FONT>       * so-called "hovered over" point), or &lt;tt&gt;null&lt;/tt&gt; if none.<a name="line.19838"></a>
<FONT color="green">19839</FONT>       * &lt;p&gt;<a name="line.19839"></a>
<FONT color="green">19840</FONT>       * <a name="line.19840"></a>
<FONT color="green">19841</FONT>       * Convenience method equivalent to (when the touched point is not<a name="line.19841"></a>
<FONT color="green">19842</FONT>       * &lt;tt&gt;null&lt;/tt&gt;) &lt;tt&gt;getTouchedPoint().getParent()&lt;/tt&gt;. See<a name="line.19842"></a>
<FONT color="green">19843</FONT>       * &lt;tt&gt;getTouchedPoint&lt;/tt&gt; for full details.<a name="line.19843"></a>
<FONT color="green">19844</FONT>       * &lt;p&gt;<a name="line.19844"></a>
<FONT color="green">19845</FONT>       * <a name="line.19845"></a>
<FONT color="green">19846</FONT>       * <a name="line.19846"></a>
<FONT color="green">19847</FONT>       * See the &lt;tt&gt;setBrushHeight&lt;/tt&gt; method for the rules GChart uses to<a name="line.19847"></a>
<FONT color="green">19848</FONT>       * determine the currently touched point.<a name="line.19848"></a>
<FONT color="green">19849</FONT>       * &lt;p&gt;<a name="line.19849"></a>
<FONT color="green">19850</FONT>       * <a name="line.19850"></a>
<FONT color="green">19851</FONT>       * <a name="line.19851"></a>
<FONT color="green">19852</FONT>       * @return a reference to the curve that the mouse "brush" is currently<a name="line.19852"></a>
<FONT color="green">19853</FONT>       *         "touching".<a name="line.19853"></a>
<FONT color="green">19854</FONT>       * <a name="line.19854"></a>
<FONT color="green">19855</FONT>       * @see #getTouchedPoint getTouchedPoint<a name="line.19855"></a>
<FONT color="green">19856</FONT>       * @see Symbol#setBrushHeight setBrushHeight<a name="line.19856"></a>
<FONT color="green">19857</FONT>       * @see Symbol#setHoverSelectionSymbolType setHoverSelectionSymbolType<a name="line.19857"></a>
<FONT color="green">19858</FONT>       * <a name="line.19858"></a>
<FONT color="green">19859</FONT>       */<a name="line.19859"></a>
<FONT color="green">19860</FONT>      public Curve getTouchedCurve() {<a name="line.19860"></a>
<FONT color="green">19861</FONT>        Curve result = null;<a name="line.19861"></a>
<FONT color="green">19862</FONT>        if (null != getTouchedPoint())<a name="line.19862"></a>
<FONT color="green">19863</FONT>          result = getTouchedPoint().getParent();<a name="line.19863"></a>
<FONT color="green">19864</FONT>        return result;<a name="line.19864"></a>
<FONT color="green">19865</FONT>      }<a name="line.19865"></a>
<FONT color="green">19866</FONT>    <a name="line.19866"></a>
<FONT color="green">19867</FONT>      /**<a name="line.19867"></a>
<FONT color="green">19868</FONT>       * Returns the point that the mouse "brush" is currently "touching" (the<a name="line.19868"></a>
<FONT color="green">19869</FONT>       * so-called "hovered over" point), or &lt;tt&gt;null&lt;/tt&gt; if none.<a name="line.19869"></a>
<FONT color="green">19870</FONT>       * <a name="line.19870"></a>
<FONT color="green">19871</FONT>       * &lt;p&gt;<a name="line.19871"></a>
<FONT color="green">19872</FONT>       * &lt;small&gt; &lt;i&gt;Fine-print:&lt;/i&gt; If the chart clicked on needs an update, this<a name="line.19872"></a>
<FONT color="green">19873</FONT>       * method returns the touched point &lt;i&gt;as of the last time the chart's<a name="line.19873"></a>
<FONT color="green">19874</FONT>       * in-browser (DOM) display was up-to-date&lt;/i&gt;. If you don't assure that your<a name="line.19874"></a>
<FONT color="green">19875</FONT>       * chart's DOM display is up-to-date via other means (e.g. updating right<a name="line.19875"></a>
<FONT color="green">19876</FONT>       * after you change its specifications) a quick check with the<a name="line.19876"></a>
<FONT color="green">19877</FONT>       * &lt;tt&gt;isUpdateNeeded&lt;/tt&gt; method and a subsequent &lt;tt&gt;update&lt;/tt&gt; before<a name="line.19877"></a>
<FONT color="green">19878</FONT>       * accessing the touched point can be a good strategy.<a name="line.19878"></a>
<FONT color="green">19879</FONT>       * &lt;p&gt;<a name="line.19879"></a>
<FONT color="green">19880</FONT>       * &lt;/small&gt;<a name="line.19880"></a>
<FONT color="green">19881</FONT>       * <a name="line.19881"></a>
<FONT color="green">19882</FONT>       * <a name="line.19882"></a>
<FONT color="green">19883</FONT>       * See the &lt;tt&gt;setBrushHeight&lt;/tt&gt; method for the rules GChart uses to<a name="line.19883"></a>
<FONT color="green">19884</FONT>       * determine the currently touched point.<a name="line.19884"></a>
<FONT color="green">19885</FONT>       * &lt;p&gt;<a name="line.19885"></a>
<FONT color="green">19886</FONT>       * <a name="line.19886"></a>
<FONT color="green">19887</FONT>       * &lt;small&gt; &lt;i&gt;Warning:&lt;/i&gt; The currently touched point, on FF2 (but not in<a name="line.19887"></a>
<FONT color="green">19888</FONT>       * IE7) can be changed (or set to &lt;tt&gt;null&lt;/tt&gt;) by invoking<a name="line.19888"></a>
<FONT color="green">19889</FONT>       * &lt;tt&gt;Window.alert&lt;/tt&gt;. Though I originally expected that such a modal alert<a name="line.19889"></a>
<FONT color="green">19890</FONT>       * box would "eat" all mouse events (and it does just that in IE7) in FF2 (and<a name="line.19890"></a>
<FONT color="green">19891</FONT>       * possibly other browsers) some mouse events on the alert box are also passed<a name="line.19891"></a>
<FONT color="green">19892</FONT>       * on up to the GChart. It's best for applications that need to "lock on" to<a name="line.19892"></a>
<FONT color="green">19893</FONT>       * the &lt;i&gt;initially&lt;/i&gt; touched point to grab a reference to the touched point<a name="line.19893"></a>
<FONT color="green">19894</FONT>       * &lt;i&gt;before&lt;/i&gt; performing any activity that allows the user to interact with<a name="line.19894"></a>
<FONT color="green">19895</FONT>       * the browser in ways that could possibly generate GChart-visible mouse<a name="line.19895"></a>
<FONT color="green">19896</FONT>       * events. &lt;/small&gt;<a name="line.19896"></a>
<FONT color="green">19897</FONT>       * &lt;p&gt;<a name="line.19897"></a>
<FONT color="green">19898</FONT>       * <a name="line.19898"></a>
<FONT color="green">19899</FONT>       * @return a reference to the point that the mouse "brush" is currently<a name="line.19899"></a>
<FONT color="green">19900</FONT>       *         "touching".<a name="line.19900"></a>
<FONT color="green">19901</FONT>       * <a name="line.19901"></a>
<FONT color="green">19902</FONT>       * @see #getTouchedCurve getTouchedCurve<a name="line.19902"></a>
<FONT color="green">19903</FONT>       * @see #touch touch<a name="line.19903"></a>
<FONT color="green">19904</FONT>       * @see Symbol#setBrushHeight setBrushHeight<a name="line.19904"></a>
<FONT color="green">19905</FONT>       * @see Symbol#setHoverSelectionSymbolType setHoverSelectionSymbolType<a name="line.19905"></a>
<FONT color="green">19906</FONT>       * @see #isUpdateNeeded isUpdateNeeded<a name="line.19906"></a>
<FONT color="green">19907</FONT>       * @see #update update<a name="line.19907"></a>
<FONT color="green">19908</FONT>       * @see Axis#getMouseCoordinate getMouseCoordinate<a name="line.19908"></a>
<FONT color="green">19909</FONT>       * @see Axis#clientToModel clientToModel<a name="line.19909"></a>
<FONT color="green">19910</FONT>       * @see Axis#modelToClient modelToClient<a name="line.19910"></a>
<FONT color="green">19911</FONT>       * @see Axis#pixelToModel pixelToModel<a name="line.19911"></a>
<FONT color="green">19912</FONT>       * @see Axis#modelToPixel modelToPixel<a name="line.19912"></a>
<FONT color="green">19913</FONT>       * <a name="line.19913"></a>
<FONT color="green">19914</FONT>       */<a name="line.19914"></a>
<FONT color="green">19915</FONT>      public Curve.Point getTouchedPoint() {<a name="line.19915"></a>
<FONT color="green">19916</FONT>        return plotPanel.touchedPoint;<a name="line.19916"></a>
<FONT color="green">19917</FONT>      }<a name="line.19917"></a>
<FONT color="green">19918</FONT>    <a name="line.19918"></a>
<FONT color="green">19919</FONT>      /**<a name="line.19919"></a>
<FONT color="green">19920</FONT>       * Sets the number of pixels, in the horizontal dimension, available for curve<a name="line.19920"></a>
<FONT color="green">19921</FONT>       * display. Note that this curve display area does &lt;i&gt;not&lt;/i&gt; include the axes<a name="line.19921"></a>
<FONT color="green">19922</FONT>       * themselves, their tick marks, their labels, etc.<a name="line.19922"></a>
<FONT color="green">19923</FONT>       * <a name="line.19923"></a>
<FONT color="green">19924</FONT>       * &lt;p&gt;<a name="line.19924"></a>
<FONT color="green">19925</FONT>       * <a name="line.19925"></a>
<FONT color="green">19926</FONT>       * &lt;i&gt;Note&lt;/i&gt;: Most modern display devices use "square" pixels, that is,<a name="line.19926"></a>
<FONT color="green">19927</FONT>       * pixels whose width and height are the same. GChart tacitly assumes square<a name="line.19927"></a>
<FONT color="green">19928</FONT>       * pixels in many of its default settings.<a name="line.19928"></a>
<FONT color="green">19929</FONT>       * <a name="line.19929"></a>
<FONT color="green">19930</FONT>       * <a name="line.19930"></a>
<FONT color="green">19931</FONT>       * @param xChartSize<a name="line.19931"></a>
<FONT color="green">19932</FONT>       *          the number of x-pixels in the chart region used for curve display.<a name="line.19932"></a>
<FONT color="green">19933</FONT>       * <a name="line.19933"></a>
<FONT color="green">19934</FONT>       * @see #getXChartSize getXChartSize<a name="line.19934"></a>
<FONT color="green">19935</FONT>       * @see #getXChartSizeDecorated getXChartSizeDecorated<a name="line.19935"></a>
<FONT color="green">19936</FONT>       * @see #setYChartSize setYChartSize<a name="line.19936"></a>
<FONT color="green">19937</FONT>       * <a name="line.19937"></a>
<FONT color="green">19938</FONT>       */<a name="line.19938"></a>
<FONT color="green">19939</FONT>      public void setXChartSize(int xChartSize) {<a name="line.19939"></a>
<FONT color="green">19940</FONT>        chartDecorationsChanged = true;<a name="line.19940"></a>
<FONT color="green">19941</FONT>        this.xChartSize = xChartSize;<a name="line.19941"></a>
<FONT color="green">19942</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.19942"></a>
<FONT color="green">19943</FONT>        c.getSymbol().setWidth(xChartSize);<a name="line.19943"></a>
<FONT color="green">19944</FONT>      }<a name="line.19944"></a>
<FONT color="green">19945</FONT>    <a name="line.19945"></a>
<FONT color="green">19946</FONT>      /**<a name="line.19946"></a>
<FONT color="green">19947</FONT>       * Sets the number of pixels, in the vertical dimension, available for curve<a name="line.19947"></a>
<FONT color="green">19948</FONT>       * display. Note that this curve display region of the chart does &lt;i&gt;not&lt;/i&gt;<a name="line.19948"></a>
<FONT color="green">19949</FONT>       * include the axes themselves, their tick marks, labels, etc.<a name="line.19949"></a>
<FONT color="green">19950</FONT>       * <a name="line.19950"></a>
<FONT color="green">19951</FONT>       * &lt;p&gt;<a name="line.19951"></a>
<FONT color="green">19952</FONT>       * <a name="line.19952"></a>
<FONT color="green">19953</FONT>       * &lt;i&gt;Note&lt;/i&gt;: Most modern display devices use "square" pixels, that is,<a name="line.19953"></a>
<FONT color="green">19954</FONT>       * pixels whose width and height are the same. GChart tacitly assumes square<a name="line.19954"></a>
<FONT color="green">19955</FONT>       * pixels in many of its default settings.<a name="line.19955"></a>
<FONT color="green">19956</FONT>       * <a name="line.19956"></a>
<FONT color="green">19957</FONT>       * @param yChartSize<a name="line.19957"></a>
<FONT color="green">19958</FONT>       *          the number of y-pixels in the chart region used for curve display.<a name="line.19958"></a>
<FONT color="green">19959</FONT>       * <a name="line.19959"></a>
<FONT color="green">19960</FONT>       * @see #getYChartSize getYChartSize<a name="line.19960"></a>
<FONT color="green">19961</FONT>       * @see #getYChartSizeDecorated getYChartSizeDecorated<a name="line.19961"></a>
<FONT color="green">19962</FONT>       * @see #setXChartSize setXChartSize<a name="line.19962"></a>
<FONT color="green">19963</FONT>       * <a name="line.19963"></a>
<FONT color="green">19964</FONT>       */<a name="line.19964"></a>
<FONT color="green">19965</FONT>      public void setYChartSize(int yChartSize) {<a name="line.19965"></a>
<FONT color="green">19966</FONT>        chartDecorationsChanged = true;<a name="line.19966"></a>
<FONT color="green">19967</FONT>        this.yChartSize = yChartSize;<a name="line.19967"></a>
<FONT color="green">19968</FONT>        Curve c = getSystemCurve(PLOTAREA_ID);<a name="line.19968"></a>
<FONT color="green">19969</FONT>        c.getSymbol().setHeight(yChartSize);<a name="line.19969"></a>
<FONT color="green">19970</FONT>      }<a name="line.19970"></a>
<FONT color="green">19971</FONT>    <a name="line.19971"></a>
<FONT color="green">19972</FONT>    /**<a name="line.19972"></a>
<FONT color="green">19973</FONT>       * Simulates the user "touching" a point with the mouse, by<a name="line.19973"></a>
<FONT color="green">19974</FONT>       * performing those operations that occur when the user "hovers<a name="line.19974"></a>
<FONT color="green">19975</FONT>       * over" the specified point. In detail, this method does the<a name="line.19975"></a>
<FONT color="green">19976</FONT>       * following:&lt;p&gt;<a name="line.19976"></a>
<FONT color="green">19977</FONT>       * <a name="line.19977"></a>
<FONT color="green">19978</FONT>       * &lt;ol&gt;<a name="line.19978"></a>
<FONT color="green">19979</FONT>       *<a name="line.19979"></a>
<FONT color="green">19980</FONT>       *  &lt;li&gt; The specified point is made the currently "touched point"<a name="line.19980"></a>
<FONT color="green">19981</FONT>       *  (this is the reference returned by &lt;tt&gt;getTouchedPoint&lt;/tt&gt;). &lt;p&gt;<a name="line.19981"></a>
<FONT color="green">19982</FONT>       *<a name="line.19982"></a>
<FONT color="green">19983</FONT>       *  &lt;li&gt;If the previously touched point had a hover widget,<a name="line.19983"></a>
<FONT color="green">19984</FONT>       *  that hover widget's &lt;tt&gt;hoverCleanup&lt;/tt&gt; method is called.&lt;p&gt;<a name="line.19984"></a>
<FONT color="green">19985</FONT>       *<a name="line.19985"></a>
<FONT color="green">19986</FONT>       *  &lt;li&gt;If the touched point has an associated hover widget, that<a name="line.19986"></a>
<FONT color="green">19987</FONT>       *  widget's &lt;tt&gt;hoverUpdate&lt;/tt&gt; method is called.&lt;p&gt;<a name="line.19987"></a>
<FONT color="green">19988</FONT>       *<a name="line.19988"></a>
<FONT color="green">19989</FONT>       *  &lt;li&gt; Any hover selection feedback or hover annotation on<a name="line.19989"></a>
<FONT color="green">19990</FONT>       *  any previously touched point is removed.&lt;p&gt;<a name="line.19990"></a>
<FONT color="green">19991</FONT>       *<a name="line.19991"></a>
<FONT color="green">19992</FONT>       *  &lt;li&gt;Any hover annotation for the newly touched point is<a name="line.19992"></a>
<FONT color="green">19993</FONT>       *  displayed as per the various hover annotation related<a name="line.19993"></a>
<FONT color="green">19994</FONT>       *  specifications (e.g.  &lt;tt&gt;setHoverLocation&lt;/tt&gt;) associated with<a name="line.19994"></a>
<FONT color="green">19995</FONT>       *  the symbol used to render the point.&lt;p&gt;<a name="line.19995"></a>
<FONT color="green">19996</FONT>       *<a name="line.19996"></a>
<FONT color="green">19997</FONT>       *  &lt;li&gt; Any selection feedback for the newly touched point is<a name="line.19997"></a>
<FONT color="green">19998</FONT>       *  displayed in accord with the hover selection feedback<a name="line.19998"></a>
<FONT color="green">19999</FONT>       *  specificiations (e.g.  &lt;tt&gt;setHoverSelectionBorderColor&lt;/tt&gt;)<a name="line.19999"></a>
<FONT color="green">20000</FONT>       *  associated with the symbol used to render the point.&lt;p&gt;<a name="line.20000"></a>
<FONT color="green">20001</FONT>       *  <a name="line.20001"></a>
<FONT color="green">20002</FONT>       *  &lt;/ol&gt;<a name="line.20002"></a>
<FONT color="green">20003</FONT>       *<a name="line.20003"></a>
<FONT color="green">20004</FONT>       * Using &lt;tt&gt;null&lt;/tt&gt; as the point to touch simulates<a name="line.20004"></a>
<FONT color="green">20005</FONT>       * the user moving the mouse into a region where it is not<a name="line.20005"></a>
<FONT color="green">20006</FONT>       * touching any point (for example, off the chart entirely).<a name="line.20006"></a>
<FONT color="green">20007</FONT>       * &lt;p&gt;<a name="line.20007"></a>
<FONT color="green">20008</FONT>       * <a name="line.20008"></a>
<FONT color="green">20009</FONT>       * Note that, as with all chart specification changes, you must<a name="line.20009"></a>
<FONT color="green">20010</FONT>       * invoke &lt;tt&gt;update&lt;/tt&gt; before the point selection and other<a name="line.20010"></a>
<FONT color="green">20011</FONT>       * changes associated with this method will appear on the chart.<a name="line.20011"></a>
<FONT color="green">20012</FONT>       * &lt;p&gt;<a name="line.20012"></a>
<FONT color="green">20013</FONT>       *<a name="line.20013"></a>
<FONT color="green">20014</FONT>       * &lt;i&gt;Tip:&lt;/i&gt; The touched point can sometimes be used in lieu of a<a name="line.20014"></a>
<FONT color="green">20015</FONT>       * point selection capability (which GChart lacks). For example, a<a name="line.20015"></a>
<FONT color="green">20016</FONT>       * dialog box that allowed users to choose data points by their<a name="line.20016"></a>
<FONT color="green">20017</FONT>       * names could "touch" the point associated with a user-selected<a name="line.20017"></a>
<FONT color="green">20018</FONT>       * name in order to highlight it on the chart.<a name="line.20018"></a>
<FONT color="green">20019</FONT>       * <a name="line.20019"></a>
<FONT color="green">20020</FONT>       * @param pointToTouch this method will perform appropriate<a name="line.20020"></a>
<FONT color="green">20021</FONT>       *   operations (as described above) in order to simulate the user<a name="line.20021"></a>
<FONT color="green">20022</FONT>       *   "touching" this point with their mouse.<a name="line.20022"></a>
<FONT color="green">20023</FONT>       *<a name="line.20023"></a>
<FONT color="green">20024</FONT>       * @see #getTouchedPoint getTouchedPoint<a name="line.20024"></a>
<FONT color="green">20025</FONT>       * @see #getTouchedCurve getTouchedCurve<a name="line.20025"></a>
<FONT color="green">20026</FONT>       * @see HoverUpdateable#hoverUpdate hoverUpdate<a name="line.20026"></a>
<FONT color="green">20027</FONT>       * @see HoverUpdateable#hoverCleanup hoverCleanup<a name="line.20027"></a>
<FONT color="green">20028</FONT>       * @see Symbol#setHoverWidget setHoverWidget<a name="line.20028"></a>
<FONT color="green">20029</FONT>       * @see Symbol#setHoverLocation setHoverLocation<a name="line.20029"></a>
<FONT color="green">20030</FONT>       * @see Symbol#setHoverSelectionBorderColor<a name="line.20030"></a>
<FONT color="green">20031</FONT>       * setHoverSelectionBorderColor<a name="line.20031"></a>
<FONT color="green">20032</FONT>       * @see Axis#getMouseCoordinate getMouseCoordinate<a name="line.20032"></a>
<FONT color="green">20033</FONT>       * @see Axis#clientToModel clientToModel<a name="line.20033"></a>
<FONT color="green">20034</FONT>       * @see Axis#modelToClient modelToClient<a name="line.20034"></a>
<FONT color="green">20035</FONT>       * @see Axis#pixelToModel pixelToModel<a name="line.20035"></a>
<FONT color="green">20036</FONT>       * @see Axis#modelToPixel modelToPixel<a name="line.20036"></a>
<FONT color="green">20037</FONT>       * <a name="line.20037"></a>
<FONT color="green">20038</FONT>       */<a name="line.20038"></a>
<FONT color="green">20039</FONT>      public void touch(Curve.Point pointToTouch) {<a name="line.20039"></a>
<FONT color="green">20040</FONT>        plotPanel.touch(pointToTouch);<a name="line.20040"></a>
<FONT color="green">20041</FONT>      }<a name="line.20041"></a>
<FONT color="green">20042</FONT>    <a name="line.20042"></a>
<FONT color="green">20043</FONT>      /**<a name="line.20043"></a>
<FONT color="green">20044</FONT>       * Builds a chart that reflects current user-specified chart specs (curve<a name="line.20044"></a>
<FONT color="green">20045</FONT>       * data, symbol choices, etc.)<a name="line.20045"></a>
<FONT color="green">20046</FONT>       * &lt;p&gt;<a name="line.20046"></a>
<FONT color="green">20047</FONT>       * <a name="line.20047"></a>
<FONT color="green">20048</FONT>       * Before any of the chart specifications of the other methods of this class<a name="line.20048"></a>
<FONT color="green">20049</FONT>       * will actually be visible on the chart, you must call this method.<a name="line.20049"></a>
<FONT color="green">20050</FONT>       * &lt;p&gt;<a name="line.20050"></a>
<FONT color="green">20051</FONT>       * <a name="line.20051"></a>
<FONT color="green">20052</FONT>       * Typically, for efficiency, you would call this method only after you had<a name="line.20052"></a>
<FONT color="green">20053</FONT>       * made all of the desired chart specifications via the other methods.<a name="line.20053"></a>
<FONT color="green">20054</FONT>       * <a name="line.20054"></a>
<FONT color="green">20055</FONT>       * &lt;p&gt;<a name="line.20055"></a>
<FONT color="green">20056</FONT>       * <a name="line.20056"></a>
<FONT color="green">20057</FONT>       * By default, updates are optimized for speed, and this can end up wasting<a name="line.20057"></a>
<FONT color="green">20058</FONT>       * (usually not too much, though there are exceptions) memory. To optimize for<a name="line.20058"></a>
<FONT color="green">20059</FONT>       * memory instead, use the &lt;tt&gt;setOptimizeForMemory&lt;/tt&gt; method.<a name="line.20059"></a>
<FONT color="green">20060</FONT>       * &lt;p&gt;<a name="line.20060"></a>
<FONT color="green">20061</FONT>       * <a name="line.20061"></a>
<FONT color="green">20062</FONT>       * For a discussion of Client-side GChart update times and how minimize them,<a name="line.20062"></a>
<FONT color="green">20063</FONT>       * see &lt;a href="{@docRoot}/com/googlecode/gchart/client/doc-files/tipsformakingupdatesfaster.html"&gt;<a name="line.20063"></a>
<FONT color="green">20064</FONT>       * Tips for Making Client-side GChart Updates Faster&lt;/a&gt;.<a name="line.20064"></a>
<FONT color="green">20065</FONT>       * &lt;p&gt;<a name="line.20065"></a>
<FONT color="green">20066</FONT>       * <a name="line.20066"></a>
<FONT color="green">20067</FONT>       * &lt;i&gt;Note&lt;/i&gt; Hover feedback is disabled whenever the currently rendered<a name="line.20067"></a>
<FONT color="green">20068</FONT>       * chart does not match current chart specs, that is, whenever<a name="line.20068"></a>
<FONT color="green">20069</FONT>       * &lt;tt&gt;isUpdateNeeded&lt;/tt&gt; returns &lt;tt&gt;true&lt;/tt&gt;. Thus, to assure that hover<a name="line.20069"></a>
<FONT color="green">20070</FONT>       * feedback remains operational once your code returns control to the browser,<a name="line.20070"></a>
<FONT color="green">20071</FONT>       * be sure to call &lt;tt&gt;update()&lt;/tt&gt; after making a series of changes to your<a name="line.20071"></a>
<FONT color="green">20072</FONT>       * chart's properties.<a name="line.20072"></a>
<FONT color="green">20073</FONT>       * &lt;p&gt;<a name="line.20073"></a>
<FONT color="green">20074</FONT>       * <a name="line.20074"></a>
<FONT color="green">20075</FONT>       * Understanding how &lt;tt&gt;update&lt;/tt&gt; impacts visibility and size:<a name="line.20075"></a>
<FONT color="green">20076</FONT>       * &lt;p&gt;<a name="line.20076"></a>
<FONT color="green">20077</FONT>       * &lt;blockquote&gt; &lt;small&gt; Due to an implementation-related limitation,<a name="line.20077"></a>
<FONT color="green">20078</FONT>       * &lt;tt&gt;visibility: hidden&lt;/tt&gt; won't hide a GChart (&lt;tt&gt;update&lt;/tt&gt;<a name="line.20078"></a>
<FONT color="green">20079</FONT>       * commandeers the visibility attribute). Instead use &lt;tt&gt;display: none&lt;/tt&gt;<a name="line.20079"></a>
<FONT color="green">20080</FONT>       * or, equivalently:<a name="line.20080"></a>
<FONT color="green">20081</FONT>       * <a name="line.20081"></a>
<FONT color="green">20082</FONT>       * &lt;pre&gt;<a name="line.20082"></a>
<FONT color="green">20083</FONT>       * myGChart.setVisible(false);<a name="line.20083"></a>
<FONT color="green">20084</FONT>       * &lt;/pre&gt;<a name="line.20084"></a>
<FONT color="green">20085</FONT>       * <a name="line.20085"></a>
<FONT color="green">20086</FONT>       * If you need to avoid &lt;tt&gt;display: none&lt;/tt&gt; (it can change page layout),<a name="line.20086"></a>
<FONT color="green">20087</FONT>       * you can also hide a GChart via lines such as:<a name="line.20087"></a>
<FONT color="green">20088</FONT>       * <a name="line.20088"></a>
<FONT color="green">20089</FONT>       * &lt;pre&gt;<a name="line.20089"></a>
<FONT color="green">20090</FONT>       * DOM.setStyleAttribute(myGChart.getElement(), &amp;quot;overflow&amp;quot;, &amp;quot;hidden&amp;quot;);<a name="line.20090"></a>
<FONT color="green">20091</FONT>       * myGChart.setPixelSize(0, 0);<a name="line.20091"></a>
<FONT color="green">20092</FONT>       * &lt;/pre&gt;<a name="line.20092"></a>
<FONT color="green">20093</FONT>       * <a name="line.20093"></a>
<FONT color="green">20094</FONT>       * This later approach gives you the option of leaving the top corner of the<a name="line.20094"></a>
<FONT color="green">20095</FONT>       * GChart visible, etc. Note that, with the next &lt;tt&gt;update&lt;/tt&gt;, GChart will<a name="line.20095"></a>
<FONT color="green">20096</FONT>       * overwrite your size (based on the GChart properties that define the size of<a name="line.20096"></a>
<FONT color="green">20097</FONT>       * the the chart, such as &lt;tt&gt;setChartSize&lt;/tt&gt; and &lt;tt&gt;set*Thickness&lt;/tt&gt;)<a name="line.20097"></a>
<FONT color="green">20098</FONT>       * and your &lt;tt&gt;overflow:hidden&lt;/tt&gt; (based on<a name="line.20098"></a>
<FONT color="green">20099</FONT>       * &lt;tt&gt;setClipToDecoratedChart&lt;/tt&gt;) specifications. To preserve them (or in<a name="line.20099"></a>
<FONT color="green">20100</FONT>       * other special cases) you may need to apply such settings to an enclosing<a name="line.20100"></a>
<FONT color="green">20101</FONT>       * parent element.<a name="line.20101"></a>
<FONT color="green">20102</FONT>       * <a name="line.20102"></a>
<FONT color="green">20103</FONT>       * &lt;/small&gt; &lt;/blockquote&gt;<a name="line.20103"></a>
<FONT color="green">20104</FONT>       * <a name="line.20104"></a>
<FONT color="green">20105</FONT>       * <a name="line.20105"></a>
<FONT color="green">20106</FONT>       * @param option<a name="line.20106"></a>
<FONT color="green">20107</FONT>       *          determines how the touched (or "hovered over") point changes as a<a name="line.20107"></a>
<FONT color="green">20108</FONT>       *          result of this update. See &lt;tt&gt;TouchedPointUpdateOption&lt;/tt&gt; for<a name="line.20108"></a>
<FONT color="green">20109</FONT>       *          the available choices.<a name="line.20109"></a>
<FONT color="green">20110</FONT>       * <a name="line.20110"></a>
<FONT color="green">20111</FONT>       * @see TouchedPointUpdateOption TouchedPointUpdateOption<a name="line.20111"></a>
<FONT color="green">20112</FONT>       * @see #setOptimizeForMemory setOptimizeForMemory<a name="line.20112"></a>
<FONT color="green">20113</FONT>       * @see #isUpdateNeeded isUpdateNeeded<a name="line.20113"></a>
<FONT color="green">20114</FONT>       * <a name="line.20114"></a>
<FONT color="green">20115</FONT>       */<a name="line.20115"></a>
<FONT color="green">20116</FONT>      public void update(TouchedPointUpdateOption option) {<a name="line.20116"></a>
<FONT color="green">20117</FONT>    <a name="line.20117"></a>
<FONT color="green">20118</FONT>        /*<a name="line.20118"></a>
<FONT color="green">20119</FONT>         * This method defines each curve's default pie slice orientations, and also<a name="line.20119"></a>
<FONT color="green">20120</FONT>         * separates each curve's points into the vertically or horizontally banded<a name="line.20120"></a>
<FONT color="green">20121</FONT>         * bins, that GChart needs to perform the hit testing that allows it to<a name="line.20121"></a>
<FONT color="green">20122</FONT>         * emulate "touching" points with the mouse. &lt;p&gt;<a name="line.20122"></a>
<FONT color="green">20123</FONT>         * <a name="line.20123"></a>
<FONT color="green">20124</FONT>         * Therefore, this line must come first.<a name="line.20124"></a>
<FONT color="green">20125</FONT>         */<a name="line.20125"></a>
<FONT color="green">20126</FONT>        assembleChart();<a name="line.20126"></a>
<FONT color="green">20127</FONT>    <a name="line.20127"></a>
<FONT color="green">20128</FONT>        if (TouchedPointUpdateOption.TOUCHED_POINT_LOCKED == option) {<a name="line.20128"></a>
<FONT color="green">20129</FONT>          // must re-touch (point position, hover-config can change)<a name="line.20129"></a>
<FONT color="green">20130</FONT>          plotPanel.touch(plotPanel.touchedPoint);<a name="line.20130"></a>
<FONT color="green">20131</FONT>        } else if (TouchedPointUpdateOption.TOUCHED_POINT_CLEARED == option) {<a name="line.20131"></a>
<FONT color="green">20132</FONT>          // if needed, will clear out touched point &amp; related feedback<a name="line.20132"></a>
<FONT color="green">20133</FONT>          plotPanel.touch(null);<a name="line.20133"></a>
<FONT color="green">20134</FONT>        } else if (TouchedPointUpdateOption.TOUCHED_POINT_UPDATED == option) {<a name="line.20134"></a>
<FONT color="green">20135</FONT>          // re-determine which point is underneath the mouse now...<a name="line.20135"></a>
<FONT color="green">20136</FONT>          plotPanel.retouchObjectAtMousePosition();<a name="line.20136"></a>
<FONT color="green">20137</FONT>        }<a name="line.20137"></a>
<FONT color="green">20138</FONT>    <a name="line.20138"></a>
<FONT color="green">20139</FONT>        /*<a name="line.20139"></a>
<FONT color="green">20140</FONT>         * Because only the hover feedback curves have changed since the<a name="line.20140"></a>
<FONT color="green">20141</FONT>         * first call above, this second call only has to update these hover<a name="line.20141"></a>
<FONT color="green">20142</FONT>         * feedback curves (so it's not like we are really assembling the<a name="line.20142"></a>
<FONT color="green">20143</FONT>         * chart twice)<a name="line.20143"></a>
<FONT color="green">20144</FONT>         */<a name="line.20144"></a>
<FONT color="green">20145</FONT>        assembleChart();<a name="line.20145"></a>
<FONT color="green">20146</FONT>    <a name="line.20146"></a>
<FONT color="green">20147</FONT>      }<a name="line.20147"></a>
<FONT color="green">20148</FONT>    <a name="line.20148"></a>
<FONT color="green">20149</FONT>      /**<a name="line.20149"></a>
<FONT color="green">20150</FONT>       * Updates the chart, using an appropriate default touched point update<a name="line.20150"></a>
<FONT color="green">20151</FONT>       * option, depending on if hover touching is enabled or not.<a name="line.20151"></a>
<FONT color="green">20152</FONT>       * &lt;p&gt;<a name="line.20152"></a>
<FONT color="green">20153</FONT>       * <a name="line.20153"></a>
<FONT color="green">20154</FONT>       * A convenience method equivalent to:<a name="line.20154"></a>
<FONT color="green">20155</FONT>       * &lt;p&gt;<a name="line.20155"></a>
<FONT color="green">20156</FONT>       * <a name="line.20156"></a>
<FONT color="green">20157</FONT>       * &lt;pre&gt;<a name="line.20157"></a>
<FONT color="green">20158</FONT>       * if (getHoverTouchingEnabled())<a name="line.20158"></a>
<FONT color="green">20159</FONT>       *   update(TouchedPointUpdateOption.TOUCHED_POINT_UPDATED);<a name="line.20159"></a>
<FONT color="green">20160</FONT>       * else<a name="line.20160"></a>
<FONT color="green">20161</FONT>       *   update(TouchedPointUpdateOption.TOUCHED_POINT_LOCKED);<a name="line.20161"></a>
<FONT color="green">20162</FONT>       * &lt;/pre&gt;<a name="line.20162"></a>
<FONT color="green">20163</FONT>       * <a name="line.20163"></a>
<FONT color="green">20164</FONT>       * <a name="line.20164"></a>
<FONT color="green">20165</FONT>       * @see #update(TouchedPointUpdateOption) update(TouchedPointUpdateOption)<a name="line.20165"></a>
<FONT color="green">20166</FONT>       * @see #setHoverTouchingEnabled setHoverTouchingEnabled<a name="line.20166"></a>
<FONT color="green">20167</FONT>       * <a name="line.20167"></a>
<FONT color="green">20168</FONT>       */<a name="line.20168"></a>
<FONT color="green">20169</FONT>      public void update() {<a name="line.20169"></a>
<FONT color="green">20170</FONT>        if (getHoverTouchingEnabled())<a name="line.20170"></a>
<FONT color="green">20171</FONT>          update(TouchedPointUpdateOption.TOUCHED_POINT_UPDATED);<a name="line.20171"></a>
<FONT color="green">20172</FONT>        else<a name="line.20172"></a>
<FONT color="green">20173</FONT>          update(TouchedPointUpdateOption.TOUCHED_POINT_LOCKED);<a name="line.20173"></a>
<FONT color="green">20174</FONT>      }<a name="line.20174"></a>
<FONT color="green">20175</FONT>    <a name="line.20175"></a>
<FONT color="green">20176</FONT>      // constructs the chart within the chart panel from current specs<a name="line.20176"></a>
<FONT color="green">20177</FONT>      private void assembleChart() {<a name="line.20177"></a>
<FONT color="green">20178</FONT>    <a name="line.20178"></a>
<FONT color="green">20179</FONT>        if (chartDecorationsChanged || xAxis.limitsChanged()<a name="line.20179"></a>
<FONT color="green">20180</FONT>            || yAxis.limitsChanged() || y2Axis.limitsChanged()) {<a name="line.20180"></a>
<FONT color="green">20181</FONT>          plotPanel.reset(xChartSize, yChartSize, hasYAxis(), hasY2Axis(),<a name="line.20181"></a>
<FONT color="green">20182</FONT>              xAxis, yAxis, y2Axis);<a name="line.20182"></a>
<FONT color="green">20183</FONT>    /*<a name="line.20183"></a>
<FONT color="green">20184</FONT>     * As of GChart 2.7, in most cases, font-family in annotations gets set<a name="line.20184"></a>
<FONT color="green">20185</FONT>     * explicitly at the table-cell level. This is the only way to assure<a name="line.20185"></a>
<FONT color="green">20186</FONT>     * that &lt;td&gt; stylings (present, for example, in GWT's default CSS<a name="line.20186"></a>
<FONT color="green">20187</FONT>     * stylesheets) don't short-circuit the user-selected font-family for a<a name="line.20187"></a>
<FONT color="green">20188</FONT>     * chart's annotations. But, for the special case where a low-level<a name="line.20188"></a>
<FONT color="green">20189</FONT>     * annotation has explicitly defined it's font-family as "" (a.k.a.<a name="line.20189"></a>
<FONT color="green">20190</FONT>     * USE_CSS) we still need this top level CSS so the GChart-wide<a name="line.20190"></a>
<FONT color="green">20191</FONT>     * font-family cascades down when it isn't short-circuited (a savy<a name="line.20191"></a>
<FONT color="green">20192</FONT>     * user can modify the GWT default stylesheet to eliminate the<a name="line.20192"></a>
<FONT color="green">20193</FONT>     * &lt;td&gt; style rules, thus saving a bit of time by avoiding<a name="line.20193"></a>
<FONT color="green">20194</FONT>     * the need to explicitly set the low level font-family style in<a name="line.20194"></a>
<FONT color="green">20195</FONT>     * the DOM).<a name="line.20195"></a>
<FONT color="green">20196</FONT>     *<a name="line.20196"></a>
<FONT color="green">20197</FONT>     */ <a name="line.20197"></a>
<FONT color="green">20198</FONT>          GChart.setFontFamily(this, getFontFamily());<a name="line.20198"></a>
<FONT color="green">20199</FONT>          GChart.setBackgroundColor(this, getBackgroundColor());<a name="line.20199"></a>
<FONT color="green">20200</FONT>          GChart.setBorderColor(this, getBorderColor());<a name="line.20200"></a>
<FONT color="green">20201</FONT>          GChart.setBorderStyle(this, getBorderStyle());<a name="line.20201"></a>
<FONT color="green">20202</FONT>          GChart.setBorderWidth(this, getBorderWidth());<a name="line.20202"></a>
<FONT color="green">20203</FONT>          GChart.setPadding(this, getPadding());<a name="line.20203"></a>
<FONT color="green">20204</FONT>          GChart.setOverflow(this, getClipToDecoratedChart() ? "hidden"<a name="line.20204"></a>
<FONT color="green">20205</FONT>              : "visible");<a name="line.20205"></a>
<FONT color="green">20206</FONT>    <a name="line.20206"></a>
<FONT color="green">20207</FONT>          this.setPixelSize(plotPanel.getXChartSizeDecoratedQuickly(),<a name="line.20207"></a>
<FONT color="green">20208</FONT>              plotPanel.getYChartSizeDecoratedQuickly());<a name="line.20208"></a>
<FONT color="green">20209</FONT>          updateDecorations(plotPanel.getXChartSizeDecoratedQuickly());<a name="line.20209"></a>
<FONT color="green">20210</FONT>          xAxis.rememberLimits();<a name="line.20210"></a>
<FONT color="green">20211</FONT>          yAxis.rememberLimits();<a name="line.20211"></a>
<FONT color="green">20212</FONT>          y2Axis.rememberLimits();<a name="line.20212"></a>
<FONT color="green">20213</FONT>          invalidateEveryCurve();<a name="line.20213"></a>
<FONT color="green">20214</FONT>          chartDecorationsChanged = false;<a name="line.20214"></a>
<FONT color="green">20215</FONT>        }<a name="line.20215"></a>
<FONT color="green">20216</FONT>        // actually renders chart, including internal curves used<a name="line.20216"></a>
<FONT color="green">20217</FONT>        // to represent the decorations (title, axis labels, etc.)<a name="line.20217"></a>
<FONT color="green">20218</FONT>        realizePlotPanel();<a name="line.20218"></a>
<FONT color="green">20219</FONT>    <a name="line.20219"></a>
<FONT color="green">20220</FONT>        // To avoid order-of-magnitude FF2 performance hit on busy pages,<a name="line.20220"></a>
<FONT color="green">20221</FONT>        // first time, must add plotPanel only AFTER building chart<a name="line.20221"></a>
<FONT color="green">20222</FONT>        if (plotPanel != chartPanel.getWidget()) {<a name="line.20222"></a>
<FONT color="green">20223</FONT>          chartPanel.add(plotPanel);<a name="line.20223"></a>
<FONT color="green">20224</FONT>          /*<a name="line.20224"></a>
<FONT color="green">20225</FONT>           * Due to how GChart plays around with visible elements contained inside<a name="line.20225"></a>
<FONT color="green">20226</FONT>           * hidden elements to align it's labels properly, if we allowed top level<a name="line.20226"></a>
<FONT color="green">20227</FONT>           * &lt;tt&gt;visibility:hidden&lt;/tt&gt; the result would be that everything<a name="line.20227"></a>
<FONT color="green">20228</FONT>           * &lt;i&gt;except&lt;/i&gt; annotations would be invisible. &lt;p&gt;<a name="line.20228"></a>
<FONT color="green">20229</FONT>           * <a name="line.20229"></a>
<FONT color="green">20230</FONT>           * We can prevent such weird behavior by setting<a name="line.20230"></a>
<FONT color="green">20231</FONT>           * &lt;tt&gt;visibility:visible&lt;/tt&gt; on the top level element; this setting<a name="line.20231"></a>
<FONT color="green">20232</FONT>           * effectively short-circuits any top level visibility setting the user<a name="line.20232"></a>
<FONT color="green">20233</FONT>           * may have made. &lt;p&gt;<a name="line.20233"></a>
<FONT color="green">20234</FONT>           * <a name="line.20234"></a>
<FONT color="green">20235</FONT>           * Users must either use &lt;tt&gt;display:none&lt;/tt&gt; (as the Widget method<a name="line.20235"></a>
<FONT color="green">20236</FONT>           * &lt;tt&gt;setVisible&lt;/tt&gt; does) or create an enclosing 0-sized div with<a name="line.20236"></a>
<FONT color="green">20237</FONT>           * &lt;tt&gt;overflow:hidden&lt;/tt&gt;) to hide a GChart. &lt;p&gt;<a name="line.20237"></a>
<FONT color="green">20238</FONT>           */<a name="line.20238"></a>
<FONT color="green">20239</FONT>          DOM.setStyleAttribute(getElement(), "visibility", "visible");<a name="line.20239"></a>
<FONT color="green">20240</FONT>        } else {<a name="line.20240"></a>
<FONT color="green">20241</FONT>          /*<a name="line.20241"></a>
<FONT color="green">20242</FONT>           * Without these 2 lines IE7 won't repaint GChart's annotations. The lines<a name="line.20242"></a>
<FONT color="green">20243</FONT>           * are not needed in FF2; an IE7 bug is suspected.&lt;p&gt;<a name="line.20243"></a>
<FONT color="green">20244</FONT>           * <a name="line.20244"></a>
<FONT color="green">20245</FONT>           * I got this workaround from &lt;a href= "http://examples.roughian.com"&gt;Ian<a name="line.20245"></a>
<FONT color="green">20246</FONT>           * Bambury&lt;/a&gt; as part of &lt;a href=<a name="line.20246"></a>
<FONT color="green">20247</FONT>           * "http://groups.google.com/group/Google-Web-Toolkit/browse_thread/thread/4c54d8b4aea7f98b/6efd1ab4e5fc0e7b?#6efd1ab4e5fc0e7b"<a name="line.20247"></a>
<FONT color="green">20248</FONT>           * &gt; this discussion on the GWT forum&lt;/a&gt;. &lt;p&gt;<a name="line.20248"></a>
<FONT color="green">20249</FONT>           * <a name="line.20249"></a>
<FONT color="green">20250</FONT>           * (Note comment regarding need for explicit visibility above).<a name="line.20250"></a>
<FONT color="green">20251</FONT>           */<a name="line.20251"></a>
<FONT color="green">20252</FONT>          DOM.setStyleAttribute(getElement(), "visibility", "hidden");<a name="line.20252"></a>
<FONT color="green">20253</FONT>          DOM.setStyleAttribute(getElement(), "visibility", "visible");<a name="line.20253"></a>
<FONT color="green">20254</FONT>        }<a name="line.20254"></a>
<FONT color="green">20255</FONT>      }<a name="line.20255"></a>
<FONT color="green">20256</FONT>    <a name="line.20256"></a>
<FONT color="green">20257</FONT>      // create a Grid representing the chart legend.<a name="line.20257"></a>
<FONT color="green">20258</FONT>      private Grid createLegend(PlotPanel pp) {<a name="line.20258"></a>
<FONT color="green">20259</FONT>        Grid result = new Grid(getNVisibleCurvesOnLegend(), 2);<a name="line.20259"></a>
<FONT color="green">20260</FONT>        int iVisible = 0;<a name="line.20260"></a>
<FONT color="green">20261</FONT>        /*<a name="line.20261"></a>
<FONT color="green">20262</FONT>         * Simply eliminating the border entirely is a valid transparency emulation<a name="line.20262"></a>
<FONT color="green">20263</FONT>         * for the legend (no positional shifting is needed as is needed for the<a name="line.20263"></a>
<FONT color="green">20264</FONT>         * images used to draw the main chart's curves) because the legend is always<a name="line.20264"></a>
<FONT color="green">20265</FONT>         * positioned by its center point, and the border extends around the entire<a name="line.20265"></a>
<FONT color="green">20266</FONT>         * legend key, so removing it does not result in any change to the legend<a name="line.20266"></a>
<FONT color="green">20267</FONT>         * key's center position. &lt;p&gt;<a name="line.20267"></a>
<FONT color="green">20268</FONT>         * <a name="line.20268"></a>
<FONT color="green">20269</FONT>         * If multiple legend locations (beyond the current "always centered in a<a name="line.20269"></a>
<FONT color="green">20270</FONT>         * band along the right edge" option) were ever supported, appropriate<a name="line.20270"></a>
<FONT color="green">20271</FONT>         * positional shifts would then have to be introduced to emulate transparent<a name="line.20271"></a>
<FONT color="green">20272</FONT>         * borders.<a name="line.20272"></a>
<FONT color="green">20273</FONT>         */<a name="line.20273"></a>
<FONT color="green">20274</FONT>        GChart.setBorderWidth(result,<a name="line.20274"></a>
<FONT color="green">20275</FONT>           TRANSPARENT_BORDER_COLOR == getLegendBorderColor() ? 0 : <a name="line.20275"></a>
<FONT color="green">20276</FONT>           Math.abs(getLegendBorderWidth()));<a name="line.20276"></a>
<FONT color="green">20277</FONT>        GChart.setBorderColor(<a name="line.20277"></a>
<FONT color="green">20278</FONT>            result,<a name="line.20278"></a>
<FONT color="green">20279</FONT>            TRANSPARENT_BORDER_COLOR == getLegendBorderColor() ? "transparent"<a name="line.20279"></a>
<FONT color="green">20280</FONT>            : getLegendBorderColor());<a name="line.20280"></a>
<FONT color="green">20281</FONT>        GChart.setBorderStyle(result, getLegendBorderStyle());<a name="line.20281"></a>
<FONT color="green">20282</FONT>        GChart.setBackgroundColor(result, getLegendBackgroundColor());<a name="line.20282"></a>
<FONT color="green">20283</FONT>        int nCurves = getNCurves();<a name="line.20283"></a>
<FONT color="green">20284</FONT>        for (int i = 0; i &lt; nCurves; i++) {<a name="line.20284"></a>
<FONT color="green">20285</FONT>          Curve c = getSystemCurve(i);<a name="line.20285"></a>
<FONT color="green">20286</FONT>          if (c.isVisible() &amp;&amp; c.getLegendLabel() != null) {<a name="line.20286"></a>
<FONT color="green">20287</FONT>            double symBorderFraction = <a name="line.20287"></a>
<FONT color="green">20288</FONT>               c.getSymbol().getBorderWidth() / <a name="line.20288"></a>
<FONT color="green">20289</FONT>               Math.max(Math.max(1.0, c.getSymbol().getFillThickness()), <a name="line.20289"></a>
<FONT color="green">20290</FONT>                        Math.max(c.getSymbol().getWidth(pp), <a name="line.20290"></a>
<FONT color="green">20291</FONT>                                 c.getSymbol().getHeight(pp,c.onY2())));<a name="line.20291"></a>
<FONT color="green">20292</FONT>            Image icon = c.getSymbol().getSymbolType().createIconImage(<a name="line.20292"></a>
<FONT color="green">20293</FONT>                c.getSymbol(), getLegendFontSize(), symBorderFraction);<a name="line.20293"></a>
<FONT color="green">20294</FONT>    <a name="line.20294"></a>
<FONT color="green">20295</FONT>            result.setWidget(iVisible, 0, icon);<a name="line.20295"></a>
<FONT color="green">20296</FONT>            result.getCellFormatter().setAlignment(iVisible, 0,<a name="line.20296"></a>
<FONT color="green">20297</FONT>                HasHorizontalAlignment.ALIGN_CENTER,<a name="line.20297"></a>
<FONT color="green">20298</FONT>                HasVerticalAlignment.ALIGN_MIDDLE);<a name="line.20298"></a>
<FONT color="green">20299</FONT>    <a name="line.20299"></a>
<FONT color="green">20300</FONT>            HTML label = new HTML(c.getLegendLabel());<a name="line.20300"></a>
<FONT color="green">20301</FONT>            GChart.setFontWeight(label, getLegendFontWeight());<a name="line.20301"></a>
<FONT color="green">20302</FONT>            GChart.setFontFamily(label, (null == getLegendFontFamily()) ?<a name="line.20302"></a>
<FONT color="green">20303</FONT>                                 getFontFamily() : getLegendFontFamily());<a name="line.20303"></a>
<FONT color="green">20304</FONT>            GChart.setFontStyle(label, getLegendFontStyle());<a name="line.20304"></a>
<FONT color="green">20305</FONT>            GChart.setColor(label, getLegendFontColor());<a name="line.20305"></a>
<FONT color="green">20306</FONT>            GChart.setFontSize(label, getLegendFontSize());<a name="line.20306"></a>
<FONT color="green">20307</FONT>    <a name="line.20307"></a>
<FONT color="green">20308</FONT>            result.setWidget(iVisible, 1, label);<a name="line.20308"></a>
<FONT color="green">20309</FONT>            result.getCellFormatter().setAlignment(iVisible, 1,<a name="line.20309"></a>
<FONT color="green">20310</FONT>                HasHorizontalAlignment.ALIGN_LEFT,<a name="line.20310"></a>
<FONT color="green">20311</FONT>                HasVerticalAlignment.ALIGN_MIDDLE);<a name="line.20311"></a>
<FONT color="green">20312</FONT>    <a name="line.20312"></a>
<FONT color="green">20313</FONT>            iVisible++;<a name="line.20313"></a>
<FONT color="green">20314</FONT>          }<a name="line.20314"></a>
<FONT color="green">20315</FONT>        }<a name="line.20315"></a>
<FONT color="green">20316</FONT>        return result;<a name="line.20316"></a>
<FONT color="green">20317</FONT>      }<a name="line.20317"></a>
<FONT color="green">20318</FONT>    <a name="line.20318"></a>
<FONT color="green">20319</FONT>      // returns char-width-based default legend thickness<a name="line.20319"></a>
<FONT color="green">20320</FONT>      private int getDefaultLegendThickness() {<a name="line.20320"></a>
<FONT color="green">20321</FONT>        final int EXTRA_WIDTH = 5; // allow for padding &amp; symbol<a name="line.20321"></a>
<FONT color="green">20322</FONT>        int maxLen = 0;<a name="line.20322"></a>
<FONT color="green">20323</FONT>        int nCurves = getNCurves();<a name="line.20323"></a>
<FONT color="green">20324</FONT>        for (int i = 0; i &lt; nCurves; i++) {<a name="line.20324"></a>
<FONT color="green">20325</FONT>          Curve c = getSystemCurve(i);<a name="line.20325"></a>
<FONT color="green">20326</FONT>          if (c.isVisible() &amp;&amp; null != c.getLegendLabel()) {<a name="line.20326"></a>
<FONT color="green">20327</FONT>            maxLen = Math.max(maxLen, htmlWidth(c.getLegendLabel()));<a name="line.20327"></a>
<FONT color="green">20328</FONT>          }<a name="line.20328"></a>
<FONT color="green">20329</FONT>        }<a name="line.20329"></a>
<FONT color="green">20330</FONT>        int result = (int) ((maxLen + EXTRA_WIDTH) * getLegendFontSize() * TICK_CHARWIDTH_TO_FONTSIZE_LOWERBOUND);<a name="line.20330"></a>
<FONT color="green">20331</FONT>        return result;<a name="line.20331"></a>
<FONT color="green">20332</FONT>      }<a name="line.20332"></a>
<FONT color="green">20333</FONT>    <a name="line.20333"></a>
<FONT color="green">20334</FONT>      private int getNVisibleCurvesOnLegend() {<a name="line.20334"></a>
<FONT color="green">20335</FONT>        int result = 0;<a name="line.20335"></a>
<FONT color="green">20336</FONT>        int nCurves = getNCurves();<a name="line.20336"></a>
<FONT color="green">20337</FONT>        for (int i = 0; i &lt; nCurves; i++) {<a name="line.20337"></a>
<FONT color="green">20338</FONT>          if (getSystemCurve(i).isVisible()<a name="line.20338"></a>
<FONT color="green">20339</FONT>              &amp;&amp; getSystemCurve(i).getLegendLabel() != null)<a name="line.20339"></a>
<FONT color="green">20340</FONT>            result++;<a name="line.20340"></a>
<FONT color="green">20341</FONT>        }<a name="line.20341"></a>
<FONT color="green">20342</FONT>        return result;<a name="line.20342"></a>
<FONT color="green">20343</FONT>      }<a name="line.20343"></a>
<FONT color="green">20344</FONT>    <a name="line.20344"></a>
<FONT color="green">20345</FONT>      // Defines a default curve border color when curves first created<a name="line.20345"></a>
<FONT color="green">20346</FONT>      private void setDefaultBorderColor(Curve curve, int index) {<a name="line.20346"></a>
<FONT color="green">20347</FONT>        curve.getSymbol().setBorderColor(<a name="line.20347"></a>
<FONT color="green">20348</FONT>            defaultSymbolBorderColors[index<a name="line.20348"></a>
<FONT color="green">20349</FONT>            % defaultSymbolBorderColors.length]);<a name="line.20349"></a>
<FONT color="green">20350</FONT>      }<a name="line.20350"></a>
<FONT color="green">20351</FONT>    <a name="line.20351"></a>
<FONT color="green">20352</FONT>      // Is the symbol type one of the special ANCHOR_MOUSE types,<a name="line.20352"></a>
<FONT color="green">20353</FONT>      // whose position varies with the mouse cursor location?<a name="line.20353"></a>
<FONT color="green">20354</FONT>      private boolean isMouseAnchored(SymbolType symbolType) {<a name="line.20354"></a>
<FONT color="green">20355</FONT>        boolean result = false;<a name="line.20355"></a>
<FONT color="green">20356</FONT>        if (SymbolType.ANCHOR_MOUSE == symbolType<a name="line.20356"></a>
<FONT color="green">20357</FONT>            || SymbolType.ANCHOR_MOUSE_SNAP_TO_X == symbolType<a name="line.20357"></a>
<FONT color="green">20358</FONT>            || SymbolType.ANCHOR_MOUSE_SNAP_TO_Y == symbolType)<a name="line.20358"></a>
<FONT color="green">20359</FONT>          result = true;<a name="line.20359"></a>
<FONT color="green">20360</FONT>        return result;<a name="line.20360"></a>
<FONT color="green">20361</FONT>      }<a name="line.20361"></a>
<FONT color="green">20362</FONT>    <a name="line.20362"></a>
<FONT color="green">20363</FONT>      // renders the curve in the plot panel<a name="line.20363"></a>
<FONT color="green">20364</FONT>      private void realizeCurve(Curve c) {<a name="line.20364"></a>
<FONT color="green">20365</FONT>        int internalIndex = 0;<a name="line.20365"></a>
<FONT color="green">20366</FONT>        int rpIndex = 0;<a name="line.20366"></a>
<FONT color="green">20367</FONT>        GraphicsRenderingPanel grp = null;<a name="line.20367"></a>
<FONT color="green">20368</FONT>        AnnotationRenderingPanel arp = null;<a name="line.20368"></a>
<FONT color="green">20369</FONT>    <a name="line.20369"></a>
<FONT color="green">20370</FONT>        if (!c.isValidated() || c.xOrYShiftChanged) {<a name="line.20370"></a>
<FONT color="green">20371</FONT>          internalIndex = getInternalCurveIndex(c);<a name="line.20371"></a>
<FONT color="green">20372</FONT>          rpIndex = getRenderingPanelIndex(internalIndex);<a name="line.20372"></a>
<FONT color="green">20373</FONT>          grp = plotPanel.getGraphicsRenderingPanel(rpIndex);<a name="line.20373"></a>
<FONT color="green">20374</FONT>          arp = plotPanel.getAnnotationRenderingPanel(rpIndex);<a name="line.20374"></a>
<FONT color="green">20375</FONT>        }<a name="line.20375"></a>
<FONT color="green">20376</FONT>    <a name="line.20376"></a>
<FONT color="green">20377</FONT>        if (!c.isValidated()) {<a name="line.20377"></a>
<FONT color="green">20378</FONT>          currentCurveData = c.getCurveData();<a name="line.20378"></a>
<FONT color="green">20379</FONT>          if (PlotPanel.DECORATIVE_RENDERING_PANEL_INDEX == rpIndex) {<a name="line.20379"></a>
<FONT color="green">20380</FONT>            // background panel only gets initialized for first curve<a name="line.20380"></a>
<FONT color="green">20381</FONT>            if (0 == internalIndex) {<a name="line.20381"></a>
<FONT color="green">20382</FONT>              // background panel never uses canvas<a name="line.20382"></a>
<FONT color="green">20383</FONT>              grp.beginRendering(null);<a name="line.20383"></a>
<FONT color="green">20384</FONT>              arp.beginRendering();<a name="line.20384"></a>
<FONT color="green">20385</FONT>            }<a name="line.20385"></a>
<FONT color="green">20386</FONT>            c.setWasCanvasRendered(false);<a name="line.20386"></a>
<FONT color="green">20387</FONT>          } else if (0 == c.getSymbol().getFillSpacing() &amp;&amp; // continuous fill<a name="line.20387"></a>
<FONT color="green">20388</FONT>              0 &lt; c.getSymbol().getFillThickness() &amp;&amp; // non-empty fill<a name="line.20388"></a>
<FONT color="green">20389</FONT>              null != getCanvasFactory() &amp;&amp; // canvas available<a name="line.20389"></a>
<FONT color="green">20390</FONT>              c.isVisible()) {<a name="line.20390"></a>
<FONT color="green">20391</FONT>            grp.maybeAddCanvas();<a name="line.20391"></a>
<FONT color="green">20392</FONT>            Rectangle canvasRegion = c.getContainingRectangle(plotPanel);<a name="line.20392"></a>
<FONT color="green">20393</FONT>            grp.beginRendering(canvasRegion);<a name="line.20393"></a>
<FONT color="green">20394</FONT>            arp.beginRendering();<a name="line.20394"></a>
<FONT color="green">20395</FONT>            c.setWasCanvasRendered(true);<a name="line.20395"></a>
<FONT color="green">20396</FONT>          } else { // does not use canvas, or it is invisible<a name="line.20396"></a>
<FONT color="green">20397</FONT>            grp.beginRendering(null);<a name="line.20397"></a>
<FONT color="green">20398</FONT>            arp.beginRendering();<a name="line.20398"></a>
<FONT color="green">20399</FONT>            c.setWasCanvasRendered(false);<a name="line.20399"></a>
<FONT color="green">20400</FONT>          }<a name="line.20400"></a>
<FONT color="green">20401</FONT>    <a name="line.20401"></a>
<FONT color="green">20402</FONT>          if (c.isVisible()) {<a name="line.20402"></a>
<FONT color="green">20403</FONT>            // Separate points into vertical/horizontal band-bins provided<a name="line.20403"></a>
<FONT color="green">20404</FONT>            // 1) it is not a system curve and 2) it is not of a type whose<a name="line.20404"></a>
<FONT color="green">20405</FONT>            // position follows the mouse (and thus has no fixed location<a name="line.20405"></a>
<FONT color="green">20406</FONT>            // suitable for banding) and 3) at least one kind of hover<a name="line.20406"></a>
<FONT color="green">20407</FONT>            // feedback is being provided for the curve.<a name="line.20407"></a>
<FONT color="green">20408</FONT>            if (getCurveIndex(c) &gt;= 0<a name="line.20408"></a>
<FONT color="green">20409</FONT>                &amp;&amp; !isMouseAnchored(c.getSymbol().getSymbolType())<a name="line.20409"></a>
<FONT color="green">20410</FONT>                &amp;&amp; (c.getSymbol().getHoverSelectionEnabled() || c<a name="line.20410"></a>
<FONT color="green">20411</FONT>                .getSymbol().getHoverAnnotationEnabled()))<a name="line.20411"></a>
<FONT color="green">20412</FONT>              c.bandSeparatePoints();<a name="line.20412"></a>
<FONT color="green">20413</FONT>            else<a name="line.20413"></a>
<FONT color="green">20414</FONT>              // hit test banding calcs unneeded; skip them for speed.<a name="line.20414"></a>
<FONT color="green">20415</FONT>              c.clearBandList();<a name="line.20415"></a>
<FONT color="green">20416</FONT>    <a name="line.20416"></a>
<FONT color="green">20417</FONT>            // Note: these lines must come AFTER band separation lines above<a name="line.20417"></a>
<FONT color="green">20418</FONT>            int nPoints = c.getNPoints();<a name="line.20418"></a>
<FONT color="green">20419</FONT>            for (int j = 0; j &lt; nPoints; j++) {<a name="line.20419"></a>
<FONT color="green">20420</FONT>              c.realizePoint(plotPanel, grp, arp, j);<a name="line.20420"></a>
<FONT color="green">20421</FONT>            }<a name="line.20421"></a>
<FONT color="green">20422</FONT>          }<a name="line.20422"></a>
<FONT color="green">20423</FONT>          // only end background panel rendering w last background curve<a name="line.20423"></a>
<FONT color="green">20424</FONT>          if (PlotPanel.DECORATIVE_RENDERING_PANEL_INDEX != rpIndex<a name="line.20424"></a>
<FONT color="green">20425</FONT>              || internalIndex == N_PRE_SYSTEM_CURVES - 1) {<a name="line.20425"></a>
<FONT color="green">20426</FONT>            grp.endRendering();<a name="line.20426"></a>
<FONT color="green">20427</FONT>            arp.endRendering();<a name="line.20427"></a>
<FONT color="green">20428</FONT>          }<a name="line.20428"></a>
<FONT color="green">20429</FONT>          // else it's a background panel curve, and not the last one<a name="line.20429"></a>
<FONT color="green">20430</FONT>          c.isValidated = true;<a name="line.20430"></a>
<FONT color="green">20431</FONT>          currentCurveData = null;<a name="line.20431"></a>
<FONT color="green">20432</FONT>        }<a name="line.20432"></a>
<FONT color="green">20433</FONT>    <a name="line.20433"></a>
<FONT color="green">20434</FONT>        if (c.xOrYShiftChanged) {<a name="line.20434"></a>
<FONT color="green">20435</FONT>          plotPanel.setRenderingPosition(grp, arp, c.getXShift(), c.getYShift());<a name="line.20435"></a>
<FONT color="green">20436</FONT>          c.xOrYShiftChanged = false;<a name="line.20436"></a>
<FONT color="green">20437</FONT>        }<a name="line.20437"></a>
<FONT color="green">20438</FONT>    <a name="line.20438"></a>
<FONT color="green">20439</FONT>      }<a name="line.20439"></a>
<FONT color="green">20440</FONT>    <a name="line.20440"></a>
<FONT color="green">20441</FONT>      // marks every curve, including system curves, as needing an update<a name="line.20441"></a>
<FONT color="green">20442</FONT>      private void invalidateEveryCurve() {<a name="line.20442"></a>
<FONT color="green">20443</FONT>        for (int i = 0; i &lt; curves.size(); i++) {<a name="line.20443"></a>
<FONT color="green">20444</FONT>          curves.get(i).invalidate();<a name="line.20444"></a>
<FONT color="green">20445</FONT>        }<a name="line.20445"></a>
<FONT color="green">20446</FONT>      }<a name="line.20446"></a>
<FONT color="green">20447</FONT>    <a name="line.20447"></a>
<FONT color="green">20448</FONT>      // marks every developer-accessible curve as needing an update<a name="line.20448"></a>
<FONT color="green">20449</FONT>      private void invalidateAccessibleCurves() {<a name="line.20449"></a>
<FONT color="green">20450</FONT>        int nCurves = getNCurves();<a name="line.20450"></a>
<FONT color="green">20451</FONT>        for (int i = 0; i &lt; nCurves; i++) {<a name="line.20451"></a>
<FONT color="green">20452</FONT>          getSystemCurve(i).invalidate();<a name="line.20452"></a>
<FONT color="green">20453</FONT>        }<a name="line.20453"></a>
<FONT color="green">20454</FONT>      }<a name="line.20454"></a>
<FONT color="green">20455</FONT>    <a name="line.20455"></a>
<FONT color="green">20456</FONT>      // invalidates every curve that has a pie slice type<a name="line.20456"></a>
<FONT color="green">20457</FONT>      void invalidateAllSlices() {<a name="line.20457"></a>
<FONT color="green">20458</FONT>        int nCurves = getNCurves();<a name="line.20458"></a>
<FONT color="green">20459</FONT>        for (int i = 0; i &lt; nCurves; i++) {<a name="line.20459"></a>
<FONT color="green">20460</FONT>          Curve c = getSystemCurve(i);<a name="line.20460"></a>
<FONT color="green">20461</FONT>          if (c.getSymbol().getSymbolType() instanceof SymbolType.PieSliceSymbolType)<a name="line.20461"></a>
<FONT color="green">20462</FONT>            c.invalidate();<a name="line.20462"></a>
<FONT color="green">20463</FONT>        }<a name="line.20463"></a>
<FONT color="green">20464</FONT>      }<a name="line.20464"></a>
<FONT color="green">20465</FONT>    <a name="line.20465"></a>
<FONT color="green">20466</FONT>      // Invalidates every pie slice curve whose orientation could<a name="line.20466"></a>
<FONT color="green">20467</FONT>      // depend on the orientation of the given curve<a name="line.20467"></a>
<FONT color="green">20468</FONT>      void invalidateDependentSlices(int iFirstCurve) {<a name="line.20468"></a>
<FONT color="green">20469</FONT>        // only user defined curve can have slice dependency relationships<a name="line.20469"></a>
<FONT color="green">20470</FONT>        if (isSystemCurveIndex(iFirstCurve))<a name="line.20470"></a>
<FONT color="green">20471</FONT>          return;<a name="line.20471"></a>
<FONT color="green">20472</FONT>        int nCurves = getNCurves();<a name="line.20472"></a>
<FONT color="green">20473</FONT>        for (int i = iFirstCurve; i &lt; nCurves; i++) {<a name="line.20473"></a>
<FONT color="green">20474</FONT>          Curve c = getSystemCurve(i);<a name="line.20474"></a>
<FONT color="green">20475</FONT>          if (c.getSymbol().getSymbolType() instanceof SymbolType.PieSliceSymbolType)<a name="line.20475"></a>
<FONT color="green">20476</FONT>            c.invalidate();<a name="line.20476"></a>
<FONT color="green">20477</FONT>          else if (i == iFirstCurve) // if first curve isn't a slice,<a name="line.20477"></a>
<FONT color="green">20478</FONT>            break; // there are no dependent slices<a name="line.20478"></a>
<FONT color="green">20479</FONT>        }<a name="line.20479"></a>
<FONT color="green">20480</FONT>      }<a name="line.20480"></a>
<FONT color="green">20481</FONT>    <a name="line.20481"></a>
<FONT color="green">20482</FONT>      // Defines the default pie slice orientations for every pie-slice curve<a name="line.20482"></a>
<FONT color="green">20483</FONT>      private void setDefaultPieSliceOrientations() {<a name="line.20483"></a>
<FONT color="green">20484</FONT>        setLastPieSliceOrientation(getInitialPieSliceOrientation());<a name="line.20484"></a>
<FONT color="green">20485</FONT>        int nCurves = getNCurves();<a name="line.20485"></a>
<FONT color="green">20486</FONT>        for (int i = 0; i &lt; nCurves; i++) {<a name="line.20486"></a>
<FONT color="green">20487</FONT>          Curve c = getSystemCurve(i);<a name="line.20487"></a>
<FONT color="green">20488</FONT>          // keep track of default next orientation for pie slices<a name="line.20488"></a>
<FONT color="green">20489</FONT>          // (must do this even if we don't have to redraw slice)<a name="line.20489"></a>
<FONT color="green">20490</FONT>          if (c.getSymbol().getSymbolType() instanceof SymbolType.PieSliceSymbolType) {<a name="line.20490"></a>
<FONT color="green">20491</FONT>            c.getSymbol().setDefaultPieSliceOrientation(<a name="line.20491"></a>
<FONT color="green">20492</FONT>                getLastPieSliceOrientation());<a name="line.20492"></a>
<FONT color="green">20493</FONT>            setLastPieSliceOrientation(c.getSymbol().getDecodedPieSliceOrientation()<a name="line.20493"></a>
<FONT color="green">20494</FONT>                + c.getSymbol().getPieSliceSize());<a name="line.20494"></a>
<FONT color="green">20495</FONT>          }<a name="line.20495"></a>
<FONT color="green">20496</FONT>        }<a name="line.20496"></a>
<FONT color="green">20497</FONT>      }<a name="line.20497"></a>
<FONT color="green">20498</FONT>    <a name="line.20498"></a>
<FONT color="green">20499</FONT>      private void realizePlotPanel() {<a name="line.20499"></a>
<FONT color="green">20500</FONT>    <a name="line.20500"></a>
<FONT color="green">20501</FONT>        setDefaultPieSliceOrientations();<a name="line.20501"></a>
<FONT color="green">20502</FONT>        /*<a name="line.20502"></a>
<FONT color="green">20503</FONT>         * Render both system curves (those with negative ids that are used to<a name="line.20503"></a>
<FONT color="green">20504</FONT>         * render title, ticks, etc.) and ordinary curves.<a name="line.20504"></a>
<FONT color="green">20505</FONT>         */<a name="line.20505"></a>
<FONT color="green">20506</FONT>        int nCurves = getNCurves();<a name="line.20506"></a>
<FONT color="green">20507</FONT>        for (int i = -N_SYSTEM_CURVES; i &lt; nCurves; i++) {<a name="line.20507"></a>
<FONT color="green">20508</FONT>          Curve c = getSystemCurve(i);<a name="line.20508"></a>
<FONT color="green">20509</FONT>          realizeCurve(c);<a name="line.20509"></a>
<FONT color="green">20510</FONT>        }<a name="line.20510"></a>
<FONT color="green">20511</FONT>    <a name="line.20511"></a>
<FONT color="green">20512</FONT>      }<a name="line.20512"></a>
<FONT color="green">20513</FONT>    <a name="line.20513"></a>
<FONT color="green">20514</FONT>      /*<a name="line.20514"></a>
<FONT color="green">20515</FONT>       * Returns true if the rendering panel index is associated with one of the<a name="line.20515"></a>
<FONT color="green">20516</FONT>       * internal, hover-feedback curves. &lt;p&gt;<a name="line.20516"></a>
<FONT color="green">20517</FONT>       * <a name="line.20517"></a>
<FONT color="green">20518</FONT>       * This method relies on the fact that rendering panels appear in this order:<a name="line.20518"></a>
<FONT color="green">20519</FONT>       * &lt;p&gt;<a name="line.20519"></a>
<FONT color="green">20520</FONT>       * <a name="line.20520"></a>
<FONT color="green">20521</FONT>       * &lt;ol&gt; &lt;li&gt; a single rp that renders all chart decorations &lt;li&gt; getNCurves()<a name="line.20521"></a>
<FONT color="green">20522</FONT>       * rps (1 for each developer-defined curve) &lt;li&gt; the two rendering panels<a name="line.20522"></a>
<FONT color="green">20523</FONT>       * associated with the two system-defined hover feedback curves &lt;/ol&gt;<a name="line.20523"></a>
<FONT color="green">20524</FONT>       */<a name="line.20524"></a>
<FONT color="green">20525</FONT>      boolean isHoverFeedbackRenderingPanel(int rpIndex) {<a name="line.20525"></a>
<FONT color="green">20526</FONT>        boolean result = rpIndex &gt; getNCurves();<a name="line.20526"></a>
<FONT color="green">20527</FONT>        return result;<a name="line.20527"></a>
<FONT color="green">20528</FONT>      }<a name="line.20528"></a>
<FONT color="green">20529</FONT>    <a name="line.20529"></a>
<FONT color="green">20530</FONT>      /*<a name="line.20530"></a>
<FONT color="green">20531</FONT>       * This code works around a bug in GWTCanvas that can cause (in IE) previously<a name="line.20531"></a>
<FONT color="green">20532</FONT>       * rendered VML elements to have their fill and stroke color, and stroke<a name="line.20532"></a>
<FONT color="green">20533</FONT>       * thickness properties revert to some sort of defaults (I saw white, black,<a name="line.20533"></a>
<FONT color="green">20534</FONT>       * and 1px in my tests) when the canvas is re-inserted into the DOM.<a name="line.20534"></a>
<FONT color="green">20535</FONT>       * <a name="line.20535"></a>
<FONT color="green">20536</FONT>       * See TestGChart55.java and TestGChart55a.java for more info on the GWTCanvas<a name="line.20536"></a>
<FONT color="green">20537</FONT>       * bug that makes this code neccessary.<a name="line.20537"></a>
<FONT color="green">20538</FONT>       * <a name="line.20538"></a>
<FONT color="green">20539</FONT>       * TODO: Implement technique of GWTCanvasIssue293.patch to override<a name="line.20539"></a>
<FONT color="green">20540</FONT>       * removeFromParent and store/restore innerHTML as a more efficient workaround<a name="line.20540"></a>
<FONT color="green">20541</FONT>       * for this problem. If a new GWTCanvas is released, you could remove this<a name="line.20541"></a>
<FONT color="green">20542</FONT>       * workaround altogether.<a name="line.20542"></a>
<FONT color="green">20543</FONT>       */<a name="line.20543"></a>
<FONT color="green">20544</FONT>    <a name="line.20544"></a>
<FONT color="green">20545</FONT>      // avoids inefficiency of re-rendering in most common case<a name="line.20545"></a>
<FONT color="green">20546</FONT>      private boolean wasUnloaded = false;<a name="line.20546"></a>
<FONT color="green">20547</FONT>    <a name="line.20547"></a>
<FONT color="green">20548</FONT>      @Override<a name="line.20548"></a>
<FONT color="green">20549</FONT>      protected void onUnload() {<a name="line.20549"></a>
<FONT color="green">20550</FONT>        super.onUnload();<a name="line.20550"></a>
<FONT color="green">20551</FONT>        wasUnloaded = true;<a name="line.20551"></a>
<FONT color="green">20552</FONT>      }<a name="line.20552"></a>
<FONT color="green">20553</FONT>    <a name="line.20553"></a>
<FONT color="green">20554</FONT>      @Override<a name="line.20554"></a>
<FONT color="green">20555</FONT>      protected void onLoad() {<a name="line.20555"></a>
<FONT color="green">20556</FONT>        super.onLoad();<a name="line.20556"></a>
<FONT color="green">20557</FONT>        if (wasUnloaded &amp;&amp; plotPanel.getRenderingPanelCount() &gt; 0) {<a name="line.20557"></a>
<FONT color="green">20558</FONT>          boolean isUpToDate = !isUpdateNeeded();<a name="line.20558"></a>
<FONT color="green">20559</FONT>          int nCurves = getNCurves();<a name="line.20559"></a>
<FONT color="green">20560</FONT>          for (int i = 0; i &lt; nCurves; i++) {<a name="line.20560"></a>
<FONT color="green">20561</FONT>            Curve c = getCurve(i);<a name="line.20561"></a>
<FONT color="green">20562</FONT>            if (c.isCanvasRendered()) {<a name="line.20562"></a>
<FONT color="green">20563</FONT>              c.invalidate();<a name="line.20563"></a>
<FONT color="green">20564</FONT>              if (isUpToDate)<a name="line.20564"></a>
<FONT color="green">20565</FONT>                realizeCurve(c);<a name="line.20565"></a>
<FONT color="green">20566</FONT>              // else since chart needs update, presume they will<a name="line.20566"></a>
<FONT color="green">20567</FONT>              // update later, no need to auto-patch things up<a name="line.20567"></a>
<FONT color="green">20568</FONT>              // (and simple patch-rerender won't work anyway).<a name="line.20568"></a>
<FONT color="green">20569</FONT>            }<a name="line.20569"></a>
<FONT color="green">20570</FONT>          }<a name="line.20570"></a>
<FONT color="green">20571</FONT>        }<a name="line.20571"></a>
<FONT color="green">20572</FONT>        // else never inserted/rendered; skip patchup-rerendering<a name="line.20572"></a>
<FONT color="green">20573</FONT>      }<a name="line.20573"></a>
<FONT color="green">20574</FONT>    <a name="line.20574"></a>
<FONT color="green">20575</FONT>    } // end of class GChart<a name="line.20575"></a>




























































</PRE>
</BODY>
</HTML>
